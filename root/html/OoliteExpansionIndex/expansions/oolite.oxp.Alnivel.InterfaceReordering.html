<html>
    <head>
        <title>Expansion Interface Reordering</title>
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <table border="0" width="100%">
            <tr>
                <td>Back to <a href='../index.html'>Index</a></td>
                <td align="right"><small>Page generated: Oct 11, 2023, 3:16:48 PM</small></td>
            </tr>
        </table>

        <h1>Expansion Interface Reordering</h1>

        <h2>Content</h2>
        <ul>
          <li><a href="#warnings">Warnings</a></li>
          <li><a href="#manifest">Manifest</a></li>
          <li><a href="#documentation">Documentation</a></li>
          <li><a href="#equipment">0 Equipment</a></li>
          <li><a href="#ships">0 Ships</a></li>
          <li><a href="#models">0 Models</a></li>
          <li><a href="#scripts">2 Scripts</a></li>
        </ul>

          <a name="warnings">
            <h2>Warnings</h2>
            <ol>
                <li>http://wiki.alioth.net/index.php/Interface%20Reordering -&gt; 404 Not Found</li>
                <li>Low hanging fuit: Information URL exists...</li>
            </ol>
          </a>

        <a name="manifest">
        <h2>Manifest</h2>
            <table border="1">
                <tr>
                    <th></th>
                    <th>from Expansion Manager's OXP list</th>
                    <th>from Expansion Manifest</th>
                </tr>
                <tr>
                    <td>Description</td>
                    <td>Change interface order on F4 page (\&quot;Ship and system interfaces\&quot;)</td>
                    <td>Change interface order on F4 page (\&quot;Ship and system interfaces\&quot;)</td>
                </tr>
                <tr>
                    <td>Identifier</td>
                    <td>oolite.oxp.Alnivel.InterfaceReordering</td>
                    <td>oolite.oxp.Alnivel.InterfaceReordering</td>
                </tr>
                <tr>
                    <td>Title</td>
                    <td>Interface Reordering</td>
                    <td>Interface Reordering</td>
                </tr>
                <tr>
                    <td>Category</td>
                    <td>Misc</td>
                    <td>Misc</td>
                </tr>
                <tr>
                    <td>Author</td>
                    <td>Alnivel</td>
                    <td>Alnivel</td>
                </tr>
                <tr>
                    <td>Version</td>
                    <td>0.2</td>
                    <td>0.2</td>
                </tr>
                <tr>
                    <td>Tags</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Required Oolite Version</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Maximum Oolite Version</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Required Expansions</td>
                    <td>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>Optional Expansions</td>
                    <td>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>Conflict Expansions</td>
                    <td>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>Information URL</td>
                    <td><a target="_blank" href="https://wiki.alioth.net/index.php/Interface_Reordering_OXP">https://wiki.alioth.net/index.php/Interface_Reordering_OXP</a></td>
                    <td><a target="_blank" href="">n/a</a></td>
                </tr>
                <tr>
                    <td>Download URL</td>
                    <td><a target="_blank" href="https://www.dl.dropboxusercontent.com/s/5c4bbeuw6ntlzs0/InterfaceReordering.0.2.oxz">https://www.dl.dropboxusercontent.com/s/5c4bbeuw6ntlzs0/InterfaceReordering.0.2.oxz</a></td>
                    <td><a target="_blank" href="">n/a</a></td>
                </tr>
                <tr>
                    <td>License</td>
                    <td>CC BY-NC-SA 4</td>
                    <td>CC BY-NC-SA 4</td>
                </tr>
                <tr>
                    <td>File Size</td>
                    <td>n/a</td>
                </tr>
                <tr>
                    <td>Upload date</td>
                    <td>n/a</td>
                </tr>
            </table>
                </a>

        <a name="documentation">
        <h2>Documentation</h2>
        
        </a>

        <a name="equipment">          
        <h2>Equipment</h2>
            This expansion declares no equipment. This may be related to warnings.
        </a>

        <a name="ships">    
        <h2>Ships</h2>
            This expansion declares no ships. This may be related to warnings.
        </a>

        <a name="models">    
        <h2>Models</h2>
            This expansion declares no models. This may be related to warnings.
        </a>

        <a name="scripts">    
        <h2>Scripts</h2>
            <table>
                <tr>
                    <th>Path</th>
                </tr>
                <tr>
                    <td valign="top">Scripts/interface-reordering-interfaceLib.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name = &quot;InterfaceReordering_InterfaceLib&quot;;
this.author = &quot;Alnivel&quot;;
this.copyright = &quot;2022 Alnivel&quot;;
this.version = &quot;0.4&quot;;
this.licence = &quot;CC BY-NC-SA 4.0&quot;;

(function() {
    let ILib = this;

    this.__BaseController = function __BaseController() {}

    this.__BaseController.prototype.onRun = function onRun(callback) {
        this.callbackOnRun = callback;
        return this;
    }

    this.__BaseController.prototype.onUpdate = function onUpdate(callback) {
        this.callbackOnUpdate = callback;
        return this;
    }

    this.__BasePagedController = function __BasePagedController(screenParameters) {
        __BasePagedController_init(screenParameters);
    }

    this.__BasePagedController.prototype = Object.create(__BaseController.prototype);

    this.__BasePagedController.prototype.__BasePagedController_init = function (screenParameters)  {
        this.screenParameters = screenParameters;
        this.headerLines = [];
        this.contentLines = [];
        this.footerLines = [];

        this.headerPrefix = &quot;00HEADER&quot;;
        this.contentPrefix = &quot;20CONTENT&quot;;
        this.footerPrefix = &quot;40FOOTER&quot;;

        this.currentPage = 0;
        this.pages = 0;

        this.selectedChoicesKey = undefined;
    }

    this.__BasePagedController.prototype.addToHeader = function addToHeader(line) {
        const headerLinesCount = this.headerLines.length;
        const key = (headerLinesCount &lt; 10 ? (&quot;0&quot; + headerLinesCount) : headerLinesCount) + &quot;_NO_KEY&quot;;
        this.headerLines.push({ key: key, line: line });
    }

    this.__BasePagedController.prototype.addToContent = function addToContent(line) {
        const contentLinesCount = this.contentLines.length;
        const key = (contentLinesCount &lt; 10 ? (&quot;0&quot; + contentLinesCount) : contentLinesCount) + &quot;_NO_KEY&quot;;
        this.contentLines.push({ key: key, line: line });
    }

    this.__BasePagedController.prototype.addToFooter = function addToFooter(line) {
        const footerLinesCount = this.footerLines.length;
        const key = (footerLinesCount &lt; 10 ? (&quot;0&quot; + footerLinesCount) : footerLinesCount) + &quot;_NO_KEY&quot;;
        this.footerLines.push({ key: key, line: line });
    }

    /*
        Remove line from ...
        this.__BasePagedScreenController.prototype.removeLineFromContent = function removeFromContent(line) {
        let removePos = -1;
        let i = this.contentLines.length;
        while (i--) {
            if (this.contentLines[i].line === line) {
                removePos = i;
                break;
            }
        }
        if (removePos === -1)
            return false;
        else {
            this.contentLines.splice(removePos, 1);
            return true;
        }
    }
    */

    this.__BasePagedController.prototype.clearHeader = function clearHeader() {
        this.headerLines.length = 0;
    }

    this.__BasePagedController.prototype.clearContent = function clearHeader() {
        this.contentLines.length = 0;
    }

    this.__BasePagedController.prototype.clearFooter = function clearHeader() {
        this.footerLines.length = 0;
    }

    /***
     * Update every line in header and fill &quot;choises&quot; parameter with them  
     * @param {object} choises
     * @returns {number} Header height in lines
     */
    this.__BasePagedController.prototype.updateHeader = function updateHeader(choises) {
        const linesForHeader = this.headerLines.length;

        for (let i = 0; i &lt; linesForHeader; i++) {
            let pair = this.headerLines[i];
            let key = this.headerPrefix + (i &lt; 10 ? (&quot;0&quot; + i) : i) + &quot;_&quot; + pair.key;
            choises[key] = pair.line.update();
        }

        return linesForHeader;
    }

    /**
     * Update content lines on specified page and fill &quot;choises&quot; parameter with them
     * @param {object} choises
     * @param {number} linesPerPage Maximum number of lines per page
     * @param {number} page Page number
     * @returns {number} Content height on specified page in lines
     */
    this.__BasePagedController.prototype.updateContent = function updateContent(choises, linesPerPage, page) {
        let linesStartIndex = linesPerPage * page;
        let linesEndIndex = linesStartIndex + linesPerPage;
        let contentLinesCount = this.contentLines.length;

        let linesEndIndexLimited = contentLinesCount &lt; linesEndIndex ? contentLinesCount : linesEndIndex;

        for (let i = linesStartIndex; i &lt; linesEndIndexLimited; i++) {
            let pair = this.contentLines[i];
            let key = this.contentPrefix + (i &lt; 10 ? (&quot;0&quot; + i) : i) + &quot;_&quot; + pair.key;
            choises[key] = pair.line.update();
        }

        return linesEndIndexLimited - linesStartIndex;
    }

    /***
     * Update every line in footer and fill &quot;choises&quot; parameter with them  
     * @param {object} choises
     * @returns {number} Footer height in lines
     */
    this.__BasePagedController.prototype.updateFooter = function updateFooter(choises) {
        const linesForFooter = this.footerLines.length;
        
        for (let i = 0; i &lt; linesForFooter; i++) {
            let pair = this.footerLines[i];
            let key = this.footerPrefix + (i &lt; 10 ? (&quot;0&quot; + i) : i) + &quot;_&quot; + pair.key;
            choises[key] = pair.line.update();
        }

        return linesForFooter;
    }

    this.__BasePagedController.prototype.proccessChoises = function proccessChoises(choise) {
        for (let i = 0; i &lt; this.headerLines.length; i++) {
            let pair = this.headerLines[i];
            let key = this.headerPrefix + (i &lt; 10 ? (&quot;0&quot; + i) : i) + &quot;_&quot; + pair.key;
            let line = pair.line;
            if (choise === key) {
                return line.select &amp;&amp; line.select(); // if true returned then don`t redraw this screen
            }
        }
        
        for (let i = 0; i &lt; this.contentLines.length; i++) {
            let pair = this.contentLines[i];
            let key = this.contentPrefix + (i &lt; 10 ? (&quot;0&quot; + i) : i) + &quot;_&quot; + pair.key;
            let line = pair.line;
            if (choise === key) {
                return line.select &amp;&amp; line.select();
            }
        }

        for (let i = 0; i &lt; this.footerLines.length; i++) {
            let pair = this.footerLines[i];
            let key = this.footerPrefix + (i &lt; 10 ? (&quot;0&quot; + i) : i) + &quot;_&quot; + pair.key;
            let line = pair.line;
            if (choise === key) {
                return line.select &amp;&amp; line.select();
            }
        }

        // Restarting the screen, if necessary, is performed by the child 
        /* 
        this.screenParameters.choices = this.getPage(this.currentPage);
        this.screenParameters.initialChoicesKey = initialChoicesKey;
        mission.runScreen(this.screenParameters, this.onChoiceSelected.bind(this));
        */
    }

    this.__BasePagedController.prototype.runScreen = function runScreen() {
        log(&quot;Alnivel_InterfaceLib_Message&quot;, &quot;Started &quot; + this.screenParameters.title + &quot; mission screen&quot;);
        if(this.callbackOnRun)
            this.callbackOnRun();
        
        this.currentPage = 0;
        this.screenParameters.choices = this.getPage(0);

        mission.runScreen(this.screenParameters, this.onChoiceSelected.bind(this));
    }

    this.__BasePagedController.prototype.returnToScreen = function returnToScreen() {
        if(this.currentPage === undefined || this.currentPage &gt; this.pages)
            this.currentPage = 0;

        log(&quot;Alnivel_InterfaceLib_Message&quot;, &quot;Returned to &quot; + this.screenParameters.title + &quot; mission screen on page &quot; + this.currentPage);
        if(this.callbackOnRun)
            this.callbackOnRun();
        
        this.screenParameters.choices = this.getPage(this.currentPage);
        this.screenParameters.initialChoicesKey = this.selectedChoicesKey;
        mission.runScreen(this.screenParameters, this.onChoiceSelected.bind(this));
    }


    /**
     * Create paged screen that can be filled with line objects.
     * Each time the line is selected, it will re-render, 
     * unless the Return option is selected (then will be called callbackOnReturn)
     * or the onSelect callback of the selected line returns true
     * @param {*} screenParameters 
     * @param {Function} [callbackOnReturn]
     */
    this.PagedScreenController = function PagedScreenController(screenParameters, callbackOnReturn) {
        this.__BasePagedController_init(screenParameters); // Don`t know how to get base constructor properly
        this.callbackOnReturn = callbackOnReturn ?  callbackOnReturn : null;
    }

    this.PagedScreenController.prototype = Object.create(__BasePagedController.prototype);

    this.PagedScreenController.prototype.onReturn = function onReturn(callback) {
        this.callbackOnReturn = callback;
        return this;
    }

    this.PagedScreenController.prototype.updateControls = function updateControls(choises, pages, page) {
        const spacer = { text: &quot;&quot; };
        
        if (pages &gt; 1) {
            choises[&quot;70_SPACER&quot;] = spacer;
            choises[&quot;71_PAGE_NUM&quot;] = {
                text: &quot;Page &quot; + (1 + page) + &quot; of &quot; + pages,
                unselectable: true
            }
            choises[&quot;73_NEXT_PAGE&quot;] = {
                text: &quot;Next page&quot;,
                unselectable: page + 1 === pages
            };
            choises[&quot;74_PREV_PAGE&quot;] = {
                text: &quot;Previous page&quot;,
                unselectable: page === 0
            };

        } else {
            choises[&quot;70_SPACER&quot;] = spacer;
            choises[&quot;71_SPACER&quot;] = spacer;
            choises[&quot;73_SPACER&quot;] = spacer;
            choises[&quot;74_SPACER&quot;] = spacer;
        }

        choises[&quot;80_RETURN&quot;] = { text: &quot;Return&quot; };

        return 5;
    }

    this.PagedScreenController.prototype.getPage = function getPage(page) {
        if(this.callbackOnUpdate)
            this.callbackOnUpdate();

        const screenHeight = (player.ship.hudAllowsBigGui ? 27 : 21);

        const choises = {};

        const headerHeight = this.updateHeader(choises);
        const footerHeight = this.updateFooter(choises);
        const controlsHeight = 5;

        const maxContentHeight = screenHeight - headerHeight - footerHeight - controlsHeight;
        const pages = this.pages = Math.ceil(this.contentLines.length / maxContentHeight);

        const contentHeight = this.updateContent(choises, maxContentHeight, page);
        const remainHeight = maxContentHeight - contentHeight;
        log(&quot;Alnivel_InterfaceLib_Message&quot;, &quot;Remain lines after content &quot; + remainHeight + &quot; from &quot; + maxContentHeight)
        /*** Fill empty ***/
        const spaceToFill = remainHeight &lt; maxContentHeight? remainHeight : maxContentHeight;
        const spacer = { text: &quot;&quot; };
        for (let i = 0; i &lt; spaceToFill; i++) {
            let key = &quot;21EMPTY_&quot; + (i &lt; 10 ? (&quot;0&quot; + i) : i) + &quot;_EMPTY&quot;;
            choises[key] = spacer;
        }

        /*** Controlls ***/
        this.updateControls(choises, pages, page);

        return choises;
    }

    this.PagedScreenController.prototype.getPageWithLineIndex = function getPageWithLineIndex(lineIndex) {
        if(lineIndex === null || lineIndex === undefined || 
            lineIndex === -1 || lineIndex &gt;= this.contentLines.length ) {
            // TODO: add warning
            return this.getPage(0);
        }

        const screenHeight = (player.ship.hudAllowsBigGui ? 27 : 21);

        const choises = {};

        const headerHeight = this.updateHeader(choises);
        const footerHeight = this.updateFooter(choises);
        const controlsHeight = 5;

        const maxContentHeight = screenHeight - headerHeight - footerHeight - controlsHeight;
        const pages = this.pages = Math.ceil(this.contentLines.length / maxContentHeight);
        const page = this.currentPage = Math.floor(lineIndex / maxContentHeight);

        const contentHeight = this.updateContent(choises, maxContentHeight, page);
        const remainHeight = maxContentHeight - contentHeight;
        log(&quot;Alnivel_InterfaceLib_Message&quot;, &quot;Remain lines after content &quot; + remainHeight + &quot; from &quot; + maxContentHeight)
        /*** Fill empty ***/
        const spaceToFill = remainHeight &lt; maxContentHeight? remainHeight : maxContentHeight;
        const spacer = { text: &quot;&quot; };
        for (let i = 0; i &lt; spaceToFill; i++) {
            let key = &quot;21EMPTY_&quot; + (i &lt; 10 ? (&quot;0&quot; + i) : i) + &quot;_EMPTY&quot;;
            choises[key] = spacer;
        }

        /*** Controlls ***/
        this.updateControls(choises, pages, page);

        return choises;
    }

    this.PagedScreenController.prototype.getPageWithLine = function getPageWithLine(line) {
        const lineIndex = this.contentLines.findIndex(function (pair) {
            return pair.line === line;
        });

        return this.getPageWithLineIndex(lineIndex);
    }

    this.PagedScreenController.prototype.onChoiceSelected = function onChoiceSelected(choise) {
        if (choise === &quot;80_RETURN&quot;) {
            if (this.callbackOnReturn) this.callbackOnReturn();
            return;
        }
        this.selectedChoicesKey = choise;
        if (choise === &quot;74_PREV_PAGE&quot;) {
            this.currentPage--;
            if (this.currentPage === 0)
                this.selectedChoicesKey = &quot;73_NEXT_PAGE&quot;;
        }
        else if (choise === &quot;73_NEXT_PAGE&quot;) {
            this.currentPage++;
            if (this.currentPage + 1 === this.pages)
                this.selectedChoicesKey = &quot;74_PREV_PAGE&quot;;
        }
        else {
            const stopRestartingScreen = this.proccessChoises(choise);
            
            if(stopRestartingScreen)
            {
                log(&quot;Alnivel_InterfaceLib_Message&quot;, &quot;Screen \&quot;&quot; + this.screenParameters.title + &quot;\&quot; restarting has been stopped by key &quot; + choise)
                return;
            }
                
        }

        this.screenParameters.choices = this.getPage(this.currentPage);
        this.screenParameters.initialChoicesKey = this.selectedChoicesKey;
        mission.runScreen(this.screenParameters, this.onChoiceSelected.bind(this));
    }

    this.PagedScreenController.prototype.runPage = function runPage(page, noUpdate) {
        log(&quot;Alnivel_InterfaceLib_Message&quot;, &quot;Started &quot; + this.screenParameters.title + &quot; mission screen&quot;);
        if(!noUpdate &amp;&amp; this.callbackOnRun)
            this.callbackOnRun();
        else
            this.screenParameters.initialChoicesKey = this.selectedChoicesKey;
        
        if(this.currentPage === undefined || this.currentPage &gt; this.pages)
            this.currentPage = 0;
        else
            this.currentPage = page;

        this.screenParameters.choices = this.getPage(this.currentPage);
        mission.runScreen(this.screenParameters, this.onChoiceSelected.bind(this));
    }

    this.PagedScreenController.prototype.runPageWithLine = function runPageWithLine(line, noUpdate) {
        log(&quot;Alnivel_InterfaceLib_Message&quot;, &quot;Started &quot; + this.screenParameters.title + &quot; mission screen&quot;);
        if(!noUpdate &amp;&amp; this.callbackOnRun)
            this.callbackOnRun();
        else
            this.screenParameters.initialChoicesKey = this.selectedChoicesKey;
        
        this.currentPage = 0;
        this.screenParameters.choices = this.getPageWithLine(line);
        mission.runScreen(this.screenParameters, this.onChoiceSelected.bind(this));
    }

    this.PagedScreenController.prototype.runPageWithLineIndex = function runPageWithLineIndex(lineIndex, noUpdate) {
        log(&quot;Alnivel_InterfaceLib_Message&quot;, &quot;Started &quot; + this.screenParameters.title + &quot; mission screen&quot;);
        if(!noUpdate &amp;&amp; this.callbackOnRun)
            this.callbackOnRun();
        else
            this.screenParameters.initialChoicesKey = this.selectedChoicesKey;
        
        this.currentPage = 0;
        this.screenParameters.choices = this.getPageWithLineIndex(lineIndex);
        mission.runScreen(this.screenParameters, this.onChoiceSelected.bind(this));
    }



    this.$limitText = function $limitText(text, limitWidth) {
        const ellipsis = &quot;â€¦&quot;;
        const hairSpace = String.fromCharCode(31);
        const hairSpaceWidth = defaultFont.measureString(hairSpace);

        let tmp = text;
        while (defaultFont.measureString(tmp) &gt; limitWidth) {
            tmp = tmp.substring(0, tmp.length - 2) + ellipsis;
        }
        
        const padsNeeded = Math.floor((limitWidth - defaultFont.measureString(tmp)) / hairSpaceWidth);
        if (padsNeeded &gt; 1)
            tmp = tmp + new Array(padsNeeded).join(hairSpace);

        return tmp;
    }

    /**
     * 
     * @param {string} text 
     * @param {&quot;left&quot;|&quot;right&quot;} padSide 
     * @param {number} desiredWidth 
     * @returns Padded text 
     */
    this.$padTextOnSide = function $padTextOnSide(text, padSide, desiredWidth) {
        const hairSpace = String.fromCharCode(31);
        const hairSpaceWidth = defaultFont.measureString(hairSpace);


        const textWidth = defaultFont.measureString(text);

        const padsNeeded = Math.floor((desiredWidth - textWidth) / hairSpaceWidth);

        let resultText;
        if (padsNeeded &gt; 1)
            if (padSide == &quot;left&quot;)
                resultText = new Array(padsNeeded).join(hairSpace) + text;
            else
                resultText = text + new Array(padsNeeded).join(hairSpace);
        else
            resultText = this.$limitText(text, desiredWidth);

        return resultText;
    }

    this.$padTextAround = function $padTextAround(text, desiredWidth) {
        const hairSpace = String.fromCharCode(31);
        const hairSpaceWidth = defaultFont.measureString(hairSpace);

        const textWidth = defaultFont.measureString(text);

        const padsNeeded = Math.floor((desiredWidth - textWidth) / (2 * hairSpaceWidth));

        let resultText;
        if (padsNeeded &gt; 1) {
            let sidePadding = new Array(padsNeeded).join(hairSpace);
            resultText = sidePadding + text + sidePadding;
        }
        else
            resultText = this.$limitText(text, desiredWidth);

        return resultText;
    }

    this.$repeatPattern = function $repeatPattern(pattern, desiredWidth) {
        const patternWidth = defaultFont.measureString(pattern);
        const repeatsNeeded = Math.ceil(desiredWidth / patternWidth);

        let tmp = new Array(repeatsNeeded).join(pattern);
        while (defaultFont.measureString(tmp) &gt; desiredWidth) {
            tmp = tmp.substring(0, tmp.length - 1);
        }

        return tmp
    }

    this.__LineWithCallbacksPrototype = {
        /**
         * Set callback that will be called when line is redrawing. 
         * The arguments for the function are same as for select callback, 
         * but it can return dictionary whose 
         * key-value pairs will be setted as choice parameters
         * @param {Function} updateCallback 
         * @returns Line object
         */
        onUpdate: function onUpdate(updateCallback) {
            this.updateCallback = updateCallback;
            return this;
        },
        /**
         * Set callback that will be called when line is selected. 
         * The arguments for the function depends on line type.
         * Is callback return true than screen will not redrawed. 
         * It can be used to change to another mission screen.
         * @param {*} selectCallback 
         * @returns Line object
         */
        onSelected: function onSelected(selectCallback) {
            this.selectCallback = selectCallback;
            return this;
        }
    }

    // TODO: Add lines hiding?

    /**
     * Create empty line object
     */
    this.EmptyLine = function () {}

    this.EmptyLine.prototype.update = function update() {
        return { text: &quot;&quot; };
    }

    /**
     * Create line object that can`t be selected
     * @param {string} text 
     */
    this.LabelLine = function (text, alignment) {
        this.choiceObject = {
            text: ILib.$padTextAround(text, 32),
            unselectable: true,
            color: &quot;whiteColor&quot;,
            alignment: alignment? alignment : &quot;CENTER&quot;
        }
    }

    this.LabelLine.prototype = Object.create(__LineWithCallbacksPrototype);
    this.LabelLine.prototype.update = function update() {
        if (this.updateCallback) {
            let updated = this.updateCallback();

            const updatedKeys = Object.keys(updated);
            for (let i = 0; i &lt; updatedKeys.length; i++) {
                const key = updatedKeys[i];
                const value = updated[key];
                if (value !== undefined &amp;&amp;
                    key !== &quot;unselectable&quot;) {

                    if (key === &quot;text&quot;)
                        this.choiceObject[key] = ILib.$padTextOnSide(value, &quot;right&quot;, 32);
                    else if (key === &quot;color&quot;)
                        this.choiceObject[key] = value === &quot;default&quot; ? &quot;whiteColor&quot; : value;
                    else
                        this.choiceObject[key] = value;
                }
            }

        }
        return this.choiceObject;
    };

    /**
     * Create line object that can be selected.
     * When selected onSelected callback will be called without any arguments
     * @param {string} text 
     */
    this.ButtonLine = function (text) {
        this.choiceObject = {
            text: ILib.$padTextOnSide(text, &quot;right&quot;, 32),
            color: &quot;cyanColor&quot;,
            alignment: &quot;LEFT&quot;
        };
        this.selectableColor = &quot;cyanColor&quot;;
        this.unselectableColor = &quot;darkGrayColor&quot;;
    }

    this.ButtonLine.prototype = Object.create(__LineWithCallbacksPrototype);
    this.ButtonLine.prototype.update = function update() {
        if (this.updateCallback) {
            let updated = this.updateCallback();
            const updatedKeys = Object.keys(updated);
            for (let i = 0; i &lt; updatedKeys.length; i++) {
                const key = updatedKeys[i];
                const value = updated[key];
                if (value !== undefined) {
                    if (key === &quot;color&quot;)
                        this.selectableColor = value === &quot;default&quot; ? &quot;cyanColor&quot; : value;
                    else if (key === &quot;text&quot;)
                        this.choiceObject[key] = ILib.$padTextOnSide(value, &quot;right&quot;, 32);
                    else
                        this.choiceObject[key] = value;
                }
            }
            if (this.choiceObject.unselectable)
                this.choiceObject.color = this.unselectableColor;
            else
                this.choiceObject.color = this.selectableColor;
        }

        return this.choiceObject;
    }
    this.ButtonLine.prototype.select = function select() {
        if (this.selectCallback)
            return this.selectCallback();
    }


    /**
     * Create line object that toggles between true and false when selected.
     * When selected onSelected callback will be called with new state as argument
     * @param {string} text 
     * @param {Boolean} initialState 
     */
    this.ToggleLine = function (text, initialState) {
        this.choiceObject = {
            color: &quot;cyanColor&quot;
        };
        this.selectableColor = &quot;cyanColor&quot;;
        this.unselectableColor = &quot;darkGrayColor&quot;;
        this.text = text;
        this.state = !!initialState;
    }

    this.ToggleLine.prototype = Object.create(__LineWithCallbacksPrototype);
    this.ToggleLine.prototype.update = function update() {
        if (this.updateCallback) {
            let updated = this.updateCallback(this.state);

            const updatedKeys = Object.keys(updated);
            for (let i = 0; i &lt; updatedKeys.length; i++) {
                const key = updatedKeys[i];
                const value = updated[key];
                if (value !== undefined) {
                    if (key === &quot;color&quot;)
                        this.selectableColor = value === &quot;default&quot; ? &quot;cyanColor&quot; : value;
                    else if (key === &quot;text&quot;)
                        this.text = value;
                    else if (key === &quot;state&quot;)
                        this.state = !!value;
                    else
                        this.choiceObject[key] = value;
                }
            }
            if (this.choiceObject.unselectable)
                this.choiceObject.color = this.unselectableColor;
            else
                this.choiceObject.color = this.selectableColor;
        }

        this.choiceObject.text =
            ILib.$padTextOnSide(this.text, &quot;right&quot;, 24) +
            ILib.$padTextAround(&quot; &lt; &quot; + (this.state ? &quot;On&quot; : &quot;Off&quot;) + &quot; &gt; &quot;, 8);
        return this.choiceObject;
    }
    this.ToggleLine.prototype.select = function select() {
        this.state = !this.state;
        if (this.selectCallback)
            return this.selectCallback(this.state);
    }


    /**
     * Create line object that cycles between the specified values when selected.
     * When selected onSelected callback will be called with new index and value as arguments
     * @param {string} text
     * @param {Array|Object.&lt;string, any&gt;} items If it is an array the values are 
     * the same as the labels, otherwise it is treated as a dictionary of labels to values
     * @param {any} [initialItem] 
     */
    this.CycleLine = function (text, items, initialItem) {
        const itemsIsArray = Array.isArray(items);
        const itemKeys = itemsIsArray ? items : Object.keys(items);

        let itemValues;
        if (itemsIsArray)
            itemValues = items
        else { // Object.values(items);
            itemValues = Array(itemKeys.length)
            for (let i = 0; i &lt; itemKeys.length; i++)
                itemValues[i] = items[itemKeys[i]]
        }

        let initialIndex = itemKeys.indexOf(initialItem);
        if (initialIndex === -1)
            initialIndex = 0;

        this.choiceObject = {
            color: &quot;cyanColor&quot;,
        };
        this.items = itemKeys;
        this.values = itemValues;
        this.currentIndex = initialIndex;
        this.text = text;
        this.selectableColor = &quot;cyanColor&quot;;
        this.unselectableColor = &quot;darkGrayColor&quot;;
    }

    this.CycleLine.prototype = Object.create(__LineWithCallbacksPrototype);
    this.CycleLine.prototype.update = function update() {
        if (this.updateCallback) {
            let updated = this.updateCallback(this.currentIndex, this.values[this.currentIndex]);

            const updatedKeys = Object.keys(updated);
            for (let i = 0; i &lt; updatedKeys.length; i++) {
                const key = updatedKeys[i];
                const value = updated[key];
                if (value !== undefined) {
                    if (key === &quot;color&quot;)
                        this.selectableColor = value === &quot;default&quot; ? &quot;cyanColor&quot; : value;
                    else if (key === &quot;text&quot;)
                        this.text = value;
                    else if (key === &quot;currentIndex&quot;) {
                        this.currentIndex = value;
                    }
                    else
                        this.choiceObject[key] = value;
                }
            }
            if (this.choiceObject.unselectable)
                this.choiceObject.color = this.unselectableColor;
            else
                this.choiceObject.color = this.selectableColor;
        }

        const currentItem = this.items[this.currentIndex];
        this.choiceObject.text =
            ILib.$padTextOnSide(this.text, &quot;right&quot;, 24) +
            ILib.$padTextAround(&quot; &lt; &quot; + currentItem + &quot; &gt; &quot;, 8);

        return this.choiceObject;
    }
    this.CycleLine.prototype.select = function select() {
        this.currentIndex = (this.currentIndex + 1) % this.values.length;
        if (this.selectCallback)
            return this.selectCallback(this.currentIndex, this.values[this.currentIndex]);
    }

}).call(this);</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/interface-reordering-main.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name = &quot;InterfaceReordering&quot;;
this.author = &quot;Alnivel&quot;;
this.copyright = &quot;2022 Alnivel&quot;;
this.version = &quot;0.2&quot;;
this.licence = &quot;CC BY-NC-SA 4.0&quot;;


this.$interfacePrefixes = {/* key: prefix */ };

this.$idToStationMap = [/* stationId: station */];
this.$stationIdToInterfacesMap = [/* stationId: { key: interfaceDefinition }*/];

/// Replace orginal method with one which modify original interface category 
/// to visualy similar string that will be placed acording to interfaceOrder
///
/// If something add interface directly in the body of the script, the set  
/// interface will be above all others and can&#39;t be reordered until it will be reset
///
/// Well, it could be worse

this.$originalSetInterface = Station.prototype.setInterface;

(function substituteSetInterface() {
    let idToStationMap = this.$idToStationMap;
    let stationIdToInterfacesMap = this.$stationIdToInterfacesMap;

    let script = this;

    let originalSetInterface = this.$originalSetInterface;

    Station.prototype.setInterface = function (key, interfaceDefinition) {

        let stationId = idToStationMap.indexOf(this);
        if (stationId === -1) {
            stationId = idToStationMap.length;
            idToStationMap.push(this);
            stationIdToInterfacesMap[stationId] = {};
        }
        let seenInterfaces = stationIdToInterfacesMap[stationId];

        if (interfaceDefinition !== null) {


            let reorderedDefinition = {};
            for (let idKey in interfaceDefinition) {
                reorderedDefinition[idKey] = interfaceDefinition[idKey];
            }

            // // A way to get the name of the calling script
            // let stack = new Error().stack;
            // let callerScript = stack.substring(
            //     stack.indexOf(&quot;\&quot;(\&quot;&quot;) + 3, 
            //     stack.indexOf(&quot;\&quot;,[object Object])&quot;)
            // );
            //            
            // interfaceDefinition.InterfaceReordering_callerScript = callerScript;
            // //

            // I hope someone doesn&#39;t use the same key as an existing category
            let prefix = script.$interfacePrefixes[key] ||
                script.$interfacePrefixes[interfaceDefinition.category] ||
                script.$interfacePrefixes[&quot;InterfaceReordering_OtherPrefix&quot;];

            reorderedDefinition.category = prefix + interfaceDefinition.category;

            originalSetInterface.call(this, key, reorderedDefinition);
            seenInterfaces[key] = interfaceDefinition;


        }
        else {
            originalSetInterface.call(this, key, null);

            if (seenInterfaces[key])
                seenInterfaces[key] = null;
        }



    }

}).call(this);


this.startUp = function () {
    const storedInterfaceOrder = JSON.parse(missionVariables.interfaceReordering_interfaceOrder);
    if (storedInterfaceOrder)
        this.$interfaceOrder = storedInterfaceOrder;

    const hasOtherEntry = this.$interfaceOrder.some(function (orderItem) {
        return orderItem.key === &quot;InterfaceReordering_OTHER&quot;;
    })
    if (!hasOtherEntry) {
        this.$interfaceOrder.push({ key: &quot;InterfaceReordering_OTHER&quot;, name: &quot;&lt;Other interfaces&gt;&quot;, type: &quot;&quot; });
    }

    // copy loaded order to variable that used by user interface
    this.$unsavedInterfaceOrder.length = 0;
    Array.prototype.push.apply(this.$unsavedInterfaceOrder, this.$interfaceOrder);

    this.$updateInterfaceOrder(this.$interfaceOrder);
}

this.interfaceInitialized = false;
this.startUpComplete = this.shipDockedWithStation = function () {
    if (!this.interfaceInitialized) {
        this.$initializeInterfaceScreens();
        this.interfaceInitialized = true;
    }

    const interfaceMain = this.$screens.main;
    const station = player.ship.dockedStation;
    station.setInterface(&quot;InterfaceReordering_ManageOrder&quot;, {
        title: &quot;Reorder interfaces&quot;,
        category: &quot;Ship Systems&quot;,
        summary: &quot;Change the order of interfaces&quot;,
        callback: interfaceMain.runScreen.bind(interfaceMain)
    });
}

this.playerWillSaveGame = function () {
    missionVariables.interfaceReordering_interfacePrefixes = JSON.stringify(this.$interfacePrefixes);
    missionVariables.interfaceReordering_interfaceOrder = JSON.stringify(this.$interfaceOrder);
};

// Clear known stations and interfaces before 
// any interfaces from new system will be set
this.shipWillEnterWitchspace = function () {
    this.$idToStationMap.length = 0;
    this.$stationIdToInterfacesMap.length = 0;
};

// Settings interface //

this.$screens = {};

this.$interfaceOrder = [
    { key: &quot;InterfaceReordering_OTHER&quot;, name: &quot;&lt;Other interfaces&gt;&quot;, type: &quot;&quot; },
    /* Other entries looks like
    {key: &quot;&lt;interfaceKey&gt;&quot;, name:&quot;&lt;interfaceName&gt;&quot;,  type:&quot;Interface&quot;},
    {key: &quot;&lt;categoryName&gt;&quot;, name:&quot;&lt;categoryName&gt;&quot;,  type:&quot;Category&quot;},
    */
];
this.$unsavedInterfaceOrder = []; // changes in order stored here until they saved 

this.$initializeInterfaceScreens = function $initializeInterfaceScreens() {
    /*** Binding script variables to function scope ***/
    const ILib = worldScripts[&quot;InterfaceReordering_InterfaceLib&quot;];
    const mainScript = this;
    const screens = this.$screens;
    const stationIdToInterfacesMap = this.$stationIdToInterfacesMap;
    const idToStationMap = this.$idToStationMap;
    const updateInterfaceOrder = this.$updateInterfaceOrder.bind(this);

    const interfaceOrder = this.$unsavedInterfaceOrder;
    let selectedOrderItemKey = null;
    let selectedOrderItemIndex = null;

    const station = player.ship.dockedStation
    const stationId = idToStationMap.indexOf(station);
    const interfacesOnStation = stationId === -1 ? {} : stationIdToInterfacesMap[stationId];

    /*** ***/
    let interfaceOrderWasChanged = false;
    const saveChangesAndResetSelected = function () {
        selectedOrderItemKey = null;
        selectedOrderItemIndex = null;
        if (interfaceOrderWasChanged) {
            updateInterfaceOrder(interfaceOrder);
            interfaceOrderWasChanged = false;
        }
    };

    const cancelChangesAndResetSelected = function () {
        selectedOrderItemKey = null;
        selectedOrderItemIndex = null;

        if (interfaceOrderWasChanged) {        
            interfaceOrder.length = 0;
            Array.prototype.push.apply(interfaceOrder, mainScript.$interfaceOrder)
            interfaceOrderWasChanged = false;
        }

        this.screenParameters.initialChoicesKey = undefined;
    }

    const resetOrderList = function () {
        selectedOrderItemIndex = null;
        selectedOrderItemKey = null;
        interfaceOrder.length = 0;
        interfaceOrder.push({ key: &quot;InterfaceReordering_OTHER&quot;, name: &quot;&lt;Other interfaces&gt;&quot;, type: &quot;&quot; });
        interfaceOrderWasChanged = true;
        screens.interfaceOrderList.runPageWithLineIndex(0);
    };

    const formatToReorderingListColumns = function (no, name, type) {
        return &quot;&quot; +
            ILib.$padTextAround(no, 4) +
            ILib.$padTextOnSide(name, &quot;right&quot;, 22) +                
            ILib.$padTextAround(&quot;&quot;, 1) +
            ILib.$padTextOnSide(type, &quot;right&quot;, 5)
    }

    const updateListItem = function () {
        let item = interfaceOrder[this.data_index];
        let isSelected = this.data_index === selectedOrderItemIndex;
        //log(&quot;InterfaceReordering_Message&quot;, &quot;Updated line to \&quot;&quot; + &quot;Name &quot; + item.name + &quot; Type &quot; + item.type + &quot;\&quot;&quot;);
        return {
            text: formatToReorderingListColumns(this.data_index + 1, item.name, item.type),
            color: isSelected ? &quot;yellowColor&quot; : &quot;default&quot;,
            alignment: &quot;LEFT&quot;
        }
    }

    const selectListItem = function () {
        let item = interfaceOrder[this.data_index];
        selectedOrderItemKey = item.key;
        selectedOrderItemIndex = this.data_index;

        screens.moveItem.screenParameters.initialChoicesKey = undefined;
        screens.moveItem.runPageWithLineIndex(this.data_index);
        return true;
    }

    const spacerLine = new ILib.EmptyLine();
    const delimiterLine = new ILib.LabelLine(ILib.$repeatPattern(&quot;-&quot;, 32));
    const interfaceOrderListHeaderLine = new ILib.LabelLine(formatToReorderingListColumns(&quot;#&quot;, &quot;Name&quot;, &quot;Type&quot;));

    const interfaceOrderListScreenParameters = {
        title: &quot;Reorder interfaces&quot;,
        screenID: &quot;InterfaceReordering_Main&quot;,
        allowInterrupt: true,
        exitScreen: &quot;GUI_SCREEN_INTERFACES&quot;
    }

    const interfaceOrderListScreen = new ILib.PagedScreenController(interfaceOrderListScreenParameters);
    interfaceOrderListScreen: {
        this.$screens.main = interfaceOrderListScreen;
        this.$screens.interfaceOrderList = interfaceOrderListScreen;

        interfaceOrderListScreen.addToHeader(interfaceOrderListHeaderLine);
        interfaceOrderListScreen.addToHeader(delimiterLine);

        interfaceOrderListScreen.addToFooter(delimiterLine);
        interfaceOrderListScreen.addToFooter(new ILib.ButtonLine(&quot;Save changes&quot;)
            .onUpdate(function () {
                return {
                    color: &quot;yellowColor&quot;, // selectable color
                    unselectable: !interfaceOrderWasChanged
                };
            })
            .onSelected(saveChangesAndResetSelected)
        );
        interfaceOrderListScreen.addToFooter(new ILib.ButtonLine(&quot;Add interface&quot;)
            .onSelected(function () {
                screens.addInterface.runScreen();
                return true;
            })
        );
        interfaceOrderListScreen.addToFooter(new ILib.ButtonLine(&quot;Add category&quot;)
            .onSelected(function () {
                screens.addCategory.runScreen();
                return true;
            })
        );
        interfaceOrderListScreen.addToFooter(new ILib.ButtonLine(&quot;Reset&quot;)
            .onSelected(resetOrderList)
        );
        interfaceOrderListScreen.addToFooter(spacerLine);


        const updateReorderingListScreen = function updateReorderingListScreen() {

            this.clearContent(); // this === interfaceOrderListScreen;

            const reorderListCount = interfaceOrder.length;

            for (let i = 0; i &lt; reorderListCount; i++) {
                let line = new ILib.ButtonLine(&quot;Line&quot;)
                    .onUpdate(updateListItem)
                    .onSelected(selectListItem);
                line.data_index = i;
                this.addToContent(line);
            }
        }

        interfaceOrderListScreen.onRun(updateReorderingListScreen);
        interfaceOrderListScreen.onReturn(cancelChangesAndResetSelected);
    }

    const returnToOrderList = interfaceOrderListScreen.returnToScreen.bind(interfaceOrderListScreen);

    const moveItemScreen = new ILib.PagedScreenController(interfaceOrderListScreenParameters);
    moveItemScreen: {
        this.$screens.moveItem = moveItemScreen;

        moveItemScreen.addToHeader(interfaceOrderListHeaderLine);
        moveItemScreen.addToHeader(delimiterLine);

        moveItemScreen.addToFooter(delimiterLine);
        moveItemScreen.addToFooter(new ILib.ButtonLine(&quot;Deselect&quot;)
            .onSelected(function () {
                selectedOrderItemKey = null;
                selectedOrderItemIndex = null;
                interfaceOrderListScreen.screenParameters.initialChoicesKey = interfaceOrderListScreen.selectedChoicesKey;
                interfaceOrderListScreen.runPage(moveItemScreen.currentPage);
                return true;
            })
        );
        moveItemScreen.addToFooter(new ILib.ButtonLine(&quot;Move up&quot;)
            .onUpdate(function () {
                return {
                    unselectable: interfaceOrder.length &lt;= 1
                };
            })
            .onSelected(function () {
                let minPosition = 0;
                let newPosition = selectedOrderItemIndex - 1;
                if (newPosition &lt; minPosition)
                    newPosition = interfaceOrder.length - 1;

                let temp = interfaceOrder[selectedOrderItemIndex];
                interfaceOrder[selectedOrderItemIndex] = interfaceOrder[newPosition];
                interfaceOrder[newPosition] = temp;

                selectedOrderItemIndex = newPosition;

                interfaceOrderWasChanged = true;
                moveItemScreen.runPageWithLineIndex(selectedOrderItemIndex, true);
                return true;
            })
        );
        moveItemScreen.addToFooter(new ILib.ButtonLine(&quot;Move down&quot;)
            .onUpdate(function () {
                return {
                    unselectable: interfaceOrder.length &lt;= 1
                };
            })
            .onSelected(function () {
                let maxPosition = interfaceOrder.length - 1;
                let newPosition = selectedOrderItemIndex + 1;
                if (newPosition &gt; maxPosition)
                    newPosition = 0;

                let temp = interfaceOrder[selectedOrderItemIndex];
                interfaceOrder[selectedOrderItemIndex] = interfaceOrder[newPosition];
                interfaceOrder[newPosition] = temp;

                selectedOrderItemIndex = newPosition;

                interfaceOrderWasChanged = true;
                moveItemScreen.runPageWithLineIndex(selectedOrderItemIndex, true);
                return true;
            })
        );
        moveItemScreen.addToFooter(new ILib.ButtonLine(&quot;Remove&quot;)
            .onUpdate(function () {
                return {
                    unselectable: selectedOrderItemKey === &quot;InterfaceReordering_OTHER&quot;
                }
            })
            .onSelected(function () {
                if (selectedOrderItemKey !== &quot;InterfaceReordering_OTHER&quot;) {
                    interfaceOrder.splice(selectedOrderItemIndex, 1);
                    let returnIndex = selectedOrderItemIndex === 1 ? 0 : selectedOrderItemIndex - 1;

                    selectedOrderItemKey = null;
                    selectedOrderItemIndex = null;

                    interfaceOrderWasChanged = true;
                    interfaceOrderListScreen.runPageWithLineIndex(returnIndex);

                    return true;
                }
            })
        );
        moveItemScreen.addToFooter(spacerLine);

        const updateMoveItemScreen = function updateMoveItemScreen() {
            this.clearContent(); // this === updateMoveItemScreen;

            const reorderListCount = interfaceOrder.length;

            for (let i = 0; i &lt; reorderListCount; i++) {
                let line = new ILib.LabelLine(&quot;Line&quot;)
                    .onUpdate(updateListItem);
                line.data_index = i;
                this.addToContent(line);
            }
        }

        moveItemScreen.onRun(updateMoveItemScreen);
        moveItemScreen.onReturn(cancelChangesAndResetSelected);
    }


    /*** Adding order items to main list ***/

    const addItemAndReturnToList = function (pair, type) {
        const newItemIndex = interfaceOrder.length;
        interfaceOrder.push({ key: pair.key, name: pair.name, type: type });

        interfaceOrderWasChanged = true;
        screens.interfaceOrderList.screenParameters.initialChoicesKey = screens.interfaceOrderList.selectedChoicesKey;
        screens.interfaceOrderList.runPageWithLineIndex(newItemIndex);
        return true;
    }

    const addAllItemsAndReturnToList = function (items, type) {
        let lastItemIndex;
        for (let i = 0; i &lt; items.length; i++) {
            let pair = items[i];
            lastItemIndex = interfaceOrder.length;
            interfaceOrder.push({ key: pair.key, name: pair.name, type: type });
        }

        interfaceOrderWasChanged = true;
        screens.interfaceOrderList.screenParameters.initialChoicesKey = screens.interfaceOrderList.selectedChoicesKey;
        screens.interfaceOrderList.runPageWithLineIndex(lastItemIndex);
        return true;
    }

    const updateItems = function updateItems(type, makePairFunc) {
        const itemsInUse = interfaceOrder.reduce(function (accum, orderItem) {
            if (orderItem.type === type)
                accum[orderItem.key] = 1;
            return accum;
        }, {});

        this.clearContent();
        let noItemsToAdd = true;
        const items = [];

        for (let key in interfacesOnStation) {
            let id = interfacesOnStation[key];
            if (id === null)
                continue;

            const pair = makePairFunc(key, id);
            if (itemsInUse[pair.key])
                continue;
            itemsInUse[pair.key] = 1;

            let line = new ILib.ButtonLine(pair.name).onSelected(function () {
                return addItemAndReturnToList(this.data_pair, this.data_type)
            });
            line.data_pair = pair;
            line.data_type = type;
            this.addToContent(line);

            noItemsToAdd = false;
            items.push(pair);
        }

        if (noItemsToAdd)
            this.addToContent(new ILib.LabelLine(&quot;No items to add&quot;, &quot;CENTER&quot;));
        this.data_items = items;
    }

    addInterfaceScreen: {
        const addInterfaceScreen = this.$screens.addInterface = new ILib.PagedScreenController({
            title: &quot;Add interface&quot;,
            screenID: &quot;InterfaceReordering_AddInterface&quot;,
            allowInterrupt: true,
            exitScreen: &quot;GUI_SCREEN_INTERFACES&quot;
        }, returnToOrderList)
            .onRun(function () {
                updateItems.call(this, &quot;Interface&quot;, function (key, id) {
                    return { key: key, name: id.title };
                });
            });

        addInterfaceScreen.addToHeader(delimiterLine);
        addInterfaceScreen.addToFooter(delimiterLine);
        addInterfaceScreen.addToFooter(new ILib.ButtonLine(&quot;Add all&quot;)
            .onUpdate(function () {
                let isItemsToAdd = addInterfaceScreen.data_items &amp;&amp;
                    addInterfaceScreen.data_items.length &gt; 0;
                return {
                    unselectable: !isItemsToAdd
                };
            })
            .onSelected(function () {
                const items = addInterfaceScreen.data_items;
                return addAllItemsAndReturnToList.call(this, items, &quot;Interface&quot;)
            })
        );
    }

    addCategoryScreen: {
        const addCategoryScreen = this.$screens.addCategory = new ILib.PagedScreenController({
            title: &quot;Add category&quot;,
            screenID: &quot;InterfaceReordering_AddCategory&quot;,
            allowInterrupt: true,
            exitScreen: &quot;GUI_SCREEN_INTERFACES&quot;
        }, returnToOrderList)
            .onRun(function () {
                updateItems.call(this, &quot;Category&quot;, function (key, id) {
                    return { key: id.category, name: id.category };
                });
            });

        addCategoryScreen.addToHeader(delimiterLine);
        addCategoryScreen.addToFooter(delimiterLine);
        addCategoryScreen.addToFooter(new ILib.ButtonLine(&quot;Add all&quot;)
            .onUpdate(function () {
                let isItemsToAdd = addCategoryScreen.data_items &amp;&amp;
                    addCategoryScreen.data_items.length &gt; 0;
                return {
                    unselectable: !isItemsToAdd
                };
            })
            .onSelected(function () {
                const items = addCategoryScreen.data_items;
                return addAllItemsAndReturnToList.call(this, items, &quot;Category&quot;)
            })
        );
    }
}

// Order updating //

this.$updateInterfaceOrder = function $updateInterfaceOrder(newReorderings) {
    const originalSetInterface = this.$originalSetInterface;

    for (let stationId = 0; stationId &lt; this.$stationIdToInterfacesMap.length; stationId++) {
        let station = this.$idToStationMap[stationId];
        if (!station || !station.isValid) {
            this.$idToStationMap[stationId] = null;
            this.$stationIdToInterfacesMap[stationId] = null;
            continue;
        }

        let interfaces = this.$stationIdToInterfacesMap[stationId];
        for (let key in interfaces) {
            originalSetInterface.call(station, key, null); // hide all
        }
    }

    this.$interfacePrefixes = this.$makeInterfacePrefixes(newReorderings);
    this.$interfaceOrder = newReorderings.slice(); // NOT SPLICE
    this.$unsavedInterfaceOrder.length = 0;
    Array.prototype.push.apply(this.$unsavedInterfaceOrder, this.$interfaceOrder);

    log(&quot;InterfaceReordering_Message&quot;, &quot;New prefixes set: &quot; + JSON.stringify(this.$interfacePrefixes));

    for (let stationId = 0; stationId &lt; this.$stationIdToInterfacesMap.length; stationId++) {
        let station = this.$idToStationMap[stationId];
        if (!station)
            continue;

        let interfaces = this.$stationIdToInterfacesMap[stationId];
        for (let key in interfaces) {
            let interfaceDefinition = interfaces[key];
            station.setInterface(key, interfaceDefinition); // show with new rules
        }
    }
}

this.$makeInterfacePrefixes = function $makeInterfacePrefixes(interfaceOrder) {
    return this.$makeInterfacePrefixes_V1(interfaceOrder);
}

/// Use zero width and hair spaces, on some computers they even don&#39;t display as &quot;?&quot;
this.$makeInterfacePrefixes_V0 = function $makeInterfacePrefixes_V0(interfaceOrder) {
    // 0x200A - hair space character
    // 0x200B - zero width character
    const markerBeforeOthers = String.fromCharCode(0x200A) + String.fromCharCode(0x200B) + String.fromCharCode(0x200B);
    const markerOthers = String.fromCharCode(0x200B) + String.fromCharCode(0x200A) + String.fromCharCode(0x200B);
    const markerAfterOthers = String.fromCharCode(0x200B) + String.fromCharCode(0x200B) + String.fromCharCode(0x200A);
    const markerDepth = String.fromCharCode(0x200B);

    const interfacePrefixes = {/* key: prefix */ };

    let beforeOthers = true;
    let depthLevel = 1;
    for (let i = 0; i &lt; interfaceOrder.length; i++) {
        let orderItem = interfaceOrder[i];
        if (orderItem.type === &quot;&quot;) {
            beforeOthers = false;
            depthLevel = 1;
        }
        else if (beforeOthers) {
            interfacePrefixes[orderItem.key] = markerBeforeOthers + new Array(depthLevel).join(markerDepth);
        }
        else {
            interfacePrefixes[orderItem.key] = markerAfterOthers + new Array(depthLevel).join(markerDepth);
        }
        depthLevel += 1;
    }

    interfacePrefixes[&quot;InterfaceReordering_OtherPrefix&quot;] = markerOthers;

    return interfacePrefixes;
}

this.$makeInterfacePrefixes_V1 = function $makeInterfacePrefixes_V1(interfaceOrder) {
    const markerBeforeOthers = String.fromCharCode(0x1F, 0x1F);
    const markerOthers = String.fromCharCode(0x1F, 0x200A);
    const markerAfterOthers = String.fromCharCode(0x200A, 0x200A);
    const markerDepth = String.fromCharCode(0x200A);

    const interfacePrefixes = {/* key: prefix */ };

    let beforeOthers = true;
    let depthLevel = 1;
    for (let i = 0; i &lt; interfaceOrder.length; i++) {
        let orderItem = interfaceOrder[i];
        if (orderItem.type === &quot;&quot;) {
            beforeOthers = false;
            depthLevel = 1;
        }
        else if (beforeOthers) {
            interfacePrefixes[orderItem.key] = markerBeforeOthers + new Array(depthLevel).join(markerDepth);
        }
        else {
            interfacePrefixes[orderItem.key] = markerAfterOthers + new Array(depthLevel).join(markerDepth);
        }
        depthLevel += 1;
    }

    interfacePrefixes[&quot;InterfaceReordering_OtherPrefix&quot;] = markerOthers;

    return interfacePrefixes;
}
</pre></td>
                </tr>
            </table>
        </a>
    </body>
</html>
