<html>
    <head>
        <title>Expansion Escort Deck</title>
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <table border="0" width="100%">
            <tr>
                <td>Back to <a href='../index.html'>Index</a></td>
                <td align="right"><small>Page generated: Oct 11, 2023, 3:16:48 PM</small></td>
            </tr>
        </table>

        <h1>Expansion Escort Deck</h1>

        <h2>Content</h2>
        <ul>
          
          <li><a href="#manifest">Manifest</a></li>
          <li><a href="#documentation">Documentation</a></li>
          <li><a href="#equipment">8 Equipment</a></li>
          <li><a href="#ships">5 Ships</a></li>
          <li><a href="#models">0 Models</a></li>
          <li><a href="#scripts">12 Scripts</a></li>
        </ul>


        <a name="manifest">
        <h2>Manifest</h2>
            <table border="1">
                <tr>
                    <th></th>
                    <th>from Expansion Manager's OXP list</th>
                    <th>from Expansion Manifest</th>
                </tr>
                <tr>
                    <td>Description</td>
                    <td>Build up your escort fleet and hold on an external deck attached to your ship. Salvage damaged ships for cash.</td>
                    <td>Build up your escort fleet and hold on an external deck attached to your ship. Salvage damaged ships for cash.</td>
                </tr>
                <tr>
                    <td>Identifier</td>
                    <td>oolite.oxp.Norby.EscortDeck</td>
                    <td>oolite.oxp.Norby.EscortDeck</td>
                </tr>
                <tr>
                    <td>Title</td>
                    <td>Escort Deck</td>
                    <td>Escort Deck</td>
                </tr>
                <tr>
                    <td>Category</td>
                    <td>Activities</td>
                    <td>Activities</td>
                </tr>
                <tr>
                    <td>Author</td>
                    <td>Norby</td>
                    <td>Norby</td>
                </tr>
                <tr>
                    <td>Version</td>
                    <td>1.12</td>
                    <td>1.12</td>
                </tr>
                <tr>
                    <td>Tags</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Required Oolite Version</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Maximum Oolite Version</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Required Expansions</td>
                    <td>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>Optional Expansions</td>
                    <td>
                            <li>oolite.oxp.Norby.Carriers:0.9</li>
                            <li>oolite.oxp.Norby.EscortPack:1.1</li>
                            <li>oolite.oxp.Norby.Towbar:0.98</li>
                            <li>oolite.oxp.Svengali.Library:1.7.1</li>
                    </td>
                    <td>
                            <li>oolite.oxp.Norby.Carriers:0.9</li>
                            <li>oolite.oxp.Norby.EscortPack:1.1</li>
                            <li>oolite.oxp.Norby.Towbar:0.98</li>
                            <li>oolite.oxp.Svengali.Library:1.7.1</li>
                    </td>
                </tr>
                <tr>
                    <td>Conflict Expansions</td>
                    <td>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>Information URL</td>
                    <td><a target="_blank" href="http://wiki.alioth.net/index.php/EscortDecks">http://wiki.alioth.net/index.php/EscortDecks</a></td>
                    <td><a target="_blank" href="">n/a</a></td>
                </tr>
                <tr>
                    <td>Download URL</td>
                    <td><a target="_blank" href="https://wiki.alioth.net/img_auth.php/9/92/EscortDeck-1.12.oxz">https://wiki.alioth.net/img_auth.php/9/92/EscortDeck-1.12.oxz</a></td>
                    <td><a target="_blank" href="">n/a</a></td>
                </tr>
                <tr>
                    <td>License</td>
                    <td>CC BY-NC-SA 4.0</td>
                    <td>CC BY-NC-SA 4.0</td>
                </tr>
                <tr>
                    <td>File Size</td>
                    <td>n/a</td>
                </tr>
                <tr>
                    <td>Upload date</td>
                    <td>1671037018</td>
                </tr>
            </table>
                </a>

        <a name="documentation">
        <h2>Documentation</h2>
        <p>Also read <a href='http://wiki.alioth.net/index.php/Escort%20Deck'>http://wiki.alioth.net/index.php/Escort%20Deck</a></p>
        <h3>Readme</h3>
        <pre>Escort Deck


Build up your escort fleet and hold on an external deck attached to your ship.

First you must buy Escort Deck equipment then you will see an attached platform in your aft view.


Ship rules

A deck provide 4 landing pads for escort ships with max. 130t mass, 70m width, 29m height and 95m length: Adder, Asp, Cobra Mark I, Constrictor, Fer-de-Lance, Gecko, Mamba, Moray, Sidewinder and Viper.

If your ship is over 130t mass like Cobra Mark III then can hold another two small ships like Adders (max. 30t, 15m height, 39m width and 65m length) on the sides of the deck.

The mass of your escort must be less than 40% of your ship&#39;s mass. For example an Asp (75t) can hold 4 small escorts below 30t: Adder, Gecko or Sidewinder. You should use a ship over 40t mass to be able to use Adders (16t) as escorts. Ships below 30t mass can not get Escort Deck.

Beware of replacing your large ship to a smaller one, all of your escorts will be salvaged which isn&#39;t fit into the smaller limits.


Wide deck

Ships over 260t like Python receive wider deck to hold escorts up to 95m width like Krait or Tiger Ray (http://aegidian.org/bb/viewtopic.php?f=2&amp;t=16926&amp;hilit=Tiger+Ray&amp;start=45#p229820).


Purchasing escorts

You can buy escorts in the ship outfitting (F3) screen. These are not available in the local shipyard but ordered from a remote owner so your time will forwarding a lot if you buy one, but in this way you can buy advanced ships in the low tech worlds also.

 Name	Cost	Energy	Recharg	Speed	Pitch	Mass t	Eqipment
 Adder	80000	85	2	240	2	16	Pulse laser, Injectors, Shield booster
 Asp	400000	350	4	400	1	75	Beam Lasers forward and aft, ECM, Injectors, Shield booster
 Gecko	100000	250	4	300	1.5	25	Beam Laser, ECM
 Sidew.	76000	240	2	370	1.6	26	Beam Laser
 Viper	600000	180	4	320	1.8	34	Military Laser, ECM, Injectors, Shield booster and enhancer

There are very good pirate escort ships but these are not purchaseable in main stations: you must force to eject the pilot or find in the outfitting list in alternative stations.

There are rumors about ace sniper pilots in pirate stations with better ships than an Asp, but these surely costs more than 1MCr if you want to hire them into your escort fleet.


Derelicts

You can pick up derelict ships: put your target lock on, go nearer than 300m and with less than 100m/s speed difference. If you can not target it (due to the target has jamming device) then you can collide very slowly to trigger the pickup.

If an &quot;usable&quot; message shown in your console when target a derelict ship (Combat MFD show it also) then you can use this ship as your escort, else transfer it to a dock on your deck and you will get some money for the salvage.

If you have Towbar OXP then you will get reputation also for the delivered salvage.


Heavy escorts

There are heavy escorts around 120t mass, these are multipurpose ships modified for escort jobs which mean removed cargo capacity and some bonuses (please install Escort Pack OXP to get these).

You need a ship with 325t mass to be able to use all escorts up to the maximal 130t, so an Anaconda or special (OXP) Pythons can hold heavy escorts but a Cobra Mark III (215t) or a Boa (182t) can&#39;t.


Usage

You can prime Escort Deck with Shift+N then activate with &quot;n&quot; key to launch or call back your escorts. The mode key &quot;b&quot; select a single escort for launch or callback. You can not launch escorts over normal speeds to avoid collisions.

You can prevent the launch of any ship if you select it by the mode key then activate once only: the first press will change the status to &quot;LOCKED&quot;. The second activate will remove the lock and launch it, but you can call back instantly with a third keypress if you want to stay on the deck without the lock.

There is an auto launch if you enter into red alert and auto callback when changed to green.

There is a Multi-Function Display of Escort Deck, you can turn it on using the &quot;:&quot; and &quot;;&quot; keys. This show the list of current escorts, a  &quot;-&gt;&quot; mark before the selected one, name, energy, fuel (if this escort has working Injectors), distance, bearing (^&gt; mean up left) and activity:

 ATTACK: Attack a hostile ship (your target first)
 DECK: Landed on the deck
 FLEE: Flee from a missile or recover some energy (from 40% to 80%)
 FOLLOW: Follow your ship at 2km range
 GOTO: Go to a hostile ship using Injectors if available until arrive within Beam Laser range (15km)
 INJECT: Attack using Injectors until distance is over 10km
 LANDING: Landing approach, will not do anything else until landed
 LOCKED: Stay on the deck and will not launch with the other ships
 SALVAGE: Unusable ship, will be salvaged in the next dock for a few thousand credits
 SNIPER: Sniper attack, need a forward laser over 15km range, like Military Laser

You can pick up a new escort even if no more free landing pads listed on your MFD if you select a pad and maintain a target lock on the new ship when try to land or an escort is not in your deck. In these cases will replace the old one what you will find a bit farther behind your ship.

The released escort will follow you (if is not derelict) until you stay within the same system and don&#39;t take a rest (reload the game), but will not defend you just itself. So you can pick up a derelict ship by replacing one of your escorts, transfer it into a station for payment, then leave the station and relock your old escort to the deck.

If you dock or enter into a wormhole while some of your escorts are not in your deck then those that is within your scanner range will be docked also. Others can be lost, especially if travelled far from you.

If you want to exchange the positions of two escorts on your deck then do these in order:
 1. Select an escort by mode key (b) if Escort Deck is primed with Shift+N and all escorts landed.
 2. Launch it with the activate key (n) and wait a few seconds to go out of landing distance.
 3. Press activate (n) again to order it back to landing and turn your ship to keep it in your screen.
 4. Press mode (b) until you select the second escort to flag the wanted landing position.
 5. Put your target lock to the launched ship: press &quot;r&quot; and aim well with your crosshairs.
 6. Wait for landing when the exchange will be done.

The MFD can show the ship on Towbar in the last line, maked as T: . You can release the towed ship by selecting and activating it in this MFD. If no ship on your Towbar then show the maximal mass which your ship can tow (1.6 times of the mass of your ship).

Your escorts will be refuelled when you buy fuel for your ship.


Cost: 2000.0 Cr.
Techlevel: 1



Escort Deck XL

If your ship is over 400t like an Anaconda then this longer deck can hold 8 escorts behind you, but the mass limit is lower: max. 60t, so you can&#39;t use Asp and heavy escort ships.

If you have Towbar then you can&#39;t pick up any ship there due to the long XL deck occupy the same space behind you. The simple escort deck is shorter and Towbar compatible so if you plan to salvage larger ships than small escorts then you should choose the normal deck.

Warning: your ship can be &quot;uber&quot; if you use 8 escorts, so if you want limit yoursef then stick with the smaller deck and avoid the XL variant.

Carriers can hold 10 escorts on the internal XL deck (the &quot;neck&quot;) and the mass limit is 130t as in the normal deck. Moreover the first two pads (on the top) can hold wider and heavier ships up to 378t (40% of Carriers&#39; mass) and 130x35x95m including Cobra Mark III, Krait and other large ships also. This is even more &quot;uber&quot; but intentionally: a Carrier should be able to hold stronger fleet than others.


Cost: 2000.0 Cr.
Techlevel: 1



Interface

In F4 screen you can view, rename and salvage your current escorts. Moreover if Hyperspace Hangar is installed then you can buy esorts from the main shipyard (F3F3) using the following steps:

1. Buy a small ship from a shipyard which fit into your deck and save your main ship into the Hyperspace Hangar.
2. Equip it for combat as you wish, just avoid player-only tools like Railgun.
3. Save the escort into the hangar by switching into your main ship.
4. Go to the Escort Deck interface, select an empty deck and get the escort from the hangar.

The hangar is usable as a temporary storage to rearrange your escorts as well as fix damaged equipments or buy new ones, just store your main ship into the hangar:

1. Select a ship in the EscortDeck Interface.
2. Put into Hyperspace Hangar.
3. Go into the interface of Hyperspace Hangar and switch into the stored escort.
4. Equip or fix it.
5. Switch back into your main ship in the hangar interface.
6. Go to the EscortDeck interface, select an empty deck and get your escort from the hangar.

If you acquired an OXP escort ship which is not designed for player then you can not switch into.



Ship mass table

Adder   	16
Moray    	51
Cobra Mk I	52
Fer-de-Lance	53
Asp     	75
Cobra Mk III	215
Boa     	182
Boa2    	216
Python  	267
Anaconda	438

NPC:
Gecko   	25
Sidewinder	26
Constrictor	28
Viper   	34
Mamba   	36
Krait   	94



Escort Deck types

There are more appearance of decks depending on the mass of your ship. 

* Below 30t: You can not use any decks.
* 30t-130t: The smallest deck without side pads.
* 130t-260t: Normal deck with side pads for two additional small escorts.
* 260t-: Wider deck which can hold ships up to 95m width (like Krait).
* 400t-: You can select either the wider deck or XL deck.
* Carriers can hold the most powerful escort fleet, using the big hull as a deck.


For more information see the regarding discussuion: http://aegidian.org/bb/viewtopic.php?f=4&amp;t=17009


Instructions:

Do not unzip the .oxz file, just move into the AddOns folder of your Oolite installation.


License:
This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike License version 4.0.
If you are re-using any piece of this OXP, please let me know by sending an e-mail to norbylite@gmail.com.

The 3D models of decks are derived from Leviathan Platform in Aquatics OXP, thanks to Thargoid and P.A. Groove.

Escort locked sound is equal with Towbar locked which is based on bgs-m_fx_shipyard1.ogg in BGS OXP.


Changelog:
 2022.11.13. v1.12 Updates escorts&#39; AIs and scripts to avoid closing too fast at landing.
                   Increases TL for equipments and escort ships.
                   Adds configuration for launching/calling back when going in/out of red alert.
                   Adds configuration for base usable derelict probability.
                   Configuration via Svengali&#39;s Library &#39;Config for AddOns&#39;.
                   Takes NPC_equipmentDamage OXP&#39;s equipment damage into account for usable derelecit probability 
                   calculation (reduces base probability of being usable).
                   Makes Towbar not salvage usable derelicts if Hyperspace Hangar is installed.
                   Optimizes masss factor (degradation of ship maneuvarability by ship&#39;s total mass) updates. 
                   Tests for a funcitonal escortdeck in the player ship in event handlers.
                   Updates shipAtackedOther event handler to handle Laser Reductor presence and be compatible with use 
                   as a ship event handler for the escorts.
                   Puts a random fatcor into awarding equipment to usable derelicts, and those equipment couldd be damaged.
                   Uses ShipStorageHelper OXP for ship serialization if installed.
                   Sets event handlers in the escorts&#39; ship scripts to use Laser Reductor.
                   Fixes bug in scrolling along the pads in the MFD.
                   Makes Towbar&#39;s Tug Drone store usable derelicts in the Hyperspace Hangar.
                   Performance updates to FCB.
                   Adds status of escorts&#39; shields to MFD.
                   Adds menu entry to refuel escort to EscortDeck Station Interface.
                   Sets current galaxy number and system ID to the shipdata array when storing an escort in Hyperspace Hangar.
 2016.07.17. v1.11 Updated for Oolite 1.84 where player can not be the leader of a group.
 2016.06.25. v1.9  Fixed long message bug at salvage without Towbar, thanks to Strato1.
                   Too heavy message is not repeated too often anymore.
                   Deck is drifting away after player died.
                   Improved landing code based on the similar part in Fighters OXP.
 2016.03.13. v1.8  Interface menu display the names of ships in deck.
                   Fixed value in &quot;you paid&quot; message in costly non-main stations.
                   Aft Sniper Gun will not move the deck too far anymore, needed by Asp SG and Python SG.
                   Escort Deck can hold the long Asp SG and Fer-de-Lance SG, Wide Deck can hold Krait SG also.
                   Carrier top deck can hold Cobra Mark III SG, main deck can hold Krait SG.
                   Typo fix in shipdata, thanks to phkb.
 2015.10.14. v1.7  Interface functions: rename, salvage, put into Hyperspace Hangar and get back.
 2015.10.04. v1.6  Escort Deck Interface added into the F4 screen.
                   Deck positions can be locked to avoid launch of some ships.
                   Deck cost raised to 2000cr as suggested by Vincentz.
                   Escorts start with heat shield for sunskimming, requested by QCS.
                   Chance to find an usable derelict escort is reduced, salvage increased.
                   MFD show the ship on Towbar in the last line, maked as T: .
                   You can release the towed ship by selecting and activating it in MFD.
                   Show the mass of attached salvage ships on MFD.
                   Fixed for the change of weaponPositions to array in Oolite 1.83.
                   Escortship personality is restored from Oolite 1.81.
 2015.04.14. v1.5  MFD show max. mass and sizes of empty decks depending on player ship.
                   Further increased distances on deck before Oolite 1.81.
                   Fixed maximum mass check of escorts, must below 40% of owner ship&#39;s mass.
                   Hard and Granite escorts counted with original mass (without double density).
                   Fixed equipment restore on escorts if depends on another equipment.
 2015.04.11. v1.4  Collision fixes, needed before Oolite 1.81.
                   Granite ships on deck do not prevent hyperjump anymore.
                   From 1.81 slower steering and acceleration in proportion with the mass on deck.
 2015.04.06. v1.3  Increased distance around player without Injectors to 5km, thanks to QCS.
                   Workaround against escort terminated by Witchpoint Beacon.
 2015.03.20. v1.2  Refined escort landing sequence to prevent collisions, thanks to QCS.
                   Added a collisionException between the Witchpoint Beacon and escorts.
                   Fixed rollback price of unsuccessful escort purchase in Rock Hermits.
 2015.01.20. v1.1  No escort launch at injector speeds nor autolaunch at maximum speed.
                   Fixed escort equipments after load game.
                   All escorts got a missile pylon to workaround a bug with Carriers&#39; sit into feature.
                   Escort view positions added.
 2015.01.11. v1.0  First release.
</pre>
        </a>

        <a name="equipment">          
        <h2>Equipment</h2>
            <table>
                <tr>
                    <th>Name</th>
                    <th>Visible</th>
                    <th>Cost [deci-credits]</th>
                    <th>Tech-Level</th>
                </tr>
                <tr>
                    <td><a href="../equipment/EQ_DTAUSA.html">HUD</a></td>
                    <td>no</td>
                    <td align="right">0</td>
                    <td align="center">100+</td>
                </tr>
                <tr>
                    <td><a href="../equipment/EQ_ESCORTDECK.html">Escort Deck</a></td>
                    <td>yes</td>
                    <td align="right">20000</td>
                    <td align="center">5+</td>
                </tr>
                <tr>
                    <td><a href="../equipment/EQ_ESCORTDECKXL.html">Escort Deck XL</a></td>
                    <td>yes</td>
                    <td align="right">20000</td>
                    <td align="center">5+</td>
                </tr>
                <tr>
                    <td><a href="../equipment/EQ_ESCORTDECK_adder.html">Adder Escort</a></td>
                    <td>yes</td>
                    <td align="right">800000</td>
                    <td align="center">5+</td>
                </tr>
                <tr>
                    <td><a href="../equipment/EQ_ESCORTDECK_asp.html">Asp Escort</a></td>
                    <td>yes</td>
                    <td align="right">4000000</td>
                    <td align="center">8+</td>
                </tr>
                <tr>
                    <td><a href="../equipment/EQ_ESCORTDECK_gecko.html">Gecko Escort</a></td>
                    <td>yes</td>
                    <td align="right">1000000</td>
                    <td align="center">7+</td>
                </tr>
                <tr>
                    <td><a href="../equipment/EQ_ESCORTDECK_sidewinder.html">Sidewinder Escort</a></td>
                    <td>yes</td>
                    <td align="right">760000</td>
                    <td align="center">7+</td>
                </tr>
                <tr>
                    <td><a href="../equipment/EQ_ESCORTDECK_viper.html">Viper Escort</a></td>
                    <td>yes</td>
                    <td align="right">6000000</td>
                    <td align="center">9+</td>
                </tr>
            </table>
        </a>

        <a name="ships">    
        <h2>Ships</h2>
            <table>
                <tr>
                    <th>Name</th>
                </tr>
                <tr>
                    <td><a href="../ships/escortdeck-adder.html">Adder Escort</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/escortdeck-asp.html">Asp Escort</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/escortdeck-gecko.html">Gecko Escort</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/escortdeck-sidewinder.html">Sidewinder Escort</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/escortdeck-viper.html">Viper Escort</a></td>
                </tr>
            </table>
        </a>

        <a name="models">    
        <h2>Models</h2>
            This expansion declares no models. 
        </a>

        <a name="scripts">    
        <h2>Scripts</h2>
            <table>
                <tr>
                    <th>Path</th>
                </tr>
                <tr>
                    <td valign="top">Scripts/escortdeck.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name        = &quot;escortdeck&quot;;
this.version     = &quot;1.12&quot;
this.author      = &quot;Norby&quot;;
this.copyright   = &quot;2015 Norbert Nagy&quot;;
this.description = &quot;Buy and hold escort ships on external deck&quot;;
this.licence     = &quot;CC BY-NC-SA 4.0&quot;;

this.$debug = false; // debug verbose log
this.$logging = true; // verbose log
this.$Derelicts = false; //add derelict ships near the nav buoy of the starting station
this.$EscortDeckAutoLaunch = false; // automatically launch/callback when leaving/entering green condition
this.$EscortDeckBigTraderLaunch = false; //launch Anaconda from Carriers automatically or not
this.$EscortDeckCMaxMass = 800000; //escorts must below this mass on XL deck of Carriers
this.$EscortDeckExtremeMass = 10*this.$EscortDeckCMaxMass; //so much so don&#39;t display message
this.$EscortDeckJumpDist = 50; //escorts jump this m farther from the main ship at launch
this.$EscortDeckMassEffect = true; //slower steering and acceleration with more mass on deck
this.$EscortDeckMassFactor = 1; // fraction of steering maneuverability to retain
this.$EscortDeckMinMass = 30000; //which ships can tow the deck (30t not small in ShipVersion)
this.$EscortDeckLandingDist = 1500; //escorts will be added to the deck within this m if possible
this.$EscortDeckSpinModel = true;//spinning model in the interface screen
//this.$EscortDeckLargeMass = 130000; //max. escort mass, border of large ships in ShipVersion OXP
//this.$EscortDeckWMass = 2 * this.$EscortDeckLargeMass; //which ships can tow wide deck (2*large)
this.$EscortDeckLargeMass = 205000; //max. escort mass, border of large ships in ShipVersion OXP
this.$EscortDeckWMass = 1.5 * this.$EscortDeckLargeMass; //which ships can tow wide deck (2*large)
this.$EscortDeckXLMass = 400000; //which can tow XL deck (400t mean xl ships in Telescope OXP)
this.$EscortDeckBasicUnusableProb = 0.9; //probability of damage (0-1) to base systems (not equipment) of a derelict, which would render it unusable

//internal properties, should not touch
this.$EscortDeckEqs = []; //buyable escort ship sizes and masses
this.$EscortDeckEqs[&quot;EQ_ESCORTDECK_adder&quot;] = [28.02, 14.9, 51, 16000];
this.$EscortDeckEqs[&quot;EQ_ESCORTDECK_asp&quot;] = [64.73, 23.52, 83.69, 75882];
this.$EscortDeckEqs[&quot;EQ_ESCORTDECK_gecko&quot;] = [61.48, 14.64, 51, 24670];
this.$EscortDeckEqs[&quot;EQ_ESCORTDECK_sidewinder&quot;] = [63.23, 14.43, 44, 25088];
this.$EscortDeckEqs[&quot;EQ_ESCORTDECK_viper&quot;] = [50, 18.12, 65.199, 34000];

this.$EscortDeckPad = { //landing pad max. x,y,z sizes and max. mass
            escort:[70,29,135,this.$EscortDeckLargeMass], //for Asp SG, Arachnid, S8
//            escort:[70,45,135,this.$EscortDeckLargeMass], //for Asp SG, Arachnid, S8
            mini:[39,15,65,30000], //Adder, Ophidian
            wide:[95,29,135,this.$EscortDeckLargeMass], //wide ship: Krait SG, Tiger Ray
//            wide:[95,45,135,this.$EscortDeckLargeMass], //wide ship: Krait SG, Tiger Ray
            xl:[70,29,95,60000], //sizes like heavy escorts but smaller mass, no Asp
//            xl:[70,45,95,60000], //sizes like heavy escorts but smaller mass, no Asp
            //Carrier specific pads
            center:[65,29,95,130000], //small center pad for Asp, Fer-De-Lance, S8
            main:[95,64,170,this.$EscortDeckCMaxMass], //Anaconda, D.T.T. Atlas, Krait SG
                        side:[70,29,95,this.$EscortDeckLargeMass], //heavy escorts: Asp, Arachnid, S8
                        small:[65,19,66,40000], //aft side pad for Gecko, Ophidian, Sonoran, Viper
            top:[140,35,135,this.$EscortDeckCMaxMass] } //Cobra Mark III, King Cobra, Krait SG

this.$EscortDeckLPos = [[-36,6,-25], [36,6,-25], //landing pad positions: top left-right
            [-36,-6,-25], [36,-6,-25], //bottom left-right
            [-43,0,-25], [43,0,-25]];  //center left-right (Adder only)
//            [34,0,-43], [-34,0,-43],   //aft left, aft right (facing backward) - disabled
this.$EscortDeckLVec = [[0,1,0], [0,1,0], //vectors from landing pad to ship center: up
            [0,-1,0], [0,-1,0], //down
            [-1,0,0], [1,0,0]]; //left, right
//            [0,0,-1], [0,0,-1], //back - disabled

this.$EscortDeckWPos = [[-48,6,-25], [48,6,-25], //Wide deck landing pad positions: top left-right
            [-48,-6,-25], [48,-6,-25], //bottom left-right
            [-54,0,-25], [54,0,-25]];  //center left-right (Adder only)
//            [34,0,-43], [-34,0,-43],   //aft left, aft right (facing backward)
this.$EscortDeckWVec = [[0,1,0], [0,1,0], //vectors from landing pad to ship center: up
            [0,-1,0], [0,-1,0], //down
            [-1,0,0], [1,0,0]]; //left, right
//            [0,0,-1], [0,0,-1], //back

this.$EscortDeckXLPos = [[-8,0,-15], [8,0,-15], //XL deck landing pad positions: left, right
            [-8,0,-44], [8,0,-44], //left, right
            [-8,0,-73], [8,0,-73], //left, right
            [-8,0,-102], [8,0,-102]];  //left, right
this.$EscortDeckXLVec = [[-1,0,0], [1,0,0], //XL deck vectors from landing pad to ship center
            [-1,0,0], [1,0,0], //left, right
            [-1,0,0], [1,0,0], //left, right
            [-1,0,0], [1,0,0]]; //left, right

this.$EscortDeckCPos = [[0,15,215], [0,15,135], //Carrier pad positions: top front and center
            [0,15,15], [-67,16,15], [67,16,15], //aft center, left, right
            [-52,15,46], [52,15,46], //main deck left, right
            [-30,0,233], [30,0,233]];  //mini front deck left, right
this.$EscortDeckCSize = [this.$EscortDeckPad.top, //Carrier max. sizes and mass, top front pad
            this.$EscortDeckPad.center, //center: Asp, Fer-De-Lance, S8
            this.$EscortDeckPad.top, //top aft for Cobra Mark III and King Cobra
            this.$EscortDeckPad.small, this.$EscortDeckPad.small, //aft sides
            this.$EscortDeckPad.main, this.$EscortDeckPad.main, //left-right main deck
            this.$EscortDeckPad.mini, this.$EscortDeckPad.mini]; //front pads
this.$EscortDeckCVec = [[0,1,0], [0,1,0], //Carrier vectors from landing pad to ship center: up
            [0,1,0], //up
            [0,1,0], [0,1,0], //up
            [0,0,1], [0,0,1], //forward
            [0,0,0], [0,0,0]]; //center

this.$EscortDeckCXPos = [[0,15,215], [0,15,115],  //Carrier XL deck positions: top front, center
            [-48,16,15], [48,16,15], //aft left, right
            [-11,0,151], [11,0,151], //left, right
            [-11,0,81], [11,0,81], //left, right
            [-30,0,233], [30,0,233]];  //front left, right
this.$EscortDeckCXSize = [this.$EscortDeckPad.top, this.$EscortDeckPad.top, //top front and center
            this.$EscortDeckPad.wide, this.$EscortDeckPad.wide, //top aft wide pads
            this.$EscortDeckPad.side, this.$EscortDeckPad.side, //4 heavy escorts
            this.$EscortDeckPad.side, this.$EscortDeckPad.side, //on main decks
            this.$EscortDeckPad.mini, this.$EscortDeckPad.mini]; //front pads
            
this.$EscortDeckCXVec = [[0,1,0], [0,1,0], //Carrier XL deck vectors from landing pad to ship center: up
            [0,1,0], [0,1,0], //up
            [-1,0,0], [1,0,0], //left, right
            [-1,0,0], [1,0,0], //left, right
            [0,0,0], [0,0,0]]; //center

/* Carrier deck positions for 10 heavy escorts, removed to be less powerful
this.$EscortDeckCXXPos = [[0,14,220], [0,14,23], //landing pad positions: top front-aft
            [-11,0,170], [11,0,170], //left, right
            [-11,0,135], [11,0,135], //left, right
            [-11,0,100], [11,0,100], //left, right
            [-11,0,65], [11,0,65]];  //left, right
this.$EscortDeckCXXSize = [this.$EscortDeckPad.top, this.$EscortDeckPad.top, //top front and aft
            this.$EscortDeckPad.escort, this.$EscortDeckPad.escort, //8 heavy escorts
            this.$EscortDeckPad.escort, this.$EscortDeckPad.escort, //on main decks
            this.$EscortDeckPad.escort, this.$EscortDeckPad.escort,
            this.$EscortDeckPad.escort, this.$EscortDeckPad.escort];
this.$EscortDeckCXXVec = [[0,1,0], [0,1,0], //vectors from landing pad to ship center: up
            [-1,0,0], [1,0,0], //left, right
            [-1,0,0], [1,0,0], //left, right
            [-1,0,0], [1,0,0], //left, right
            [-1,0,0], [1,0,0]]; //left, right
*/
this.$EscortDeckVersion = null; //version of EscortDeck installed on the ship
this.$EscortDeckCWS = null; //carriers worldscript if Carriers OXP is installed
this.$EscortDeckDockingTunnel = false; //player in the tunnel
this.$EscortDeckEWS = null; //escortdeck_escort worldscript
this.$EscortDeckFCB = null; //FrameCallBack updating escort ship positions
this.$EscortDeckFCBDelta = 0; //delta counter in FrameCallBack
this.$EscortDeckFirstMSO = true; //first missionScreenOpportunity after docked
this.$EscortDeckGWS = null; //Gallery worldscript
this.$EscortDeckI = false; //start on the first page within EscortDeck Interface
this.$EscortDeckLaunch = false; //launch or call back via primeable equipment
this.$EscortDeckLastTooLargeTarget = null; //prevent repeated too large messages
this.$EscortDeckLocked = []; //which positions will not launch with the other escorts
this.$EscortDeckMaxs = null; //store maxThrust, maxPitch, maxRoll and maxYaw
this.$EscortDeckNPCEqDamage = false; // NPC Equipment Damage OPC is installed
this.$EscortDeckPadPos = []; //landing pad positions
this.$EscortDeckPadSize = []; //landing pad sizes
this.$EscortDeckPadVec = []; //vectors from landing pad to ship center
this.$EscortDeckPlayableDataKeys = null;  //playable ships
this.$EscortDeckPWS = null; //escortpack worldscript if escortpack OXP is installed
this.$EscortDeckSelectedPad = -1; //the pad selected via primeable equipment
this.$EscortDeckShip = []; //store the ship objects of escorts
this.$EscortDeckShipData = []; //store the data of escort ships
this.$EscortDeckShipPos = []; //positions of escort ships on board
this.$EscortDeckSitInto = false; //sit into the selected escort when launch it from a Carrier
this.$EscortDeckSitIntoWithMode = false; //allow sit into with mode key when deck is primed
this.$EscortDeckSound = null; //sound of escort landing
this.$EscortDeckSpawnedShips = []; //stack for restoring ship data in FCB after shipSpawned
this.$EscortDeckSGWS = null; //snipergun worldscript if Sniper Gun OXP is installed
this.$EscortDeckTWS = null; //telecope worldscript if telecope OXP is installed
this.$EscortDeckToWS = null; //towbar worldscript if towbar OXP is installed
this.$EscortDeckV = null; //visualeffect of the escort deck of the player ship
this.$EscortDeckXL = false; //the current deck is xl or not
this.$EscortDeckZV = 0; //the z offset of deck position from the center of the player ship

// configuration settings for use in Lib_Config
this.$newUsableProb = 1 - this.$EscortDeckBasicUnusableProb;
this.$newAutoLaunch = false;
this._compConfig = {
    Name:this.name, Alias:&quot;EscortDeck&quot;, Display:&quot;Config&quot;, Alive:&quot;_compConfig&quot;, Notify:&quot;$onChange&quot;, Reset:true,
    Bool:   {
                B0: {Name:&quot;$newAutoLaunch&quot;, Def:true, Desc:&quot;Automatic Launch&quot;},
                Info:&quot;Automatic launch/callback on Red condition transition (0:no, 1:yes)&quot;
            },
    SInt:   {
                S0:{Name:&quot;$newUsableProb&quot;, Min:0, Max:1, Float:true, Def:0.1, Desc:&quot;Usable derelict probability&quot;},
                Info:&quot;0 - Value between 0 (all unusable) and 1 (all usable)&quot;
            },
};

//
//equipment events
//

//-----------------------------------------------------------------------------------------------//
this.activated = function  _escortdeck_activated() { //launch or call back one or all escorts
    var w = worldScripts.escortdeck;
    w.$EscortDeck_EQActivated(w);
}

//-----------------------------------------------------------------------------------------------//
this.mode = function _escortdeck_mode() { //select the next pad on escort deck
    var w = worldScripts.escortdeck;
    w.$EscortDeck_EQMode(w);
}


//
//worldscript events
//

//-----------------------------------------------------------------------------------------------//
this.startUp = function _escortdeck_startUp() {
    var hh = worldScripts.HyperspaceHangar;
    if (!player.ship.addCollisionException) { //before v1.81 need more room
        for (var i = 0; i &lt; this.$EscortDeckLPos.length; i++) 
            this.$EscortDeckLPos[i][2] -= 30;
        for (var i = 0; i &lt; this.$EscortDeckWPos.length; i++)
            this.$EscortDeckWPos[i][2] -= 30;
        for (var i = 0; i &lt; this.$EscortDeckXLPos.length; i++)
            this.$EscortDeckXLPos[i][2] -= 20;
    }
    this.$EscortDeck_SetPads(player.ship, this);
    
    this.$EscortDeckSound = new SoundSource;
    this.$EscortDeckSound.sound = &quot;escortdeck.ogg&quot;;
    this.$EscortDeckSound.loop = false;
    this.$EscortDeckSound.repeatCount = 1;
    this.$EscortDeckSound2 = new SoundSource;
    if (worldScripts[&quot;BGS-M&quot;]) this.$EscortDeckSound2.sound = &quot;bgs-c_sell.ogg&quot;;
    else this.$EscortDeckSound2.sound = &quot;sell.ogg&quot;; //Oolite default sell sound
    this.$EscortDeckSound2.loop = false;
    this.$EscortDeckSound2.repeatCount = 1;
    this.$EscortDeckSound3 = new SoundSource;
    this.$EscortDeckSound3.sound = &quot;escortdeckhitderelict.ogg&quot;;
    this.$EscortDeckSound3.loop = false;
    this.$EscortDeckSound3.repeatCount = 1;

    this.$EscortDeckPlayableDataKeys = Ship.keysForRole( &quot;player&quot; );  //playable ships
    
    if (worldScripts.escortdeck_escort) this.$EscortDeckEWS = worldScripts.escortdeck_escort;
    if (worldScripts.carriers) this.$EscortDeckCWS = worldScripts.carriers;
    if (worldScripts.gallery) this.$EscortDeckGWS = worldScripts.gallery; 
    if (worldScripts.escortpack) this.$EscortDeckPWS = worldScripts.escortpack;
    if (worldScripts.snipergun) this.$EscortDeckSGWS = worldScripts.snipergun;
    if (worldScripts.telescope) this.$EscortDeckTWS = worldScripts.telescope;
    if (worldScripts.NPC_Equipment_Damage) this.$EscortDeckNPCEqDamage = true;

    var h = worldScripts.hudselector;
    if( h &amp;&amp; h.$HUDSelectorAddMFD ) h.$HUDSelectorAddMFD(this.name);

    var s = missionVariables.$EscortDeckShipData;
    if( s &amp;&amp; s.length &gt; 0 )    this.$EscortDeckShipData = JSON.parse(s);
    var s = missionVariables.$EscortDeckLocked;
    if( s &amp;&amp; s.length &gt; 0 )    this.$EscortDeckLocked = JSON.parse(s);

    var t = worldScripts.towbar;
    if (t) {
        this.$EscortDeckToWS = t; //save Towbar worldscript
        //inject code to do not lock on derelicts of escort deck
        eval(&quot;t.$EscortDeckToWS_IsDerelictOrig = &quot;+t.$Towbar_IsDerelict);
        eval(&quot;t.$Towbar_IsDerelict = function(entity) { \
            var w = worldScripts.escortdeck; \
            if ((!w.$EscortDeckXL || \
                w.$EscortDeckCWS &amp;&amp; player.ship &amp;&amp; player.ship.isValid \
                &amp;&amp; player.ship.dataKey.indexOf(&#39;carrier&#39;) &gt; -1 ) &amp;&amp; \
                worldScripts.towbar.$EscortDeckToWS_IsDerelictOrig(entity) \
                &amp;&amp; ( !w.$EscortDeckShip \
                || w.$EscortDeckShip.indexOf(entity) == -1 )) \
                 return true; \
            return false; \
        }&quot;);
        eval(&quot;t.$EscortDeckToWS_shipCollidedOrig = &quot;+t.shipCollided);
        eval(&quot;t.shipCollided = function(otherShip) { \
            var w = worldScripts.escortdeck; \
            if( (!w.$EscortDeckXL || \
                w.$EscortDeckCWS &amp;&amp; player.ship &amp;&amp; player.ship.isValid &amp;&amp; \
                player.ship.dataKey.indexOf(&#39;carrier&#39;) &gt; -1 ) &amp;&amp; \
                !w.$EscortDeckShip || w.$EscortDeckShip.indexOf(otherShip) == -1 ) \
                worldScripts.towbar.$EscortDeckToWS_shipCollidedOrig(otherShip); \
        }&quot;);
        if (hh) {
            //makes Towbar not salvage usable derelicts
            eval(&quot;t.$EscortDeckToWS_missionScreenOpportunityOrig = &quot;+t.missionScreenOpportunity);
            eval(&quot;t.missionScreenOpportunity = function _Towbar_missionScreenOpportunity_escortdeck() { \
                var w = worldScripts.towbar; \
                if (w.$TowbarShip &amp;&amp; w.$TowbarShip.script &amp;&amp; w.$TowbarShip.script.$EscortDeckUsable != 1) \
                    w.$EscortDeckToWS_missionScreenOpportunityOrig(); \
            }&quot;);
            //makes Towbar&#39;s Tug Drone not salvage usable derelicts
            eval(&quot;t.$Towbar_TugDrone_ProcessingOrig = &quot;+t.$Towbar_TugDrone_Processing);
            eval(&quot;t.$Towbar_TugDrone_Processing = &quot;+worldScripts.escortdeck.$EscortDeck_TugDrone_Processing)
        }
    }
}

//-----------------------------------------------------------------------------------------------//
this.startUpComplete = function _escortdeck_startUpComplete() {
    // register our settings, if Lib_Config is present
    if (worldScripts.Lib_Config) worldScripts.Lib_Config._registerSet(this._compConfig);
    if (missionVariables.$EscortDeck_unusable_derelic_prob) {
        this.$EscortDeckBasicUnusableProb = parseFloat(missionVariables.$EscortDeck_unusable_derelic_prob)
    } else {
        if (worldScripts.NPC_Equipment_Damage) this.$EscortDeckBasicUnusableProb -= 0.1
    }
    this.$newUsableProb = 1 - this.$EscortDeckBasicUnusableProb;
    log(this.name, &quot;Base unusable derelict probability: &quot;+this.$EscortDeckBasicUnusableProb)
    this.$EscortDeck_SaveMaxs( player.ship, this );
    //call after towbar and ccl startups finished
    this.$EscortDeck_SalvageBadEscorts(player.ship);
    this.$EscortDeckI = false; //start on the first page
    this.$EscortDeck_Interface();
    this.$EscortDeckVersion = this.$EscortDeck_Version();
}

//-----------------------------------------------------------------------------------------------//
this.alertConditionChanged = function _escortdeck_alertConditionChanged(newCondition, oldCondition) {
    if (!this.$EscortDeckVersion) return;
    if( !player.ship || !player.ship.isValid || !this.$EscortDeckAutoLaunch) return;
     if( newCondition == 3 &amp;&amp; player.alertHostiles ) {
        this.$EscortDeck_ControlAll(true, false, this); //launch all escorts
    } else if( newCondition == 1 ) { //call back escorts in green alert
        this.$EscortDeck_ControlAll(false, false, this);
    }
}

//-----------------------------------------------------------------------------------------------//
this.guiScreenChanged = function _escortdeck_guiScreenChanged(to, from) {
    if( to == &quot;GUI_SCREEN_INTERFACES&quot; ) this.$EscortDeck_Interface(); //update displayed ship names
}

//-----------------------------------------------------------------------------------------------//
this.missionScreenOpportunity = function _escortdeck_missionScreenOpportunity() {
    var that = _escortdeck_missionScreenOpportunity;
    var hh = (that.hh = that.hh || worldScripts.HyperspaceHangar);
    var t = this.$EscortDeckToWS; //use Towbar salvage if available
    if (t &amp;&amp; t.$TowbarShip &amp;&amp; t.$TowbarShip.isValid
        &amp;&amp; !t.$Towbar_IsHeavyShip(t.$TowbarShip)) { //avoid heavy ships in aegis with autodock
        if (t.$TowbarShip.script &amp;&amp; t.$TowbarShip.script.$EscortDeckUsable &gt; 0 &amp;&amp; hh) {
            var displayName = t.$TowbarShip.displayName;
            log(&quot;escortdeck&quot;, &quot;Towed ship &quot;+displayName+&quot; is usable, storing in Hyperspace Hangar&quot;);
            // towed ship is usable and HH is installed, transfer it to HH
            this.$EscortDeck_HHStoreShip(t.$TowbarShip)
            player.consoleMessage(&quot;Usable ship &quot;+displayName+&quot; stored into Hyperspace Hangar&quot;, 10);
            player.commsMessage(&quot;Usable ship &quot;+displayName+&quot; stored into Hyperspace Hangar&quot;, 10);
            t.$TowbarShip.remove(true);
            t.$TowbarShip = null;
        } else {
            log(&quot;escortdeck&quot;, t.$TowbarShip.displayName+&quot; is not usable, salvaging it!&quot;);
            t.$Towbar_Payout(t.$TowbarShip); //call payout in towbar oxp
        }
    }
    if( player.ship.docked &amp;&amp; this.$EscortDeckFirstMSO
        &amp;&amp; this.$EscortDeckShip &amp;&amp; this.$EscortDeckShip.length &gt; 0 ) {
        this.$EscortDeckFirstMSO = false; //do only once
        for(var i = 0; i &lt; this.$EscortDeckPadPos.length; i++ ) { //salvage unusables
            var s = this.$EscortDeckShip[i]; //the ship on this pad
            if( s &amp;&amp; s.isValid ) {
                if( !s.script || !( s.script.$EscortDeckUsable &gt; 0 ) ) { //unusable
                    this.$EscortDeck_Salvage(i, player.ship); //salvage
                    if(this.$EscortDeckToWS) {
                        this.$EscortDeckFirstMSO = true; //do one at a time
                        i = this.$EscortDeckPadPos.length;
                    }
                }
            } else { //inside stations check saved ship data
                var d = this.$EscortDeckShipData[i];
                if( d &amp;&amp; d[1] &amp;&amp; ( !d[14] || !(d[14].usable &gt; 0) ) ) {//unusable
                    this.$EscortDeck_Salvage(i, player.ship);
                    if(this.$EscortDeckToWS) {
                        this.$EscortDeckFirstMSO = true; //do one at a time
                        i = this.$EscortDeckPadPos.length;
                    }
                }
            }
        }
    }
    if( t &amp;&amp; t.$TowbarRunScreens.length &gt; 0 ) {
        var rs = t.$TowbarRunScreens.shift(); //get and remove the oldest element
        if(this.$debug) log(this.name, &quot;MSO &quot;+t.$TowbarRunScreens.length+&quot; &quot;+guiScreen+&quot; &quot;+rs );
        t.$Towbar_RunScreen(rs.place, rs.msg, rs.model); //show sell salvage screen
    }
}

//-----------------------------------------------------------------------------------------------//
this.playerBoughtEquipment = this.equipmentAdded = function _escortdeck_playerBoughtEquipment(equipment) {
    var p = player.ship;
    var w = this; //w is used below
    if( equipment.indexOf(&quot;EQ_ESCORTDECK_&quot; ) == 0 ) {
        p.removeEquipment(equipment);
        var k = equipment.substring(14); //extract datakey from the end of the eq key
        var s = this.$EscortDeck_SpawnOne( &quot;[escortdeck-&quot;+k+&quot;]&quot;, this, false );
        if(this.$debug) log(this.name, k+&quot; &quot;+s); //debug
        if( !s || !s[0] || !s[0].isValid ) { //possible bug
            this.$EscortDeck_RollBack(equipment, &quot;You can&#39;t buy &quot;+k+&quot;.&quot;);
            return;
        } else s = s[0];
        var c = EquipmentInfo.infoForKey(equipment).price/10; //escort price
                if( p &amp;&amp; p.dockedStation ) { //Rock Hermits ask more
                        var e = p.dockedStation.equipmentPriceFactor;
                        if( e &gt; 0 ) c = e * c;
                }
        var en = EquipmentInfo.infoForKey(equipment).name; //escort name
        w.$EscortDeck_AwardEQs(s);
        var d = this.$EscortDeck_MakeShipData(s);
        if(d[14]) d[14].usable = 1; //usable
        var added = false;
        var reason = this.$EscortDeck_TooLarge(s, p, this);
        if( !reason &amp;&amp; !this.$EscortDeckXL &amp;&amp; this.$EscortDeck_isLarge(p, this)
            &amp;&amp; this.$EscortDeck_isMini(s) ) { //Adder or smaller, try side decks first
            for( var i = 0; !added &amp;&amp; i &lt; w.$EscortDeckPadPos.length; i++ ) {
                if( w.$EscortDeck_isMiniPad(i, p, w) ) {
                    if( !this.$EscortDeckShipData[i] ) {
                        this.$EscortDeckShipData[i] = d;
                        added = i+1; //=pad+1
                    }
                }
            }
        }
        var len = this.$EscortDeckPadPos.length;
        if( !reason &amp;&amp; !added ) for(var i = 0; i &lt; len; i++ ) {
            if( !this.$EscortDeckShipData[i] 
                &amp;&amp; !w.$EscortDeck_TooLarge2(s, p, w, i) ) {
                this.$EscortDeckShipData[i] = d;
                added = i+1;
                i=10;
            }
        }
        s.remove(true);
        if( added ) player.consoleMessage(&quot;You paid &quot;+c+&quot; credits for &quot;+en+&quot; placed to landing pad &quot;+added, 10);
        else {
            if(!reason) reason = &quot;no room on your deck&quot;;
            this.$EscortDeck_RollBack( equipment, &quot;You can&#39;t buy &quot;+en+&quot;, &quot;+reason );
        }
    }
    if( equipment == &quot;EQ_ESCORTDECK&quot; ) {
        this.$EscortDeckXL = false;
        if( w &amp;&amp; w.$EscortDeckCWS &amp;&amp; p.dataKey.indexOf(&quot;carrier&quot;) &gt; -1
            &amp;&amp; p.equipmentStatus(&quot;EQ_ESCORTDECKXL&quot;) == &quot;EQUIPMENT_OK&quot; ) {
            //salvage pad 8, exchange pad 2-3 and shift pad 9-10 to 8-9
            w.$EscortDeck_Salvage(7, p); //salvage a ship to reduce from 10 to 9
            var d = [], s = [];
            d[0] = w.$EscortDeckShipData[0]; s[0] = w.$EscortDeckShip[0];
            d[1] = w.$EscortDeckShipData[2]; s[1] = w.$EscortDeckShip[2];
            d[2] = w.$EscortDeckShipData[1]; s[2] = w.$EscortDeckShip[1];
            d[3] = w.$EscortDeckShipData[3]; s[3] = w.$EscortDeckShip[3];
            d[4] = w.$EscortDeckShipData[4]; s[4] = w.$EscortDeckShip[4];
            d[5] = w.$EscortDeckShipData[5]; s[5] = w.$EscortDeckShip[5];
            d[6] = w.$EscortDeckShipData[6]; s[6] = w.$EscortDeckShip[6];
            d[7] = w.$EscortDeckShipData[8]; s[7] = w.$EscortDeckShip[8];
            d[8] = w.$EscortDeckShipData[9]; s[8] = w.$EscortDeckShip[9];
            w.$EscortDeckShipData = d;
            w.$EscortDeckShip = s;
        }
        p.removeEquipment(&quot;EQ_ESCORTDECKXL&quot;); //replace
        this.$EscortDeck_SalvageBadEscorts(p);
    }
    if( equipment == &quot;EQ_ESCORTDECKXL&quot; ) {
        this.$EscortDeckXL = true;
        if( w &amp;&amp; w.$EscortDeckCWS &amp;&amp; p.dataKey.indexOf(&quot;carrier&quot;) &gt; -1
            &amp;&amp; p.equipmentStatus(&quot;EQ_ESCORTDECK&quot;) == &quot;EQUIPMENT_OK&quot; ) {
            //exchange pad 2-3 and shift pad 8-9 to 9-10
            var d = [], s = [];
            d[0] = w.$EscortDeckShipData[0]; s[0] = w.$EscortDeckShip[0];
            d[1] = w.$EscortDeckShipData[2]; s[1] = w.$EscortDeckShip[2];
            d[2] = w.$EscortDeckShipData[1]; s[2] = w.$EscortDeckShip[1];
            d[3] = w.$EscortDeckShipData[3]; s[3] = w.$EscortDeckShip[3];
            d[4] = w.$EscortDeckShipData[4]; s[4] = w.$EscortDeckShip[4];
            d[5] = w.$EscortDeckShipData[5]; s[5] = w.$EscortDeckShip[5];
            d[6] = w.$EscortDeckShipData[6]; s[6] = w.$EscortDeckShip[6];
            d[7] = null; s[7] = null;
            d[8] = w.$EscortDeckShipData[7]; s[8] = w.$EscortDeckShip[7];
            d[9] = w.$EscortDeckShipData[8]; s[9] = w.$EscortDeckShip[8];
            w.$EscortDeckShipData = d;
            w.$EscortDeckShip = s;
        }
        p.removeEquipment(&quot;EQ_ESCORTDECK&quot;); //replace
        this.$EscortDeck_SalvageBadEscorts(p);
    }
    if( equipment == &quot;EQ_FUEL&quot; ) {
        var d = this.$EscortDeckShipData;
        var f = 0;
        var s = &quot;&quot;;
        var len = this.$EscortDeckPadPos.length;
        if(d) for(var i = 0; i &lt; len; i++ ) {
            if( d[i] &amp;&amp; d[i][9] &lt; 7 ) {
                if( f &gt; 0 ) s = &quot;s&quot;; //more than one escort ship need refuel
                f += 7 - d[i][9];
            }
        }
        if( f &gt; 0 ) {
            var c = f * 3;//3cr/ly
            if( player.credits &gt; c ) {
                for(var i = 0; i &lt; len; i++ ) {
                    if( d[i] &amp;&amp; d[i][9] &lt; 7 ) d[i][9] = 7;
                }
                player.credits -= c;
                player.consoleMessage(&quot;Your escort&quot;+s+&quot; got &quot;+(Math.round(f*10)/10)+&quot; ly fuel for &quot;+(Math.round(c*10)/10)+&quot; credits&quot;, 10);
            }
        }
    }
}


//-----------------------------------------------------------------------------------------------//
this.playerBoughtNewShip = function _escortdeck_playerBoughtNewShip(ship) {
    this.$EscortDeck_SaveMaxs( player.ship, this );
    if( !this.$EscortDeckCWS || !this.$EscortDeckCWS.$CarriersPlayerInEscort ) {
        this.$EscortDeck_SalvageBadEscorts(player.ship);
        //setup new pads after SalvageBadEscorts only!
        this.$EscortDeck_SetPads( player.ship, this );
    }
}

//-----------------------------------------------------------------------------------------------//
this.playerStartedJumpCountdown = function _escortdeck_playerStartedJumpCountdown(type, seconds) {
    if (!this.$EscortDeckVersion) return;
    //fix for Granite ships to the too close high mass do not prevent the jump
    if( !this.$EscortDeckCWS || player.ship.dataKey.indexOf(&quot;carrier&quot;) == -1 ) {
        for( var i = 0; i &lt; this.$EscortDeckPadPos.length; i++ )
            if( this.$EscortDeckShipPos[i] )
                this.$EscortDeckShipPos[i].z -= 40; //move backward on non-Carriers
    } else { //on Carriers move escort up
        for( var i = 0; i &lt; this.$EscortDeckPadPos.length; i++ )
            if( this.$EscortDeckShipPos[i] )
                this.$EscortDeckShipPos[i].y += 100;
    }
}

//-----------------------------------------------------------------------------------------------//
this.playerWillSaveGame = function _escortdeck_playerWillSaveGame(message) {
    missionVariables.$EscortDeckShipData = JSON.stringify(this.$EscortDeckShipData);
    missionVariables.$EscortDeckLocked = JSON.stringify(this.$EscortDeckLocked);
    missionVariables.$EscortDeck_unusable_derelic_prob = this.$EscortDeckBasicUnusableProb
}

//-----------------------------------------------------------------------------------------------//
this.shipKilledOther = function _escortdeck_shipKilledOther(whom, damageType) {
    var _npcShip = this.ship; // set if called from an escort&#39;s ship script, unidefined if called as a world script for the playership
    var _ship = (_npcShip ? _npcShip : player.ship);

    if (!_npcShip &amp;&amp; !this.$EscortDeckVersion) return;

    log(&quot;escortdeck&quot;, _ship.displayName+&quot; killed &quot;+whom.displayName+&quot; with &quot;+damageType);
    if (_npcShip &amp;&amp; this.$EscortDeckUsable === 1)
        _ship.commsMessage(&quot;Mama, &quot;+whom.displayName+&quot; is no more!&quot;, player.ship);
}

//-----------------------------------------------------------------------------------------------//
this.shipAttackedOther = function _escortdeck_shipAttackedOther(other) { //player hits other
    // this function is both a world script event handler for the playership and a ship event handler for the escorts
    var that = _escortdeck_shipAttackedOther;
    var wc = (that.wc = that.wc || worldScripts.escortdeck);
    var tb = (that.tb = that.tb || worldScripts.towbar);
    var weak_lasers = (that.weak_lasers = that.weak_lasers || [&quot;EQ_WEAPON_EBEAM_LASER&quot;,&quot;EQ_WEAPON_BEAM_LASER&quot;]);
    var npcShip = this.ship; // set if called from an escort&#39;s ship script, unidefined if called as a world script for the playership
    var _ship = (npcShip ? npcShip : player.ship);
    var current_weapon = _ship.currentWeapon;
    var weapon_info = current_weapon.weaponInfo;
    var hit_energy = (weapon_info &amp;&amp; weapon_info.damage ?
                                                weapon_info.damage :
                                                (weak_lasers.indexOf(current_weapon.equipmentKey) &gt;= 0 ? 14 : 23)
                    );
    var fname = &quot;shipAttackedOther&quot;;
    var debug = this.$debug;
    var logging = this.$logging;
    if (!npcShip &amp;&amp; !this.$EscortDeckVersion) return;
    if (!other || !other.isValid || other.isPlayer) return; //for sure
    if (npcShip &amp;&amp; logging) log(&quot;escortdeck&quot;, _ship.displayName+&quot; attacked &quot;+other.displayName+&quot; with &quot;+other.energy.toFixed(1)+&quot; energy at &quot;+_ship.position.distanceTo(other).toFixed(1));
    if( !other.script ) other.script = &quot;oolite-default-ship-script.js&quot;; //for sure
    if( other.script ) other.script.$EscortDeck_Target = 1; //flag for escort AI

    if (!other.isThargoid &amp;&amp; !other.isDerelict &amp;&amp; other.energy &gt; 0 &amp;&amp; other.energy &lt; 2 * hit_energy) {
        //the next Military Laser hit can destroy the target
        if (logging) log(&quot;escortdeck&quot;, _ship.displayName+&quot;: forcing target &#39;&quot;+other.displayName+&quot;&#39; to abandon ship&quot;);
        other.fireMissile();//last resort
        if( other.equipmentStatus(&quot;EQ_ESCAPE_POD&quot;) === &quot;EQUIPMENT_OK&quot;
            &amp;&amp; other.abandonShip()) {//eject to make more derelict ship but only if has Escape Pod
            var dn;
            if( worldScripts[&quot;detectors&quot;] ) {
                dn = other.script.$Detectors_Origname;//short name with version
            } else {
                dn = other.displayName;
                other.displayName = &quot;Derelict &quot; + dn;
            }
            if (!npcShip) {
                player.consoleMessage(dn+&quot; ejected!&quot;);
                log(&quot;escortdeck&quot;, _ship.displayName+&quot; turned &quot;+other.displayName+&quot; derelict&quot;);
                if( other.script &amp;&amp; !other.script.$AlreadyScored ) {
                    other.script.$AlreadyScored = true;
                    player.score++;
                }
            } else if (npcShip &amp;&amp; this.$EscortDeckUsable === 1) {
               _ship.commsMessage(&quot;Mama, look, I got &quot;+other.displayName+&quot; !&quot;, player.ship);
               log(&quot;escortdeck&quot;, &quot;Escort &quot;+_ship.displayName+&quot; turned &quot;+other.displayName+&quot; derelict&quot;);
            }
        } else log(&quot;escortdeck&quot;, _ship.displayName+&quot; &quot;+other.displayName+&quot; has no functional escape pod&quot;);
    }
    if( other.isDerelict &amp;&amp; !other.isThargoid ) {
        if (!npcShip) this.$EscortDeckSound3.play(); //audio feedback if derelict
        if( other.script ) {
            if( !other.script.$TowbarDerelictAttack ) { 
                other.script.$TowbarDerelictAttack = 1;
            } else {
                if (++other.script.$TowbarDerelictAttack &gt;= tb.$TowbarMaxReduct)
                   log(&quot;escortdeck&quot;, _ship.displayName+&quot;, Laser Reductor disabled for &quot;+other.displayName+&quot;, used too many times:&quot;+other.script.$TowbarDerelictAttack);
            }
        }
        if (_ship.equipmentStatus(&quot;EQ_LASERREDUCTOR&quot;) === &quot;EQUIPMENT_OK&quot; &amp;&amp; tb.$TowbarLaserReductorOn &amp;&amp;
            (!other.script || other.script.$TowbarDerelictAttack &lt;= tb.$TowbarMaxReduct) ) { //prevent invulnerability
            // there are too many special cases for weapons and weapons positions (like shipdata&#39;s weapon_energy field)
            // so let&#39;s err on the conservative side...
            if (debug) log(&quot;escortdeck&quot;, _ship.displayName+&quot; giving &quot;+2*hit_energy+&quot; back to derelict &quot;+other.displayName+&quot;, &quot;+other.script.$TowbarDerelictAttack+&quot; attacks&quot;);
            other.energy += 2 * hit_energy;
        }
        if (npcShip) return;
        var reason = wc.$EscortDeck_TooLarge(_ship, other, this); //fit into the deck limits?
        if (other.script &amp;&amp; !(other.script.$EscortDeckUsable &gt; 0) &amp;&amp; !(other.script.$EscortDeckUsable &lt; 0) ) {
            if (wc.$isUsable(other, fname) ) { //fit into the deck limits and lucky
                log(this.name, _ship.displayName+&quot;: &quot;+fname+&quot;: &#39;&quot;+other.displayName+&quot;&#39; is usable&quot;);
                other.script.$EscortDeckUsable = 1;
                other.script.$TowbarUsableShip = true;
                other.script.$TowbarShipHealth = 1;
                wc.$EscortDeck_AwardEQs(other);
            } else {
                log(this.name, _ship.displayName+&quot;: &quot;+fname+&quot;: &#39;&quot;+other.displayName+&quot;&#39; is NOT usable&quot;);
                other.script.$EscortDeckUsable = -1; //unusable as escort
                other.script.$TowbarUsableShip = false;
            }
        }
    }
    if (!npcShip) this.$EscortDeck_Bounty( other );
}

//-----------------------------------------------------------------------------------------------//
this.shipCollided = function _escortdeck_shipCollided(otherShip) {
    var _fname = &quot;shipCollided&quot;;
    var p = player.ship;
    if (!this.$EscortDeckVersion) return;
    if( !p || !p.isValid ) return;
    var w = this;
    var i = w.$EscortDeckShip.indexOf(otherShip);
    if( i &gt; -1 ) {
        if( w.$EscortDeckShipPos[i] ) { //move escort until avoid collision
            if( !w.$EscortDeckCWS || p.dataKey.indexOf(&quot;carrier&quot;) == -1 ) {
                w.$EscortDeckShipPos[i].z -= 2; //move backward on non-Carriers
            } else { //on Carriers move escort up until avoid collision
                w.$EscortDeckShipPos[i].y += 5;
//                if( w.$EscortDeckXL ) {
//                    if( i &lt; 4 ) w.$EscortDeckShipPos[i].y += 5; //top pads up
//                    else w.$EscortDeckShipPos[i].y -= 5; //others move down
//                    else if( Math.round(i/2) != i/2 )
//                        w.$EscortDeckShipPos[i].x += 5; //move right
//                    else w.$EscortDeckShipPos[i].x -= 5; //move left
//                } else {
//                    if( i &lt; 5 ) w.$EscortDeckShipPos[i].y += 5; //on top move up
//                    else w.$EscortDeckShipPos[i].y -= 5; //others move down
//                }
            }
        }
        if( otherShip.AIState == &quot;LANDING&quot; ) {
            var r = w.$EscortDeck_PutShip(false, otherShip, i, p, true, true);
            if( !r ) otherShip.AIState == &quot;DECK&quot;; //landed
            else {
                otherShip.AIState == &quot;FOLLOW&quot;; //no room?
                if(w.$debug) log(w.name, &quot;Can&#39;t add &quot;+t.displayName +&quot; to Escort Deck pad &quot;+i+&quot;, &quot;+r); //debug
            }
        }
    } else {
        if (this.$debug) log(this.name, _fname+&quot;: bumped &#39;&quot;+otherShip.dislayName+&quot;&#39;&quot;);
        w.$EscortDeck_AddEscort( otherShip, w.$EscortDeckShip, p, w, true );
    }
}

//-----------------------------------------------------------------------------------------------//
this.shipDied = function _escortdeck_shipDied() {
        var p = player.ship;
        //var e = system.addVisualEffect(&quot;escortdeckxl&quot;, p.position);e.orientation = p.orientation;
        //this.$EscortDeckV.remove();
}

//-----------------------------------------------------------------------------------------------//
this.shipDockedWithStation = function _escortdeck_shipDockedWithStation(station) {
    this.$EscortDeck_RestoreMaxs(player.ship, this);
    this.$EscortDeckDockingTunnel = false;
    this.$EscortDeckI = false; //start on the first page
    this.$EscortDeck_Interface();
}

//-----------------------------------------------------------------------------------------------//
this.shipExitedWitchspace = function _escortdeck_shipExitedWitchspace() {
    if (!this.$EscortDeckVersion) return;
    this.$EscortDeck_Show(player.ship);
    this.$EscortDeckDockingTunnel = false;
}

//-----------------------------------------------------------------------------------------------//
this.shipLaunchedFromStation = function _escortdeck_shipLaunchedFromStation() {
    if (!this.$EscortDeckVersion) return;
    this.$EscortDeck_SaveMaxs( player.ship, this );
    this.$EscortDeckDockingTunnel = false;
    if( this.$EscortDeckCWS &amp;&amp; this.$EscortDeckCWS.$CarriersPlayerInEscort ) return;
    if (this.$debug) {
        log(this.name, &quot;Launching, PadSize:&quot;+JSON.stringify(this.$$EscortDeckPadSize));
        this.$printDeckLoad();
    }
    this.$EscortDeck_Show(player.ship);
}

//-----------------------------------------------------------------------------------------------//
this.shipTargetAcquired = function _escortdeck_shipTargetAcquired(t) {  //make some derelicts usable
    var _fname = &quot;shipTargetAcquired&quot;;
    if( !t || !t.isValid ) return;
    this.$EscortDeckLastTooLargeTarget = null;
    var p = player.ship;
    var pad = this.$EscortDeckShip.indexOf(t);
//    if( pad &gt; -1 ) this.$EscortDeckSelectedPad = pad; - do not use, cause disturbing changes in selected pad
    if( !t.script ) t.script = &quot;oolite-default-ship-script.js&quot;; //for sure
    if( t.script.$TowbarMinedShip ) t.script.$EscortDeckUsable = -1; //unusable as escort
    if ( t.isDerelict &amp;&amp; !(t.script.$EscortDeckUsable &gt; 0) &amp;&amp; !(t.script.$EscortDeckUsable &lt; 0) ) {
        //determine usability once only
        if (this.$isUsable(t, _fname)) { //limits and lucky
            log(this.name, &quot;&#39;&quot;+t.displayName+&quot;&#39; is usable&quot;);
            t.displayName = t.displayName.replace(&quot;Derelict&quot;, &quot;Usable&quot;);
            t.script.$EscortDeckUsable = 1;
            t.script.$TowbarUsableShip = true;
            t.script.$TowbarShipHealth = 1;
            this.$EscortDeck_AwardEQs(t);
        } else {
            log(this.name, &quot;&#39;&quot;+t.displayName+&quot;&#39; is NOT usable&quot;);
            t.script.$EscortDeckUsable = -1; //unusable 
            t.script.$TowbarUsableShip = false;
            if(this.$debug) log(this.name, t.displayName+&quot; is set to unusable: &quot;+t);
        }
    }
    if( t.script &amp;&amp; pad == -1  &amp;&amp; ( t.isDerelict || t.script.$EscortDeckUsable &gt; 0 )
        &amp;&amp; (!this.$EscortDeck_isLarge(t, this) //exclude ships over 130t except for Carriers
            || this.$EscortDeckCWS &amp;&amp; p.dataKey.indexOf(&quot;carrier&quot;) &gt; -1
            &amp;&amp; t.mass &lt; this.$EscortDeckCMaxMass ) ) { //must below this mass on Carriers
        var shipmass = t.mass/1000;
        //remove extra density from HardShips and Granite ships
        if( t.scriptInfo &amp;&amp; t.scriptInfo.hardarmour &gt; 1 )
            shipmass = shipmass / 2;
        var reason = this.$EscortDeck_TooLarge(t, p, this); //fit into the deck limits?
        if( t.script.$EscortDeckUsable &gt; 0 ) {
            t.script.$TowbarUsableShip = true; //show Usable! flag in CombatMFD
            var f = &quot;Found an usable &quot;+t.name+&quot; (&quot;+Math.ceil(shipmass)+&quot;t) &quot;;
            var g = null;
            if( p.equipmentStatus(&quot;EQ_ESCORTDECK&quot;) != &quot;EQUIPMENT_OK&quot;
                 &amp;&amp; p.equipmentStatus(&quot;EQ_ESCORTDECKXL&quot;) != &quot;EQUIPMENT_OK&quot; )
                g = &quot;You need an Escort Deck equipment to use as your escort&quot;;
            else if( reason ) f = t.name+&quot; is &quot;+reason+&quot; for your Escort Deck&quot;;
            else if( t.position.distanceTo(p.position) &gt; this.$EscortDeckLandingDist
                 + t.collisionRadius )
                g = &quot;Go near to pick up to the Escort Deck&quot;;
            if(this.$debug) log(this.name, f+&quot; &quot;+g); //debug
            player.consoleMessage(f, 10);
            if(g) player.consoleMessage(g, 10);
        } else if( t.script.$EscortDeckUsable &lt; 0 ) {
            t.script.$TowbarUsableShip = false;
            player.consoleMessage(&quot;Salvage &quot;+t.displayName+&quot; (&quot;+Math.ceil(shipmass)+&quot;t)&quot;, 4.5);
        }
    }
    if( pad == -1 &amp;&amp; t.script &amp;&amp; t.script.$EscortDeckUsable &gt; 0 )
        p.awardEquipment(&quot;EQ_DTAUSA&quot;); //show Usable label on NumericHUD
    else p.removeEquipment(&quot;EQ_DTAUSA&quot;); //remove Usable label on NumericHUD
}

//-----------------------------------------------------------------------------------------------//
this.shipTargetLost = function _escortdeck_shipTargetLost() {
    if (!this.$EscortDeckVersion) return;
    player.ship.removeEquipment(&quot;EQ_DTAUSA&quot;); //remove Usable label on NumericHUD
}

//-----------------------------------------------------------------------------------------------//
this.shipWillDockWithStation = function _escortdeck_shipWillDockWithStation(station) {
    if (!this.$EscortDeckVersion) return;
    if (this.$debug) {
        log(this.name, &quot;Will Dock&quot;);
        this.$printDeckLoad();
    }
    this.$EscortDeckDockingTunnel = true;
    if( station.dataKey != &quot;carriers-vdock&quot; 
        &amp;&amp; station.dataKey.indexOf(&quot;carrier-player&quot;) == -1 )
        this.$EscortDeck_VClear(this);
    else this.$EscortDeckFirstMSO = false; //do not salvage in vdock
    player.ship.removeEquipment(&quot;EQ_DTAUSA&quot;); //remove Usable label on NumericHUD
}

//-----------------------------------------------------------------------------------------------//
this.shipWillEnterWitchspace = function _escortdeck_shipWillEnterWitchspace(cause) {
    if (!this.$EscortDeckVersion) return;
    this.$EscortDeckDockingTunnel = true;
    this.$EscortDeck_VClear(this);
    player.ship.removeEquipment(&quot;EQ_DTAUSA&quot;); //remove Usable label on NumericHUD
}

//-----------------------------------------------------------------------------------------------//
this.shipWillLaunchFromStation = function _escortdeck_shipWillLaunchFromStation() {
    this.$EscortDeckVersion = this.$EscortDeck_Version();
    if (!this.$EscortDeckVersion) return;
    this.$EscortDeckDockingTunnel = true;
//    this.$EscortDeck_Show(player.ship); - lose escorts here, must call in shipLaunchedFromStation
    var ps = player.ship; //show mfd as early as other mfds but avoid no escorts message
    if( ps.setMultiFunctionText ) ps.setMultiFunctionText(this.name, &quot;&quot;, false);
    
    if( this.$EscortDeckCWS &amp;&amp; this.$EscortDeckCWS.$CarriersPlayerInEscort )
        return;
    
    this.$EscortDeckFirstMSO = true;
    if( this.$Derelicts &amp;&amp; system &amp;&amp; !system.isInterstellarSpace ) { //derelict targets
        var m = system.mainStation;
        var r = 300; //spread ship in this radius
        var ships = system.addShips(&quot;escort&quot;, 16, //random escorts over the nav buoy
            m.position.add(m.vectorForward.multiply( 11000 )), 3*r);

                if( this.$EscortDeckSGWS ) {
                        var a = system.addShips(&quot;[asp-sg]&quot;, 2,
                                m.position.add(m.vectorForward.multiply( 1800 )), r);
                        ships.push(a[0]); ships.push(a[1]);
                        var a = system.addShips(&quot;[cobra3-sg]&quot;, 2,
                                m.position.add(m.vectorForward.multiply( 2100 )), r);
                        ships.push(a[0]); ships.push(a[1]);
                        var a = system.addShips(&quot;[ferdelance-sg]&quot;, 2,
                                m.position.add(m.vectorForward.multiply( 2400 )), r);
                        ships.push(a[0]); ships.push(a[1]);
                        var a = system.addShips(&quot;[krait-sg]&quot;, 2,
                                m.position.add(m.vectorForward.multiply( 2700 )), r);
                        ships.push(a[0]); ships.push(a[1]);
                }
                var a = system.addShips(&quot;[escortdeck-adder]&quot;, 4,
                        m.position.add(m.vectorForward.multiply( 3000 )), r);
        ships.push(a[0]); ships.push(a[1]); ships.push(a[2]); ships.push(a[3]);
/*        var a = system.addShips(&quot;[escortdeck-asp]&quot;, 4,
            m.position.add(m.vectorForward.multiply( 3500 )), r);
        ships.push(a[0]); ships.push(a[1]); ships.push(a[2]); ships.push(a[3]);
        var a = system.addShips(&quot;[escortdeck-gecko]&quot;, 4,
            m.position.add(m.vectorForward.multiply( 4000 )), r);
        ships.push(a[0]); ships.push(a[1]); ships.push(a[2]); ships.push(a[3]);
        var a = system.addShips(&quot;[escortdeck-sidewinder]&quot;, 4,
            m.position.add(m.vectorForward.multiply( 4500 )), r);
        ships.push(a[0]); ships.push(a[1]); ships.push(a[2]); ships.push(a[3]);
        var a = system.addShips(&quot;[escortdeck-viper]&quot;, 4,
            m.position.add(m.vectorForward.multiply( 5000 )), r);
        ships.push(a[0]); ships.push(a[1]); ships.push(a[2]); ships.push(a[3]);
        
        var a = system.addShips(&quot;[cobramk1]&quot;, 4,
            m.position.add(m.vectorForward.multiply( 6000 )), r);
        ships.push(a[0]); ships.push(a[1]); ships.push(a[2]); ships.push(a[3]);
        var a = system.addShips(&quot;[ferdelance]&quot;, 4,
            m.position.add(m.vectorForward.multiply( 7000 )), r);
        ships.push(a[0]); ships.push(a[1]); ships.push(a[2]); ships.push(a[3]);
        var a = system.addShips(&quot;[moray]&quot;, 4,
            m.position.add(m.vectorForward.multiply( 8000 )), r);
        ships.push(a[0]); ships.push(a[1]); ships.push(a[2]); ships.push(a[3]);
        var a = system.addShips(&quot;[cobra3-player]&quot;, 4,
            m.position.add(m.vectorForward.multiply( 6500 )), r);
        ships.push(a[0]); ships.push(a[1]); ships.push(a[2]); ships.push(a[3]);
        var a = system.addShips(&quot;[krait]&quot;, 4,
            m.position.add(m.vectorForward.multiply( 7500 )), r);
        ships.push(a[0]); ships.push(a[1]); ships.push(a[2]); ships.push(a[3]);
*/

        if( this.$EscortDeckPWS ) {
            var a = system.addShips(&quot;[escortdeck-ophidian]&quot;, 4,
                m.position.add(m.vectorForward.multiply( 8000 )), r);
            ships.push(a[0]); ships.push(a[1]); ships.push(a[2]); ships.push(a[3]);
/*            var a = system.addShips(&quot;[escortdeck-ghavial]&quot;, 2,
                m.position.add(m.vectorForward.multiply( 8000 )), r);
            ships.push(a[0]); ships.push(a[1]);
            var a = system.addShips(&quot;[escortdeck-wolf]&quot;, 2,
                m.position.add(m.vectorForward.multiply( 8500 )), r);
            ships.push(a[0]); ships.push(a[1]);
            var a = system.addShips(&quot;[escortdeck-sniper-wolf]&quot;, 2,
                m.position.add(m.vectorForward.multiply( 8500 )), r);
            ships.push(a[0]); ships.push(a[1]);
*/            var a = system.addShips(&quot;[escortdeck-arachnid]&quot;, 2,
                m.position.add(m.vectorForward.multiply( 9000 )), r);
            ships.push(a[0]); ships.push(a[1]);
            var a = system.addShips(&quot;[escortdeck-sniper-arachnid]&quot;, 2,
                m.position.add(m.vectorForward.multiply( 9000 )), r);
            ships.push(a[0]); ships.push(a[1]);
            var a = system.addShips(&quot;[escortdeck-s8]&quot;, 2,
                m.position.add(m.vectorForward.multiply( 9500 )), r);
            ships.push(a[0]); ships.push(a[1]);
            var a = system.addShips(&quot;[escortdeck-sniper-s8]&quot;, 2,
                m.position.add(m.vectorForward.multiply( 9500 )), r);
            ships.push(a[0]); ships.push(a[1]);
        }

        for(var i=0; i&lt;ships.length; i++) {
            if( ships[i] ) {
                ships[i].orientation = ps.orientation;
                ships[i].switchAI(&quot;nullAI.plist&quot;); //need to deactivate escortdeck AI
                if( worldScripts[&quot;shipversion&quot;] ) {
                    worldScripts[&quot;shipversion&quot;].shipSpawned(ships[i]);
                }
                ships[i].awardEquipment(&quot;EQ_ESCAPE_POD&quot;);
                if(i == 0) { //make first ship to weak offender without injectors, need a few shot only to eject it
                    ships[i].removeEquipment(&quot;EQ_FUEL_INJECTION&quot;);
                    ships[i].bounty=33;
                    ships[i].energy=33;
                } else ships[i].abandonShip(); //other ships derelict
            } else if( this.$debug ) log(this.name, &quot;ships[&quot;+i+&quot;] is undefined &quot;);
        }
        if( this.$debug ) log(this.name, &quot;test derelict ships: &quot;+ships);
    }
}


//
// Internal functions
//

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_Version = function _escortdeck_EscortDeck_Version() {
    var that = _escortdeck_EscortDeck_Version;
    var eq_list = (that.eq_list = that.eq_list || [ &quot;EQ_ESCORTDECK&quot;, &quot;EQ_ESCORTDECKXL&quot; ]);
    var ship = player.ship;
    var i = eq_list.length;
    while (i--)
        if (ship.equipmentStatus(eq_list[i]) === &quot;EQUIPMENT_OK&quot;)
            return eq_list[i];
    return null;
}

//-----------------------------------------------------------------------------------------------//
this.$onChange = function _escortdeck_onChange() {
    if (this.$newUsableProb != (1-this.$EscortDeckBasicUnusableProb) &amp;&amp; this.$newUsableProb &gt;= 0 &amp;&amp; this.$newUsableProb &lt;= 1) {
        this.$EscortDeckBasicUnusableProb = (1-this.$newUsableProb);
        log(this.name, &quot;Unusable derelict probability changed to &quot;+this.$EscortDeckBasicUnusableProb);
    }
    if (this.$newAutoLaunch != this.$EscortDeckAutoLaunch) {
        this.$EscortDeckAutoLaunch = this.$newAutoLaunch;
        log(this.name, &quot;AutoLaunch changed to &quot;+this.$EscortDeckAutoLaunch);
    }
    log(this.name,&quot;Config changed, newUsableProb:&quot;+this.$newUsableProb+&quot;, newAutoLaunch:&quot;+this.$newAutoLaunch+&quot;, $EscortDeckBasicUnusableProb:&quot;+this.$EscortDeckBasicUnusableProb+&quot;, $EscortDeckAutoLaunch:&quot;+this.$EscortDeckAutoLaunch);
}

//-----------------------------------------------------------------------------------------------//
this.$damageRatio = function _escortdeck_damageRatio(s) {
    var fname = &quot;damageRatio&quot;;
    var shipEquipments = s.equipment;
    var i = shipEquipments.length;
    var ok = 0;
    var damaged = 0;
    var eqpKey, eqpStatus, damaged_ratio;

    while (i--) {
        eqpKey = shipEquipments[i].equipmentKey;
        eqpStatus = s.equipmentStatus(eqpKey);
        if (this.$debug) log(this.name, fname+&quot;: &#39;&quot;+s.displayName+&quot;&#39; has &quot;+eqpKey+&quot;: &quot;+eqpStatus);
        if (eqpStatus === &quot;EQUIPMENT_OK&quot;) {
            ok++;
        } else if (eqpStatus === &quot;EQUIPMENT_DAMAGED&quot;) {
            damaged++;
        }
    }
    if (ok + damaged === 0) {
        damaged_ratio = 0;
    } else if (ok === 0 &amp;&amp; damaged &gt; 0) {
        damaged_ratio = 1;
    } else {
        damaged_ratio =  damaged / (damaged + ok);
    }
    if (this.$debug) log(this.name, fname+&quot;: &#39;&quot;+s.displayName+&quot;&#39; has &quot;+damaged+&quot; damaged of &quot;+(damaged+ok)+&quot; equipments, ratio &quot;+damaged_ratio+&quot;, $EscortDeckUsable: &quot;+s.script.$EscortDeckUsable);
    return damaged_ratio
}

//-----------------------------------------------------------------------------------------------//
this.$isUsable = function _escortdeck_isUsable(s, from_fname) {
    var fname = &quot;isUsable&quot;;
    var unusable_prob, rnd;

    if (s.script &amp;&amp; s.script.$EscortDeckUsable &amp;&amp; s.script.$EscortDeckUsable === -1) return false;

    var damaged_ratio = this.$damageRatio(s);
    if (this.$EscortDeckNPCEqDamage) {
        // NPC Equipment Damage OPC is installed, and it adds _a lot_ of equipment damage
        damaged_ratio = damaged_ratio / 6.7;
    }
    if (this.$debug) log(this.name, fname+&quot;(&quot;+from_fname+&quot;): &#39;&quot;+s.displayName+&quot;&#39;, adjusted damage_ratio: &quot;+damaged_ratio+&quot;, $EscortDeckUsable: &quot;+s.script.$EscortDeckUsable);
    // probability of damaged to basic systems + equipment damage 
    // (it&#39;s not a probem being larger than 1)    
    unusable_prob = this.$EscortDeckBasicUnusableProb + damaged_ratio;
    rnd = Math.random();
    if (this.$debug) log(this.name, fname+&quot;: unusable probability: &quot;+unusable_prob+&quot;, random: &quot;+rnd);
    return (rnd &gt; unusable_prob);
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_HHStoreShip = function _escortdeck_HHStoreShip(ship) {
    var that = _escortdeck_HHStoreShip;
    var ws = (that.ws = that.ws || worldScripts.escortdeck);
    if (!ship) return;
    var shipdata = $EscortDeck_MakeShipData(ship);
    if (shipdata &amp;&amp; shipdata[0]) {
        ws.$EscortDeck_HHStoreShipData(shipdata);
    } else {
        log(ws.name, &quot;Trouble creating shipData for &quot;+ship.displayName);
    }
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_HHStoreShipData = function _escortdeck_HHStoreShipData(shipdata) {
    var that = _escortdeck_HHStoreShipData;
    var ws = (that.ws = that.ws || worldScripts.escortdeck);
    var hh = (that.hh = that.hh || worldScripts.HyperspaceHangar);
    if (shipdata &amp;&amp; shipdata[0]) {
        var k = clock.absoluteSeconds;
        while (hh._shipsStored[k]) k++;
        var displayName = shipdata[0][3];
        shipdata[0][0] = galaxyNumber;
        shipdata[0][1] = system.ID;
        hh._shipsStored[k] = JSON.stringify(shipdata);
        hh._currentNames[k] = displayName;
        if (hh._currentNames[&quot;0_EXIT&quot;] === &quot;EMPTY&quot;) hh._currentNames[&quot;0_EXIT&quot;] = &quot;Exit&quot;;
    }
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_AddEscort = function _escortdeck_AddEscort( t, e, owner, w, msg ) { //add t into the deck of ship if possible
    var _fname = &quot;$EscortDeck_AddEscort&quot;;
//    if (this.$debug) log(this.name, _fname+&quot;: examining &quot;+(t.displayName ? t.displayName : t)+&quot;, mass:&quot;+t.mass); 
    if( t &amp;&amp; t.isValid &amp;&amp; t.script &amp;&amp;
        ( t.isDerelict || t.script.$EscortDeckUsable === -1 || t.script.$EscortDeckUsable &gt; 0 )
        &amp;&amp; t.mass &gt; 1000 &amp;&amp; t.mass &lt; this.$EscortDeckExtremeMass &amp;&amp; !t.isVisualEffect &amp;&amp; !t.isPlayer
        &amp;&amp; !t.isDock &amp;&amp; !t.isStation &amp;&amp; !t.isCargo &amp;&amp; !t.isRock &amp;&amp; !t.isThargoid &amp;&amp; !t.isWeapon
        &amp;&amp; owner &amp;&amp; owner.isValid
        &amp;&amp; ( owner.equipmentStatus(&quot;EQ_ESCORTDECK&quot;) == &quot;EQUIPMENT_OK&quot;
            || owner.equipmentStatus(&quot;EQ_ESCORTDECKXL&quot;) == &quot;EQUIPMENT_OK&quot; )
        &amp;&amp; owner.mass &gt;= w.$EscortDeckMinMass
        &amp;&amp; owner.position.distanceTo(t.position) &lt; w.$EscortDeckLandingDist + t.collisionRadius ) {
        var p = e.indexOf(t);
        if( p &gt; -1 &amp;&amp; t.AIState != &quot;LANDING&quot; ) return false;//owned escort is on way, do not land
    
        var r = this.$EscortDeck_TooLarge(t, owner, w);
        if( r ) { //reason
                        w.$EscortDeckLastTooLargeTarget = t; //prevent repeated message
            if( msg &amp;&amp; owner == player.ship ) {
                player.consoleMessage(&quot;You can&#39;t pick up &quot;+t.displayName+&quot; to your Escort Deck, &quot;+r, 10);
            }
            return false;
        }
        if (t.script.$EscortDeckUsable != 1 &amp;&amp; t.script.$EscortDeckUsable != -1 ) {
            // derelict was not examined for usability
            if (this.$isUsable(t, _fname)) { //fit into the deck limits and lucky
                log(this.name, t.displayName+&quot; is usable&quot;);
                t.script.$EscortDeckUsable = 1;
                t.script.$TowbarUsableShip = true;
                t.script.$TowbarShipHealth = 1;
                this.$EscortDeck_AwardEQs(t);
            } else {
                log(this.name, t.displayName+&quot; is NOT usable&quot;);
                t.script.$EscortDeckUsable = -1; //unusable as escort
                t.script.$TowbarUsableShip = false;
                if(this.$debug) log(this.name, t.displayName+&quot; is set to unusable: &quot;+t);
            }
        }

        var diff = owner.velocity.subtract( t.velocity ).magnitude();
        if( diff &gt; 100 ) {
            log(this.name, &quot;Velocity difference (&quot;+(Math.round(diff/10)*10)+&quot;m/s) too big to load into EscortDeck&quot;);
            if( owner == player.ship &amp;&amp; msg &amp;&amp; p == -1 ) //not in auto landing
                player.consoleMessage(Math.round(diff/10)*10+&quot; m/s speed difference&quot;);
            return false;
        }

        //put into the selected pad if fit into
        //and regardless of occupied (replace) if this is the current target
        var spad = w.$EscortDeckSelectedPad;
        if( spad &gt; -1 ) {
            if(this.$debug) log(w.name, &quot;Try &quot;+t.displayName+&quot; to selected pad &quot;+(spad+1)); //debug
            var f = false; //force replace
            if( owner.target == t ) f = true;
            r = w.$EscortDeck_PutShip(false, t, spad, owner, msg, f);
            if( !r ) return true; //report successfully added
            else if(this.$debug) log(w.name, &quot;Can&#39;t add &quot;+t.displayName+&quot; to selected pad &quot;+(spad+1)+&quot;, &quot;+r); //debug
        }

        //put owned escorts back to the correct pad
        if( p &gt; -1 ) {
            if(this.$debug) log(w.name, &quot;Try &quot;+t.displayName+&quot; to old pad &quot;+(p+1)); //debug
            r = w.$EscortDeck_PutShip(false, t, p, owner, msg, true);
            if( !r ) return true; //report successfully added
            else { //if faliled the remove and try other pads as new ships
                if(this.$debug) log(w.name, &quot;Can&#39;t add &quot;+t.displayName+&quot; back to pad &quot;+(p+1)+&quot;, &quot;+r); //debug
                e[p] = null;
                p = -1;
            }
        }
        if(this.$debug) log(w.name, &quot;Try &quot;+t.displayName+&quot; to empty pads&quot;); //debug

        //if Adder or smaller then try Adder pads first
        var large = w.$EscortDeck_isLarge(owner, w);
        if( large &amp;&amp; //side pads need large ship
            w.$EscortDeck_AddMini(t, owner, w, msg, false) )
            return true; //report successfully added

        //non-small escort need large ship
        for(var i = 0; i &lt; w.$EscortDeckPadPos.length; i++ ) {
            if( !w.$EscortDeck_isMiniPad(i, owner, w) ) {
                //find the first empty pad except Adder only pads
//                log(w.name, i+&quot;. free:&quot;+w.$EscortDeck_isPadFree(i, w)); //debug
                r = w.$EscortDeck_PutShip(false, t, i, owner, msg, false);
                if( !r ) i = w.$EscortDeckPadPos.length;//exit from the for cycle
            }
        }
        if( e.indexOf(t) &gt; -1 ) return true; //report successfully added

        //replace first flying escort if no more empty pad and none selected
        if(this.$debug) log(w.name, &quot;Try &quot;+t.displayName+&quot; to replace a flying escort&quot;);
        for(var i = 0; i &lt; w.$EscortDeckPadPos.length; i++ ) {
            if( !w.$EscortDeck_isMiniPad(i, owner, w)
                || large &amp;&amp; w.$EscortDeck_isMini(t) ) {
                if( !w.$EscortDeckShipPos[i] ) { //on the way
                    r = w.$EscortDeck_PutShip(false, t, i, owner, msg, true);
                    if( !r ) return true;
                }
            }
        }

        if( e.indexOf(t) &gt; -1 ) return true; //report successfully added
        else {
            if( msg &amp;&amp; owner == player.ship ) {
                player.consoleMessage(&quot;No room on Escort Deck for &quot;+t.displayName, 10);
            }
            if(this.$debug) log(w.name, &quot;Can&#39;t add &quot;+t.displayName+&quot; to Escort Deck, &quot;+r); //debug
            return false;
        }
    } //else log(this.name, _fname+&quot;: ship &quot;+(t.displayName ? t.displayName : t)+&quot; didn&#39;t meet basic condition, ignoring&quot;);
    return false; //can not add escort to the deck
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_AddMini = function _escortdeck_AddMini( t, owner, w, msg, land ) { //add mini escort to a small pad if possible
    if( !w.$EscortDeck_isMini(t) ) return false; //need like an Adder or smaller
    for( var i = 0; i &lt; w.$EscortDeckPadPos.length; i++ ) {
        if( w.$EscortDeck_isMiniPad(i, owner, w) ) {
            if( !w.$EscortDeck_PutShip(false, t, i, owner, msg, land ) )
                return true;
        }
    }
    return false;
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_AwardEQs = function _escortdeck_AwardEQs(ship) {
    var logging = this.$logging;
    var debug  = this.$debug;
    var LN10 = Math.LN10;
    var damage_ratio = this.$damageRatio(ship);

    function escortdeck_awardEQ(eqKey) {
        var eqInfo = EquipmentInfo.infoForKey(eqKey);
        var rnd = Math.random();
        var threshold = 0.03 * eqInfo.techLevel + 0.05 * Math.log(eqInfo.calculatedPrice/10)/LN10;

        if (debug) log(&quot;escortdeck&quot;, &quot;usable &quot;+ship.displayName+&quot;, &quot;+eqKey+&quot;: tl:&quot;+eqInfo.techLevel+&quot; (&quot;+0.03 * eqInfo.techLevel+&quot;), price: &quot;+eqInfo.calculatedPrice/10+&quot; (&quot;+0.05 * Math.log(eqInfo.calculatedPrice/10)/LN10+&quot;), threshold: &quot;+threshold+&quot;, rnd: &quot;+rnd);
        if (rnd &gt; threshold) {
            var damage_prob = damage_ratio * eqInfo.damageProbability;
            ship.awardEquipment(eqKey);
            if (Math.random() &lt; damage_prob) ship.setEquipmentStatus(eqKey, &quot;EQUIPMENT_DAMAGED&quot;);
            if (logging) log(&quot;escortdeck&quot;, &quot;awarding &quot;+eqKey+&quot;(&quot;+ship.equipmentStatus(eqKey)+&quot;) to usable &quot;+ship.displayName);
            return true;
        }
        return false;
    }

    //award player specific equipments, useful when sitting in from a Carrier
    if (ship &amp;&amp; ship.isValid) {
        escortdeck_awardEQ(&quot;EQ_ADVANCED_COMPASS&quot;);
        if(worldScripts.combat_MFD) escortdeck_awardEQ(&quot;EQ_COMBATMFD&quot;);
        if (worldScripts.MFDFastConfiguration) escortdeck_awardEQ(&quot;EQ_MFD_FAST_CONFIG&quot;);
        if (ship.hasHyperspaceMotor) escortdeck_awardEQ(&quot;EQ_ADVANCED_NAVIGATIONAL_ARRAY&quot;);
        escortdeck_awardEQ(&quot;EQ_MULTI_TARGET&quot;);
        escortdeck_awardEQ(&quot;EQ_SCANNER_SHOW_MISSILE_TARGET&quot;);
        if (worldScripts.targetAutolock) //requires EQ_SCANNER_SHOW_MISSILE_TARGET so add after
            escortdeck_awardEQ(&quot;EQ_TARGET_AUTOLOCK&quot;);
        escortdeck_awardEQ(&quot;EQ_TARGET_MEMORY&quot;);
        escortdeck_awardEQ(&quot;EQ_INTEGRATED_TARGETING_SYSTEM&quot;);//requires Target Memory so add after
        if (worldScripts.telescope) escortdeck_awardEQ(&quot;EQ_TELESCOPE&quot;);
        if (worldScripts.sniperlock) escortdeck_awardEQ(&quot;EQ_SNIPERLOCK&quot;);
        if (worldScripts.towbar) escortdeck_awardEQ(&quot;EQ_LASERREDUCTOR&quot;);
        if (worldScripts.traildetector) escortdeck_awardEQ(&quot;EQ_TRAIL_DETECTOR&quot;);
        if (worldScripts.Police_Scanner_Upgrade) escortdeck_awardEQ(&quot;EQ_POLICE_SCANNER_UPGRADE&quot;);
        if (worldScripts.hudselector) escortdeck_awardEQ(&quot;EQ_HUDSELECTOR&quot;);
        if (worldScripts.BarrelRoll) escortdeck_awardEQ(&quot;EQ_BARREL_ROLL&quot;);
        escortdeck_awardEQ(&quot;EQ_WORMHOLE_SCANNER&quot;);
        escortdeck_awardEQ(&quot;EQ_HEAT_SHIELD&quot;);//protection for sunskimming, requested by QCS
    }
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_Bounty = function _escortdeck_Bounty( ship ) {
    if( ship.isDerelict &amp;&amp; ship.bounty &gt; 0 ) {
        player.credits += ship.bounty;
        player.consoleMessage(&quot;Bounty: &quot;+formatCredits(ship.bounty, true, true));
        player.consoleMessage(&quot;Total: &quot;+formatCredits(player.credits, true, true));
        ship.bounty = 0;
    }
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_ControlAll = function _escortdeck_ControlAll( launch, manual, w ) { //launch or call back all escorts
    if( launch &amp;&amp; w.$EscortDeck_ControlFast(manual) ) return(false);
    var c = 0;
    var carrier = false;
    if( w.$EscortDeckCWS &amp;&amp; player.ship.dataKey.indexOf(&quot;carrier&quot;) &gt; -1 )
        carrier = true;
    for(var i = 0; i &lt; w.$EscortDeckPadPos.length; i++ ) {
        if( !w.$EscortDeckLocked[i] &amp;&amp;
            ( !launch || !carrier || w.$EscortDeckXL || manual ||
            //can prevent auto launch of Anaconda from Carrier
            w.$EscortDeckCBigTraderLaunch ||
            w.$EscortDeckShip &amp;&amp; w.$EscortDeckShip[i]
            &amp;&amp; w.$EscortDeckShip[i].mass &lt; w.$EscortDeckXLMass ) ) {
            if( w.$EscortDeck_Control1(launch, i, false, manual)) //launch without message
                c++; //count usable escorts
        }
    }
    if( c &gt; 0 &amp;&amp; ( manual || !launch ) ) { //do not message autolaunch when entering red alert
        var e = c+&quot; Escorts &quot;;
        if( c == 1 ) e = &quot;1 Escort &quot;;
        var m = &quot;called back&quot;;
        if( launch ) m = &quot;on the way&quot;;
        player.consoleMessage(e+m, 10);
    }
    w.$EscortDeck_MFD(w); //update MFD
    return(c);
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_ControlFast = function _escortdeck_ControlFast(manual) {
    var max = player.ship.maxSpeed; //no launch over max.speed
//    if( !manual ) max = max * 0.999; //no autolaunch at max.speed
    if( player.ship.speed &gt; max ) {
        if( manual ) player.consoleMessage(&quot;You travel too fast to launch escorts&quot;, 3);
//        else player.consoleMessage(&quot;No autolaunch of escorts at maximal speed&quot;, 3);
        return(true);
    }
    return(false);
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_Control = function _escortdeck_Control( launch, pad, msg, w ) { //launch or call back an escort
    w.$EscortDeck_Control1(launch, pad, msg, true);
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_Control1 = function _escortdeck_Control1(launch, pad, msg, manual) { //launch or call back an escort
    var that = _escortdeck_Control1;
    var w = (that.w = that.w || worldScripts.escortdeck);

    if (launch &amp;&amp; this.$EscortDeck_ControlFast(manual)) return false;
    var s = null;
    var p = player.ship;
    if (w.$EscortDeckShip) s = w.$EscortDeckShip[pad];
    if (s &amp;&amp; s.isValid) {
        if (!s.script || !(s.script.$EscortDeckUsable &gt; 0)) { //unusable
            if (msg) w.$EscortDeck_Release(p, pad, w); //msg mean manual and one ship
            return(false);
        }
        var m = null; //the carrier can&#39;t launch
        if (launch &amp;&amp; !w.$EscortDeckLocked[pad]) {
            var seen = [];
            s.script.shipAttackedOther = this.shipAttackedOther;
            s.script.shipKilledOther = this.shipKilledOther;
            s.script.$debugHarderWay = true;
            s.script.$debug = false;
            s.script.$logging = true;
            log(this.name, &quot;Launching &quot;+s.displayName+&quot; from Pad &quot;+pad+&quot;, escortdeckUsable &quot;+s.script.$EscortDeckUsable+&quot; script: &quot;+JSON.stringify(s.script, function(key,val) {
                                if (val != null &amp;&amp; typeof val == &quot;object&quot;) {
                                    if (seen.indexOf(val) &gt;= 0) {return;}
                                    seen.push(val);
                                }
                                return val;
                               }));
            if (p.removeCollisionException) //from v1.81
                p.removeCollisionException(s);
            w.$EscortDeckShipData[pad] = null; //prevent recreation in dock
            w.$EscortDeckShipPos[pad] = null; //do not update position in FCB

            //increase steering and acceleration in proportion with the smaller mass on deck
            w.$EscortDeck_SetMaxs(p, w);

            if (s.AI != &quot;EscortDeck_AI.plist&quot;) s.switchAI(&quot;EscortDeck_AI.plist&quot;);
            s.AIState = &quot;GOTO&quot;; //switch back from waypoint AI
            s.scannerDisplayColor1 = [0, 0.7, 0]; //green
            s.velocity = p.velocity; //prevent collision if player travel at speed
            if (w.$EscortDeckPadVec) {//help to leave the owner: jump 20m far
                var j = w.$EscortDeckJumpDist;
                var x = j * w.$EscortDeckPadVec[pad][0];
                var y = j * w.$EscortDeckPadVec[pad][1];
                var z = j * w.$EscortDeckPadVec[pad][2];
                if (p.dataKey.indexOf(&quot;carrier&quot;) &gt; -1) {
                    if (w.$EscortDeck_isMiniPad(pad, p, w)) {
                        z = j; //Carrier mini pads jump forward
                    } else if(!w.$EscortDeckXL) { //traders jump sideways
                        if (pad == 6) {x = j; z = 0;}
                        else if (pad == 5) {x = -j; z = 0;}
                    }
                }
                var o = p.orientation;
                var sp = s.position.add(o.vectorRight().multiply(x))
                    .add(o.vectorUp().multiply(y))
                    .add(p.heading.multiply(z));
                if (sp.magnitude() &gt; 500) s.position = sp;
            }
            s.script.$EscortDeckOnDeck = false;
            m = &quot;on the way&quot;;
        } else { //call back
            if (s.AIState != &quot;DECK&quot;) { //isn&#39;t in deck already
//            if( !w.$EscortDeckShipPos[pad] ) {
                if (s.AI != &quot;EscortDeck_AI.plist&quot;) s.switchAI(&quot;EscortDeck_AI.plist&quot;);
                s.AIState = &quot;LANDING&quot;;  //switch back from waypoint AI
                m = &quot;called back&quot;;
            }
        }
        if (m &amp;&amp; msg) {
            player.consoleMessage(s.displayName+&quot; &quot;+m, 5);
            w.$EscortDeck_MFD(w); //update MFD
        }
        if (w.$debug) log(w.name, pad+&quot;. launch:&quot;+launch+&quot; &quot;+m); //debug
        if (m) return true;
    }
    return false;
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_EQActivated = function _escortdeck_EQActivated(w) { //launch or call back one or all escorts
    var p = player.ship;            //called from carriers-escort-eq.js also!
    if( !p || !p.isValid ) return;
    if( w.$EscortDeckSelectedPad == w.$EscortDeckPadPos.length &amp;&amp; w.$EscortDeckToWS ) {
        if( w.$EscortDeckToWS.$TowbarShip ) w.$EscortDeckToWS.$Towbar_Release();
        else player.consoleMessage(&quot;No ship on Towbar&quot;);
    } else if( w.$EscortDeckSelectedPad == -2 ) { //setup sit into mode
        w.$EscortDeckSitInto = !w.$EscortDeckSitInto; //flip-flop
         w.$EscortDeck_EQDisplayMode(w);
    } else if( w.$EscortDeckSelectedPad == -1 ) { //launch or call back all escorts
        w.$EscortDeckLaunch = !w.$EscortDeckLaunch; //flip-flop
        w.$EscortDeck_ControlAll(w.$EscortDeckLaunch, true, w);
    } else { //launch or call back a selected escort with message
        var s = w.$EscortDeckShip[w.$EscortDeckSelectedPad];
        if( s &amp;&amp; s.isValid ) {
            if( w.$EscortDeckShipPos[w.$EscortDeckSelectedPad] ) {
                if( w.$EscortDeckLocked[w.$EscortDeckSelectedPad] ) {
                    w.$EscortDeckLaunch = true; //launch if on deck and locked
                    w.$EscortDeckLocked[w.$EscortDeckSelectedPad] = false;
                } else {
                    w.$EscortDeckLaunch = false;
                    w.$EscortDeckLocked[w.$EscortDeckSelectedPad] = true; //lock
                }
                w.$EscortDeck_MFD(w); //update MFD
            } else {
                w.$EscortDeckLocked[w.$EscortDeckSelectedPad] = false;
                if( s.AIState == &quot;LANDING&quot; ) w.$EscortDeckLaunch = true;
                else {
                    w.$EscortDeckLaunch = false;
                    if( s.dataKey.indexOf(&quot;carrier-player&quot;) &gt; -1 ) {
                        if( p.target == s ) {//target is the player&#39;s carrier?
                            player.consoleMessage(&quot;Approach the Carrier &quot;+
                                &quot;within &quot;+w.$EscortDeckLandingDist+
                                &quot;m with small speed difference &quot;+
                                &quot; for landing&quot;,10);
                        } else { player.consoleMessage(&quot;Hold ident lock on&quot;+
                                &quot; your Carrier to keep up&quot;+
                                &quot; landing clearance&quot;,5);
                        }
                    }
                }
            }
            if( w.$EscortDeckSitInto //deck is in the &quot;sit into the escort&quot; mode
                &amp;&amp; w.$EscortDeckCWS //Carriers OXP is installed
                &amp;&amp; p.dataKey.indexOf(&quot;carrier-player&quot;) &gt; -1 //player in the Carrier
                &amp;&amp; s.AIState == &quot;DECK&quot; //selected a landed, usable and playable escort
                &amp;&amp; s.missileCapacity &gt; 0 //bugfix against a core bug with 0 max_missiles
                &amp;&amp; w.$EscortDeckPlayableDataKeys.indexOf(s.dataKey) &gt; -1 ) {
                w.$EscortDeckCWS.$Carriers_SitIntoAnEscort(s); //launch player
            } else w.$EscortDeck_Control( w.$EscortDeckLaunch,
                w.$EscortDeckSelectedPad, true, w);
        } else { //no ship in this pad
            if( w.$EscortDeckLocked[w.$EscortDeckSelectedPad] )
                w.$EscortDeckLocked[w.$EscortDeckSelectedPad] = false;
            else w.$EscortDeckLocked[w.$EscortDeckSelectedPad] = true;
        }
    }
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_EQDisplayMode = function _escortdeck_EQDisplayMode(w) {
     if( w.$EscortDeckSelectedPad == -1 ) { //launch or callback mode
        var l = &quot;Launch all non-locked&quot;;
        if( w.$EscortDeckLaunch ) l = &quot;Call back all flying&quot;;
        player.consoleMessage(l+&quot; escorts when EscortDeck activated&quot;,5);
    } else if( w.$EscortDeckSelectedPad == -2 ) { //setup sit into mode
        var l = &quot;avoid&quot;;
        if( w.$EscortDeckSitInto ) l = &quot;allow&quot;;
        player.consoleMessage(&quot;EscortDeck &quot;+l+&quot; to sit into a selected escort&quot;,5);
    }
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_EQMode = function _escortdeck_EQMode(w, playable) { //select the next pad on escort deck
     var p = player.ship;         //called from carriers-escort-eq.js also!
    if( p &amp;&amp; p.isValid ) {
        w.$EscortDeckSelectedPad++;
/*        if( playable ) { - removed to allow select any ship to drop salvage, etc.
            var start = false;
            if( w.$EscortDeckSelectedPad == 0 ) start = true; //start from the first pad
            var found = -1;
            while( found &lt; 0 &amp;&amp; w.$EscortDeckSelectedPad &lt; w.$EscortDeckPadPos.length ) {
                var s = w.$EscortDeckShip[w.$EscortDeckSelectedPad];
                if( s &amp;&amp; s.isValid &amp;&amp; s.script &amp;&amp; s.script.$EscortDeckUsable &gt; 0
                    &amp;&amp; w.$EscortDeckPlayableDataKeys.indexOf(s.dataKey) &gt; -1 )
                    found = w.$EscortDeckSelectedPad;
                w.$EscortDeckSelectedPad++;
            }
            w.$EscortDeckSelectedPad = found;
            if( start &amp;&amp; found == -1 )
                player.consoleMessage( &quot;You have not any playable ships on board&quot;, 5 );
        }
*/
//        while( w.$EscortDeckSelectedPad &lt; w.$EscortDeckPadPos.length
//            &amp;&amp; !w.$EscortDeckShip[w.$EscortDeckSelectedPad] )  //skip empty pads
//            w.$EscortDeckSelectedPad++; - no skip to be able to lock to a specific pad
        if( !w.$EscortDeckToWS || w.$EscortDeckSelectedPad &lt;= w.$EscortDeckPadPos.length ) {
            if( w.$EscortDeckSelectedPad &gt;= w.$EscortDeckPadPos.length ) {
            if( w.$EscortDeckSitIntoWithMode //allowing sit into enabled with mode key
                &amp;&amp; p.dataKey.indexOf(&quot;carrier&quot;) &gt; -1 )//and player in a Carrier
                w.$EscortDeckSelectedPad = -2; //setup sit into mode
            else w.$EscortDeckSelectedPad = -1; //none selected
            var ws = w.$EscortDeckTWS; //Telescope worldScript
            if( ws ) ws.$TelescopeTargetSet = true;
            p.target = null;
            if( ws ) ws.$TelescopeTargetSet = false;
            }
            if( w.$EscortDeckSelectedPad &gt; -1 ) {
            var s = w.$EscortDeckShip[w.$EscortDeckSelectedPad];
            if( s &amp;&amp; s.isValid ) {
                var ws = w.$EscortDeckTWS; //Telescope worldScript
                if( ws ) {
                    var mi = ws.$TelescopeList.indexOf( s );
                    if( mi == -1 ) ws.$Telescope_Scan(); //forced rescan
                    if( mi &gt; -1 ) {
                        if(  ws.$TelescopeListi != mi + 1 ) {
                            ws.$TelescopeListi = mi + 1;
                            ws.$Telescope_Show2( false ); //lock target
                        }
                    }
                } else p.target = s; //target the selected ship
            }
            } else w.$EscortDeck_EQDisplayMode(w);
        }
        w.$EscortDeck_MFD(w); //update MFD
    }
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_FCB = function _escortdeck_FCB(delta) { //FrameCallBack updating positions of escort ships
    var that = _escortdeck_FCB;
    var owner = (that.owner = that.owner || player.ship); //modify this for NPCs
    var w = (that.w = that.w || worldScripts.escortdeck);
    var wSV = (that.wSV = that.wSV || worldScripts.shipversion); // ShipVersion
    var tb = (that.tb = that.tb || w.$EscortDeckToWS); // Towbar
    var oldSV = (that.oldSV = that.oldSV || (wSV &amp;&amp; wSV.version &amp;&amp; wSV.version &gt; &quot;1.24&quot; ? false : true));

    if (!owner || !owner.isValid) { //test with PS.explode() in debug console
            var v = w.$EscortDeckV;
            if (!v || !v.position) return; //exit if player died
            if (!w.$EDH) w.$EDH = v.heading.multiply(-4).add(Vector3D.randomDirection());
            v.position = v.position.add(w.$EDH.multiply(100*delta)); //deck drift away
            v.orientation = v.orientation.rotateX(delta).rotateY(delta).rotateZ(delta/2);
            //log(w.name, w.$EscortDeckV.position.x);
            return;
        }
    var zv = w.$EscortDeckZV;

    var eship = w.$EscortDeckShip;
    var epos = w.$EscortDeckShipPos;
    if (owner != player.ship &amp;&amp; owner.script &amp;&amp; owner.script.$EscortDeckZV) { //NPC
        zv = owner.script.$EscortDeckZV;
        eship = owner.script.$EscortDeckShip;
        epos = owner.script.$EscortDeckShipPos;
    } else if (w.$EscortDeckCWS &amp;&amp; w.$EscortDeckCWS.$CarriersPlayerInEscort) {
        owner = w.$EscortDeckCWS.$CarriersCarrier; //deck is no more on player ship but on Carrier
        if (!owner || !owner.isValid) return; //exit if carrier died
    }
    if (!zv) {
        if (!zv) zv = Vector3D(0,0,-50);
        zv.x = 0;
        var hl = owner.boundingBox.z * 0.5; //half of the ship&#39;s length
        if (zv.z &lt; hl) zv.z = -hl; //correct z position for carriers
        if (zv.y &gt; 0) zv.y = 0; //do not raise over the center line
        w.$EscortDeckZV = zv;
    }

    var d = w.$EscortDeckShipData;
    var sh = w.$EscortDeckSpawnedShips.pop();
    if ( sh &amp;&amp; sh.isValid &amp;&amp; oldSV) { 
        // restore ship data after ShipVersion&#39;s shipSpawned has its way with the ship
        // ShipVersion 1.25+ looks for ship.script.$ShipVersionIgnore, which we set, and ignores the ship
        var pad = eship.indexOf(sh);
        if (w.$debug) log(w.name, &quot;FCB pad:&quot;+pad+&quot; d:&quot;+d[pad]);
        if (pad &gt; -1 &amp;&amp; d[pad]) {
            var seen = [];
            w.$EscortDeck_RestoreShipData(sh, d[pad], w, owner);
            log(w.name, &quot;restored ship: &quot;+JSON.stringify(sh, function(key,val) {
                                        if (val != null &amp;&amp; typeof val == &quot;object&quot;) {
                                            if (seen.indexOf(val) &gt;= 0) {return;}
                                            seen.push(val);
                                        }
                                        return val;
                                    }));
        }   
    }
//    if(w.$debug) log(w.name, &quot;FCB pad:1 d:&quot;+d[1]);

    //set the new position of the deck if exist (carriers haven&#39;t added deck)
    var dp = owner.position.add(owner.heading.multiply(zv.z)); //deck position, used at escorts also
    if (zv.y != 0) dp = dp.add(owner.orientation.vectorUp().multiply(zv.y)); //move lower if needed
    if (w.$EscortDeckV) { //set the new position of the deck if exist (carriers haven&#39;t added deck)
        w.$EscortDeckV.position = dp;
        w.$EscortDeckV.orientation = owner.orientation;
    }
    
    //set the new positions of escorts
    for (var pad = 0; pad &lt; w.$EscortDeckPadPos.length; pad++) {
        var s = eship[pad];
        if (s) {
            if(s.isValid) {
                var sp = epos[pad]; //on deck and is not a Carrier?
                if (sp &amp;&amp; s.dataKey.indexOf(&quot;carrier&quot;) === -1) {
                    var h = owner.heading;
                    var o = owner.orientation;
                    var r = o.vectorRight();
                    var u = o.vectorUp();
                    var pos = dp.add(h.multiply(sp.z)).add(r.multiply(sp.x)).add(u.multiply(sp.y));
                    if (pos.magnitude() &gt; 500) s.position = pos;

                    if (w.$EscortDeckCWS
                        &amp;&amp; owner.dataKey.indexOf(&quot;carrier&quot;) &gt; -1) {
                        w.$EscortDeck_FCBC(s, owner, pad, o, h, r, u, w);
                    } else if (w.$EscortDeckXL) {
                        var left = -0.5; //left side of the xl deck
                        if (Math.round(pad/2) != pad/2) left = 0.5; //right
                        var p = -Math.PI;
                        s.orientation=o.rotate(r,p*0.5001).rotate(h,left*p);
                    } else s.orientation = o.rotate(r, 0.0001);
                    //if(pad==6 || pad==7) reverse ori
                }
            } else { //escort ship destroyed
                if (w.$EscortDeckShip) {
                    if (owner != player.ship &amp;&amp; (!w.$EscortDeckCWS
                        || owner != w.$EscortDeckCWS.$CarriersCarrier))
                        owner.script.$EscortDeckShip[pad] = null; //NPC escort
                    else w.$EscortDeckShip[pad] = null; //player escort
                }
            }
        }
    }
    
    w.$EscortDeckFCBDelta += delta;
    if (w.$EscortDeckFCBDelta &gt; 0.5) { //update AI and MFD twice in a second
        w.$EscortDeckFCBDelta = 0;
        //check nearby usable derelict for pickup
        var t = owner.target;
//        log(w.name, &quot;target:&quot;+t); //debug
        if (t &amp;&amp; w.$EscortDeckLastTooLargeTarget != t //prevent repeated too large message
            &amp;&amp; eship.indexOf(t) === -1 //and must not already owned
            &amp;&amp; !(tb &amp;&amp; tb.$TowbarShip &amp;&amp; t == tb.$TowbarShip) ) //and not being towed
            w.$EscortDeck_AddEscort(t, eship, owner, w, true);
        
        //AI helper part, keep in sync with the UPDATE parts of EscortDeck_AI.plist
        for (var pad = 0; pad &lt; w.$EscortDeckPadPos.length; pad++) {
            var s = eship[pad];
            if (s &amp;&amp; s.isValid &amp;&amp; s.AI === &quot;EscortDeck_AI.plist&quot;) { //skip waipoint AIs
                var e = s.script;
                if (s.AIState === &quot;FOLLOW&quot;) e._locatePlayer2(s);
                else if (s.AIState === &quot;GOTO&quot;) e._findPlayerHostiles2(s);
                else if (s.AIState === &quot;ATTACK&quot; || s.AIState == &quot;INJECT&quot;
                    || s.AIState === &quot;SNIPER&quot;) e._combatCheck2(s);
                else if (s.AIState === &quot;FLEE&quot;) e._fleeCheck2(s);
                else if (s.AIState === &quot;LANDING&quot;) e._landing2(s);
            }
        }
        w.$EscortDeck_MFD(w); //update MFD
    }
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_FCBC = function _escortdeck_FCBC(s, owner, pad, o, h, r, u, w) { //FrameCallBack rotate ships on Carriers
    var left = -0.5001; //left side of the xl deck
    if( Math.round(pad/2) != pad/2 ) left = 0.5001; //right side
    var p = -Math.PI;
    if( w.$EscortDeck_isMiniPad(pad, owner, w) ) {
        if( w.$EscortDeckXL ) left = -left;
        s.orientation = o.rotate( h, left*p ).rotate( u, left*p*0.6 ).rotate( r, 0.0001 );
    } else if( w.$EscortDeckXL &amp;&amp; pad &gt; 3 )
        s.orientation = o.rotate( u, left*p ).rotate( r, 0.0001 );
    else s.orientation = o.rotate( r, 0.0001 ); //fix blinking shaders bug
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_HHGet = function _escortdeck_HHGet(k, pad, w) { //get a ship from Hyperspace Hangar into the given pad
    var that = _escortdeck_HHGet;
    var w = (that.w = that.w || worldScripts.escortdeck);
    var hh = (that.hh = that.hh || worldScripts.HyperspaceHangar);
    var d = w.$EscortDeckShipData[pad];
    if( !d || !d[1] ) {
       log(this.name, &quot;Parsing ship &quot;+k+&quot; &quot;+hh._shipsStored[k]);
        w.$EscortDeckShipData[pad] = JSON.parse(hh._shipsStored[k]);
        delete hh._shipsStored[k];
        delete hh._currentNames[k];
        if( Object.keys(hh._currentNames).length &lt; 1 ) //this was the last ship
            hh._currentNames[&quot;1_EXIT&quot;] = &quot;EMPTY&quot;;
    }
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_Interface = function _escortdeck_Interface() {
    var ps = player.ship; if( !ps || !ps.isValid || !ps.docked ) return;

    var n = 0, m = 0, h = this.$EscortDeckShipData, p = this.$EscortDeckPadPos;
    if( h ) n = h.length;
    if( p ) m = p.length;
    var s = &quot;&quot;;
    if( n &gt; 0 ) {
        n = 0;
        for(var i = 0; i &lt; m; i++) {
            s += &quot;                                                  Deck &quot;+(i+1)+&quot;: &quot;;
            var d = h[i];
            if( d &amp;&amp; d[0] ) {
                n++;
                if( d[0][3] ) s += d[0][3]+&quot;\n&quot;; //displayName
                else {
                    if(d[0] &amp;&amp; d[0][7]) { //shipClassName
                        s += d[0][7];
                        if(d[0][8]) s += d[0][8]; //shipUniqueName
                        s += &quot;\n&quot;;
                    } else if(d[1]) s += d[1]+&quot;\n&quot;; //dataKey at last resort
                }
            } else s += &quot;empty\n&quot;
        }
        n = &quot; (&quot;+n+&quot; of &quot;+m+&quot; ships)&quot;;
        //s = s.substr( 0, s.length - 2 ); //cut last comma
    } else {
        n = &quot;&quot;;
        s = &quot;You have no ships on Escort Deck.&quot;;
    }
    if( ps.equipmentStatus(&quot;EQ_ESCORTDECKXL&quot;) == &quot;EQUIPMENT_OK&quot; ) n = &quot; XL&quot;+n;

    ps.dockedStation.setInterface(this.name,{
        title:&quot;Escort Deck&quot;+n,
        category:&quot;Ship Systems&quot;,
        summary:s,
        callback:this.$EscortDeck_InterfaceCallBack.bind(this)
    });
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_InterfaceCallBack = function _escortdeck_InterfaceCallBack(lastchoice) {
    var that = _escortdeck_InterfaceCallBack;
    var w = (that.w = that.w || worldScripts.escortdeck);
    var hh = (that.hh = that.hh || worldScripts.HyperspaceHangar);
    var ps = player.ship; if( !ps || !ps.isValid ) return;
    player.ship.hudHidden = true;//to shift down the menu
    var d = w.$EscortDeckShipData;
    var dkm = null;
    if( !w.$EscortDeckI ) w.$EscortDeckSpinModel = false; //rotate only in the subpage
    var curChoices = {};
    var exitscr = &quot;GUI_SCREEN_INTERFACES&quot;;
    var ex = &quot;99_EXIT&quot;;
    var ic = ex;
    if( lastchoice === &quot;51_SPIN&quot; ) ic = lastchoice;
    var mp = 0;
    var msg = &quot;&quot;;
    var oc = &quot;orangeColor&quot;;
    var j = 0;
    var getHH = false;
    var len = w.$EscortDeckPadPos.length;
    if( w.$EscortDeckSelectedPad &lt; 0 ) w.$EscortDeckSelectedPad = 0;
    if( ps.equipmentStatus(&quot;EQ_ESCORTDECK&quot;) !== &quot;EQUIPMENT_OK&quot;
        &amp;&amp; ps.equipmentStatus(&quot;EQ_ESCORTDECKXL&quot;) !== &quot;EQUIPMENT_OK&quot; ) {
        msg = &quot;You have no Escort Deck&quot;;
        if( ps.mass &gt; w.$EscortDeckMinMass ) msg += &quot;, buy it in the Equipment shop.&quot;;
        else msg += &quot;, moreover your ship is too small to hold it.&quot;
        exitscr = &quot;GUI_SCREEN_EQUIP_SHIP&quot;;
    } else {
        var pad = w.$EscortDeckSelectedPad;
        if( w.$EscortDeckI ) { //show submenu when an escort ship is selected
            if( d[pad] &amp;&amp; d[pad][1] ) {
//                curChoices[&quot;31_EQUIP&quot;] = {text:&quot;Equip&quot;, color:oc };

                curChoices[&quot;41_RENAME&quot;] = {text:&quot;Rename&quot;, color:oc };
            
                if( w.$EscortDeckSpinModel )
                    curChoices[&quot;51_SPIN&quot;] = {text:&quot;Stop rotation&quot;, color:oc };
                else curChoices[&quot;51_SPIN&quot;] = {text:&quot;Rotate&quot;, color:oc };

                if (d[pad][9] &lt; 7) {
                    curChoices[&quot;61_REFUEL&quot;] = {text:&quot;Refuel&quot;, color:oc };
                }

                if (hh) {
                    curChoices[&quot;71_HH&quot;] = {text:&quot;Put into Hyperspace Hangar&quot;, color:oc };
                } else curChoices[&quot;72_NHH&quot;] = {text:&quot;No Hyperspace Hangar installed&quot;,
                    unselectable:true };
                let salvage_price = w.$EscortDeck_SalvagePadPrice(pad);
                curChoices[&quot;81_SALVAGE&quot;] = {text:&quot;Salvage&quot;+(salvage_price ? &quot; and get about &quot;
                    +Math.round(salvage_price/1000)*1000+&quot; credits&quot; : &quot;&quot;),
                    color:&quot;redColor&quot; };
            } else if (hh) {
                var fitinto=false;
                var sID = system.ID;
                for( var k in hh._shipsStored ) {
                    var sh = JSON.parse(hh._shipsStored[k]); //ship in hangar
                    if (sh[0][1] === sID) {
                        if( sh &amp;&amp; !w.$EscortDeck_TooLarge2b(ps, w, pad, sh)) {
                            fitinto=true;
                            var n = sh[0];
                            if( n ) n = n[3]; else n = sh[1]; //show dataKey if no name
/*                            if( sh[14] ) {
                                n += &quot; (&quot;+Math.floor(sh[14].mass/1000)+&quot;t, &quot;
                                    +Math.round(sh[14].x)+&quot;x&quot;
                                    +Math.round(sh[14].y)+&quot;x&quot;
                                    +Math.round(sh[14].z)+&quot;m)&quot;;
                            }*/
                            curChoices[&quot;22_&quot;+k] = &quot;Get &quot;+n+&quot; from Hyperspace Hangar into Deck &quot;+(pad+1);
                        }
                    } else { log(this.name, &quot;HyperSpaceHangar ship &quot;+sh[0][3]+&quot; is in system &quot;+sh[0][4]); }
                }
                if( !fitinto ) {
                    curChoices[&quot;21_PHH&quot;] = {
                        text:&quot;No ship in Hyperspace Hangar which fit into Deck &quot;
                            +(pad+1),
                        unselectable:true };
                } else {
                    getHH = true;
                }
            } else curChoices[&quot;20_NHH&quot;] = { text:&quot;No Hyperspace Hangar installed&quot;, unselectable:true };
//            curChoices[&quot;71_EMPTY_LINE&quot;] = {text:&quot;&quot;};
            
        } else { //in the first screen show the list of pads with escort names
            for( pad = 0; pad &lt; len &amp;&amp; j++ &lt; 20; pad++ ) {
                var co = &quot;orangeColor&quot;;
                var s = d[pad];
                var tx = &quot;Deck &quot;+(pad+1)+&quot; &quot;;
                var x = 0, y = 0, z = 0, maxmass = 0;
                var si = w.$EscortDeckPadSize;
                if( si &amp;&amp; si[0] ) {
                    var e = null;
                    var len = si.length-1;
                    if( pad &lt; 0 || pad &gt; len ) e = si[len]; //the last line contain the maximums
                    else e = si[pad];
                    if( e &amp;&amp; e[0] ) {
                        x = e[0];
                        y = e[1];
                        z = e[2];
                        maxmass = e[3];
                    }
                }
                tx += &quot;(&quot;+Math.floor(maxmass/1000)+&quot;t, &quot;+x+&quot;x&quot;+y+&quot;x&quot;+z+&quot;m): &quot;;
                if( s &amp;&amp; s[0] &amp;&amp; s[0][3] ) {
                    tx += s[0][3].substring(0,38);// + &quot; Fuel: &quot;+Math.round(s[9]*10)/10+&quot;ly&quot;;
//                    msg += w.$EscortDeck_MFDAlign(tx, s.AIState)+&quot;\n&quot;;
                } else {
                    tx += &quot;Empty&quot;;
                    co = &quot;grayColor&quot;;
                }
                tx += &quot;\n&quot;;
                var cc = &quot;01_&quot; + ( pad &lt; 10 ? &quot;0&quot; : &quot;&quot; ) + pad;
                curChoices[cc] = {text:tx, color:co, alignment:&quot;LEFT&quot;};
                if( pad == w.$EscortDeckSelectedPad ) {
                    ic = cc; //initialChoicesKey
                }
            }
            pad = w.$EscortDeckSelectedPad;
        }
        msg = &quot;Deck &quot;+(pad+1)+&quot;: &quot;;
        if( d[pad] &amp;&amp; d[pad][1] ) {
            dkm = &quot;[&quot;+d[pad][1]+&quot;]&quot;;//dataKey
            mp = d[pad][13];//personality
            msg += w.$EscortDeck_InterfaceShipData(d[pad],
                w.$EscortDeckSpinModel ); //no eqs when spinning
        } else msg += &quot;Empty&quot;;
    }

    if(w.$EscortDeckI) curChoices[ex] = {text:&quot;Back&quot;, color:oc};
    else curChoices[ex] = {text:&quot;Exit&quot;, color:oc, alignment:&quot;LEFT&quot;};
    
    var xl = &quot;&quot;;
    if( ps.equipmentStatus(&quot;EQ_ESCORTDECKXL&quot;) == &quot;EQUIPMENT_OK&quot; ) xl = &quot; XL&quot;;
    var opts = {
        screenID: &quot;escortdeck&quot;,
        title: &quot;Escort Deck&quot;+xl,
        background: {name:&quot;escortdeck_bg.png&quot;, height:512},//532//546
        allowInterrupt: false,
        exitScreen: exitscr,
        choices: curChoices,
        initialChoicesKey: ic,
        message: msg,
        model: dkm,
        modelPersonality: mp,
        spinModel: w.$EscortDeckSpinModel
    };
    if (getHH) {
        worldScripts[&quot;Paginated Screen&quot;].$runScreen(opts, w.$EscortDeck_InterfaceChoice, w, true);
    } else {
        mission.runScreen(opts, w.$EscortDeck_InterfaceChoice, w);
    }
    
    // if Gallery or Towbar has been loaded and used, remove the frame callback
    var g = w.$EscortDeckGWS;
    if (g &amp;&amp; isValidFrameCallback(g.$GalleryFCB)) removeFrameCallback(g.$GalleryFCB);
    var r = w.$EscortDeckToWS;
    if( r &amp;&amp; isValidFrameCallback( r.$TowbarFCB2 ) ) removeFrameCallback( r.$TowbarFCB2 );
    
    var m = mission.displayModel;
    if( m &amp;&amp; !w.$EscortDeckSpinModel ) {
        m.orientation = m.orientation.rotateZ(-Math.PI/2).rotateX(-Math.PI/4).rotateY(Math.PI/8);
        m.position = Vector3D(m.position.x, m.position.y, 150);
    }
}


//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_InterfaceChoice = function _escortdeck_InterfaceChoice(choice) {
    var that = _escortdeck_InterfaceChoice;
    var w = (that.w = that.w || worldScripts.escortdeck);
//    log(this.name, choice+&quot; &quot;+choice.indexOf(&quot;01_&quot;)+&quot; &quot;+choice.substr(3));
    if (choice === &quot;99_EXIT&quot;) {
        if( !w.$EscortDeckI ) { //selected on the first page
            w.$EscortDeckSelectedPad = -1; //clear pad selection
            player.ship.hudHidden = false;
            return;
        } else w.$EscortDeckI = false; //back to the first page
    }
    if (choice.indexOf(&quot;01_&quot;) === 0) {
        w.$EscortDeckSelectedPad = 1*choice.substr(3);
        w.$EscortDeckI = true; //go to the subpage
    } else if (choice.indexOf(&quot;22_&quot;) === 0) {  //get ship from HyperHangar
        var k = choice.substr(3);
        w.$EscortDeck_HHGet(k, w.$EscortDeckSelectedPad, w);
        w.$EscortDeckI = false; //back to the first page
    } else if (choice === &quot;41_RENAME&quot;) {
        var pad = w.$EscortDeckSelectedPad;
        var d = w.$EscortDeckShipData[pad];
        if (d &amp;&amp; d[1] ) {
            var msg = &quot;Deck &quot;+(pad+1)+&quot;: &quot;;
            var dkm = &quot;[&quot;+d[1]+&quot;]&quot;;//dataKey
            var mp = d[13];//personality
            msg += w.$EscortDeck_InterfaceShipData(d, true)+
                &quot;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nType the new name of &quot;
                +d[0][3]+&quot;:&quot;;
            mission.runScreen({
                screenID: &quot;escortdeck&quot;,
                title: &quot;Escort Deck&quot;,
                background: {name:&quot;escortdeck_bg.png&quot;, height:512},
                allowInterrupt: false,
                message: msg,
                model: dkm,
                modelPersonality: mp,
                spinModel: w.$EscortDeckSpinModel,
                textEntry: true
            },function(text) {
                if (text &amp;&amp; text.length &gt; 0) {
                    if( d &amp;&amp; d[0] ) {
                        w.$EscortDeckShipData[pad][0][8]=text;//shipUniqueName
                        var t = &quot;&quot;;
                        if( d[0][7] ) t = d[0][7]+&quot;: &quot;;
                        w.$EscortDeckShipData[pad][0][3] = t + text;
                    }
                }
                w.$EscortDeckI = false; //back to the first page
                w.$EscortDeck_InterfaceCallBack(choice); //display the menu again
            });
        }
        return;
    } else if (choice === &quot;51_SPIN&quot;) {
        if( w.$EscortDeckSpinModel ) w.$EscortDeckSpinModel = false;
        else w.$EscortDeckSpinModel = true;
    } else if (choice === &quot;61_REFUEL&quot;) {
        this.$EscortDeck_RefuelEscort(w.$EscortDeckShipData[w.$EscortDeckSelectedPad]);
    } else if (choice === &quot;71_HH&quot;) { //put ship into HyperHangar
        w.$EscortDeck_HHStoreShipData(w.$EscortDeckShipData[w.$EscortDeckSelectedPad]);
        player.consoleMessage(w.$EscortDeckShipData[w.$EscortDeckSelectedPad][0][3]+&quot; from deck &quot;+(w.$EscortDeckSelectedPad+1)+&quot; stored into Hyperspace Hangar&quot;, 10);
        w.$EscortDeckShipData[w.$EscortDeckSelectedPad] = [];
        w.$EscortDeckI = false; //back to the first page
    } else if (choice === &quot;81_SALVAGE&quot;) {
        //are you sure?
        w.$EscortDeck_Salvage(w.$EscortDeckSelectedPad, player.ship);
        w.$EscortDeckI = false; //back to the first page
    }
    w.$EscortDeck_InterfaceCallBack(choice); //display the menu again
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_InterfaceShipData = function _escortdeck_InterfaceShipData(d, noeq, all) {
    if (!d || !d[1]) return(&quot;No data&quot;);
    var psd = d[0][3]+&quot;\n&quot;;//ship.displayName+
    var equip=&quot;&quot;;
    var s=&quot;&quot;;
    s=d[3]; if(s) s=EquipmentInfo.infoForKey(s);//ship.forwardWeapon;
    if (s!=null &amp;&amp; s.equipmentKey !== &quot;EQ_WEAPON_NONE&quot;) equip+=&quot;Forward &quot;+s.name;
    s=d[2]; if(s) s=EquipmentInfo.infoForKey(s)//ship.aftWeapon;
    if (s!=null &amp;&amp; s.equipmentKey !== &quot;EQ_WEAPON_NONE&quot;) {
        if (equip.length &gt; 0) equip+=&quot;, &quot;; //Anaconda has aft weapon only
        equip+=&quot;Aft &quot;+s.name;
    }
    s=d[4]; if(s) s=EquipmentInfo.infoForKey(s)//ship.portWeapon;
    if (s!=null &amp;&amp; s.equipmentKey !== &quot;EQ_WEAPON_NONE&quot;) equip+=&quot;, Port &quot;+s.name;
    s=d[5]; if(s) s=EquipmentInfo.infoForKey(s)//ship.starboardWeapon;
    if (s!=null &amp;&amp; s.equipmentKey !== &quot;EQ_WEAPON_NONE&quot;) equip+=&quot;, Starboard &quot;+s.name;

    if (equip.length &gt; 0) equip+=&quot;&quot;; //no newline, save space
    else equip+=&quot;No Laser&quot;;
    var eqs = &quot;&quot;;
    var savedEQ = d[7], counter;
    if (!noeq &amp;&amp; savedEQ) for (counter = 0; counter &lt; savedEQ.length; counter++) {
        if (savedEQ[counter][1] !== &quot;EQUIPMENT_DAMAGED&quot; &amp;&amp; savedEQ[counter][0].indexOf(&quot;EQ_NUMERIC3_&quot;) === -1 &amp;&amp; savedEQ[counter][0].indexOf(&quot;EQ_ADDHUD_&quot;) === -1 &amp;&amp; savedEQ[counter][0].indexOf(&quot;EQ_XENONHUD_&quot;) === -1) {
            s = EquipmentInfo.infoForKey(savedEQ[counter][0]);
            if (s) {
                var n = s.name;
                if (n.length &gt; 0) eqs += n + &quot;, &quot;;
            }
        }
    }
    eqs = eqs.substr(0, eqs.length - 2); //cut last comma
    if (eqs.length &gt; 0) equip+=&quot;, &quot;+eqs+&quot;\n&quot;;
    eqs = &quot;&quot;;
    if (!noeq &amp;&amp; savedEQ) for (counter = 0; counter &lt; savedEQ.length; counter++) {
        if (savedEQ[counter][1] === &quot;EQUIPMENT_DAMAGED&quot; &amp;&amp; savedEQ[counter][0].indexOf(&quot;EQ_NUMERIC3_&quot;) === -1 &amp;&amp; savedEQ[counter][0].indexOf(&quot;EQ_ADDHUD_&quot;) === -1 &amp;&amp; savedEQ[counter][0].indexOf(&quot;EQ_XENONHUD_&quot;) === -1) {
            s = EquipmentInfo.infoForKey(savedEQ[counter][0]);
            if (s) {
                var n = s.name;
                if (n.length &gt; 0) eqs += n + &quot;, &quot;;
            }
        }
    }
    eqs = eqs.substr( 0, eqs.length - 2 ); //cut last comma
    if (eqs.length &gt; 0) equip+=&quot;\nDamaged: &quot;+eqs+&quot;\n&quot;;

    var desc = &quot;&quot;;
    var speed = d[0][19];
    psd += &quot;Fuel: &quot;+Math.round(d[9]*10)/10+&quot; ly  &quot;;
    if (speed &gt; 0) psd += &quot;Speed: &quot;+speed+&quot; mLS  &quot;;
    if (d[0][17] &gt; 0) psd += &quot;Thrust: &quot;+d[0][17]+&quot;  &quot;;
    if (d[0][15] &gt; 0) psd += &quot;Pitch: &quot;+Math.round(d[0][15]*100)/100+&quot;  &quot;;
    if (d[0][16] &gt; 0) psd += &quot;Roll: &quot;+Math.round(d[0][16]*100)/100+&quot;  &quot;;
    if (d[0][14] &gt; 0) psd += &quot;Yaw: &quot;+Math.round(d[0][14]*100)/100+&quot;  &quot;;
    var en = &quot;&quot;;
    var r = &quot;&quot;;
    if (all &amp;&amp; d[0][20] &gt; 0) en = &quot;Energy+Shields: &quot;+d[0][20]+&quot;  &quot;;
    else {
        if (d[0][20] &gt; 0) {
            var eb = Math.max(1, Math.floor(d[0][20]/64));
            en = &quot;Energy+Shields&quot;;
            en += &quot;: &quot;+eb+&quot;  &quot;;
        }
    }

    var er = d[0][21];
    if (er &gt; 0) {
        var ers = &quot;&quot;;
        if (er &lt; 2.5) ers = &quot;Poor&quot;;
        else if (er &lt; 3.5) ers = &quot;Medium&quot;;
        else if (er &lt; 4.5) ers = &quot;Good&quot;;
        else if (er &lt; 10) ers = &quot;Excellent&quot;;
        else ers = &quot;Extreme&quot;;
        if (all) ers += &quot; (&quot;+er+&quot;)&quot;;
        r = &quot;Recharge: &quot;+ers+&quot;  &quot;;
    }
    if (d[0][6] &gt; 0) {
        var v = Math.round(d[0][6]/1333)*1000; //trade-in value is 75% of ship price
        psd += &quot;Value: &quot;+formatCredits(v, false, true)+&quot;  &quot;;
    }
    psd += &quot;\n&quot;+en+r;
//{usable:u, mass:ship.mass, x:b.x, y:b.y, z:b.z});//storedShipArray[14]
    if (d[14]) psd += &quot;Mass: &quot;+Math.max(Math.round(d[14].mass/100)/10, 1)+ //min.1t
        &quot;t  Size: &quot;+Math.round(d[14].x)+&quot;*&quot;+
        Math.round(d[14].y)+&quot;*&quot;+Math.round(d[14].z)+&quot;m  &quot;;
//        &quot;m Radius: &quot;+Math.round(ship.collisionRadius)+&quot;m&quot;+//&quot; Sphere: &quot;+sp+&quot;m^2&quot;+
    psd += &quot;\n&quot;+equip;
    psd = desc + psd;
    return(psd);
}


//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_isFreePadFor = function _escortdeck_isFreePadFor(eqKey, owner, context, w, mini) { 
    //called from escortship equipment conditions
    //should check TooLarge but no ship nor mass,etc. data available
    //due to shouldn&#39;t spawn ships in equipment conditions
    //so must provide in the prefilled $EscortDeckEqs array for TooLarge3
    
    var len = w.$EscortDeckPadPos.length;
    for(var i = 0; i &lt; len; i++ ) {
        if( !w.$EscortDeckShipData[i] &amp;&amp; //find the first empty pad where fit
            ( !w.$EscortDeck_isMiniPad(i, owner, w) || mini ) ) {
            if( !w.$EscortDeckEqs || !w.$EscortDeckEqs[eqKey] ||
                !w.$EscortDeck_TooLarge3( owner, w,
                    w.$EscortDeckEqs[eqKey][3],
                    w.$EscortDeckEqs[eqKey][0],
                    w.$EscortDeckEqs[eqKey][1],
                    w.$EscortDeckEqs[eqKey][2], i ) )
                return true;
        }
    }
    return false;
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_isLarge = function _escortdeck_isLarge(ship, w) { //check if the ship is over the large border
    var m = ship.mass; //revert HardShips&#39; double mass caused by density=2
    if( ship.scriptInfo &amp;&amp; ship.scriptInfo.hardarmour &gt; 1 ) m = m / 2;
    if( m &gt;= w.$EscortDeckLargeMass ) return true;
    return false;
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_isMini = function _escortdeck_isMini(ship) { //check if the ship is like an Adder or smaller
    if( !ship || !ship.isValid ) return false;
    var b = ship.boundingBox;
    if( !b || ship.mass &gt; this.$EscortDeckPad.mini[3]
        || b.x &gt; this.$EscortDeckPad.mini[0]
        || b.y &gt; this.$EscortDeckPad.mini[1]
        || b.z &gt; this.$EscortDeckPad.mini[2] ) return false;
    return true;
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_isMiniPad = function _escortdeck_isMiniPad(pad, owner, w) { //check if this pad is for mini ships only
    if( w.$EscortDeckCWS &amp;&amp; owner.dataKey.indexOf(&quot;carrier&quot;) &gt; -1 ) {
        if( w.$EscortDeckXL ) {
            if( pad != 8 &amp;&amp; pad != 9 ) return false;
        } else if( pad != 7 &amp;&amp; pad != 8 ) return false;
    } else if( w.$EscortDeckXL || pad != 4 &amp;&amp; pad != 5 ) return false;
    return true;
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_isPadFree = function _escortdeck_isPadFree(pad, owner, w) { //is this pad free for this ship?
    var s = null; //or the assigned ship is not valid or not in scanner range
    if( w &amp;&amp; w.$EscortDeckShip ) s = w.$EscortDeckShip[pad];
    if( w &amp;&amp; pad &lt; w.$EscortDeckPadPos.length &amp;&amp; ( !s || !s.isValid 
//        || owner &amp;&amp; owner.isValid &amp;&amp; owner.position.distanceTo(s.position) &gt; owner.scannerRange 
        || pad == w.$EscortDeckSelectedPad ) ) { //pad is selected to replace ship?
        return(true);
    }
    return(false);
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_MakeShipData = function _escortdeck_MakeShipData(ship) {
    var that = _escortdeck_MakeShipData;
    var ssh = (that.ssh = that.ssh ||  worldScripts[&quot;Ship_Storage_Helper.js&quot;]);

    if (!ship || !ship.isValid) return null;
    var storedShipArray = [];
    var entry_time = Date.now();
    if (ssh &amp;&amp; ssh.storeCurrentShipToArray) {
        storedShipArray = ssh.storeCurrentShipToArray(ship);
    } else {
        var stationAttributes;
        if (ship.dockedStation) {
            stationAttributes = [ship.dockedStation.primaryRole,ship.dockedStation.dataKey, ship.dockedStation.position];
        } else {
            stationAttributes = [null,null,null];
        }
        storedShipArray.push([galaxyNumber, system.ID, clock.seconds, ship.displayName,
                system.name, stationAttributes, ship.price,
                ship.shipClassName, ship.shipUniqueName, ship.AIScriptWakeTime, ship.beaconLabel,
                ship.destinationSystem, ship.exhaustEmissiveColor, ship.homeSystem,
                ship.maxYaw, ship.maxPitch, ship.maxRoll, ship.maxThrust, ship.thrust,
                ship.maxSpeed, ship.maxEnergy, ship.energyRechargeRate, ship.cargoSpaceCapacity,
                ship.injectorBurnRate, ship.injectorSpeedFactor,
                ship.scanDescription, ship.hyperspaceSpinTime,
                ship.scannerHostileDisplayColor1, ship.scannerHostileDisplayColor2,
                ship.forwardShield, ship.maxForwardShield, ship.forwardShieldRechargeRate,
                ship.aftShield, ship.maxAftShield, ship.aftShieldRechargeRate,
                ship.passengerCapacity]); //storedShipArray[0]
        storedShipArray.push(ship.dataKey); // storedShipArray[1]
        if (!ship.aftWeapon) { // storedShipArray[2]
            storedShipArray.push(ship.aftWeapon);
        } else {
            storedShipArray.push(ship.aftWeapon.equipmentKey);
        } 
        if (!ship.forwardWeapon) { // storedShipArray[3]
            storedShipArray.push(ship.forwardWeapon);
        } else {
            storedShipArray.push(ship.forwardWeapon.equipmentKey);
        } 
        if (!ship.portWeapon) { // storedShipArray[4]
            storedShipArray.push(ship.portWeapon);
        } else {
            storedShipArray.push(ship.portWeapon.equipmentKey);
        }
        if (!ship.starboardWeapon) { // storedShipArray[5]
            storedShipArray.push(ship.starboardWeapon);
        } else {
            storedShipArray.push(ship.starboardWeapon.equipmentKey);
        }
        var missiles = [];
        if( ship.missileCapacity &gt; 0 ) { //bugfix of &quot;Tried to init array with nil object&quot; in Oolite 1.81
            missiles = ship.missiles;
            var counter;
            for(counter = 0;counter&lt;missiles.length;counter++)
                missiles.splice(counter,1,missiles[counter].equipmentKey);
        }
        storedShipArray.push(missiles); // storedShipArray[6]
        var equipment = ship.equipment;
        var tempArray;
        for(counter = 0;counter&lt;equipment.length;counter++) {
            tempArray = [equipment[counter].equipmentKey, ship.equipmentStatus(equipment[counter])];
            equipment.splice(counter,1,tempArray);
        }
        storedShipArray.push(equipment); // storedShipArray[7]
        storedShipArray.push(ship.cargoList); // storedShipArray[8]
        storedShipArray.push(ship.fuel); //storedShipArray[9]
        storedShipArray.push(new Array); //passengers is player only, storedShipArray[10]
        var subEnts = new Array;
        if (ship.subEntityCapacity &gt; 0 &amp;&amp; ship.subEntityCapacity !== ship.subEntities.length) {
            // only store subEnts if at less than capacity
            for (counter = 0;counter &lt; ship.subEntities.length; counter++) {
                subEnts.push([ship.subEntities[counter].dataKey,
                        ship.subEntities[counter].position.x,
                        ship.subEntities[counter].position.y,
                        ship.subEntities[counter].position.z]);
            }
        }
        storedShipArray.push(subEnts);//storedShipArray[11]

        if( ship == player.ship ) {
            storedShipArray.push(ship.serviceLevel);//storedShipArray[12]
            ship.script.$SSH_serviceLevel = ship.serviceLevel; //save for Carriers OXP
        } else if( ship.script ) storedShipArray.push(ship.script.$SSH_serviceLevel);
    
        storedShipArray.push(ship.entityPersonality);//storedShipArray[13]
    
        var u = 0; //escortdeck specific data
        if( ship.script &amp;&amp; ship.script.$EscortDeckUsable &gt; 0 )
            u = ship.script.$EscortDeckUsable;
        var b = ship.boundingBox; //mass for TooLarge and ship price, sizes needed in playerboughtnewship
        storedShipArray.push({usable:u, mass:ship.mass, x:b.x, y:b.y, z:b.z});//storedShipArray[14]
    }
    if (this.$debug) log(this.name, &quot;Serializing ship &quot;+ship.displayName+&quot; took &quot;+(Date.now()-entry_time).toFixed(0)+&quot;ms&quot;);
    return(storedShipArray);
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_MassFactor = function _escortdeck_MassFactor(ship, w) { //compute thrust reduction due to extra mass in deck
    var m = 0; //total mass of ships on deck
    for(var i = 0; i &lt; w.$EscortDeckPadPos.length; i++ ) {
        var d = w.$EscortDeckShipData[i]; //inside stations must use the saved data array
        var s = w.$EscortDeckShip[i];
        if( ( d || s ) &amp;&amp; w.$EscortDeckShipPos[i] ) { //there is a ship in this deck
            if( d &amp;&amp; d[14] &amp;&amp; d[14].mass &gt; 0 ) m += d[14].mass;
            else if( s &amp;&amp; s.mass &gt; 0 ) m += s.mass;
            else m += 50000; //guess
        }
    }
    //in proportion with the original mass (max. 1)
    return( ship.mass / ( ship.mass + m / 3 ) );
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_MFD = function _escortdeck_MFD(w) { //update MFD
    var ps = player.ship; if (!ps || !ps.isValid) return;
    var d = w.$EscortDeckShipData;
    var mfd = &quot;&quot;;
    var j = 0;
    var len = w.$EscortDeckPadPos.length;
    if (w.$EscortDeckDockingTunnel) ; //show an empty MFD while the player travel in the tunnel
    else if (ps.equipmentStatus(&quot;EQ_ESCORTDECK&quot;) != &quot;EQUIPMENT_OK&quot;
        &amp;&amp; ps.equipmentStatus(&quot;EQ_ESCORTDECKXL&quot;) != &quot;EQUIPMENT_OK&quot;)
        mfd = &quot;No Escort Deck\n&quot;;
    else for ( var pad = 0; pad &lt; len &amp;&amp; j++ &lt; 10; pad++) {
        var s = w.$EscortDeckShip[pad];
        var state = &quot;&quot;;
        if (w.$EscortDeckLocked[pad]) state = &quot;LOCKED&quot;;
        var l = (pad+1)+&quot;: &quot;;
        if (pad == w.$EscortDeckSelectedPad) l += &quot;-&gt; &quot;; //mark selected pad
        if (s &amp;&amp; s.isValid) {
            if (state.length == 0) state = s.AIState; //only if not locked
            if (s.script &amp;&amp; s.script.$EscortDeckUsable &gt; 0) { //show for usables only
                //l += s.shipUniqueName.substring(0,18)+&quot; E&quot;+Math.round(s.energy/64);
                l += (s.shipUniqueName ? s.shipUniqueName.substring(0,18) : s.shipClassName.substr(0,18))+&quot; E&quot;+s.energy.toFixed(0);
                    //+&quot;/&quot;+Math.round(s.maxEnergy/64);
                    //first 18 char to fit into but show Sidewinder Special
                //l += &quot; E&quot;+Math.round(s.energy);
//                var r = &quot;&quot;;
//                var t = Math.round(s.maxEnergy/64); //total letters
//                for(var k = 0; k &lt; t; k++ )
//                    if( k &lt; Math.round(s.energy/64) ) r += &quot;E&quot;;
//                    else r += &quot;-&quot;; //empty bank
//                l += &quot; &quot;+r;
                //if( s.equipmentStatus(&quot;EQ_FUEL_INJECTION&quot;) == &quot;EQUIPMENT_OK&quot; )
                l += &quot; F&quot;+Math.ceil(s.fuel-0.01);
                if (s.forwardShield)
                    l += &quot; S&quot;+Math.ceil(s.forwardShield/64)+Math.ceil(s.aftShield/64);
                if (s.forwardShield &lt; 64 || s.aftShield &lt; 64 )
                    log(this.name, &quot;Escort &quot;+s.displayName+&quot; has low shields: &quot;+s.forwardShield.toFixed(0)+&quot;/&quot;+s.aftShield.toFixed(0));
                if (!w.$EscortDeckShipPos[pad]) //not in deck
                    l += &quot; &quot;+Math.floor(ps.position.distanceTo(s.position)/1000)+&quot;km &quot;+w.$EscortDeck_MFDFrom(s.position);
            } else l += s.displayName+&quot; (&quot;+Math.round(s.mass/1000)+&quot;t)&quot;;
            mfd += this.$EscortDeck_MFDAlign(l, state)+&quot;\n&quot;;
        } else {
            var x = 0, y = 0, z = 0, maxmass = 0;
            var s = w.$EscortDeckPadSize;
            if (s &amp;&amp; s[0]) {
                var e = null;
                var len = s.length-1;
                if (pad &lt; 0 || pad &gt; len) e = s[len]; //the last line contain the maximums
                else e = s[pad];
                if (e &amp;&amp; e[0]) {
                    x = e[0];
                    y = e[1];
                    z = e[2];
                    maxmass = e[3];
                }
            }
            l += &quot;(&quot;+Math.floor(maxmass/1000)+&quot;t, &quot;+x+&quot;x&quot;+y+&quot;x&quot;+z+&quot;m)&quot;;
            if (state.length &gt; 0) mfd += this.$EscortDeck_MFDAlign(l, state)+&quot;\n&quot;;
            else mfd += l+&quot;\n&quot;;
        }
    }

    var t = this.$EscortDeckToWS; //Towbar
    if (t &amp;&amp; j &lt; 10 &amp;&amp; !w.$EscortDeckDockingTunnel) {
        var l = &quot;T: &quot;;
        if (j == w.$EscortDeckSelectedPad) l += &quot;-&gt; &quot;; //mark selected pad
        var s = t.$TowbarShip;
        if (s) {
            l += s.displayName+&quot; (&quot;+Math.round(s.mass/1000)+&quot;t)&quot;;
            mfd += this.$EscortDeck_MFDAlign(l, (s.script &amp;&amp; s.script.$EscortDeckUsable &amp;&amp; s.script.$EscortDeckUsable &gt; 0 ? &quot;Usable&quot; : &quot;Salvage&quot;))+&quot;\n&quot;;
        } else mfd += l+&quot;(&quot;+Math.floor(ps.mass*1.6/1000)+&quot;t)\n&quot;; //max. mass on towbar
    }
        
    if (ps.setMultiFunctionText) ps.setMultiFunctionText(w.name, mfd, false);
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_MFDAlign = function _escortdeck_MFDAlign(left, right) { //insert as many spaces between as fill the line
    var width = 14.2;
    var space = &quot; &quot;;
    left += space;
    var t = left + right;
    while( defaultFont.measureString(t) &lt; width ) {
        left += space;
        t = left + right;
    }
    //fine tune with hair spaces - from spara&#39;s marketObserver
    var hairSpace = String.fromCharCode(31);
    while ( defaultFont.measureString(t + hairSpace) &lt; width ) {
        left += hairSpace;
        t = left + right;
    }
    return(t);
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_MFDFrom = function _escortdeck_MFDFrom(whomposition) { //direction mark
    var ship = player.ship;
    if( !ship || !ship.isValid || !whomposition || !whomposition.dot ) return (&quot;&quot;);
    var v = ship.position.subtract(whomposition);
    var fw = ship.vectorForward.angleTo(v);
    var ri = ship.vectorRight.angleTo(v);
    var up = ship.vectorUp.angleTo(v);
    var s = &quot;&quot;; // refine if out of front 1 degree cone
    if( ri &lt; 1.56 ) s += &quot;&lt;&quot;;
    if( up &gt; 1.58 ) s += &quot;^&quot;;
    else if( up &lt; 1.56 ) s += &quot;v&quot;;
    if( ri &gt; 1.58 ) s += &quot;&gt;&quot;;
//    if( s.length &gt; 0 || fw &lt; 1 ) //do not exclude the aft 1 degree cone
//        s = Math.round( 180 * ( 1 - fw / Math.PI ) ) + &quot; &quot; + s;
    return( s );
}


//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_PutShip = function _escortdeck_PutShip(deckinit, ship, pad, owner, msg, land, xch ) { //put ship into the pad
    var that = _escortdeck_PutShip;
    var w = (that.w = that.w || worldScripts.escortdeck);

    var r = w.$EscortDeck_TooLarge2(ship, owner, w, pad);
    if (r) return (r); //too large
    if (ship &amp;&amp; ship.isValid &amp;&amp; owner &amp;&amp; owner.isValid
        &amp;&amp; (land || w.$EscortDeck_isPadFree(pad, owner, w))) { //landing back or new ship
        if (!w.$EscortDeckShip) w.$EscortDeckShip = [];
        var old = w.$EscortDeckShip[pad];
        var sp = w.$EscortDeckShip.indexOf(ship); //ship pad if already owned
        if (old &amp;&amp; old.isValid &amp;&amp; !xch) { //prevent recursion during exchange with old ship
            if (sp &gt; -1 &amp;&amp; sp != pad) { //put an owned ship to other pad
                //exchange with the old ship if old fit into the another pad
                //if( w.$EscortDeck_PutShip(old, sp, owner, w, msg, true, true ) )
                w.$EscortDeck_Release(owner, pad, w, //relock old if fit
                              w.$EscortDeckLandingDist-100, msg);
                w.$EscortDeckSelectedPad = -1; //prevent lock to the new pad
                owner.target = old; //for relock
            } else if (ship != old)
                w.$EscortDeck_Release(owner, pad, w, false, msg); //replace old ship
        }
        if (sp &gt; -1) { //remove from the previous pad
            var d = [], s = [];
            for(var i = 0; i &lt; w.$EscortDeckPadPos.length; i++ ) {
                if (i == sp) {
                    s[i] = null;
                    d[i] = null;
                } else {
                    s[i] = w.$EscortDeckShip[i];
                    d[i] = w.$EscortDeckShipData[i];
                }
            }
            w.$EscortDeckShipData = d;
            w.$EscortDeckShip = s;
        }
        w.$EscortDeckShip[pad] = ship;
        if (!deckinit) {
            w.$EscortDeckShipData[pad] = w.$EscortDeck_MakeShipData(ship);
            if (w.$debug) log(w.name, (pad+1)+&quot;. &quot;+JSON.stringify(w.$EscortDeckShipData[pad]));
        }
        var usable = 0;
        if (ship.script &amp;&amp; ship.script.$EscortDeckUsable &gt; 0)
            usable = ship.script.$EscortDeckUsable;
        
        if (usable &gt; 0 &amp;&amp; ship.isDerelict) { //removing derelict flag need respawn
            var ship2 = w.$EscortDeck_SpawnShip(pad, w, owner);
            if (ship2 &amp;&amp; ship2.isValid) {
                ship.remove(true);
                w.$EscortDeckShip[pad] = ship = ship2;
            } //else fallback to the derelict ship
        }

        if (ship.AI != &quot;EscortDeck_AI.plist&quot;) ship.switchAI(&quot;EscortDeck_AI.plist&quot;);
//        var js = &quot;escortdeck_escort&quot;;
//        if( !ship.script || ship.script.name != js ) {
//            var sl = 0;  //must set usable and sl again after setScript
//            if( ship.script ) sl = ship.script.$SSH_serviceLevel;
//            ship.setScript(js+&quot;.js&quot;);
//            if( ship.script ) {
//                ship.script.$EscortDeckUsable = usable;
//                ship.script.$SSH_serviceLevel = sl;
//            }
//        }
        ship.script.$EscortDeckOnDeck = true;
        if (usable &gt; 0) {
            log(this.name, &quot;Adding escort &quot;+ship.displayName+&quot; with accuracy &quot;+ship.accuracy+&quot; to pad &quot;+pad+&quot;, escortdeckUsable:&quot;+ship.script.$EscortDeckUsable);
            ship.AIState = &quot;DECK&quot;;
            if (!owner.group) { //escort group for performEscort AI command
                owner.group = new ShipGroup();
                owner.group.addShip(owner);
                //from Oolite 1.84 the player can not be the leader of a group
                if (owner != player.ship) owner.group.leader = owner;
            }
            if (owner &amp;&amp; owner.group.leader != owner &amp;&amp; owner != player.ship) owner.group.leader = owner;
            if (!owner.group.containsShip(ship)) owner.group.addShip(ship);
        } else ship.AIState = &quot;SALVAGE&quot;;
        ship.beaconCode = &quot;E&quot;+pad+&quot; &quot;+ship.name;
        ship.bounty = 0;
        ship.scanClass = &quot;CLASS_CARGO&quot;; //prevent masslock
        ship.scannerDisplayColor1 = [0,0,0]; //black
// 
        var carrier = false;
        if (w.$EscortDeckCWS &amp;&amp; owner.dataKey.indexOf(&quot;carrier&quot;) &gt; -1) carrier = true;
        var p = w.$EscortDeckPadPos[pad];
        if (!p) {
            w.$EscortDeck_SetPads(owner, w);
            p = w.$EscortDeckPadPos[pad];
            if (!p) p = [0,70*(pad+1),0];
        }
        var sp = Vector3D(p[0], p[1], p[2]);
        var x = ship.boundingBox.x * 0.5;
        var y = ship.boundingBox.y * 0.5;
        var z = ship.boundingBox.z * 0.5;
        if (w.$EscortDeckXL &amp;&amp; (!carrier || pad &gt; 3 &amp;&amp; pad &lt; 8)) {
            var left = -0.5; //left side of the xl deck
            if( Math.round(pad/2) != pad/2 ) left = 0.5; //right side
            sp = sp.add(Vector3D(left * 2 * z, 0, 0));
        } else {
            var v = w.$EscortDeckPadVec[pad];
            if (!v) v = [0,1,0];//up
            var vx = v[0] * x;
            if (!carrier &amp;&amp; y &gt; 12) y = 12 - ( y - 12 ); //sunk if taller than 24m
            var vy = v[1] * y;
            var vz = v[2] * z;
            sp = sp.add(Vector3D(vx, vy, vz));
        }
        if (owner.addCollisionException) owner.addCollisionException(ship); //from v1.81
        else if(carrier) {  //must move up to avoid kill by Injector speed
            var a = y + 25;
            if (w.$EscortDeck_isMiniPad(pad, owner, w)) a = 2 * x + 30;
            sp = sp.add(Vector3D(0, a, 0));
        }

        if (sp.magnitude() &gt; 500) ship.position = sp; //prevent terminated by Witchpoint Beacon
        if (owner != player.ship &amp;&amp; ship.script) {
            if (!ship.script.$EscortDeckShipPos) 
                ship.script.$EscortDeckShipPos = [];
            ship.script.$EscortDeckShipPos[pad] = sp; //NPC
        } else w.$EscortDeckShipPos[pad] = sp; //player ship
        //ship.orientation = owner.orientation;
        ship.velocity = owner.velocity;
        
        //slower steering and acceleration in proportion with the mass on deck
        w.$EscortDeck_SetMaxs(owner, w);
        
        if (ship.script) {
            ship.script.$Towbar_TimedBombCounter = -1; //disarm timed bomb
            if (ship.script.$TowbarUsableShip)
                ship.script.$TowbarUsableShip = null;
        }
        
        if (owner == player.ship) {
            if (msg) {
                var m = ship.displayName+&quot; locked on deck &quot;+(pad+1);
                player.consoleMessage(m, 10);
                if (w.$debug) log(w.name, m); //debug
                w.$EscortDeckSound.play();
            }
        }
        
        return false;
    }
    return(&quot;no room&quot;);
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_Release = function _escortdeck_Release(owner, pad, w, dist, nomsg) {
    if( !dist ) var dist = w.$EscortDeckLandingDist + 500; //drop distance over lock range
    var s = w.$EscortDeckShip[pad];
    if( s &amp;&amp; s.isValid ) {
//        if (s.script.$EscortDeckUsable &lt; 0) s.script.$EscortDeckUsable = 0;
        //move the old ship backward, over the relock range if on deck
        if( w.$EscortDeckShipPos[pad] ) {
            var sp = s.position.add(player.ship.heading.multiply(-dist));
            if( sp.magnitude() &gt; 500 ) s.position = sp; //prevent terminated by Witchpoint Beacon
            w.$EscortDeckSound.play();
        }
        if( owner.removeCollisionException ) //from v1.81
            owner.removeCollisionException(s);
        w.$EscortDeckShipData[pad] = null;
        w.$EscortDeckShip[pad] = null;
        w.$EscortDeckShipPos[pad] = null;
        s.script.$EscortDeckOnDeck = false;
        if(!nomsg &amp;&amp; s.dataKey.indexOf(&quot;carrier-player&quot;) == -1 ) //no msg for carrier
            player.consoleMessage( s.displayName+&quot; released from deck &quot;+(pad+1), 10 );
    }
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_RestoreShipData = function _escortdeck_RestoreShipData(s, d, w, owner) {
    var that = _escortdeck_RestoreShipData;
    var ssh = (that.ssh = that.ssh ||  worldScripts[&quot;Ship_Storage_Helper.js&quot;]);

    if (s &amp;&amp; s.isValid &amp;&amp; d &amp;&amp; d[0]) {
        var entry_time = Date.now();
        if (!s.script) s.setScript(&quot;escortdeck_escort.js&quot;);
        if (ssh &amp;&amp; ssh.restoreStoredShipFromArray) {
            ssh.restoreStoredShipFromArray(d, s);
        } else {
            if( d[0][7] ) s.shipClassName = d[0][7];
            if( d[0][8] ) s.shipUniqueName = d[0][8];
            if( s != player.ship ) s.displayName = d[0][3];
            if(d[2]) s.aftWeapon = EquipmentInfo.infoForKey(d[2]);
            if(d[3]) s.forwardWeapon = EquipmentInfo.infoForKey(d[3]);
            if(d[4]) s.portWeapon = EquipmentInfo.infoForKey(d[4]);
            if(d[5]) s.starboardWeapon = EquipmentInfo.infoForKey(d[5]);

            //set new writable ship properties in Oolite 1.82
            var oolite182 = false;
            if (0 &lt; oolite.compareVersion(&quot;1.82&quot;)) { ; }
            else oolite182 = true;

            if( oolite182 ) { //these are not writable before Oolite 1.82
                var a = d[0];
                if( a[9] ) s.AIScriptWakeTime = a[9];
                if( a[11] ) s.destinationSystem = a[11];
                if( a[12] ) s.exhaustEmissiveColor = a[12];
                if( a[13] ) s.homeSystem = a[13];
                if( a[14] ) s.maxYaw = a[14];
                if( a[15] ) s.maxPitch = a[15];
                if( a[16] ) s.maxRoll = a[16];
                if( a[17] ) s.maxThrust = a[17];
                if( a[18] ) s.thrust = a[18];
                if( a[19] ) s.maxSpeed = a[19];
                if( a[20] &gt; 0 ) s.maxEnergy = a[20];
                if( a[20] &gt; 0 ) {
                    s.maxEnergy = a[20];
                    if(s.energy &lt; s.maxEnergy ) s.energy = s.maxEnergy;
                }
                if( a[21] &gt; 0 ) s.energyRechargeRate = a[21];
                if( a[22] ) s.cargoSpaceCapacity = a[22];
                if( a[23] ) s.injectorBurnRate = a[23];
                if( a[24] ) s.injectorSpeedFactor = a[24];
                if( a[25] ) s.scanDescription = a[25];
                if( a[26] ) s.hyperspaceSpinTime = a[26];
                if( a[27] ) s.scannerHostileDisplayColor1 = a[27];
                if( a[28] ) s.scannerHostileDisplayColor2 = a[28];
                if( s == player.ship ) {
                    if( a[29] ) s.forwardShield = a[29];
                    if( a[30] ) s.maxForwardShield = a[30];
                    if( a[31] ) s.forwardShieldRechargeRate = a[31];
                    if( a[32] ) s.aftShield = a[32];
                    if( a[33] ) s.maxAftShield = a[33];
                    if( a[34] ) s.aftShieldRechargeRate = a[34];
                } else if( a[10] ) s.beaconLabel = a[10]; //read-only for player
            }

            var counter, counter1;
            var equipment = s.equipment;
            //remove all equipments
            var r = [];
            for(counter = 0;counter&lt;equipment.length;counter++)
                r.push(equipment[counter].equipmentKey);
            for(counter = 0;counter&lt;r.length;counter++) //separated to avoid problems during eq array shortening
                s.removeEquipment(r[counter]);
//        if(w.$debug) log(w.name, &quot;RestoreShipData2 d:&quot;+d);
//        if(w.$debug) log(w.name, &quot;RestoreShipData2e &quot;+equipment);
            var tempArray = [];
            var savedEQ = d[7];
            for(counter = 0; counter &lt; savedEQ.length; counter++) {
                tempArray.push(savedEQ[counter][0]);
            }
            for(counter = 0; counter &lt; equipment.length; counter++) {
                var e = equipment[counter].equipmentKey;
                var index = tempArray.indexOf(e);
                if( index == -1 ) s.removeEquipment(e);
            else if( savedEQ[index][1] == &quot;EQUIPMENT_DAMAGED&quot; )
                s.setEquipmentStatus( e, &quot;EQUIPMENT_DAMAGED&quot; );
            }
            var depth = 0;
            var retryArray = []; //try again if a required equipment comes later
            retryArray[depth] = savedEQ;
            do {
                var added = false;
                retryArray[depth+1] = [];
                for(counter = 0; counter &lt; retryArray[depth].length; counter++) {
                    var e = retryArray[depth][counter][0]; //award if exists and has not
                    var ed = retryArray[depth][counter][1];
                    if( EquipmentInfo.infoForKey(e) ) {
                        if( !s.awardEquipment(e) ) //retry next time if failed
                            retryArray[depth+1].push([e,ed]);
                        else {
                            added = true;
                            if( ed == &quot;EQUIPMENT_DAMAGED&quot; )
                                s.setEquipmentStatus( e, &quot;EQUIPMENT_DAMAGED&quot; );
                        }
                    }
                }
                depth++;
//            if(w.$debug) log(w.name, &quot;RestoreShipData3 depth:&quot;+depth+&quot; retryArray:&quot;+retryArray[depth]);
            } while( retryArray[depth].length &gt; 0 &amp;&amp; added &amp;&amp; depth &lt; 100 ) //until no more added eq
        /* old code lose equipments due to make changes in the original d array
        for(counter = 0; counter&lt;equipment.length; counter++) {
            tempArray = [equipment[counter].equipmentKey,
                s.equipmentStatus(equipment[counter])];
            for(counter1 = 0; counter1&lt;savedEQ.length; counter1++) {
                if (savedEQ[counter1][0] === tempArray[0]) {
                    tempArray.push(true);
                    tempArray.push(counter1);
                    if (savedEQ[counter1][1] === &quot;EQUIPMENT_DAMAGED&quot;)
                        s.setEquipmentStatus(tempArray[0],
                                     &quot;EQUIPMENT_DAMAGED&quot;);
                    break;
                }
            }
            if (!tempArray[2]) {
                s.removeEquipment(tempArray[0]);
                continue;
            } else savedEQ.splice(tempArray[3],1);
        }
        for(counter = 0; counter&lt;savedEQ.length; counter++) {
            if(EquipmentInfo.infoForKey(savedEQ[counter][0])) {
                s.awardEquipment(savedEQ[counter][0]);
                if(savedEQ[counter][1] === &quot;EQUIPMENT_DAMAGED&quot;)
                    s.setEquipmentStatus(savedEQ[counter][0],savedEQ[counter][1]);
            }
        }*/
//        if(w.$debug) log(w.name, &quot;RestoreShipData3 d[7]:&quot;+d[7]);
//        if(w.$debug) log(w.name, &quot;RestoreShipData3e &quot;+s.equipment);

            //ship.cargoList is read-only and no ship.manifest so d[8] is skipped
            s.fuel = d[9];

            //passengers is player only, so d[10] is skipped
            var subEnts = d[11]; //will only exist if less subEnts than capacity when ship was stored.
            if (subEnts &amp;&amp; subEnts.length&gt;0) {
                var currentSubEnts = s.subEntities;
                for (counter = 0; counter&lt;currentSubEnts.length; counter++) {
                    currentSubEnts[counter].toBeRemoved = true;
                    for(counter1 = 0; counter1&lt;subEnts.length; counter1++) {
                        if(subEnts[counter1][0] === currentSubEnts[counter].dataKey &amp;&amp;
                             subEnts[counter1][1] === currentSubEnts[counter].position.x &amp;&amp;
                             subEnts[counter1][2] === currentSubEnts[counter].position.y &amp;&amp;
                             subEnts[counter1][3] === currentSubEnts[counter].position.z )
                            delete currentSubEnts[counter].toBeRemoved;
                    }
                    if (currentSubEnts[counter].toBeRemoved) {
                        delete currentSubEnts[counter].toBeRemoved;
                        currentSubEnts[counter].remove(true);
                    }
                }
            }

            //serviceLevel is player only, NPCs store it in script variable
            if( d[12] &gt; 0 ) {
                if( s == player.ship &amp;&amp; d[12] ) s.serviceLevel = d[12];
                else if( s.script ) s.script.$SSH_serviceLevel = d[12]; //must set after setScript
            }

            if (oolite.compareVersion(&quot;1.80&quot;) &lt; 0) {// can only do this in Oolite 1.81 or greater
                s.entityPersonality = d[13];
            }
        
            if( s.script &amp;&amp; d[14] )
                //s.script.$EscortDeckUsable = d[14].usable; //must set after setScript
                s.script.$EscortDeckUsable = 1; //must set after setScript
            
//        if(w.$debug) log(w.name, &quot;missileCapacity:&quot;+s.missileCapacity+&quot; d[6]:&quot;+d[6]);
            if( s.missileCapacity &gt; 0 ) {
            //do missiles at the end due to there is a core bug in Oolite 1.80
            //when land back to the carrier from an Asp which has max_missiles=0:
            //Error: Native exception: Tried to init array with nil object
                var missiles = [];
                if( s.missiles &amp;&amp; s.missiles.length &gt; 0 ) {
                    missiles = s.missiles;
                    for(counter = 0;counter&lt;missiles.length;counter++) {
                        s.removeEquipment(missiles[counter]);
                    }
                }
                missiles = d[6];
                if( missiles &amp;&amp; missiles.length &gt; 0 ) {    
                    for(counter = 0; counter&lt;missiles.length; counter++)
                        if(EquipmentInfo.infoForKey(missiles[counter]))
                            s.awardEquipment(missiles[counter]);
                }
            }
        }
        if (s.script &amp;&amp; s.script.$EscortDeckUsable === 1) {
            var js = &quot;escortdeck_escort&quot;;
            if (!s.script || s.script.name != js) {
                // sanity check only, since we set ship.script as soon as we spawn it
                var sl = 0;  //must set usable and sl again after setScript
                if (s.script) sl = s.script.$SSH_serviceLevel;
                s.setScript(js+&quot;.js&quot;);
                if (s.script) {
                    s.script.$EscortDeckUsable = 1;
                    s.script.$SSH_serviceLevel = sl;
                }
            }
            // make sure the escorts can use LaserReductor if they have it - if the player wants derelicts, they will have it!
            s.script.shipAttackedOther = this.shipAttackedOther;
            s.script.shipKilledOther = this.shipKilledOther;
            // if running HarderWay, attach SolarWind to ship script if it hasn&#39;t been already to set fuel scooping/consumption
            if (worldScripts.SolarWind &amp;&amp; typeof s.script.$debugHarderWay === &#39;undefined&#39;) worldScripts.SolarWind.shipSpawned(s);
            s.script.$debugHarderWay = true; // see log messages form the escorts in Latest.log
            // nobody would hire a novice as a escort pilot, so take out the lower accuracy range
            if (s.accuracy == null || s.accuracy &lt; 6.1) s.accuracy = 6.1 + 4 * Math.random();
        }

        var now = Date.now();
        if (this.$debug) log(this.name, &quot;Deserializing ship &quot;+s.displayName+&quot; took &quot;+(now-entry_time).toFixed(0)+&quot;ms&quot;);
    }
    if (this.$debug) log(this.name, s.displayName+&quot;: shipRestore returns&quot;);
    return (s);
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_RollBack = function _escortdeck_RollBack(eq, msg) {
    var f = 1;
    if( player.ship &amp;&amp; player.ship.dockedStation ) {
        var e = player.ship.dockedStation.equipmentPriceFactor;
        if( e &gt; 0 ) f = e;
    }
    player.credits += f * EquipmentInfo.infoForKey(eq).price/10;
    player.consoleMessage(msg, 5);
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_Salvage = function _escortdeck_Salvage( pad, owner ) { //salvage the escort on the given pad
    var that = _escortdeck_Salvage;
    var w = (that.w = that.w || worldScripts.escortdeck);
    var d = null;
    if( w.$EscortDeckShipData ) d = w.$EscortDeckShipData[pad];
    var s = null;
    if( w.$EscortDeckShip ) s = w.$EscortDeckShip[pad];
    var sn = &quot;escort&quot;;
    var t = w.$EscortDeckToWS;
    if( t ) {
        var s = w.$EscortDeck_SpawnShip( pad, w, owner );
        if (s &amp;&amp; s.isValid) {
            if (w.$debug) log(w.name, &quot;Using Towbar_Payout to salvage &quot;+s.displayName);
            t.$Towbar_Payout(s); //call payout in towbar oxp
        }
    } else { //pay salvage price like in towbar
        var cr = w.$EscortDeck_SalvagePadPrice(pad); //salvage payment
        log(w.name, &quot;Salvage &quot;+pad+&quot;. pad for &quot;+cr+&quot;cr: &quot;+d);
        if( s &amp;&amp; s.isValid ) sn = s.shipClassName; //must be short name to fit into a line
        else {
            if( !d || !d[1] ) return false; //no ship in this pad
            sn = d[0][7]; //shipClassName
        }
        player.consoleMessage(&quot;You got &quot;+cr+&quot; Cr for salvaging &quot;+sn, 10);
        player.credits += cr;
        w.$EscortDeckSound2.play();
    }
    if( s &amp;&amp; s.isValid ) s.remove(true);
    w.$EscortDeckShipData[pad] = null;
    w.$EscortDeckShip[pad] = null;
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_Salvage2 = function _escortdeck_Salvage2(pad, owner) { //salvage or save into Hyperspace Hangar
    var that = _escortdeck_Salvage2;
    var w = (that.w = that.w || worldScripts.escortdeck);
    var hh = (that.hh = that.hh || worldScripts.HyperspaceHangar);
    if (hh &amp;&amp; w.$EscortDeckShipData[pad]) {
        if (w.$EscortDeckShipData[pad][0]) 
            player.consoleMessage(w.$EscortDeckShipData[pad][0][3]+&quot; from deck &quot;+(pad+1)+&quot; stored into Hyperspace Hangar&quot;, 10);
        w.$EscortDeck_HHStoreShipData(w.$EscortDeckShipData[pad]);
        w.$EscortDeckShipData[pad] = [];//clear this deck
    } else w.$EscortDeck_Salvage(pad, owner); //salvage the escort on the given pad
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_SalvageBadEscorts = function _escortdeck_SalvageBadEscorts(owner) {
    var that = _escortdeck_SalvageBadEscorts;
    var w = (that.w = that.w || worldScripts.escortdeck);
    if (!owner) return;
    var oldlength = w.$EscortDeckPadPos.length; //save the old length before SetPads when sold a Carrier
    w.$EscortDeck_SetPads( owner, w );
    if (owner.mass &lt; w.$EscortDeckMinMass) { //bought a too small ship
        owner.removeEquipment(&quot;EQ_ESCORTDECK&quot;);
        owner.removeEquipment(&quot;EQ_ESCORTDECKXL&quot;);
        for(var i = 0; i &lt; oldlength; i++ ) //salvage all escorts
            w.$EscortDeck_Salvage2(i, owner); //or save into Hyperspace Hangar
    } else if (!w.$EscortDeck_isLarge(owner, w)) { //no side pads
        w.$EscortDeck_Salvage2(4, owner); //salvage or save left adder
        w.$EscortDeck_Salvage2(5, owner); //salvage or save right adder
    }
    if (owner.mass &lt; w.$EscortDeckXLMass) { //bought a non-xl ship
        if (owner.equipmentStatus(&quot;EQ_ESCORTDECKXL&quot;) == &quot;EQUIPMENT_OK&quot;) {
            owner.removeEquipment(&quot;EQ_ESCORTDECKXL&quot;); //downgrade
            owner.awardEquipment(&quot;EQ_ESCORTDECK&quot;);
        }
    }
    if (owner.equipmentStatus(&quot;EQ_ESCORTDECKXL&quot;) == &quot;EQUIPMENT_OK&quot;) w.$EscortDeckXL = true;
    else w.$EscortDeckXL = false; //must set XL for the following TooLarge call
    for(var i = 0; i &lt; oldlength; i++ ) {
        var t = null;
        if (w.$EscortDeckShip) t = w.$EscortDeckShip[i]; //the ship on this pad
        if (i &gt;= w.$EscortDeckPadPos.length || //salvage too much decks when bougth a smaller ship
            w.$EscortDeck_TooLarge2(t, owner, w, i)) //can use ShipData array if no ship
            w.$EscortDeck_Salvage2(i, owner); //salvage too large escorts or save into HH
    }
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_SalvagePadPrice = function _escortdeck_SalvagePadPrice(pad) { //salvage price of an escort on this pad
    var that = _escortdeck_SalvagePadPrice;
    var w = (that.w = that.w || worldScripts.escortdeck);
    var s = null;
    var t = w.$EscortDeckToWS;
    if (t) return null; // Towbar_Payout will be used to salvage, we don&#39;t know the salvage price

    if (w.$EscortDeckShip) s = w.$EscortDeckShip[pad]; //the ship on this pad if player is not docked
    if (s &amp;&amp; s.isValid) return(w.$EscortDeck_SalvageShipPrice(s, w));
    var d = null;
    if (w.$EscortDeckShipData) d = w.$EscortDeckShipData[pad]; //inside stations must use the saved data array
    if (!d || !d[1]) return(0); //no price for a nonexistent ship
    var eq = [];
    for (var i = 0; i &lt; d[7].length; i++) {
        var ep = 0;
        var e = EquipmentInfo.infoForKey(d[7][i][0]);
        if (e) ep = e.price;
        eq[i] = {price:ep};
        if (w.$debug) log(w.name, i+&quot;. &quot;+e+&quot; fullprice:&quot;+eq[i].price); //debug
    }
    var mass = 30000;//guess
    if (d[14] &amp;&amp; d[14].mass &gt; 0) mass = d[14].mass;
    return(w.$EscortDeck_SalvagePrice(mass, eq, d[3], d[2], w));
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_SalvagePrice = function _escortdeck_SalvagePrice( mass, eq, fw, af, w ) {//price like in towbar OXP
    var hull = Math.round( 32.8 * Math.min(80, Math.round( //1t alloys = 32.8cr in average
        0.3 * mass * 0.001 )) * 0.1 ) * 10 //alloys from the hull

    var comp = 0; if( mass &gt; 30000 ) comp = 84; //price of 1t computers

    var eqcr = 0; //payment for all equipments
    var rnd = 0.5;//Math.random(); - removed randomness due to repeated price listing in interface
    var i = -1;

    function weapon_value(eqKey) {
        var value = 0;
        if (eqKey) {
            var eqInfo = EquipmentInfo.infoForKey(eqKey);
            if (eqInfo) {
                value = Math.round(eqInfo.price/10*(0.2+rnd*0.2)/10)*10;
            }
        }
        return value;
    }

    while( eq[++i] ) {
        var p = eq[i].price * 0.04; //20% of the original cost in credits (not in credits*10)
        if( p &gt; 300 ) {
//            rnd = rnd * ( 300 / p ); //costly eqs always damaged - removed, already cheap
            eqcr += Math.round( Math.max( 50, Math.round(p * rnd ))/10)*10; //min. 50cr
        } else eqcr += Math.round( Math.max( 10,
            Math.round( p * rnd ))/10)*10; //at least 10cr
    }

    //payment for fw and aft weapons, min. 20%, max 40% of original price, fixed rnd mean fix 30%
    var fc = weapon_value(fw);
    var ac = weapon_value(af);
    var cr = hull + comp + eqcr + fc + ac; //all payments but nothing for cargo
    return( cr ); //* 0.5 ); //deduct 50% commission - removed, an escort already cheap
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_SalvageShipPrice = function _escortdeck_SalvageShipPrice( ship, w ) { //salvage price of this ship
    return( w.$EscortDeck_SalvagePrice( ship.mass, ship.equipment,
                      ship.forwardWeapon, ship.aftWeapon, w ) );
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_SaveMaxs = function _escortdeck_SaveMaxs( ship, w ) {
    if(ship) 
        w.$EscortDeckMaxs = {   
                                maxThrust:ship.maxThrust,
                                maxPitch:ship.maxPitch,
                                maxRoll:ship.maxRoll,
                                maxYaw:ship.maxYaw 
                            };
    else w.$EscortDeckMaxs = { maxThrust:32, maxPitch:1, maxRoll:2, maxYaw:1 };
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_RestoreMaxs = function _EscortDeck_RestoreMaxs(ship, w) {
    var stored_max = w.$EscortDeckMaxs;
    if (stored_max) {
        ship.thrust = stored_max.maxThrust;
        ship.maxPitch = stored_max.maxPitch;
        ship.maxRoll = stored_max.maxRoll;
        ship.maxYaw = stored_max.maxYaw;
    }
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_SetMaxs = function _escortdeck_SetMaxs( ship, w ) {
    var old_f = this.$EscortDeckMassFactor;
    if( !ship || !ship.addCollisionException  //need Oolite v1.81
        || !w.$EscortDeckMassEffect ) return;
    var f = w.$EscortDeck_MassFactor(ship, w);
//    var m = w.$EscortDeckMaxs; //original maximums of player ship
    ship.thrust *= f / old_f;
    ship.maxPitch *= f / old_f;
    ship.maxRoll *= f / old_f;
    ship.maxYaw *= f / old_f;
    this.$EscortDeckMassFactor = f;
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_SetPads = function _escortdeck_SetPads(owner, w) {
    var carrier = false;
    if (w.$EscortDeckCWS &amp;&amp; owner.dataKey.indexOf(&quot;carrier&quot;) &gt; -1) carrier = true;
    var p = w.$EscortDeckLPos;
    var v = w.$EscortDeckLVec;
    var xl = &quot;escortdeck&quot;;
    var m, s = [], si, x, y, z, maxmass;
    if (owner &amp;&amp; owner.isValid) {
        if (owner.equipmentStatus(&quot;EQ_ESCORTDECKXL&quot;) === &quot;EQUIPMENT_OK&quot;) {
            w.$EscortDeckXL = true;
        } else w.$EscortDeckXL = false;

        if (carrier) {
            xl = null; //use the carrier&#39;s hull as deck
            if (w.$EscortDeckXL) { //XL deck on carrier
                p = w.$EscortDeckCXPos;
                v = w.$EscortDeckCXVec;
                si = w.$EscortDeckCXSize;
            } else { //normal deck on carrier
                p = w.$EscortDeckCPos;
                v = w.$EscortDeckCVec;
                si = w.$EscortDeckCSize;
            }
            for (var i = 0; i &lt; p.length; i++) {
                var siz = si[i];
                if( siz ) {
                    x = siz[0];
                    y = siz[1];
                    z = siz[2];
                    maxmass = siz[3];
                } else x = y = z = maxmass = 0;
                s[i] = [x, y, z, maxmass];
                if (i == 0) m = [x, y, z, maxmass];
                else {
                    m[0] = Math.max(x, m[0]);
                    m[1] = Math.max(y, m[1]);
                    m[2] = Math.max(z, m[2]);
                    m[3] = Math.max(maxmass, m[3]);
                }
            }
            s.push(m); //the last item contain the maximums of size values
        } else if (w.$EscortDeckXL) { //XL deck on non-carrier
            xl += &quot;xl&quot;;
            p = w.$EscortDeckXLPos;
            v = w.$EscortDeckXLVec;
            x = w.$EscortDeckPad.xl[0];
            y = w.$EscortDeckPad.xl[1];
            z = w.$EscortDeckPad.xl[2];
            maxmass = w.$EscortDeckPad.xl[3]; //60t
            for (var i = 0; i &lt;= p.length; i++) { // &lt;= due to all equal
                s[i] = [x, y, z, maxmass]; //so the maximums are the same
            }
        } else { //normal deck on non-carrier
            if (owner.mass &gt;= w.$EscortDeckWMass) {
                xl += &quot;w&quot;;
                p = w.$EscortDeckWPos;
                v = w.$EscortDeckWVec;
            }
            if (owner.mass &gt;= w.$EscortDeckWMass) { //wide pad
                x = w.$EscortDeckPad.wide[0];
                y = w.$EscortDeckPad.wide[1];
                z = w.$EscortDeckPad.wide[2];
                maxmass = w.$EscortDeckPad.wide[3];
            } else { //normal escort pad (non-wide)
                x = w.$EscortDeckPad.escort[0];
                y = w.$EscortDeckPad.escort[1];
                z = w.$EscortDeckPad.escort[2];
                maxmass = w.$EscortDeckPad.escort[3];
            }
            maxmass = Math.min(owner.mass * 0.4,  maxmass); //max. 40% of the owner&#39;s mass
//            maxmass = Math.min(owner.mass * 0.5,  maxmass); //max. 50% of the owner&#39;s mass
            maxmass = Math.min(w.$EscortDeckLargeMass,  maxmass); //max. 130t
            for ( var i = 0; i &lt;= p.length; i++) {
                if (w.$EscortDeck_isMiniPad(i, owner, w))
                     s[i] = [w.$EscortDeckPad.mini[0],
                         w.$EscortDeckPad.mini[1],
                        w.$EscortDeckPad.mini[2],
                        w.$EscortDeckPad.mini[3]];
                else s[i] = [x, y, z, maxmass];
            }
        }
    }

    var len = p.length;
    if (owner &amp;&amp; owner.isValid &amp;&amp; !w.$EscortDeck_isLarge(owner, w))
        len = 4; //without adder pads
    w.$EscortDeckPadPos = []; //landing pad positions
    w.$EscortDeckPadSize = []; //landing pad sizes
    w.$EscortDeckPadVec = []; //vectors from landing pad to ship center
    for (var i = 0; i &lt; len; i++) { //fill up from the proper array
        w.$EscortDeckPadPos[i] = p[i];
        w.$EscortDeckPadSize[i] = s[i];
        w.$EscortDeckPadVec[i] = v[i];
    }
    w.$EscortDeckPadSize[len] = s[s.length-1]; //the last item contain the maximums of size values
    log(w.name, &quot;Pads Size:&quot;+JSON.stringify(w.$EscortDeckPadSize)+&quot;, wide:&quot;+JSON.stringify(w.$EscortDeckPad.wide));
    return(xl);
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_Show = function _escortdeck_Show(owner) { //create the deck and escorts
    var that = _escortdeck_Show;
    var w = (that.w = that.w || worldScripts.escortdeck);
    var xl = &quot;notcarrier&quot;; //carriers set xl to null
    if ((owner.equipmentStatus(&quot;EQ_ESCORTDECK&quot;) === &quot;EQUIPMENT_OK&quot; 
        || owner.equipmentStatus(&quot;EQ_ESCORTDECKXL&quot;) === &quot;EQUIPMENT_OK&quot;)
        &amp;&amp; owner.mass &gt;= w.$EscortDeckMinMass) {
        xl = w.$EscortDeck_SetPads(owner, w); //return null for Carriers
        if (!w.$EscortDeckV &amp;&amp; xl) {
            var r = system.addVisualEffect(xl, [0,0,0]);
            if (r) w.$EscortDeckV = r; //position and orientation will be set in FCB
        }
        
        //make the z offset of deck position from the center of the owner ship
        var zv = owner.weaponPositionAft;//to be able to fire backward if the deck is solid
        if (!zv.z) zv = zv[0]; //fix for the change of weaponPositions in Oolite 1.83.
        zv.x = 0;
        var hl = owner.boundingBox.z * 0.5 + 30;
        if (zv.z &lt; hl) zv.z = -hl; //correct z position for carriers
        //if there is an aft Sniper Gun on the ship then move the deck nearer
        var sg = w.$EscortDeckSGWS;
        if (sg) {
            var sub = sg._checkAftSubEnt(owner, &quot;snipergun&quot;, sg);
            if (sub &gt;= 0) {
                var e = owner.exhausts;
                if (e &amp;&amp; e[0] &amp;&amp; e[0].position) {
                    if (w.$debug) log(w.name, &quot;zvz:&quot;+zv.z+&quot; ez:&quot;+(e[0].position.z-3));
                    zv.z = e[0].position.z - 3; //3m after engine
                } else { //no engine on this ship, like Nyoka
                    var subh = sg._checkAftSubEnt(owner, &quot;snipergun-heavy&quot;, sg);
                    if (subh &gt;= 0) { //Heavy Sniper Gun, move about 50m
                        var g = owner.subEntities[subh];
                        var subz = g.position.z - g.boundingBox.z;
                        if (subz &lt; zv.z) zv.z += g.boundingBox.z - 10;
                    } else { //normal Sniper Gun, move about 20m
                        var g = owner.subEntities[sub];
                        var subz = g.position.z - g.boundingBox.z;
                        if (subz &lt; zv.z) zv.z += g.boundingBox.z - 10;
                    }
                    if (w.$debug) log(w.name, &quot;subz:&quot;+subz+&quot; zvz:&quot;+zv.z);
                }
            }
        }
 
        if (zv.y &gt; 0) zv.y = 0; //do not raise over the center line
        if (owner == player.ship) w.$EscortDeckZV = zv;
        else { //NPC deck
            if (!owner.script) owner.script = &quot;oolite-default-ship-script.js&quot;; //for sure
            owner.script.$EscortDeckZV = zv;
        }

        //spawn ships based on $EscortDeckShipData
        var b = system.shipsWithPrimaryRole(&quot;buoy-witchpoint&quot;); //avoid instant collision after hyperjump
        for (var i = 0; i &lt; w.$EscortDeckPadPos.length; i++) { //fill up ShipPos array
            var s = w.$EscortDeck_SpawnShip(i, w, owner);
            if (s &amp;&amp; s.isValid) {
                if (b &amp;&amp; b[0] &amp;&amp; b[0].addCollisionException) //from v1.81
                    b[0].addCollisionException(s);
                var r = w.$EscortDeck_PutShip(true, s, i, owner);
                if (w.$debug) log(w.name, (i+1)+&quot;. spawn &quot;+s+&quot; r:&quot;+r); //debug
            }
        }
    }
    w.$EscortDeck_MFD(w); //update MFD

    if ((w.$EscortDeckV || !xl) &amp;&amp; !isValidFrameCallback(w.$EscortDeckFCB))
        w.$EscortDeckFCB = addFrameCallback(w.$EscortDeck_FCB);
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_SpawnOne = function _escortdeck_SpawnOne(role, w, isShip) {
    var s = system.addShips(role, 1, [10000000,0,0], 5000);
    // set script as soon as possible, hopefully before any OXP&#39;s shipSpawned event handler set any property in th ship&#39;s script
    if (isShip &amp;&amp; s &amp;&amp; s[0]) s[0].setScript(&quot;escortdeck_escort.js&quot;);
    return( s );
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_SpawnShip = function _escortdeck_SpawnShip(pad, w, owner) {
    var s = null;
    var d = w.$EscortDeckShipData[pad];
    if (d &amp;&amp; d[1]) {
        if (w.$EscortDeckCWS &amp;&amp; d[14] &amp;&amp; d[14].usable &gt; 0
            &amp;&amp; w.$EscortDeckPlayableDataKeys.indexOf(d[1]) === -1) {
            var n = d[1]+&quot;-player&quot;; //try the player variant for Carriers
            if (w.$EscortDeckPlayableDataKeys.indexOf(n) &gt; -1) d[1] = n;
            else {
                var e = d[1].indexOf(&quot;-trader&quot;); //try without suffix
                if (e == d[1].length-(e.length)) {
                    n = d[1].substr(0, e);
                    if (w.$EscortDeckPlayableDataKeys.indexOf(n) &gt; -1)
                        d[1] = n;
                    else {
                        n += &quot;-player&quot;; //try replace -trader to -player
                        if (w.$EscortDeckPlayableDataKeys.indexOf(n) &gt; -1)
                            d[1] = n;
                    }
                } else {
                    var e = d[1].indexOf(&quot;-pirate&quot;); //try without suffix
                    if (e == d[1].length-(e.length)) {
                        n = d[1].substr(0, e);
                        if (w.$EscortDeckPlayableDataKeys.indexOf(n) &gt; -1)
                            d[1] = n;
                        else {
                            n += &quot;-player&quot;; //try replace to -player
                            if(w.$EscortDeckPlayableDataKeys.indexOf(n) &gt; -1) d[1] = n;
                        }
                    }
                }
            }
        }
        s = w.$EscortDeck_SpawnOne(&quot;[&quot;+d[1]+&quot;]&quot;, w, true);
        if (s &amp;&amp; s[0]) {
            if (s.script) s.script.$ShipVersionIgnore = true;
            if (w.$debug) log(w.name, &quot;Spawn escort pad:&quot;+pad+&quot; d:&quot;+d+&quot; s:&quot;+s);
            s = w.$EscortDeck_RestoreShipData(s[0], d, w, owner);
            //setup restore in FCB also, need after ShipVersion changes in shipSpawned
            w.$EscortDeckSpawnedShips.push(s);
        }
    }
    return(s);
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_TooLarge = function _escortdeck_TooLarge(ship, owner, w) { //size or mass is too large to this deck?
    return(w.$EscortDeck_TooLarge2(ship, owner, w, -1));
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_TooLarge2 = function _escortdeck_TooLarge2(ship, owner, w, pad) { //use saved data if no ship
    if( !ship || !ship.isValid ) {
        if( pad &lt; 0 ) return(&quot;invalid escort ship&quot;);
        var d = w.$EscortDeckShipData;
        if( !d ) return(&quot;missing escort ship data&quot;);
        d = d[pad];
        return(w.$EscortDeck_TooLarge2b(owner, w, pad, d ));
    } else { //ship is present
        var shipmass = ship.mass;
        if( ship.scriptInfo &amp;&amp; ship.scriptInfo.hardarmour &gt; 1 )
            shipmass = shipmass / 2; //remove extra density from HardShips and Granite ships
        var b = ship.boundingBox;
        return(w.$EscortDeck_TooLarge3(owner, w, shipmass, b.x, b.y, b.z, pad ));
    }
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_TooLarge2b = function _escortdeck_TooLarge2b(owner, w, pad, d) { //use saved data if no ship
    if( !d || !d[14] || !d[14].mass ) return(&quot;invalid escort ship data&quot;);
    var shipmass = d[14].mass;
    if( d[1].indexOf(&quot;hard&quot;) == 0 ) //if this is a HardShip or Granite ship
        shipmass = shipmass / 2; //remove the extra density
    return(w.$EscortDeck_TooLarge3(owner, w, shipmass, d[14].x, d[14].y, d[14].z, pad ));
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_TooLarge3 = function _escortdeck_TooLarge3(owner, w, shipmass, bx, by, bz, pad) { //check given data
    if (!owner || !owner.isValid)  return(&quot;invalid owner ship&quot;);
    if (!(shipmass &gt; 0)) return(&quot;missing escort ship mass&quot;);
    if (!bx || !(bx&gt;0) || !by || !(by&gt;0) || !bz || !(bz&gt;0))
        return(&quot;invalid escort ship size&quot;);
    var e, l, x = 0, y = 0, z = 0, maxmass = 0;
    var s = w.$EscortDeckPadSize;
    if (s &amp;&amp; s[0]) {
        l = s.length-1;
        if (pad &lt; 0 || pad &gt; l) e = s[l]; //the last line contain the maximums
        else e = s[pad];
        if (e &amp;&amp; e[0]) { 
            x = e[0];
            y = e[1];
            z = e[2];
            maxmass = e[3];
        }
    }

    var r = null;
    if (shipmass &gt; maxmass) r = &quot;too heavy (&quot;+Math.ceil(shipmass/1000)+&quot;t &gt; &quot;+Math.floor(maxmass/1000)+&quot;t)&quot;;
    else if (bx &gt; x) r = &quot;too wide (&quot;+Math.ceil(bx)+&quot;m &gt; &quot;+x+&quot;m)&quot;;
    else if (by &gt; y) r = &quot;too tall (&quot;+Math.ceil(by)+&quot;m &gt; &quot;+y+&quot;m)&quot;;
    else if (bz &gt; z) r = &quot;too long (&quot;+Math.ceil(bz)+&quot;m &gt; &quot;+z+&quot;m)&quot;;
    if (w.$debug) {
        var p = pad+1;
        if (p == 0) p = &quot;any&quot;;
        if (r) var l = r;
        else var l = &quot;[&quot;+Math.ceil(bx*100)/100+&quot;,&quot;+Math.ceil(by*100)/100+&quot;,&quot;+
            Math.ceil(bz*100)/100+&quot;,&quot;+Math.ceil(shipmass)+&quot;] fit into [&quot;+Math.floor(x*100)/100+&quot;,&quot;+
            Math.floor(y*100)/100+&quot;,&quot;+Math.floor(z*100)/100+&quot;,&quot;+Math.floor(maxmass)+&quot;]&quot;;
//        log(w.name, &quot;Pad &quot;+p+&quot;: &quot;+l); //debug
    }
    return(r); //if null then not too large
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_VClear = function _escortdeck_VClear(w) { //remove the models of deck and escorts
    var p = player.ship;
    if( isValidFrameCallback( w.$EscortDeckFCB ) )
        removeFrameCallback( w.$EscortDeckFCB );
    if( w.$EscortDeckV ) w.$EscortDeckV.remove();
    w.$EscortDeckV = null;
    w.$EscortDeckSelectedPad = -1;
    if( w.$EscortDeckShip ) {
        for(var i = 0; i &lt; w.$EscortDeckPadPos.length; i++ ) {
            var s = w.$EscortDeckShip[i];
            if( s &amp;&amp; s.isValid ) {
                var lost = false;
                if( !w.$EscortDeckShipPos[i] ) { //not in deck
                    var rnd = ( 5 * Math.random() + 1 ) * p.scannerRange;
                    var d = s.position.distanceTo(p.position) - p.scannerRange;
                    if( d &gt; rnd ) lost = true; //leaved farther than its luck
                }
                if( lost ) player.consoleMessage(s.name+&quot; is left behind from pad &quot;+i, 10);
                else {
                    w.$EscortDeckShipData[i] = w.$EscortDeck_MakeShipData(s);
                    s.remove(true);
                }
                if(w.$debug) log(w.name, (i+1)+&quot;. &quot;+w.$EscortDeckShipData[i]); //debug
            }
            w.$EscortDeckShip[i] = null;
            w.$EscortDeckShipPos[i] = null;
        }
    } else {
        w.$EscortDeckShip = [];
        w.$EscortDeckShipPos = [];
    }
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_TugDrone_Processing = function _escortdeck_TugDrone_Processing(ship) {
    var that = _escortdeck_TugDrone_Processing;
    var t = (that.t = that.t || worldScripts.towbar);
    var wse = (that.wse = that.wse || worldScripts.escortdeck);
    log(wse.name, &quot;_escortdeck_TugDrone_Processing_escortdeck: Tug Drone towed ship &quot;+ship.displayName);
    if (ship &amp;&amp; ship.isValid &amp;&amp; ship.script &amp;&amp; ship.script.$EscortDeckUsable &gt; 0) {
        log(wse.name, &quot;Tug Drone towed ship &quot;+ship.displayName+&quot; is usable, storing in Hyperspace Hangar&quot;);
        wse.$EscortDeck_HHStoreShip(ship);
        player.consoleMessage(&quot;Usable ship &quot;+ship.displayName+&quot; stored into Hyperspace Hangar&quot;, 10);
        player.commsMessage(&quot;Usable ship &quot;+ship.displayName+&quot; stored into Hyperspace Hangar&quot;, 10);
        ship.remove(true);
    } else {
        log(wse.name, &quot;Tug Drone towed ship &quot;+ship.displayName+&quot; not usable&quot;);
        t.$Towbar_TugDrone_ProcessingOrig(ship);
    }
}

//-----------------------------------------------------------------------------------------------//
this.$printDeckLoad = function _escortdeck_printDeckLoad() {
    var w = worldScripts.escortdeck;
    var _sArray = w.$EscortDeckShip;
    var _sDataArray = w.$EscortDeckShipData;
    var i;

    i = w.$EscortDeckPadPos.length;
    log(w.name, &quot;Decks has &quot;+i+&quot; pads&quot;);
    while (i--) {
        if (_sArray[i])
            log(w.name, &quot;Pad &quot;+i+&quot;: &quot;+_sArray[i].shipUniqueName+&quot; (&quot;+_sArray[i].dataKey+&quot;)&quot;);
        else
            log(w.name, &quot;Pad &quot;+i+&quot;: &quot;+_sDataArray[i]);
    }
}

//-----------------------------------------------------------------------------------------------//
this.$EscortDeck_RefuelEscort = function _escortdeck_RefuelEscort(d) {
    if (!d) return;
    if (d[9] &gt;= 7) return;
    var f = 7 - d[9];
    var v = f * 3; // 3 CR/LY (gotta charge extra for the service :-)
    if (player.credits &lt; v) {
        log(this.name, &quot;Insufficient funds to refuel escort &quot;+d[0][3]);
        player.consoleMessage(&quot;Insufficient funds to refuel escort &quot;+d[0][3]);
    } else {
        player.credits -= v;
        d[9] = 7;
        log(this.name, &quot;Refuelled escort &quot;+d[0][3]+&quot;: &quot;+ f.toFixed(1) +&quot;LY for &quot;+ formatCredits(v, true, true));
        player.consoleMessage(&quot;Refuelled escort &quot;+d[0][3]+&quot;: &quot;+ f.toFixed(1) +&quot;LY for &quot;+ formatCredits(v, true, true));
    }
}


</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/escortdeck_condition.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name        = &quot;escortdeck_condition&quot;;
this.author      = &quot;Norby&quot;;
this.copyright   = &quot;2014 Norbert Nagy&quot;;
this.licence     = &quot;CC BY-NC-SA 4.0&quot;;
this.description = &quot;Escort deck equipment can not fit into small ships&quot;;
this.version     = &quot;1.0&quot;;

this.allowAwardEquipment = function(eqKey, ship, context)
{
//bugfix for eqs with conditions scripts: need double replaceShip() to work!
//player.replaceShip(shipname, pers); player.replaceShip(shipname, pers);
//call twice! the first always got false for allow without run this script.
//Proof: if you uncomment the following line, only the 2nd call will write into the log.
//log(&quot;notforsmall&quot;, eqKey+&quot; &quot;+ship.name+&quot; &quot;+ship.mass+&quot; &quot;+context );

	var w = worldScripts.escortdeck;
	if( context == &quot;scripted&quot; //needed if player launched in a mini escort from a Carrier
		|| ship.mass &gt;= w.$EscortDeckMinMass ) return true;
	else return false;
}
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/escortdeck_condition_galcop.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name        = &quot;escortdeck_condition_galcop&quot;;
this.author      = &quot;Norby&quot;;
this.copyright   = &quot;2014 Norbert Nagy&quot;;
this.licence     = &quot;CC BY-NC-SA 4.0&quot;;
this.description = &quot;Vipers can fit into large ships and available in main stations only&quot;;
this.version     = &quot;1.0&quot;;

this.allowAwardEquipment = function(eqKey, ship, context)
{
//bugfix for eqs with conditions scripts: need double replaceShip() to work!
//player.replaceShip(shipname, pers); player.replaceShip(shipname, pers);
//call twice! the first always got false for allow without run this script.
//Proof: if you uncomment the following line, only the 2nd call will write into the log.
//log(&quot;notforsmall&quot;, eqKey+&quot; &quot;+ship.name+&quot; &quot;+ship.mass+&quot; &quot;+context );

	var w = worldScripts.escortdeck;
	if( w.$EscortDeck_isLarge(ship, w)
		&amp;&amp; ( ship.equipmentStatus(&quot;EQ_ESCORTDECK&quot;) == &quot;EQUIPMENT_OK&quot;
		|| ship.equipmentStatus(&quot;EQ_ESCORTDECKXL&quot;) == &quot;EQUIPMENT_OK&quot; )
		&amp;&amp; w.$EscortDeck_isFreePadFor(eqKey, ship, context, w)
		&amp;&amp; player.ship &amp;&amp; player.ship.docked &amp;&amp; system.mainStation
		&amp;&amp; player.ship.dockedStation == system.mainStation )
		return true;
	else return false;
}
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/escortdeck_condition_large.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name        = &quot;escortdeck_condition_large&quot;;
this.author      = &quot;Norby&quot;;
this.copyright   = &quot;2014 Norbert Nagy&quot;;
this.licence     = &quot;CC BY-NC-SA 4.0&quot;;
this.description = &quot;Heavy escorts can fit into large ships only and need a deck&quot;;
this.version     = &quot;1.0&quot;;

this.allowAwardEquipment = function(eqKey, ship, context)
{
//bugfix for eqs with conditions scripts: need double replaceShip() to work!
//player.replaceShip(shipname, pers); player.replaceShip(shipname, pers);
//call twice! the first always got false for allow without run this script.
//Proof: if you uncomment the following line, only the 2nd call will write into the log.
//log(&quot;notforsmall&quot;, eqKey+&quot; &quot;+ship.name+&quot; &quot;+ship.mass+&quot; &quot;+context );

	var w = worldScripts.escortdeck;
	if( w.$EscortDeck_isLarge(ship, w)
		&amp;&amp; w.$EscortDeck_isFreePadFor(eqKey, ship, context, w)
		&amp;&amp; ( ship.equipmentStatus(&quot;EQ_ESCORTDECK&quot;) == &quot;EQUIPMENT_OK&quot;
		|| ship.equipmentStatus(&quot;EQ_ESCORTDECKXL&quot;) == &quot;EQUIPMENT_OK&quot; ) )
		return true;
	else return false;
}
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/escortdeck_condition_largepirate.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name        = &quot;escortdeck_condition_largepirate&quot;;
this.author      = &quot;Norby&quot;;
this.copyright   = &quot;2014 Norbert Nagy&quot;;
this.licence     = &quot;CC BY-NC-SA 4.0&quot;;
this.description = &quot;Pirate ships can fit into large ships and available outside main stations&quot;;
this.version     = &quot;1.0&quot;;

this.allowAwardEquipment = function(eqKey, ship, context)
{
//bugfix for eqs with conditions scripts: need double replaceShip() to work!
//player.replaceShip(shipname, pers); player.replaceShip(shipname, pers);
//call twice! the first always got false for allow without run this script.
//Proof: if you uncomment the following line, only the 2nd call will write into the log.
//log(&quot;notforsmall&quot;, eqKey+&quot; &quot;+ship.name+&quot; &quot;+ship.mass+&quot; &quot;+context );

	var w = worldScripts.escortdeck;
	if( w.$EscortDeck_isLarge(ship, w)
		&amp;&amp; ( ship.equipmentStatus(&quot;EQ_ESCORTDECK&quot;) == &quot;EQUIPMENT_OK&quot;
		|| ship.equipmentStatus(&quot;EQ_ESCORTDECKXL&quot;) == &quot;EQUIPMENT_OK&quot; )
		&amp;&amp; w.$EscortDeck_isFreePadFor(eqKey, ship, context, w)
		&amp;&amp; player.ship &amp;&amp; player.ship.docked &amp;&amp; system.mainStation
		&amp;&amp; player.ship.dockedStation != system.mainStation )
		return true;
	else return false;
}
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/escortdeck_condition_mini.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name        = &quot;escortdeck_condition_mini&quot;;
this.author      = &quot;Norby&quot;;
this.copyright   = &quot;2014 Norbert Nagy&quot;;
this.licence     = &quot;CC BY-NC-SA 4.0&quot;;
this.description = &quot;This escort can fit into mini landing pads&quot;;
this.version     = &quot;1.0&quot;;

this.allowAwardEquipment = function(eqKey, ship, context)
{
//bugfix for eqs with conditions scripts: need double replaceShip() to work!
//player.replaceShip(shipname, pers); player.replaceShip(shipname, pers);
//call twice! the first always got false for allow without run this script.
//Proof: if you uncomment the following line, only the 2nd call will write into the log.
//log(&quot;notforsmall&quot;, eqKey+&quot; &quot;+ship.name+&quot; &quot;+ship.mass+&quot; &quot;+context );

	var w = worldScripts.escortdeck;
	if( ship.mass &gt;= w.$EscortDeckMinMass
		&amp;&amp; w.$EscortDeck_isFreePadFor(eqKey, ship, context, w, true) //the last true allow mini pads
		&amp;&amp; ( ship.equipmentStatus(&quot;EQ_ESCORTDECK&quot;) == &quot;EQUIPMENT_OK&quot;
		|| ship.equipmentStatus(&quot;EQ_ESCORTDECKXL&quot;) == &quot;EQUIPMENT_OK&quot; ) )
		return true;
	else return false;
}
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/escortdeck_condition_minigalcop.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name        = &quot;escortdeck_condition_minigalcop&quot;;
this.author      = &quot;Norby&quot;;
this.copyright   = &quot;2014 Norbert Nagy&quot;;
this.licence     = &quot;CC BY-NC-SA 4.0&quot;;
this.description = &quot;This escort can fit into mini landing pads&quot;;

this.allowAwardEquipment = function(eqKey, ship, context)
{
//bugfix for eqs with conditions scripts: need double replaceShip() to work!
//player.replaceShip(shipname, pers); player.replaceShip(shipname, pers);
//call twice! the first always got false for allow without run this script.
//Proof: if you uncomment the following line, only the 2nd call will write into the log.
//log(&quot;notforsmall&quot;, eqKey+&quot; &quot;+ship.name+&quot; &quot;+ship.mass+&quot; &quot;+context );

	var w = worldScripts.escortdeck;
	if( ship.mass &gt;= w.$EscortDeckMinMass
		&amp;&amp; w.$EscortDeck_isFreePadFor(eqKey, ship, context, w, true) //the last true allow mini pads
		&amp;&amp; ( ship.equipmentStatus(&quot;EQ_ESCORTDECK&quot;) == &quot;EQUIPMENT_OK&quot;
		|| ship.equipmentStatus(&quot;EQ_ESCORTDECKXL&quot;) == &quot;EQUIPMENT_OK&quot; )
		&amp;&amp; player.ship &amp;&amp; player.ship.docked &amp;&amp; system.mainStation
		&amp;&amp; player.ship.dockedStation == system.mainStation )
		return true;
	else return false;
}
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/escortdeck_condition_minipirate.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name        = &quot;escortdeck_condition_minipirate&quot;;
this.author      = &quot;Norby&quot;;
this.copyright   = &quot;2014 Norbert Nagy&quot;;
this.licence     = &quot;CC BY-NC-SA 4.0&quot;;
this.description = &quot;This escort can fit into mini landing pads&quot;;

this.allowAwardEquipment = function(eqKey, ship, context)
{
//bugfix for eqs with conditions scripts: need double replaceShip() to work!
//player.replaceShip(shipname, pers); player.replaceShip(shipname, pers);
//call twice! the first always got false for allow without run this script.
//Proof: if you uncomment the following line, only the 2nd call will write into the log.
//log(&quot;notforsmall&quot;, eqKey+&quot; &quot;+ship.name+&quot; &quot;+ship.mass+&quot; &quot;+context );

	var w = worldScripts.escortdeck;
	if( ship.mass &gt;= w.$EscortDeckMinMass
		&amp;&amp; w.$EscortDeck_isFreePadFor(eqKey, ship, context, w, true) //the last true allow mini pads
		&amp;&amp; ( ship.equipmentStatus(&quot;EQ_ESCORTDECK&quot;) == &quot;EQUIPMENT_OK&quot;
		|| ship.equipmentStatus(&quot;EQ_ESCORTDECKXL&quot;) == &quot;EQUIPMENT_OK&quot; )
		&amp;&amp; player.ship &amp;&amp; player.ship.docked &amp;&amp; system.mainStation
		&amp;&amp; player.ship.dockedStation != system.mainStation )
		return true;
	else return false;
}
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/escortdeck_condition_small.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name        = &quot;escortdeck_condition_small&quot;;
this.author      = &quot;Norby&quot;;
this.copyright   = &quot;2014 Norbert Nagy&quot;;
this.licence     = &quot;CC BY-NC-SA 4.0&quot;;
this.description = &quot;Escorts can not fit into small ships and need a deck&quot;;
this.version     = &quot;1.0&quot;;

this.allowAwardEquipment = function(eqKey, ship, context)
{
//bugfix for eqs with conditions scripts: need double replaceShip() to work!
//player.replaceShip(shipname, pers); player.replaceShip(shipname, pers);
//call twice! the first always got false for allow without run this script.
//Proof: if you uncomment the following line, only the 2nd call will write into the log.
//log(&quot;notforsmall&quot;, eqKey+&quot; &quot;+ship.name+&quot; &quot;+ship.mass+&quot; &quot;+context );

	var w = worldScripts.escortdeck;
	if( ship.mass &gt;= w.$EscortDeckMinMass
		&amp;&amp; w.$EscortDeck_isFreePadFor(eqKey, ship, context, w)
		&amp;&amp; ( ship.equipmentStatus(&quot;EQ_ESCORTDECK&quot;) == &quot;EQUIPMENT_OK&quot;
		|| ship.equipmentStatus(&quot;EQ_ESCORTDECKXL&quot;) == &quot;EQUIPMENT_OK&quot; ) )
		return true;
	else return false;
}
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/escortdeck_condition_smallpirate.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name        = &quot;escortdeck_condition_smallpirate&quot;;
this.author      = &quot;Norby&quot;;
this.copyright   = &quot;2014 Norbert Nagy&quot;;
this.licence     = &quot;CC BY-NC-SA 4.0&quot;;
this.description = &quot;Geckos available outside main stations only&quot;;
this.version     = &quot;1.0&quot;;

this.allowAwardEquipment = function(eqKey, ship, context)
{
//bugfix for eqs with conditions scripts: need double replaceShip() to work!
//player.replaceShip(shipname, pers); player.replaceShip(shipname, pers);
//call twice! the first always got false for allow without run this script.
//Proof: if you uncomment the following line, only the 2nd call will write into the log.
//log(&quot;notforsmall&quot;, eqKey+&quot; &quot;+ship.name+&quot; &quot;+ship.mass+&quot; &quot;+context );

	var w = worldScripts.escortdeck;
	if( ship.mass &gt;= w.$EscortDeckMinMass
		&amp;&amp; ( ship.equipmentStatus(&quot;EQ_ESCORTDECK&quot;) == &quot;EQUIPMENT_OK&quot;
		|| ship.equipmentStatus(&quot;EQ_ESCORTDECKXL&quot;) == &quot;EQUIPMENT_OK&quot; )
		&amp;&amp; w.$EscortDeck_isFreePadFor(eqKey, ship, context, w)
		&amp;&amp; player.ship &amp;&amp; player.ship.docked &amp;&amp; system.mainStation
		&amp;&amp; player.ship.dockedStation != system.mainStation )
		return true;
	else return false;
}
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/escortdeck_escort.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name        = &quot;escortdeck_escort&quot;;
this.author      = &quot;Norby&quot;;
this.copyright   = &quot;2014 Norbert Nagy&quot;;
this.licence     = &quot;CC BY-NC-SA 4.0&quot;;
this.description = &quot;AI support functions for escorts&quot;;


this.$debug = true;
this._landing = function() {this._landing2(this.ship);}

this._landing2 = function(ship) {
    var w = worldScripts.escortdeck;
    var p = player.ship;
    if( !p || !p.isValid ) return;
    ship.target = p;
    var dpos = p.position.add(p.velocity.multiply(2)); //target ahead the player when move
    ship.savedCoordinates = dpos; // must use setDestinationToTarget also
    ship.desiredRange = 0;
    var cd = p.collisionRadius + ship.collisionRadius + 50; //contact distance + a few for the deck
    var d = ship.position.distanceTo(p.position);
    if( d &lt; w.$EscortDeckLandingDist ) { //enough near?
        var landnow = true;
        if( p.addCollisionException ) { //from Oolite v1.81
            p.addCollisionException(ship);
            if( d &gt; cd ) {
                landnow = false; //not so near
                //apply &quot;tractor beam&quot; to pull this fighter to the deck
                var v = p.position.add(p.heading.multiply(-p.collisionRadius)).subtract(ship.position);
                //ship.velocity = v.direction().multiply(200).add(v.multiply(0.3)).add(p.velocity);
                ship.velocity = v.direction().multiply(75).add(v.multiply(0.3)).add(p.velocity);
            }
        }
        if(landnow) {
            var pad = w.$EscortDeckShip.indexOf(ship);
            if( pad &gt; -1 &amp;&amp; !w.$EscortDeck_PutShip(false, ship, pad, p, w, true, true) )
                ship.AIState = &quot;DECK&quot;; //landed
            else ship.AIState = &quot;FOLLOW&quot;; //no room or replaced with another ship
//            ship.reportAIMessages = false;
            return;
        }
    }
    //do not attack hostiles during landing
    if( d &lt;= cd ) ship.reactToAIMessage(&quot;PLAYER_NEXT&quot;);
    else if( d &lt; w.$EscortDeckLandingDist ) ship.reactToAIMessage(&quot;PLAYER_NEAR&quot;);
    else {
        if (ship.fuel &gt;= 0.5) {
            if( ship.injectorSpeedFactor &gt; 0 )
                ship.desiredSpeed = ship.injectorSpeedFactor * ship.maxSpeed;
            else ship.desiredSpeed = 7 * ship.maxSpeed; //for Oolite 1.80
        } else ship.desiredSpeed = ship.maxSpeed;
        ship.reactToAIMessage(&quot;PLAYER_FAR&quot;);
    }
//    ship.performFlyToRangeFromDestination();
}

this._locatePlayer = function() {this._locatePlayer2(this.ship);}

this._locatePlayer2 = function(ship) {
    var p = player.ship;
    if( !p || !p.isValid ) return;
    var sc = ship.script;
    ship.target = p;
    ship.savedCoordinates = p.position;
    var d = ship.position.distanceTo(p.position);
    if (player.alertCondition === 3 &amp;&amp; sc._inEscortFleet2(ship)  &amp;&amp; d &lt; 25600) {
        //if not in fleet then follow but not defend the player, just himself
        if (this.$debug) log(&quot;escortdeck_escortdeck&quot;, &quot;_locatePlayer: &quot;+ship.displayName+&quot; target:&quot;+ p.displayName+&quot; distance:&quot;+d.toFixed(0)+&quot;, GOTO&quot;);
        ship.AIState = &quot;GOTO&quot;; //attack hostiles
    } else {
        if( d &lt; 1500 ) {
            if (this.$debug) log(&quot;escortdeck_escortdeck&quot;, &quot;_locatePlayer: &quot;+ship.displayName+&quot; target:&quot;+ p.displayName+&quot; distance:&quot;+d.toFixed(0)+&quot;, PLAYER_NEXT_1&quot;);
            ship.reactToAIMessage(&quot;PLAYER_NEXT_1&quot;);
        } else if ( d &lt; 5000 ) {
            if (this.$debug) log(&quot;escortdeck_escortdeck&quot;, &quot;_locatePlayer: &quot;+ship.displayName+&quot; target:&quot;+ p.displayName+&quot; distance:&quot;+d.toFixed(0)+&quot;, PLAYER_NEAR_1_5&quot;);
            ship.reactToAIMessage(&quot;PLAYER_NEAR_1_5&quot;);
        } else if (d &lt;= 15000) {
            if (this.$debug) log(&quot;escortdeck_escortdeck&quot;, &quot;_locatePlayer: &quot;+ship.displayName+&quot; target:&quot;+ p.displayName+&quot; distance:&quot;+d.toFixed(0)+&quot;, PLAYER_FAR_5_15&quot;);
            ship.reactToAIMessage(&quot;PLAYER_FAR_5_15&quot;);
        } else if (d &lt;= 25000) {
            if (this.$debug) log(&quot;escortdeck_escortdeck&quot;, &quot;_locatePlayer: &quot;+ship.displayName+&quot; target:&quot;+ p.displayName+&quot; distance:&quot;+d.toFixed(0)+&quot;, PLAYER_FAR_15_25&quot;);
            ship.reactToAIMessage(&quot;PLAYER_FAR_15_25&quot;);
        } else {
            if (this.$debug) log(&quot;escortdeck_escortdeck&quot;, &quot;_locatePlayer: &quot;+ship.displayName+&quot; target:&quot;+ p.displayName+&quot; distance:&quot;+d.toFixed(0)+&quot;, PLAYER_FAR_25_&quot;);
            ship.reactToAIMessage(&quot;PLAYER_FAR_25_&quot;);
        }
    }
}

this._combatCheck = function() {this._combatCheck2(this.ship);}

this._combatCheck2 = function(ship) {
    var p = player.ship;
    if( !p || !p.isValid ) return;
    var sc = ship.script;

    if(ship.target &amp;&amp; ship.target.isDerelict)
    {
        ship.target = null;
        ship.reactToAIMessage(&quot;TARGET_EJECTED&quot;);
    }
    
    var t = sc._playerTarget2(ship);
    if( !ship.target || !ship.target.isValid
        || t &amp;&amp; t.isValid &amp;&amp; ship.target != t ) {
        ship.AIState = &quot;GOTO&quot;; //find new target or player set new target
        return;
    }
    
    if( ship.position.distanceTo(p.position) &gt; 24000 ) {
        // if escort is far from the player, break off combat
        if( ship.target &amp;&amp; ship.target != sc._findPlayerNearestHostile2(ship) ) {
            ship.target = null;
            ship.AIState = &quot;GOTO&quot;; //change target to the player&#39;s nearest hostile
        }
    } else {
        var e = ship.energy;
        var m = ship.maxEnergy;
        ship.savedCoordinates = ship.target.position;
        if( e &lt; m * 0.4 ) //cautious: flee if energy is below 40%
            ship.AIState=&quot;FLEE&quot;; //avoid firing ECM
        else if( sc._Inject2(ship.target,ship) ) { //inject?
            if( ship.AIState == &quot;INJECT&quot; )
                ship.reactToAIMessage(&quot;ENEMY_FIRE&quot;);
            else ship.AIState = &quot;INJECT&quot;; //switch to inject
        } else {
            if( ship.AIState == &quot;ATTACK&quot; )
                ship.reactToAIMessage(&quot;ENEMY_FIRE&quot;);
            else ship.AIState = &quot;ATTACK&quot;; //no more inject
        }
    }
}

this._findPlayerHostiles = function(caller) {
    if (this.$debug) log(this.name, this.ship.displayName+&quot; _findPlayerHostiles called from &quot;+caller);
    this._findPlayerHostiles2(this.ship);
}

this._findPlayerHostiles2 = function(ship) {
    var p = player.ship;
    if( !p || !p.isValid ) return;
    var sc = ship.script;

    if( !sc._inEscortFleet2(ship) ) { //follow but not defend the player, just himself
        ship.target = null;
        if (this.$debug) log(&quot;escortdeck_escortdeck&quot;, ship.displayName+&quot; - findPlayerHostiles: not acting as escort&quot;);
        ship.reactToAIMessage(&quot;NO_HOSTILE_FOUND&quot;);
    }
    if (this.$debug) log(&quot;escortdeck_escortdeck&quot;, ship.displayName+&quot; - findPlayerHostiles: player&#39;s target: &quot;+(p.target ? p.target.displayName+&quot; at &quot;+ship.position.distanceTo(p.target).toFixed(1) : &quot;None&quot;));

    if (ship.target &amp;&amp; ship.target.isValid &amp;&amp; sc._isHostileToPlayer(ship.target)) {
        if (this.$debug) log(&quot;escortdeck_escortdeck&quot;, ship.displayName+&quot; - findPlayerHostiles: keeping the current target: &quot;+ship.target.displayName+&quot;, at &quot;+ship.position.distanceTo(ship.target).toFixed(1));
        sc._foundPlayerHostile2( ship.target, ship ); //keep the current target
        return;
    }

    var hostile = sc._findPlayerNearestHostile2(ship);
    if (hostile) {
        if (this.$debug) log(&quot;escortdeck_escortdeck&quot;, ship.displayName+&quot; - findPlayerHostiles: targeting hostile closest to player: &quot;+hostile.displayName+&quot; at &quot;+ship.position.distanceTo(hostile));
        sc._foundPlayerHostile2(hostile, ship);
    } else {
        var t = sc._playerTarget2(ship); //follow target changes of player
        if (this.$debug) log(&quot;escortdeck_escortdeck&quot;, ship.displayName+&quot; - findPlayerHostiles: :_playerTarget2 returned &quot;+t);
        if (t &amp;&amp; t.isValid) {
            if (this.$debug) log(&quot;escortdeck_escortdeck&quot;, ship.displayName+&quot; - findPlayerHostiles: targeting player&#39;s target: &quot;+t.displayName);
            sc._foundPlayerHostile2(t, ship);
            return;
        }

        if (this.$debug) log(&quot;escortdeck_escortdeck&quot;, ship.displayName+&quot; - findPlayerHostiles: No hostiles found&quot;);
        ship.target = p;
        ship.reactToAIMessage(&quot;NO_HOSTILE_FOUND&quot;);
    }
}

this._findPlayerNearestHostile = function() {this._findPlayerNearestHostile2(this.ship);}

this._findPlayerNearestHostile2 = function(ship) {
    var sc = ship.script;
    var pship = player.ship;  
    var hostile = null;
    var distance, distance_tmp;
    var targets = pship.checkScanner(true);//much faster than filteredEntities
    if (targets &amp;&amp; targets.length &gt; 0) {
        var i = targets.length;
        while (i--) {
            var t = targets[i];
            if( t &amp;&amp; t.isValid &amp;&amp; sc._isHostileToPlayer( t ) ) {
                distance_tmp = t.position.distanceTo(pship);
                if (!distance || (distance &amp;&amp; distance &gt; distance_tmp)) {
                    distance = distance_tmp;
                    hostile = t;
                }
            }
        }
    }
    return(hostile);
}

this._fireCheck = function() {this._fireCheck2(this.ship);}

this._fireCheck2 = function(ship) {
    var t = ship.target;
    if( !t || !t.isValid || t.isPlayer || (t.script &amp;&amp; ( t.script.$EscortDeckUsable &gt; 0
        || t.script.$CarriersShipStorageID &gt; -1 ) ) ) {
        if (this.$debug) log(this.name, ship.displayName+&quot; _fireCheck, FRIENDLY_FIRE, target: &quot;+t.displayName+&quot;, escort:&quot;+t.script.$EscortDeckUsable+&quot;, carrierEscort:&quot;+t.script.$CarriersShipStorageID);
        ship.target = null;
        ship.reactToAIMessage(&quot;FRIENDLY_FIRE&quot;);
    } else {
        if (this.$debug) log(this.name, ship.displayName, &quot; energy &quot;+ship.energy+&quot;, _fireCheck, ENEMY_FIRE, target: &quot;+t.displayName+&quot; at &quot;+ship.position.distanceTo(t));
        ship.reactToAIMessage(&quot;ENEMY_FIRE&quot;);
    }
}

this._fleeCheck = function() {this._fleeCheck2(this.ship);}

this._fleeCheck2 = function(ship) {
    var e = ship.energy;
    var m = ship.maxEnergy;
    if( (!ship.target || !ship.target.isMissile) &amp;&amp; e &gt; m * 0.8 ) {
        //not a missile run and recovered 80% energy
        ship.AIState = &quot;GOTO&quot;;
    }
}

this._foundPlayerHostile = function( hostile ) {this._foundPlayerHostile2(hostile, this.ship);}

this._foundPlayerHostile2 = function( hostile, ship ) {
    var sc = ship.script;

    if( !hostile || !hostile.isValid) {
        ship.AIState = &quot;FOLLOW&quot;; //find new target
        return;
    }
    
    ship.target = hostile;
    ship.savedCoordinates = hostile.position;
    var sniper = false;
    if( sc._isSniper2(ship) ) {
        if (this.$debug) log(&quot;escortdeck_escortdeck&quot;, ship.displayName+&quot; - foundPlayerHostile: &quot;+hostile.displayName+&quot; at &quot;+ship.position.distanceTo(hostile)+&quot;, SNIPING&quot;);
        ship.reactToAIMessage(&quot;SNIPING&quot;);
    } else if(sc._Inject2(hostile, ship)) {
        if (this.$debug) log(&quot;escortdeck_escortdeck&quot;, ship.displayName+&quot; - foundPlayerHostile: &quot;+hostile.displayName+&quot; at &quot;+ship.position.distanceTo(hostile)+&quot;, HOSTILE_FAR&quot;);
        ship.reactToAIMessage(&quot;HOSTILE_FAR&quot;); //inject
    } else {
        if (this.$debug) log(&quot;escortdeck_escortdeck&quot;, ship.displayName+&quot; - foundPlayerHostile: &quot;+hostile.displayName+&quot; at &quot;+ship.position.distanceTo(hostile)+&quot;, HOSTILE_FOUND&quot;);
        ship.reactToAIMessage(&quot;HOSTILE_FOUND&quot;); //attack
    }
}

this._inEscortFleet = function() {this._inEscortFleet2(this.ship);}

this._inEscortFleet2 = function(ship) { //if not then follow but not defend the player, just himself
    var w = worldScripts.escortdeck;
    if( w.$EscortDeckShip.indexOf(ship) &gt; -1 ) return true;
    return false;
}

this._isHostileToPlayer = function(entity) {
    return (entity.isThargoid || (entity.isShip &amp;&amp; !entity.isPlayer &amp;&amp; entity.target
        &amp;&amp; !entity.isDerelict &amp;&amp; ( entity.target == player.ship &amp;&amp; entity.hasHostileTarget
            || entity.script &amp;&amp; entity.script.$EscortDeck_Target )
        &amp;&amp; ( !entity.script || !entity.script.$CarriersShipStorageID //is not owned by player
            || entity.script.$CarriersShipStorageID == -1
            || !( entity.script.$EscortDeckUsable &gt; 0 ))));
}

this._isSniper = function() {this._isSniper2(this.ship);}

this._isSniper2 = function(ship) {
    var l = ship.forwardWeapon.equipmentKey;
    if( l === &quot;EQ_WEAPON_MILITARY_LASER&quot; ) return true;
    else if( l ) {  //Oolite 1.81 can define custom lasers
        var weapon_info = ship.forwardWeapon.weaponInfo;
        if (weapon_info &amp;&amp; weapon_info.range &gt; 15000 ) return true;
    }
    return false;
}

this._Inject = function(target) {this._Inject2(target, this.ship);}

this._Inject2 = function(target, ship) { //can use injectors and farther than 10km?
    if(ship &amp;&amp; target &amp;&amp; target.isValid &amp;&amp; ship.fuel &gt; 0
        &amp;&amp; ship.equipmentStatus(&quot;EQ_FUEL_INJECTION&quot;) === &quot;EQUIPMENT_OK&quot;
        &amp;&amp; ship.position.distanceTo(target) &gt; 10000 ) {
        //more conditions: not enogh good accuracy, faster target or short range laser?
        if ( ship.accuracy &lt; 7.5 || target.speed &gt; ship.maxspeed )
            return true;
        var l = ship.forwardWeapon.equipmentKey;
        if( l === &quot;EQ_WEAPON_PULSE_LASER&quot; ) return true;
        else if( l ) {  //Oolite 1.81 can define custom lasers
            var weapon_info = ship.forwardWeapon.weaponInfo;
            if (weapon_info &amp;&amp; weapon_info.range &lt; 15000 ) return true;
        }
    }
    return false;
}

this._playerTarget = function() {this._playerTarget2(this.ship);}

this._playerTarget2 = function(ship) {
    var t = player.ship.target;
    if( t &amp;&amp; t.isValid &amp;&amp; !t.isDerelict &amp;&amp; ( !t.script || !( t.script.$EscortDeck_Usable &gt; 0 ) )
        &amp;&amp; ( t.bounty &gt; 2 || t.script &amp;&amp; t.script.$EscortDeck_Target ) &amp;&amp; //nonclean or player fired it
        t.scanClass !== &quot;CLASS_CARGO&quot; // avoid escape capsules
//        &amp;&amp; ship.position.distanceTo(t.position) &lt; ship.scannerRange )
      )
        return(t);
    return(null);
}


//ship script events
this.shipCollided = function(otherShip) {
    var w = worldScripts.escortdeck;
    if( otherShip == player.ship &amp;&amp; this.ship.energy &lt; 50
        &amp;&amp; !this.ship.addCollisionException //before Oolite 1.81
        &amp;&amp; w.$EscortDeckShip.indexOf(this.ship) &gt; -1 )
        this.ship.energy = 50; //prevent kill owned escorts by accident
}

this.shipTargetDestroyed = function(target) {
    if(this.ship == player.ship) return; //exit if worldScript, do in ship script only
    if(target.primaryRole == &quot;constrictor&quot; &amp;&amp; missionVariables.conhunt &amp;&amp; missionVariables.conhunt == &quot;STAGE_1&quot;) {
        // just in case an escort kills the constrictor, let&#39;s not break the mission for the player...
        missionVariables.conhunt = &quot;CONSTRICTOR_DESTROYED&quot;;
    }
    
    if(target.isRock || target.isBoulder || target.isCargo || target.isDerelict || target.isWeapon)
        return;
    
//    player.score += 1; - score should remain personal
    player.credits += target.bounty;
    if( this.$EscortDeckUsable &gt; 0 || this.$CarriersShipStorageID &gt; -1 )
        player.consoleMessage(this.ship.displayName+&quot; killed &quot;
            + target.name + &quot; : &quot; + target.bounty + &quot; awarded.&quot;, 5);
    log(this.name, this.ship.displayName+&quot; killed &quot; + target.name + &quot; : &quot; + target.bounty +&quot;&quot;);
}

this.shipDied = function(whom,why) {
    if(this.ship == player.ship) return; //exit if worldScript, do in ship script only
    var w = worldScripts.escortdeck;

    //increase steering and acceleration in proportion with the smaller mass on deck
    w.$EscortDeck_SetMaxs( player.ship, w );

    var pad = w.$EscortDeckShip.indexOf(this.ship);
    if( pad &gt; -1 ) w.$EscortDeckShipData[pad] = null; //prevent recreation in dock
    
    if( whom &amp;&amp; whom.isValid &amp;&amp; (this.$EscortDeckUsable &gt; 0
        || this.$CarriersShipStorageID &gt; -1 )) {
        player.commsMessage(this.ship.displayName+&quot; terminated.&quot;, 10);
    }
    log(this.name, this.ship.displayName+&quot; terminated by &quot;+whom+&quot; &quot;+why);
}
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/escortdeck_xlcondition.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name        = &quot;escortdeck_xlcondition&quot;;
this.author      = &quot;Norby&quot;;
this.copyright   = &quot;2014 Norbert Nagy&quot;;
this.licence     = &quot;CC BY-NC-SA 4.0&quot;;
this.description = &quot;XL deck equipment can not fit into ships under 400t&quot;;
this.version     = &quot;1.0&quot;;

this.allowAwardEquipment = function(eqKey, ship, context)
{
	var w = worldScripts.escortdeck;
	if( context == &quot;scripted&quot; //needed if player launched in an escort from a Carrier
		|| ship.mass &gt;= w.$EscortDeckXLMass ) return true;
	else return false;
}
</pre></td>
                </tr>
            </table>
        </a>
    </body>
</html>
