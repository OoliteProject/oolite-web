<html>
    <head>
        <title>Expansion Diplomacy</title>
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <table border="0" width="100%">
            <tr>
                <td>Back to <a href='../index.html'>Index</a></td>
                <td align="right"><small>Page generated: Oct 11, 2023, 3:16:48 PM</small></td>
            </tr>
        </table>

        <h1>Expansion Diplomacy</h1>

        <h2>Content</h2>
        <ul>
          
          <li><a href="#manifest">Manifest</a></li>
          <li><a href="#documentation">Documentation</a></li>
          <li><a href="#equipment">0 Equipment</a></li>
          <li><a href="#ships">0 Ships</a></li>
          <li><a href="#models">0 Models</a></li>
          <li><a href="#scripts">10 Scripts</a></li>
        </ul>


        <a name="manifest">
        <h2>Manifest</h2>
            <table border="1">
                <tr>
                    <th></th>
                    <th>from Expansion Manager's OXP list</th>
                    <th>from Expansion Manifest</th>
                </tr>
                <tr>
                    <td>Description</td>
                    <td>WIP: wars maps and History! GNN news concerning alliances and wars! Treasuries! Citizenships! Taxes!
Systems treasury! Wars require money, and countries are defeated either by battles or by bankruptcy, sometimes the latter producing the former.
Strategic maps! New F4 Interface screens: the Wars Map! The Diplomatic Map!
Systems alliances, wars! Two systems within 7ly of each other may now form an alliance, break their alliance, wage war on each other, and make peace too :) !
News! Some GNN news are now displayed when alliance/break/war/peace happens, and the player is in one of those systems.
Citizenships! The player may acquire, or renounce, a system citizenship when visiting this system, for the right price. They may choose which of their citizenships is displayed as their flagship. The player is considered fugitive when in systems warring with their flag. The player may buy visas in the Embassy district.</td>
                    <td>WIP: wars maps and History! GNN news concerning alliances and wars! Treasuries! Citizenships! Taxes!
Systems treasury! Wars require money, and countries are defeated either by battles or by bankruptcy, sometimes the latter producing the former.
Strategic maps! New F4 Interface screens: the Wars Map! The Diplomatic Map!
Systems alliances, wars! Two systems within 7ly of each other may now form an alliance, break their alliance, wage war on each other, and make peace too :) !
News! Some GNN news are now displayed when alliance/break/war/peace happens, and the player is in one of those systems.
Citizenships! The player may acquire, or renounce, a system citizenship when visiting this system, for the right price. They may choose which of their citizenships is displayed as their flagship. The player is considered fugitive when in systems warring with their flag. The player may buy visas in the Embassy district.</td>
                </tr>
                <tr>
                    <td>Identifier</td>
                    <td>oolite.oxp.Day.Diplomacy</td>
                    <td>oolite.oxp.Day.Diplomacy</td>
                </tr>
                <tr>
                    <td>Title</td>
                    <td>Diplomacy</td>
                    <td>Diplomacy</td>
                </tr>
                <tr>
                    <td>Category</td>
                    <td>Ambience</td>
                    <td>Ambience</td>
                </tr>
                <tr>
                    <td>Author</td>
                    <td>Day</td>
                    <td>Day</td>
                </tr>
                <tr>
                    <td>Version</td>
                    <td>0.18</td>
                    <td>0.18</td>
                </tr>
                <tr>
                    <td>Tags</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Required Oolite Version</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Maximum Oolite Version</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Required Expansions</td>
                    <td>
                            <li>oolite.oxp.Svengali.GNN:0</li>
                            <li>oolite.oxp.Commander_McLane.Anarchies:0</li>
                    </td>
                    <td>
                            <li>oolite.oxp.Svengali.GNN:0</li>
                            <li>oolite.oxp.Commander_McLane.Anarchies:0</li>
                    </td>
                </tr>
                <tr>
                    <td>Optional Expansions</td>
                    <td>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>Conflict Expansions</td>
                    <td>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>Information URL</td>
                    <td><a target="_blank" href="http://wiki.alioth.net/index.php/Diplomacy">http://wiki.alioth.net/index.php/Diplomacy</a></td>
                    <td><a target="_blank" href="">n/a</a></td>
                </tr>
                <tr>
                    <td>Download URL</td>
                    <td><a target="_blank" href="https://github.com/DaymareOn/Diplomacy/raw/master/oolite.oxp.Day.Diplomacy.oxz">https://github.com/DaymareOn/Diplomacy/raw/master/oolite.oxp.Day.Diplomacy.oxz</a></td>
                    <td><a target="_blank" href="">n/a</a></td>
                </tr>
                <tr>
                    <td>License</td>
                    <td>CC BY-NC-SA 4</td>
                    <td>CC BY-NC-SA 4</td>
                </tr>
                <tr>
                    <td>File Size</td>
                    <td>n/a</td>
                </tr>
                <tr>
                    <td>Upload date</td>
                    <td>n/a</td>
                </tr>
            </table>
                </a>

        <a name="documentation">
        <h2>Documentation</h2>
        <p>Also read <a href='http://wiki.alioth.net/index.php/Diplomacy'>http://wiki.alioth.net/index.php/Diplomacy</a></p>
        <h3>Diplomacy_EngineAPI_readme.txt</h3>
        <pre>FIXME reintegrate this to DayDiplomacy_JsDocDiplomacy.js
An &#39;EventType&#39; is a string defined by an oxp developer. As an example, the system taxation EventType is &quot;SELFTAX&quot;.
EventTypes are stored in an ordered array, so that &quot;Event&quot;s&#39; &quot;Response&quot;s and &quot;Action&quot;s may be executed in a designed order
(for example, &quot;VICTORY&quot; should follow &quot;ATTACK&quot; and not happen before :) ).
For a same EventType, recurrent &quot;Action&quot;s are executed before &quot;Event&quot;s.

An &#39;ActorType&#39; is a string defined by an oxp developer. As an example, the system ActorType is &quot;SYSTEM&quot;.
ActorTypes are stored in an ordered array, so that &quot;Event&quot;s&#39; &quot;Response&quot;s and &quot;Action&quot;s may be executed in a designed order
(for example, &quot;SYSTEM&quot;s should act before &quot;ALLIANCE&quot;s as information come to alliances through their systems :) ).
For a same ActorType, recurrent &quot;Action&quot;s are executed before &quot;Event&quot;s.

An &quot;Action&quot; may be said init (only executed once at the creation of an Actor) or recurring (executed each turn).
An &quot;Action&quot; encapsulates a function, which typically will fire Events, or act onto the Oolite world.
It contains: an &#39;EventType&#39;, an &#39;ActorType&#39; (whose kind of actors will execute this action?), and a function.

An &quot;Event&quot; is something done by an &quot;Actor&quot;, to which other Actors may react by some &quot;Response&quot;s.
It contains: an &#39;EventType&#39;, the acting Actor id, and some args to be used by the Responses (defined by the oxp developer).

An &quot;Actor&quot; is everything which should react to events. Systems are Actors, Alliances will be.
It contains : an &#39;ActorType&#39;, the Actor id, its responses, and the observing other actors&#39; ids.
An Actor observer is another actor which may react onto that actor events.
This is useful so that for example only near systems may react to an event, and not far away systems.
It&#39;s useful to limit the cpu load too by at least a factor 100.

A &quot;Response&quot; encapsulates a function.
It contains: an Id, the &#39;EventType&#39; to which it responds, the &#39;ActorType&#39; of actors which will use this response, and a function which may use the args given in the event.

When docked in station, once every 10 frames, an action (event, response, etc) is realized.
A &#39;turn&#39; of events is allowed each jump.
Before beginning a new &#39;turn&#39;, all the actions of the precedent turn have been realized.</pre>
        <h3>Diplomacy_readme.txt</h3>
        <pre>Diplomacy OXP

==============================
Summary
1. Description
2. What&#39;s currently implemented functionality-wise?
3. What&#39;s currently implemented technically?
4. Effects on game difficulty
5. Effects on game performance
6. Compatibility
7. Dependencies
8. Instructions
9. License
10. Known bugs
11. Changelog

==============================
Description

Hello everybody,

this OXP intended goal is to allow historical events to happen between systems (attacks, loots,
 alliances, taxes...), and to have actions depending on this (news, massed flotillas, state racket, who knows?).
Technically, I see it as a war/diplomacy framework. It includes a good JsDoc for oxp developers.

It is STILL a Work In Progress.

In particular, the savefile format might change in the future; so it wouldn&#39;t do to expect a savefile from an old
 version to work with a newer version code.
If experimenting problems, the easy way is to edit the savefile and remove the lines including &quot;Diplomacy&quot;.
 Then next start, the oxp will begin anew.

==============================
What&#39;s currently implemented functionality-wise?

Systems treasury!
    Wars require money, and countries are defeated either by battles or by bankruptcy,
     sometimes the latter producing the former.
    The Treasury and Tax levels are displayed in the F7 system information.
    Each system treasury is increased through taxation each player jump,
     depending on the time past since the last jump.

Strategic maps!
    Showing the warring systems, and the diplomatic relationships!

Systems alliances, wars!
    Two systems within 7ly of each other may now form an alliance, if they like each other enough.
    They may break their alliance, too =-o !
    They may wage war to each other, and make peace too :) !
    New F4 Interface screen: the Systems History!

News!
    Some GNN news are now displayed when an alliance is formed or broken between two systems,
      or when a war starts or ends between two systems, and the player is in one of those systems.

Citizenships!
    The player may acquire, or renounce, a system citizenship when visiting this system, for the right price. They may
      choose which one of their citizenships is announced as the flag of their ship.
    The player is considered fugitive when in systems warring with their flag.
    Anarchies provide no citizenship and have no embassy district.
    The player may buy days of visa in the Embassy district in a neighbouring, non-enemy from the destination, system.
    Corporate systems, dictatorships and communists refuse docking to the player when stateless and visaless.

==============================
What&#39;s currently implemented technically?

The oxp contains Engines which may be use by developers to implement interesting galaxy-spanning events:
- (main) Engine,
- War,
- History,
- Systems,
- Economy,
- Citizenships.

==============================
Effects on game difficulty

+ the player is considered fugitive when in systems warring with their flag.
+ the player is refused docking in some stations when they have not the requisite visa or passport.
+ some new ways to spend money: passports, visas.

==============================
Effects on game performance

This oxp works only when the player is docked, so there is no impact during the flight time.
During the docking, it works once every ten frames, the effect on player experience should be negligible.
If it isn&#39;t negligible, tell me and I&#39;ll put in the ability to choose the number of frames.
Even if the effect is negligible on the player, it uses lots of cpu, so it might not be negligible on the battery.

==============================
Compatibility

==============================
Dependencies

- GNN OXP
- Anarchies OXP

==============================
Instructions

Do not unzip the .oxz file, just move into the AddOns folder of your Oolite installation.

==============================
License

This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike License version 4.0.
If you are re-using any piece of this OXP, please let me know by sending an e-mail to david at pradier dot info

==============================
Known bugs

None.

==============================
Changelog

0.18    Improvement, user-friendliness: the visa system in-game explanation is clearerer.
0.17    Improvement, user-friendliness: the visa system in-game explanation is clearer.
0.16    Improvement, flavor: the player is considered fugitive when in systems warring with their flag.
        Improvement, flavor: no &quot;Embassy district&quot; in anarchies, no citizenship in an Anarchy
        Improvement, flavor: the player may buy days of visa (cost: productivity / population / 365 per day) in the embassy district in a neighbouring, non-enemy from the destination system.
        Improvement, flavor: the first time the Diplomacy OXP is used, if a visa is needed in the current system, we give the player a 1-day visa.
        Improvement, flavor: a GNN news introduces the Visa Law.
        Improvement, flavor: when stateless, docking is refused in corporates, dictatorships and communists without having a visa.
        Improvement, flavor: maps are centered and zoomed. Possibility to center on the target system, or on the whole trajectory. Possibility to display the short/quick trajectory, or no trajectory at all.
        Improvement, performance: the API are removed in favor of JsDoc.
        Improvement, code quality: the Snoopers dependency, which is deprecated, is replaced by the GNN dependency. Oolite minimal required version is now 1.88, because of this.
        Improvement, code quality: moved the GNN connection to external script.
        Improvement, code quality: tax level and treasury are now displayed through mission.addMessageText rather than through a modification of the system description.
        Improvement, tweaking: the alliance threshold between systems is lowered.
        Bugfix: the initActions wasn&#39;t set as it should be. In particular, initActionsByType wasn&#39;t set when adding an initAction, and initActions was set with an ActorType as key instead of an ActionId.
0.15    Improvement, flavor: the player may acquire or renounce the citizenship of the system they are in.
        Improvement, flavor: the player may display one of their citizenships as the flag of their ship.
        Improvement, dev func: other scripts may subscribe to be informed of a citizenship change of the player.
        Improvement, dev func: citizenships prices are dynamic and available to other scripts.
        Improvement, dev func: other scripts may inquire if the player has a particular citizenship.
        Improvement, code quality: introduced JsDoc comments, including some allowing to document the Oolite javascript hooks!
0.14    Improvement, flavor: War declaration! Peace! Snooper news about them!
        Improvement, flavor: Wars map!
        Improvement, dev func: the war threshold and the alliance threshold are scriptable through the WarEngineAPI.
        Improvement, dev func: new F4 interface making History happen for debug purposes.
        Improvement, code consistency: Alliances scripts become War scripts.
0.13    Bugfix: manifest.plist for the oxz manager.
0.12    Bugfix: manifest.plist for the oxz manager.
0.11    Improvement, flavor: added a F4 Alliances Map, showing alliances between systems.
        Improvement, flavor: having only Snooper news for the player current system.
        Improvement, flavor: fixed Diziet Sma citation
        Improvement, code consistency: the tax script becomes the economy script.
        Improvement, code consistency: removed the TechnicalPrinciples.txt file, as its content is now mainly in the new OXP Performance thread.
        Improvement, dev func: added a beginning of Economy Engine API.
        Improvement, dev func: added a _debug flag in the Engine to start as if you just spent a turn and entered the station; ie, events are processing.
0.10    Improvement, flavor: added a F4 System history, showing the F7-selected system events history. The displayed text depends on a formatting function definable through API per event.
        Improvement, flavor: the alliance and alliance break events are now displayed in the history.
        Improvement, dev func: the EngineAPI provides the events, and the events by actor.
        Improvement, dev func: the EngineAPI allows now to store a variable in the saved state with the other saved variables of the oxp.
        Improvement, dev func: introduced a Systems API and a History API. The systems API provides the system actors indexed by galaxyID and systemID.
0.9     Improvement, flavor: the score given to a system by another depend on who they are allied to.
        Improvement, flavor: systems may now break their alliances.
        Bugfix: systems within 7 ly of any of both systems in the alliance are now informed of the alliance.
        Improvement, dev func: introduced an Alliance API.
0.8     Improvement, flavor: Two systems within 7ly of each other may now form an alliance, depending
        on their relation quality. Currently, each must have a score for the other of at least +0.5.
        Improvement, flavor: some Snooper news are now displayed when an alliance is formed between two systems,
        and the player is within 7ly of one of the allied systems.
        New, oxp dev func: introduced a functional Event system.
0.7     Improvement, flavor: added a F4 Strategic Map, showing links between systems nearer than 7. The relation between systems is currently based on their government.
0.6     Improvement, flavor: tax amount depends on the time spent since the last taxation.
        Improvement, speed: major refactor to remove closures, dereferences, JSON (de)serialization special functions.
0.5     Bugfix manifest.plist for the oxz manager.
0.4     Put into the oxz manager.
0.3     New, oxp dev func: delivered DiplomacyEngineAPI for oxp developers, provided a dedicated readme file.
        New, doc: provided a dedicated file DiplomacyRoadmap.txt
        Improvement, code consistency: the Systems and Tax js script now use the API rather than the native engine calls.
        Improvement, speed: optimized the loops in the engine
        Improvement, logic: when starting, the player is docked, so we should process the saved actions.
        Bugfix: solved a bug in the Tax script recurrent tax task after a savefile load.
        Bugfix: the init action using the api wasn&#39;t working after a restore from the savefile.
        Cleaning: log cleaning, file cleaning.
0.2     The actions are made progressively, one every 10 frames when docked, so as not to need more execution time than allowed at the same time, and to avoid slowdowns during the game.
0.1     First version of the Diplomacy engine. Systems are introduced as a type of &quot;Actor&quot;. &quot;SELFTAX&quot; is introduced as an event for systems. Tax level and treasury are displayed on the F7 screen.</pre>
        </a>

        <a name="equipment">          
        <h2>Equipment</h2>
            This expansion declares no equipment. 
        </a>

        <a name="ships">    
        <h2>Ships</h2>
            This expansion declares no ships. 
        </a>

        <a name="models">    
        <h2>Models</h2>
            This expansion declares no models. 
        </a>

        <a name="scripts">    
        <h2>Scripts</h2>
            <table>
                <tr>
                    <th>Path</th>
                </tr>
                <tr>
                    <td valign="top">Scripts/DayDiplomacy_Citizenships.js</td>
                    <td><pre>&quot;use strict&quot;;

this.name = &quot;DayDiplomacy_060_Citizenships&quot;;
this.author = &quot;Loic Coissard, David Pradier&quot;;
// noinspection JSUnusedGlobalSymbols Used by Oolite itself
this.copyright = &quot;(C) 2019 Loic Coissard, David Pradier&quot;;
// noinspection JSUnusedGlobalSymbols Used by Oolite itself
this.licence = &quot;CC-NC-by-SA 4.0&quot;;
this.description = &quot;This script is the citizenships engine.&quot;;

/* ************************** Public functions ********************************************************/

/**
 * This formula would put the US citizenship at 57.000.000 USD in 2016 and the french one at 37.000.000 USD.
 * Remember everything is a lot more expensive in space!
 * @param {System} aSystem
 * @returns {number} the price to acquire or renounce this citizenship in credits
 * @lends worldScripts.DayDiplomacy_060_Citizenships.$getCitizenshipPrice
 */
this.$getCitizenshipPrice = function (aSystem) {
    // productivity is in 10^6 credits units, and population is in 10^8 people units
    // the price is 1000 years of 1-person productivity: prod*10^6 *1000 / (pop *10^8) = 10*prod/pop
    return Math.round(10 * aSystem.productivity / aSystem.population * 10) / 10;
};

/**
 * This formula would put the US 1-day visa at 15.600 USD in 2016 and the french one at 10.100 USD.
 * Remember everything is a lot more expensive in space!
 * @param {SystemInfo} aSystem
 * @returns {number} the price to acquire or renounce the visa for 1 day in credits
 * @lends worldScripts.DayDiplomacy_060_Citizenships.$getVisaPrice
 */
this.$getVisaPrice = function (aSystem) {
    // the price is 100 days of 1-person productivity: prod*10^6 / (pop*10^8) /365 * 100 = prod/pop/365
    return Math.round(aSystem.productivity / aSystem.population / 365 * 10) / 10;
};

/**
 * @param {int} galaxyID
 * @param {int} systemID
 * @returns {boolean} true if the player has the citizenship
 * @lends worldScripts.DayDiplomacy_060_Citizenships.$hasPlayerCitizenship
 */
this.$hasPlayerCitizenship = function (galaxyID, systemID) {
    var citizenships = this._citizenships;
    var i = citizenships.length;
    while (i--) {
        var planetarySystem = citizenships[i];
        if (planetarySystem.galaxyID === galaxyID &amp;&amp; planetarySystem.systemID === systemID) {
            return true;
        }
    }
    return false;
};

/**
 *
 * @param systemID
 * @return {boolean}
 * @lends worldScripts.DayDiplomacy_060_Citizenships.$hasPlayerVisa
 */
this.$hasPlayerVisa = function(systemID) {
    this._cleaningVisas();
    return this._visas.hasOwnProperty(systemID);
};

/**
 * @param {PlanetarySystem[]} citizenships
 * @returns {string} a displayable list of citizenships
 * @lends worldScripts.DayDiplomacy_060_Citizenships.$buildCitizenshipsString
 */
this.$buildCitizenshipsString = function (citizenships) {
    var result = &quot;&quot;;
    var i = citizenships.length;
    while (i--) {
        result += citizenships[i].name + &quot;, &quot;;
    }
    if (result.length) { // We delete the comma at the end of the string
        result = result.substring(0, result.length - 2);
    }
    return result;
};

this.$buildVisasString = function () {
    this._cleaningVisas(); // Cleaning obsolete visas before displaying visas
    var visas = this._visas;
    var result = &quot;&quot;;
    var now = clock.seconds;
    for (var systemID in visas) {
        if (visas.hasOwnProperty(systemID)) {
            var systemInfo = System.infoForSystem(system.info.galaxyID, systemID);
            var remainingTime = visas[systemID] - now;
            var remainingHours = Math.floor(remainingTime / 3600);
            var remainingMinutes = Math.floor((remainingTime - remainingHours * 3600) / 60);
            result += &quot;\n   &quot; + systemInfo.name + &quot;: &quot; + remainingHours + &quot; h &quot; + remainingMinutes + &quot; min&quot; + &quot;,&quot;
        }
    }

    if (result.length) { // We delete the comma at the end of the string
        result = result.substring(0, result.length - 1);
    } else {
        result = &quot;none&quot;;
    }
    return result;
};

/**
 * Allows the script which name is given as argument to be called through the method $playerCitizenshipsUpdated
 * each time the player citizenships are updated. The script must implement that method: this.$playerCitizenshipsUpdated = function(citizenships) {}
 * @param {string} scriptName the script.name
 * @lends worldScripts.DayDiplomacy_060_Citizenships.$subscribeToPlayerCitizenshipsUpdates
 */
this.$subscribeToPlayerCitizenshipsUpdates = function (scriptName) {
    (this._playerCitizenshipsUpdatesSubscribers || (this._playerCitizenshipsUpdatesSubscribers = [])).push(scriptName);
};

/* ************************** OXP private functions *******************************************************/

/**
 * @param {number} price
 * @returns {boolean} true if there was enough money to pay
 * @private
 */
this._payIfCapable = function(price) {
    if (player.credits &gt;= price) {
        player.credits -= price;
        return true;
    }
    return false;
};

/**
 * Allows the player to acquire a citizenship
 * @param {int} galaxyID the galaxyID of the citizenship
 * @param {int} systemID the systemID of the citizenship
 * @returns {boolean} true if the player had the money to acquire the citizenship
 * @private
 */
this._buyCitizenship = function (galaxyID, systemID) {
    if (this._payIfCapable(this.$getCitizenshipPrice(system))) { // FIXME incorrect price if not asking for the current system
        this._citizenships.push({
            &quot;galaxyID&quot;: galaxyID,
            &quot;systemID&quot;: systemID,
            &quot;name&quot;: this._Systems.$retrieveNameFromSystem(galaxyID, systemID)
        });
        return true;
    }
    return false;
};

/**
 * Allows the player to renounce a citizenship
 * @param {int} galaxyID the galaxyID of the citizenship
 * @param {int} systemID the systemID of the citizenship
 * @returns {boolean} true if the citizenship has been renounced
 * @private
 */
this._loseCitizenship = function (galaxyID, systemID) {
    if (this._payIfCapable(this.$getCitizenshipPrice(system))) { // FIXME incorrect price if not asking for the current system
        var citizenships = this._citizenships;
        var i = citizenships.length;
        while (i--) {
            var planetarySystem = citizenships[i];
            if (planetarySystem.galaxyID === galaxyID &amp;&amp; planetarySystem.systemID === systemID) {
                if (this._flag.galaxyID === galaxyID &amp;&amp; this._flag.systemID === systemID) {
                    delete this._flag.galaxyID;
                    delete this._flag.systemID;
                    delete this._flag.name;
                }
                citizenships.splice(i, 1);
                return true;
            }
        }
    }
    return false;
};

/**
 *
 * @private
 */
this._cleaningVisas = function () {
    var now = clock.seconds;
    var visas = this._visas;
    for (var systemID in visas) {
        if (visas.hasOwnProperty(systemID)) {
            if (visas[systemID] &lt;= now) {
                delete visas[systemID];
            }
        }
    }
};

/**
 * Displays the citizenship&#39;s screen allowing the player to buy and lose citizenships, to display their citizenships
 * and to choose which citizenship is displayed.
 * @param {boolean} notEnoughMoney set to true if a previous command failed because the player had not enough money
 * @private
 */
this._runCitizenship = function (notEnoughMoney) {
    player.ship.hudHidden || (player.ship.hudHidden = true);

    var info = system.info;
    var currentGalaxyID = info.galaxyID;
    var currentSystemID = info.systemID;
    var currentSystemName = this._Systems.$retrieveNameFromSystem(currentGalaxyID, currentSystemID);
    var currentCitizenships = this._citizenships;
    var i = currentCitizenships.length;
    var price = this.$getCitizenshipPrice(system);
    var currentFlag = this._flag;

    // Exit choice, and displayed information
    var opts = {
        screenID: &quot;DiplomacyCitizenshipsScreenId&quot;,
        title: &quot;Embassy&quot;,
        allowInterrupt: true,
        exitScreen: &quot;GUI_SCREEN_INTERFACES&quot;,
        choices: {&quot;6_EXIT&quot;: &quot;Exit&quot;},
        message: &quot;Your credits: &quot; + (Math.round(player.credits * 10) / 10) + &quot; ₢\n&quot;
            + (notEnoughMoney ? &quot;You had not enough money to do this.\n&quot; : &quot;&quot;)
            + &quot;Your flag: &quot; + (currentFlag.name || &quot;stateless&quot;)
            + &quot;\nYour passports: &quot; + (i ? this.$buildCitizenshipsString(currentCitizenships) : &quot;none&quot;) // FIXME &quot;none&quot; should be in the $build
            + &quot;\nYour visas: &quot; + this.$buildVisasString()
    };

    // Choices to acquire or renounce the system citizenship
    var currentChoices = opts.choices;
    if (this.$hasPlayerCitizenship(currentGalaxyID, currentSystemID)) {
        currentChoices[&quot;2_LOSE&quot;] = &quot;Renounce your &quot; + currentSystemName + &quot;ian passport for a cost of &quot; + price + &quot; ₢&quot;;
    } else {
        currentChoices[&quot;1_BUY&quot;] = &quot;Acquire &quot; + currentSystemName + &quot; citizenship for a cost of &quot; + price + &quot; ₢&quot;;
    }

    // Choosing which among the owned citizenships to display as the flagship
    while (i--) {
        var planetarySystem = currentCitizenships[i];
        // We don&#39;t propose the current flagship
        if (!(currentFlag.galaxyID === planetarySystem.galaxyID &amp;&amp; currentFlag.systemID === planetarySystem.systemID)) {
            currentChoices[&quot;3_DISPLAY_&quot; + planetarySystem.galaxyID + &quot;_&quot; + planetarySystem.systemID] = &quot;Make your ship display your &quot; + planetarySystem.name + &quot; flag&quot;;
        }
    }

    // Choice to hide the flagship
    if (currentFlag.name) {
        currentChoices[&quot;4_HIDEFLAG&quot;] = &quot;Hide your flag&quot;;
    }

    // Choices to buy a visa for the neighbouring, non-enemy, dictator, communist or corporate systems
    var theseSystems = info.systemsInRange(), j = theseSystems.length;
    if (j) {
        var systemsActorIdsByGalaxyAndSystemId = this._Systems.$getSystemsActorIdsByGalaxyAndSystemId();
        var war = worldScripts.DayDiplomacy_040_WarEngine;
        while (j--) {
            var thatSystemInfo = theseSystems[j];
            var gov = thatSystemInfo.government;
            if (gov === 3 || gov === 4 || gov === 7) { // dictator, communist, corporate
                var isEnemy = war.$areActorsWarring(
                    // current system ActorId
                    systemsActorIdsByGalaxyAndSystemId[currentGalaxyID][currentSystemID],
                    // other system ActorId
                    systemsActorIdsByGalaxyAndSystemId[currentGalaxyID][thatSystemInfo.systemID]
                );
                if (!isEnemy) {
                    if (this.$hasPlayerVisa(thatSystemInfo.systemID)) {
                        currentChoices[&quot;5_BUYVISA_&quot; + thatSystemInfo.systemID] =
                            &quot;Extend your visa for &quot; + thatSystemInfo.name + &quot; by 24 hours for a cost of &quot; + this.$getVisaPrice(thatSystemInfo) + &quot; ₢&quot;;
                    } else {
                        currentChoices[&quot;5_BUYVISA_&quot; + thatSystemInfo.systemID] =
                            &quot;Buy 24 hours of visa for &quot; + thatSystemInfo.name + &quot; for a cost of &quot; + this.$getVisaPrice(thatSystemInfo) + &quot; ₢&quot;;
                    }
                }
            }
        }
    }

    mission.runScreen(opts, this._F4InterfaceCallback.bind(this));
};

this._add1DayVisa = function (systemID) {
    var now = clock.seconds;
    if (this._visas[systemID] &gt; now) {
        this._visas[systemID] += 3600 * 24;
    } else {
        this._visas[systemID] = now + 3600 * 24;
    }
};

/**
 Calls the necessary functions depending on the player&#39;s choice in the F4 interface
 @param {String} choice - predefined values: 1_BUY, 2_LOSE, 3_DISPLAY_{int}, 4_HIDEFLAG, 5_EXIT
 @private
 */
this._F4InterfaceCallback = function (choice) {
    if (choice === &quot;1_BUY&quot; || choice === &quot;2_LOSE&quot;) {
        var info = system.info;
        var success = choice === &quot;1_BUY&quot; ? this._buyCitizenship(info.galaxyID, info.systemID) : this._loseCitizenship(info.galaxyID, info.systemID);
        if (success) {
            this._publishNewsSubscribers();
        }
        this._runCitizenship(!success);
    } else {
        var currentFlag = this._flag;
        if (choice === &quot;4_HIDEFLAG&quot;) {
            delete currentFlag.galaxyID;
            delete currentFlag.systemID;
            delete currentFlag.name;
            this._runCitizenship(false);
        } else if (choice !== null &amp;&amp; choice.substring(0, 10) === &quot;3_DISPLAY_&quot;) {
            var galaxyID = parseInt(choice.substring(10, 11)), systemID = parseInt(choice.substring(12));
            currentFlag.galaxyID = galaxyID;
            currentFlag.systemID = systemID;
            currentFlag.name = this._Systems.$retrieveNameFromSystem(galaxyID, systemID);
            this._runCitizenship(false);
        } else if (choice !== null &amp;&amp; choice.substring(0, 10) === &quot;5_BUYVISA_&quot;) {
            var systemID = parseInt(choice.substring(10));
            var thatSystemInfo = System.infoForSystem(system.info.galaxyID, systemID);
            var paid = this._payIfCapable(this.$getVisaPrice(thatSystemInfo));
            if (paid) {
                this._add1DayVisa(systemID);
            }
            this._runCitizenship(!paid);
        }
    } // else EXIT
};

/**
 * Hides the HUD and displays the F4 interface
 * @private
 */
this._displayF4Interface = function () {
    this._runCitizenship(false);
};

/**
 * Displays the citizenship line in the F4 interface
 * @private
 */
this._initF4Interface = function () {

    // No Embassy district in anarchies
    if (system.government === 0) return;

    player.ship.dockedStation.setInterface(&quot;DiplomacyCitizenships&quot;,
        {
            title: &quot;Embassy district&quot;,
            category: &quot;Diplomacy&quot;,
            summary: &quot;You may see current citizenships&quot;,
            callback: this._displayF4Interface.bind(this)
        });
};

/**
 * Calls the method $playerCitizenshipsUpdated() for each subscribed script with the current citizenships list as argument.
 * @private
 */
this._publishNewsSubscribers = function () {
    var subscribers = this._playerCitizenshipsUpdatesSubscribers, l = subscribers.length,
        citizenships = this._citizenships;
    while (l--) {
        // noinspection JSUnresolvedFunction This method must be implemented in the subscribed scripts.
        worldScripts[subscribers[l]].$playerCitizenshipsUpdated(citizenships);
    }
};

/**
 * This function makes sure that the player is considered as a fugitive in an enemy system.
 * @private
 */
this._checkPlayerStatusInWar = function () {
    var worldScriptsVar = worldScripts;
    var systemInfo = system.info;
    var flag = this._flag;
    var systemsActorIdsByGalaxyAndSystemId = worldScriptsVar.DayDiplomacy_010_Systems.$getSystemsActorIdsByGalaxyAndSystemId();
    var inEnemySystem = flag.systemID &amp;&amp; worldScriptsVar.DayDiplomacy_040_WarEngine.$areActorsWarring(
        // current system ActorId
        systemsActorIdsByGalaxyAndSystemId[systemInfo.galaxyID][systemInfo.systemID],
        // current flag ActorId
        systemsActorIdsByGalaxyAndSystemId[flag.galaxyID][flag.systemID]
    );
    var comingFromEnemySystem = this._peacefulSystemsBounty.value !== null;

    if (inEnemySystem) {
        if (!comingFromEnemySystem) { // Entering enemy system
            this._peacefulSystemsBounty.value = player.bounty;
        }
        player.bounty = 200;
        player.commsMessage(&quot;It seems we are in an enemy system, fights are probable...&quot;);
    } else if (comingFromEnemySystem) { // Exiting enemy system
        player.bounty = this._peacefulSystemsBounty.value;
        this._peacefulSystemsBounty.value = null;
    }
};

/* ************************** Oolite events ***************************************************************/

// noinspection JSUnusedLocalSymbols Called by Oolite itself
/**
 * Displays the citizenship&#39;s line in the F4 interface when the player is docked.
 * @param {Station} station an Oolite object where the ship is docked. We don&#39;t use it.
 */
this.shipDockedWithStation = function (station) {
    this._initF4Interface();
};

// noinspection JSUnusedGlobalSymbols Called by Oolite itself
/**
 * We stop hiding the HUD when we exit our citizenship interface
 */
this.missionScreenEnded = function () {
    player.ship.hudHidden = false;
};

/**
 *
 * @private
 */
this._setStationsVisaRequirements = function () {
    var gov = system.government;
    if (gov === 3 || gov === 4 || gov === 7) {
        var checker = function (ship) {
            if (!(ship instanceof PlayerShip)) { // Only for the player ship
                return true;
            }
            if (worldScripts.DayDiplomacy_060_Citizenships._citizenships.length) {
                // No problem if the player has a citizenship
                return true;
            }
            if (worldScripts.DayDiplomacy_060_Citizenships.$hasPlayerVisa(system.info.systemID)) {
                // No problem if the player has a visa
                return true;
            }
            this.commsMessage(&quot;WARNING - This station is accessible only to citizens and visa holders, Commander.&quot;, player.ship);
            return false;
        };
        var ss = system.stations, z = ss.length;
        while (z--) {
            var station = ss[z];
            var al = station.allegiance;
            if (al === &quot;galcop&quot; || al === &quot;neutral&quot;) {
                var ses = station.subEntities, y = ses.length;
                while (y--) {
                    var se = ses[y];
                    if (se.isDock) {
                        se.script.acceptDockingRequestFrom = checker.bind(station);
                        break;
                    }
                }
            }
        }
    }
};

// noinspection JSUnusedGlobalSymbols Called by Oolite itself
this.shipExitedWitchspace = function () {
    this._checkPlayerStatusInWar();
    this._setStationsVisaRequirements();
};

// noinspection JSUnusedGlobalSymbols Called by Oolite itself
/**
 *
 * @param {Station}station - the station from which the ship is launched
 */
this.shipLaunchedFromStation = function (station) {
    this._checkPlayerStatusInWar();
};

/**
 * Loads the player citizenship from the save file, loads the scripts which are subscribed to the
 * playerCitizenshipsUpdates, and initialises the F4 interface.
 * @private
 */
this._startUp = function () {
    worldScripts.XenonUI &amp;&amp; worldScripts.XenonUI.$addMissionScreenException(&quot;DiplomacyCitizenshipsScreenId&quot;);
    worldScripts.XenonReduxUI &amp;&amp; worldScripts.XenonReduxUI.$addMissionScreenException(&quot;DiplomacyCitizenshipsScreenId&quot;);

    this._Systems = worldScripts.DayDiplomacy_010_Systems;
    var engine = worldScripts.DayDiplomacy_000_Engine;

    // {String[]} _playerCitizenshipsUpdatesSubscribers - an array containing the names of the scripts which have subscribed to receive notifications when the player citizenships have changed.
    this._playerCitizenshipsUpdatesSubscribers || (this._playerCitizenshipsUpdatesSubscribers = []);

    /**
     * The flag of the player ship, saved. None by default.
     * @type {PlanetarySystem}
     * @private
     */
    this._flag = engine.$initAndReturnSavedData(&quot;flag&quot;, {});

    /**
     * The value is only set when the player is in an enemy system; else it is &#39;null&#39;.
     * When beginning to use the Diplomacy Oxp, the player is not in an enemy system.
     * @type {Object}
     * @param {int} value
     * @private
     */
    this._peacefulSystemsBounty = engine.$initAndReturnSavedData(&quot;peacefulSystemsBounty&quot;, {value: null});

    /**
     * The object in which the player citizenships are saved. That object is saved into the saveGame file.
     * @type {PlanetarySystem[]}
     */
    this._citizenships = engine.$initAndReturnSavedData(&quot;citizenships&quot;, []);

    var visasDefaultValue = {};
    var gov = system.government;
    if (gov == 3 || gov == 4 || gov == 7) {
        visasDefaultValue[system.info.systemID] = clock.seconds + 24*3600;
    }
    /**
     * The object in which the player visas are saved. That object is saved into the saveGame file. The first int is the systemID, the second the end date of the visa in seconds.
     * The first time the Diplomacy OXP is used, if a visa is needed in the current system, we give the player a 1-day visa.
     * @type {Object&lt;int,int&gt;}
     */
    this._visas = engine.$initAndReturnSavedDataAndInitialize(&quot;visas&quot;, visasDefaultValue, function() {
        worldScripts.DayDiplomacy_015_GNN.$publishNews(
             &quot;Serious news! To ensure their security, corporate systems have agreed to require a visa for all undocumented travelers.&quot;
            +&quot; Are you up-to-date on your citizenship papers, Commanders?\n&quot;
            +&quot;\nIn a shocking political twist, dictatorships and communist systems have happily adopted the same law.&quot;
            +&quot; The President of Ceesxe, the Preeminent Corporate Planet, told us: \&quot;We are appalled that our well-meant initiatives and technologies are copied by rogue governments.\&quot;\n&quot;
            +&quot;\nTo avoid an economic freeze due to the newly introduced laws, all pilots currently in a system requiring a visa will be provided a 1-day visa free of charge.&quot;
            +&quot; The Ceesxe President confided in us: \&quot;The first shot is always free. That&#39;s only good business, after all.\&quot;\n&quot;
            +&quot; What he meant by this, the truth is, we don&#39;t know.&quot;);
    });

    this._setStationsVisaRequirements();
    this._initF4Interface();
    delete this._startUp; // No need to startup twice
};

this.startUp = function () {
    worldScripts.DayDiplomacy_000_Engine.$subscribe(this.name);
    delete this.startUp; // No need to startup twice
};</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/DayDiplomacy_Economy.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name = &quot;DayDiplomacy_030_EconomyEngine&quot;;
this.author = &quot;David (Day) Pradier&quot;;
// noinspection JSUnusedGlobalSymbols Used by Oolite itself
this.copyright = &quot;(C) 2017 David Pradier&quot;;
// noinspection JSUnusedGlobalSymbols Used by Oolite itself
this.licence = &quot;CC-NC-by-SA 4.0&quot;;
this.description = &quot;This script is the economy engine of the Diplomacy OXP. It makes systems tax themselves.&quot; +
    &quot; The idea here is to use the system GDP, called &#39;productivity&#39; in Oolite,&quot; +
    &quot; and a &#39;tax level&#39; on GDP which adds to the system&#39;s government&#39;s &#39;treasury&#39;.&quot;;

/* Credit monetary policy is such that the total number of credits in the Ooniverse is always the same.
   This is needed to avoid game imbalances leading to exploding monetary mass, or monetary mass converging to zero.
   This implies that the money cannot be produced, destroyed or counterfeited, which is a mystery in itself. */
/**
 *
 * @type {{&quot;0&quot;: number, &quot;1&quot;: number, &quot;2&quot;: number, &quot;3&quot;: number, &quot;4&quot;: number, &quot;5&quot;: number, &quot;6&quot;: number, &quot;7&quot;: number}}
 * @lends worldScripts.DayDiplomacy_030_EconomyEngine.$GOVERNMENT_DEFAULT_TAX_LEVEL;
 */
this.$GOVERNMENT_DEFAULT_TAX_LEVEL = {
    &quot;0&quot;: 0.0, // Anarchy =&gt; no tax
    &quot;1&quot;: 0.3, // Feudal =&gt; not everybody is taxed
    &quot;2&quot;: 0.1, // Multi-government =&gt; tax avoiding is rampant
    &quot;3&quot;: 0.2, // Dictator =&gt; feeble taxes
    &quot;4&quot;: 0.5, // Communist =&gt; major taxes, but those systems are not crumbling
    &quot;5&quot;: 0.1, // Confederacy =&gt; tax avoiding is rampant
    &quot;6&quot;: 0.5, // Democracy =&gt; major taxes, but those systems are not crumbling
    &quot;7&quot;: 0.1  // Corporate =&gt; tax avoiding is rampant
};

this.$moveProductivityInPercentage = function(fromSystemActor, percentage) {
    // FIXME 0.15 TODO
};
this.$moveProductivityInCredits = function(fromSystemActor, creditsNb) {
    // FIXME 0.15 TODO
};
this.$moveProductivityToNeighborsInPercentage = function(fromSystemActor, percentage) {
    // FIXME 0.15 TODO
};
this.$moveProductivityToNeighborsInCredits = function(fromSystemActor, creditsNb) {
    // FIXME 0.15 TODO
};
this.$moveProductivityToNeighborsDependingOnDistanceInPercentage = function(fromSystemActor, percentage) {
    // FIXME 0.15 TODO
};
this.$moveProductivityToNeighborsDependingOnDistanceInCredits = function(fromSystemActor, creditsNb) {
    // FIXME 0.15 TODO
};

/* ************************** Oolite events ***************************************************************/

this._startUp = function () {
    var engine = worldScripts.DayDiplomacy_000_Engine;

    // Not initializing if already done.
    if (engine.$getEventTypes().indexOf(&quot;SELFTAX&quot;) !== -1) {
        return;
    }

    // This eventType means a system government taxes the system GDP (economic output) to fund its treasury.
    engine.$addEventType(&quot;SELFTAX&quot;, 0);

    /**
     * @function
     * @param {Actor}aSystem
     */
    var diplomacyTaxInitAction = function diplomacyTaxInitAction(aSystem) {
        var that = diplomacyTaxInitAction;
        var engine = that.engine || (that.engine = worldScripts.DayDiplomacy_000_Engine);
        var taxLevel = that.taxLevel || (that.taxLevel = worldScripts.DayDiplomacy_030_EconomyEngine.$GOVERNMENT_DEFAULT_TAX_LEVEL);
        var sys = that.sys || (that.sys = System);
        var cloc = that.cloc || (that.cloc = clock);
        var ourSystemInOolite = sys.infoForSystem(aSystem.galaxyNb, aSystem.systemId);
        var government = ourSystemInOolite.government;
        engine.$setField(aSystem, &quot;government&quot;, government);
        // Necessary for alliancesAndWars. Bad location but avoids other system initialization :/
        // FIXME 0.perfectstyle fields should be inited in the systems part. Make it all fields?
        // FIXME 0.f move treasury and tax level to a F4 Diplomacy system information including the history.
        // Or use the new description system?
        // FIXME Should the Actor aSystem be typed ActorSystem? mwofff
        engine.$setField(aSystem, &quot;name&quot;, ourSystemInOolite.name);
        engine.$setField(aSystem, &quot;taxLevel&quot;, taxLevel[government]);
        engine.$setField(aSystem, &quot;treasury&quot;, 0); // Everybody begins with treasury = 0.
        engine.$setField(aSystem, &quot;lastTaxDate&quot;, cloc.seconds);
    };
    var functionId = engine.$getNewFunctionId();
    engine.$setFunction(functionId, diplomacyTaxInitAction);
    engine.$setInitAction(engine.$buildAction(engine.$getNewActionId(), &quot;SELFTAX&quot;, &quot;SYSTEM&quot;, functionId));

    // Recurrent tax.
    var diplomacyTaxRecurrentAction = function diplomacyTaxRecurrentAction(aSystem) {
        var that = diplomacyTaxRecurrentAction;
        var engine = that.engine || (that.engine = worldScripts.DayDiplomacy_000_Engine);
        var sys = that.sys || (that.sys = System);
        var cloc = that.cloc || (that.cloc = clock);
        var ourSystemInOolite = sys.infoForSystem(aSystem.galaxyNb, aSystem.systemId);
        var now = cloc.seconds;
        engine.$setField(aSystem, &quot;treasury&quot;, aSystem.treasury + Math.floor(ourSystemInOolite.productivity * (now - parseInt(aSystem.lastTaxDate)) / 31.5576 * aSystem.taxLevel));
        engine.$setField(aSystem, &quot;lastTaxDate&quot;, now);
    };
    var fid =  engine.$getNewFunctionId();
    engine.$setFunction(fid, diplomacyTaxRecurrentAction);
    engine.$setRecurrentAction(engine.$buildAction(engine.$getNewActionId(), &quot;SELFTAX&quot;, &quot;SYSTEM&quot;, fid));
    delete this._startUp; // No need to startup twice
};

this.guiScreenChanged = function(to, from) {
    if (to == &quot;GUI_SCREEN_SYSTEM_DATA&quot;) {
        var targetSystem = worldScripts.DayDiplomacy_010_Systems.$retrieveActorFromSystem(system.info.galaxyID, player.ship.targetSystem);
        mission.addMessageText(&quot;Tax level: &quot; + targetSystem.taxLevel*100 + &quot;% Treasury: &quot; + Math.floor(targetSystem.treasury/1000000) + &quot; M€&quot;);
    }
};

this.startUp = function() {
    worldScripts.DayDiplomacy_000_Engine.$subscribe(this.name);
    delete this.startUp; // No need to startup twice
};</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/DayDiplomacy_Engine.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name = &quot;DayDiplomacy_000_Engine&quot;;
this.author = &quot;David (Day) Pradier&quot;;
// noinspection JSUnusedGlobalSymbols Used by Oolite itself
this.copyright = &quot;(C) 2017 David Pradier&quot;;
// noinspection JSUnusedGlobalSymbols Used by Oolite itself
this.licence = &quot;CC-NC-by-SA 4.0&quot;;
this.description = &quot;This script is the engine of the Diplomacy OXP.&quot;;

/* ************************** Closures ********************************************************************/

this._missionVariables = missionVariables;
this._clock = clock;
this._JSON = JSON;

/* ************************** Engine **********************************************************************/

// FIXME use the debugger to set _debug to true
this._debug = false;

/**
 * Loads state from the saved game
 * @param toBeModifiedState
 * @param sourceState
 * @private
 */
this._loadState = function (toBeModifiedState, sourceState) {
    for (var id in sourceState) {
        if (sourceState.hasOwnProperty(id)) { // Avoiding prototypes&#39; fields
            toBeModifiedState[id] = sourceState[id];
        }
    }
};

/**
 *
 * @return {{shortStack: Array, eventsToPublish: {}, initActions: {}, eventMaxId: number, actorTypes: Array, initActionsByType: {}, recurrentActionsByType: {}, actorsEvents: {}, functionMaxId: number, eventTypes: Array, actorMaxId: number, actors: {}, recurrentActions: {}, responseMaxId: number, actionMaxId: number, responsesByType: {}, actorsByType: {}, eventsToPublishNextTurn: {}, responses: {}, currentActorType: string, currentEventType: string, events: {}}}
 * @private
 * @lends worldScripts.DayDiplomacy_000_Engine._getInitState
 */
this._getInitState = function () {
  return {

      /** @type {Object.&lt;ActorId,Actor&gt;}*/
      actors: {},

      /** @type {Object.&lt;ActionId,Action&gt;}*/
      initActions: {},

      /** @type {Object.&lt;ActionId,Action&gt;}*/
      recurrentActions: {},

      /** @type {Object.&lt;EventId,DiplomacyEvent&gt;}*/
      events: {},

      /** @type {Object.&lt;ResponseId,DiplomacyResponse&gt;}*/
      responses: {},

      /** @type {Object.&lt;ActorType,ActorId[]&gt;}*/
      actorsByType: {},

      /** @type {Object.&lt;ActorType,ActionId[]&gt;}*/
      initActionsByType: {},

      /** @type {Object.&lt;EventType,Object.&lt;ActorType,ActionId[]&gt;&gt;}*/
      recurrentActionsByType: {},

      /** @type {Object.&lt;EventType,Object.&lt;ActorType,ResponseId[]&gt;&gt;}*/
      responsesByType: {},

      /** @type {int} */
      actorMaxId: 1,

      /** Useful to remove recurrentActions and initActions.
       *  @type {int} */
      actionMaxId: 1,

      /** @type {int} */
      eventMaxId: 1,

      /** @type {int} */
      responseMaxId: 1,

      /** @type {int} */
      functionMaxId: 1,

      /** @type {EventType[]} */
      eventTypes: [],

      /** @type {ActorType[]} */
      actorTypes: [],

      /** @type {Object.&lt;ActorId,EventId[]&gt;}*/
      actorsEvents: {},

      /** @type {Object.&lt;EventType,EventId[]&gt;}*/
      eventsToPublish: {},

      /** @type {Object.&lt;EventType,EventId[]&gt;}*/
      eventsToPublishNextTurn: {},

      /** @type EventType */
      currentEventType: &quot;&quot;,

      /** @type ActorType */
      currentActorType: &quot;&quot;,

      /** @type {Object[]} */
      shortStack: []
  };
};

// FIXME should _State be of a defined state? That would be what would make stable the savefile... ?
/**
 * @type {{shortStack: Array, eventsToPublish: {}, initActions: {}, eventMaxId: number, actorTypes: Array, initActionsByType: {}, recurrentActionsByType: {}, actorsEvents: {}, functionMaxId: number, eventTypes: Array, actorMaxId: number, actors: {}, recurrentActions: {}, responseMaxId: number, actionMaxId: number, responsesByType: {}, actorsByType: {}, eventsToPublishNextTurn: {}, responses: {}, currentActorType: string, currentEventType: string, events: {}}}
 * @private
 * @lends worldScripts.DayDiplomacy_000_Engine._State
 */
this._State = this._getInitState();

/**
 * @type {Object.&lt;FunctionId,function&gt;}
 * @private
 */
this._Functions = {};

/**
 * @return {ActorId}
 * @lends worldScripts.DayDiplomacy_000_Engine.$getNewActorId
 */
this.$getNewActorId = function () {
    return &quot;DAr_&quot; + this._State.actorMaxId++;
};

/**
 * @return {ResponseId}
 * @lends worldScripts.DayDiplomacy_000_Engine.$getNewResponseId
 */
this.$getNewResponseId = function () {
    return &quot;DR_&quot; + this._State.responseMaxId++;
};

/**
 * @return {ActionId}
 * @lends worldScripts.DayDiplomacy_000_Engine.$getNewActionId
 */
this.$getNewActionId = function () {
    return &quot;DAn_&quot; + this._State.actionMaxId++;
};

/**
 * @return {FunctionId}
 * @lends worldScripts.DayDiplomacy_000_Engine.$getNewFunctionId
 */
this.$getNewFunctionId = function () {
    return &quot;DFn_&quot; + this._State.functionMaxId++;
};

/**
 * @return {EventId}
 * @lends worldScripts.DayDiplomacy_000_Engine.$getNewEventId
 */
this.$getNewEventId = function () {
    return &quot;DEt_&quot; + this._State.eventMaxId++;
};

/**
 * An action, whether it is init or recurrent isn&#39;t put into the History. Only Events are.
 * @param {ActionId}id -
 * @param {EventType}eventType - is used to order the actions and events execution. For a same eventType, Actions are executed before Events.
 * @param {ActorType}actorType - Only actors of the type will execute the action.
 * @param {FunctionId} actionFunctionId - the id of a function which must take one and only one argument: the actor which will &quot;act&quot;.
 * @return {Action}
 * @lends worldScripts.DayDiplomacy_000_Engine.$buildAction
 */
this.$buildAction = function (id, eventType, actorType, actionFunctionId) {
    /** @type {Action} */
    return {id: id, eventType: eventType, actorType: actorType, actionFunctionId: actionFunctionId};
};

/**
 * To copy before modifying
 * @return {EventType[]}
 * @lends worldScripts.DayDiplomacy_000_Engine.$getEventTypes
 */
this.$getEventTypes = function () {
    return this._State.eventTypes;
};

/**
 * @return {Object&lt;FunctionId, function&gt;}
 * @lends worldScripts.DayDiplomacy_000_Engine.$getFunctions
 */
this.$getFunctions = function () {
    return this._Functions;
};

/**
 * @return {Object&lt;EventId,DiplomacyEvent&gt;}
 * @lends worldScripts.DayDiplomacy_000_Engine.$getEvents
 */
this.$getEvents = function () {
    return this._State.events;
};

/**
 * @param {ActorId} actorId
 * @return {EventId[]}
 * @lends worldScripts.DayDiplomacy_000_Engine.$getActorEvents
 */
this.$getActorEvents = function (actorId) {
    return this._State.actorsEvents[actorId] || [];
};

/**
 * Make sure you don&#39;t modify that or its content. Copy it before if you need to modify it.
 * @return {ActorType[]} The ActorType list
 * @lends worldScripts.DayDiplomacy_000_Engine.$getActorTypes
 */
this.$getActorTypes = function () {
    return this._State.actorTypes;
};

/**
 * @param {ActorType} actorType
 * @returns {ActorId[]} the list of actorId having the type given as parameter
 * @lends worldScripts.DayDiplomacy_000_Engine.$getActorsIdByType
 */
this.$getActorsIdByType = function (actorType) {
    return this._State.actorsByType[actorType];
};

/**
 * @name $getActors
 * @returns {Object.&lt;ActorId,Actor&gt;} - an object with {@link ActorId} as keys and as value the corresponding {@link Actor}
 * @lends worldScripts.DayDiplomacy_000_Engine.$getActors
 */
this.$getActors = function () {
    return this._State.actors;
};

/**
 * A planetary system or an alliance, or whatever you wish :)
 * An actor is {id:id, actorType:actorType, responsesIdByEventType:{eventType:[responseIds]}, observers:{actorType:[actorIds]}}
 * @param {ActorType} actorType
 * @param {ActorId} id
 * @return {Actor}
 * @lends worldScripts.DayDiplomacy_000_Engine.$buildActor
 */
this.$buildActor = function (actorType, id) {
    /** @type {Actor} */
    return {id: id, actorType: actorType, responsesIdByEventType: {}, observers: {}};
};

/**
 * @param {EventId} id
 * @param {EventType}eventType
 * @param {ActorId} actorId
 * @param {Object[]} args  Have to be compatible with our implementation of JSON stringify/parse. Those are the information/arguments which will be given to the response function.
 * @return {DiplomacyEvent}
 */
this.$buildEvent = function (id, eventType, actorId, args) {
    return {id: id, eventType: eventType, actorId: actorId, args: args, date:0};
};

/**
 *
 * @param {Actor} anActor
 * @param {ActorType} observersActorType
 * @returns {ActorId[]} the list of the actorId&#39;s of the observers of the given actor, which are of the given type
 * @lends worldScripts.DayDiplomacy_000_Engine.$getObservers
 */
this.$getObservers = function (anActor, observersActorType) {
    return anActor.observers[observersActorType];
};

/**
 * @param {Actor} anActor
 * @param {Action} anAction
 */
this.$letActorExecuteAction = function (anActor, anAction) {
    this._Functions[anAction.actionFunctionId](anActor);
};

/**
 *
 * @param {ActorId} actorId
 * @param {EventType}anEventType
 * @param {Object[]} someArgs
 * @lends worldScripts.DayDiplomacy_000_Engine.$makeActorEventKnownToUniverse
 */
this.$makeActorEventKnownToUniverse = function (actorId, anEventType, someArgs) {
    this._record(this.$buildEvent(this.$getNewEventId(), anEventType, actorId, someArgs));
};

// this.$Actor.prototype.actNextTurn = function (anEventType, someArgs) {
//     this.recordForNextTurn({id:eventId, eventType: anEventType, actorId: this._State.id, args: someArgs});
// };

/**
 * @param {Actor} anActor
 * @lends worldScripts.DayDiplomacy_000_Engine.$addActor
 */
this.$addActor = function (anActor) {
    var state = this._State, responsesByType = state.responsesByType, initActions = state.initActions,
        initActionsByType = state.initActionsByType, eventTypes = state.eventTypes, actorType = anActor.actorType,
        id = anActor.id, responses = state.responses;

    // We add the actor to the actors maps.
    state.actorsByType[actorType].push(id);
    state.actors[id] = anActor;

    // We complete the existing actor responses with the engine responses.
    var y = eventTypes.length;
    while (y--) {
        var eventType = eventTypes[y];
        var eventTypeResponses = responsesByType[eventType] || (responsesByType[eventType] = {});
        var responsesIdsToAdd = eventTypeResponses[actorType] || (eventTypeResponses[actorType] = []);
        var x = responsesIdsToAdd.length;
        while (x--) {
            this.$addResponseToActor(responses[responsesIdsToAdd[x]], anActor);
        }
    }

    // We execute the initActions on the actor
    var initActionsToExecute = initActionsByType[actorType];
    var z = initActionsToExecute.length;
    while (z--) {
        this.$letActorExecuteAction(anActor, initActions[initActionsToExecute[z]]);
    }
};

// Consistent with history usage.
// this.disableActor = function (anActor) {
//     var engineState = this._State, actorState = anActor._State, arr = engineState.actorsByType[actorState.actorType];
//     arr.splice(arr.indexOf(actorState.id), 1);
//     delete engineState.actors[actorState.id];
// };

/**
 * @param {Actor} anActor
 * @param {ActorType} thatObserverType
 * @param {ActorId} thatObserverId
 * @lends worldScripts.DayDiplomacy_000_Engine.$addObserverToActor
 */
this.$addObserverToActor = function (anActor, thatObserverType, thatObserverId) {
    var observers = anActor.observers;
    (observers[thatObserverType] || (observers[thatObserverType] = [])).push(thatObserverId);
};

/**
 * @param {DiplomacyResponse}aResponse
 * @param {Actor}anActor
 */
this.$addResponseToActor = function (aResponse, anActor) {
    var responsesIdByEventType = anActor.responsesIdByEventType;
    (responsesIdByEventType[aResponse.eventType] || (responsesIdByEventType[aResponse.eventType] = [])).push(aResponse.id);
};

// this.$Actor.prototype.removeResponse = function (aResponse) {
//     var arr = this._State.responses[aResponse.eventType];
//     arr.splice(arr.indexOf(aResponse.id), 1);
// };

/**
 * @param {FunctionId} anId
 * @param {function} aFunction
 * @lends worldScripts.DayDiplomacy_000_Engine.$setFunction
 */
this.$setFunction = function (anId, aFunction) {
    this._Functions[anId] = aFunction;
};

/**
 * @param {Object} anObject
 * @param {string} fieldName
 * @param {Object} fieldValue
 * @lends worldScripts.DayDiplomacy_000_Engine.$setField
 */
this.$setField = function (anObject, fieldName, fieldValue) {
    if (anObject.hasOwnProperty(&quot;_State&quot;)) { // We put the field into _State
        anObject._State[fieldName] = fieldValue;
    } else {
        anObject[fieldName] = fieldValue;
    }
};

/**
 * @param {Action} anInitAction
 * @lends worldScripts.DayDiplomacy_000_Engine.$setInitAction
 */
this.$setInitAction = function (anInitAction) {
    var initActions = this._State.initActions, initActionsByType = this._State.initActionsByType,
        initActionActorType = anInitAction.actorType;

    // We add the initAction to initActions and initActionsByType
    initActions[anInitAction.id] = anInitAction;
    (initActionsByType[initActionActorType] || (initActionsByType[initActionActorType] = [])).push(anInitAction.id);

    // We execute the action on the existing actors in an ordered fashion.
    this.$executeAction(anInitAction);
};

/**
 * @param {Action} anAction
 * @lends worldScripts.DayDiplomacy_000_Engine.$setRecurrentAction
 */
this.$setRecurrentAction = function (anAction) {
    // We add the action to recurrentActions
    var recurrentActionsByType = this._State.recurrentActionsByType, recurrentActions = this._State.recurrentActions,
        actionEventType = anAction.eventType, actionActorType = anAction.actorType;
    var eventTypeActions = recurrentActionsByType[actionEventType] || (recurrentActionsByType[actionEventType] = {});
    (eventTypeActions[actionActorType] || (eventTypeActions[actionActorType] = [])).push(anAction.id);
    recurrentActions[anAction.id] = anAction;
};

/**
 * FIXME
 * @param {string} name
 * @param {*} defaultValue
 * @returns {*}
 * @lends worldScripts.DayDiplomacy_000_Engine.$initAndReturnSavedData
 */
this.$initAndReturnSavedData = function (name, defaultValue) {
    return this._State[name] || (this._State[name] = defaultValue);
};

/**
 * FIXME
 * @param {string} name
 * @param {*} defaultValue
 * @returns {*}
 * @lends worldScripts.DayDiplomacy_000_Engine.$initAndReturnSavedDataAndInitialize
 */
this.$initAndReturnSavedDataAndInitialize = function (name, defaultValue, initFunction) {
    if (this._State[name] === undefined) {
        initFunction();
    }
    return this._State[name] || (this._State[name] = defaultValue);
};

this.$executeAction = function (anAction) {
    var ourActorIds = this._State.actorsByType[anAction.actorType], actors = this._State.actors;
    var z = ourActorIds.length;
    while (z--) {
        this.$letActorExecuteAction(actors[ourActorIds[z]], anAction);
    }
};

/**
 * A Response contains a behaviour to be executed when a certain event happens.
 * The responseFunction must take as first argument the responding actor,
 * 2nd argument the eventActor, and may take as many additional arguments as you wish.
 * The actorType is the type of the responding actors.
 *
 * @param {ResponseId}id
 * @param {EventType}eventType
 * @param {ActorType}actorType
 * @param {FunctionId}responseFunctionId
 * @return {DiplomacyResponse}
 * @lends worldScripts.DayDiplomacy_000_Engine.$buildResponse
 */
this.$buildResponse = function (id, eventType, actorType, responseFunctionId) {
    return {id: id, eventType: eventType, actorType: actorType, responseFunctionId: responseFunctionId};
};

/**
 * @param {DiplomacyResponse} aResponse
 * @lends worldScripts.DayDiplomacy_000_Engine.$setResponse
 */
this.$setResponse = function (aResponse) {
    var state = this._State, actors = state.actors;
    // We add the response to responses
    state.responsesByType[aResponse.eventType][aResponse.actorType].push(aResponse.id);
    state.responses[aResponse.id] = aResponse;

    // We add the response to the existing actors in an ordered fashion.
    var ourActorIds = state.actorsByType[aResponse.actorType];
    var z = ourActorIds.length;
    while (z--) {
        this.$addResponseToActor(aResponse, actors[ourActorIds[z]]);
    }
};

// this.unsetInitAction = function (anInitAction) { // This doesn&#39;t impact History.
//     delete this._State.initActions[anInitAction.actorType][anInitAction.id];
// };
// this.unsetRecurrentAction = function (anAction) { // This doesn&#39;t impact History.
//     var engineState = this._State, arr = engineState.recurrentActionsByType[anAction.eventType][anAction.actorType];
//     arr.splice(arr.indexOf(anAction.id), 1);
//     delete engineState.recurrentActions[anAction.id];
// };
// this.unsetResponse = function (aResponse) { // This doesn&#39;t impact History.
//     var state = this._State, actors = state.actors;
//     delete state.responses[aResponse.eventType][aResponse.actorType][aResponse.id];
//     var ourActorIds = state.actorsByType[aResponse.actorType];
//     var z = ourActorIds.length;
//     while (z--) {
//         actors[ourActorIds[z]].removeResponse(aResponse);
//     }
// };

/**
 * We don&#39;t allow to remove eventTypes as it would make the history inconsistent.
 * @param {EventType} name - name of the new eventType, it must be different from already existing names.
 * @param {int} position - the position in the ordered list of existing types
 * @lends worldScripts.DayDiplomacy_000_Engine.$addEventType
 */
this.$addEventType = function (name, position) {
    var state = this._State;
    state.eventTypes.splice(position, 0, name);
    if (this._debug) log(&quot;DiplomacyEngine&quot;, &quot;Added &quot; + name + &quot; event type in position &quot; + position + &quot;. Current event types: &quot; + state.eventTypes);
    var ourResponses = (state.responsesByType[name] = {});
    var ourRecurrentActions = (state.recurrentActionsByType[name] = {});
    var actorTypes = state.actorTypes;
    var z = actorTypes.length;
    while (z--) {
        var ourActorType = actorTypes[z];
        ourResponses[ourActorType] = [];
        ourRecurrentActions[ourActorType] = [];
    }
    state.eventsToPublish[name] = [];
    state.eventsToPublishNextTurn[name] = [];
};

/**
 * @param {ActorType} name
 * @param {int} position
 * @lends worldScripts.DayDiplomacy_000_Engine.$addActorType
 */
this.$addActorType = function (name, position) {
    var state = this._State;
    state.actorTypes.splice(position, 0, name);

    state.actorsByType[name] = [];
    state.initActionsByType[name] = [];

    var responses = state.responsesByType;
    var recurrentActions = state.recurrentActionsByType;
    var z = state.eventTypes.length;
    while (z--) {
        var eventType = state.eventTypes[z];
        responses[eventType][name] = [];
        recurrentActions[eventType][name] = [];
    }
};

/**
 * Gives the next state. Returns empty string if array is finished.
 * @param {EventType | ActorType} type
 * @param currentState FIXME document what&#39;s a state
 */
this._nextState = function (type, currentState) {
    var arr = this._State[type];
    var newIndex = arr.indexOf(currentState) + 1;
    return newIndex === arr.length ? &quot;&quot; : arr[newIndex];
};

/**
 * @param {DiplomacyEvent} anEvent
 * @private
 */
this._record = function (anEvent) {
    var eventsToPublish = this._State.eventsToPublish, eventType = anEvent.eventType,
        eventId = anEvent.id, eventActorId = anEvent.actorId, actorsEvents = this._State.actorsEvents;

    // Stamping the event
    anEvent.date = this._clock.seconds;

    // Recording the history. This is ordered by insertion, so ordered by date.
    (actorsEvents[eventActorId] || (actorsEvents[eventActorId] = [])).push(eventId);

    this._State.events[eventId] = anEvent;

    // Publishing the reality
    (eventsToPublish[eventType] || (eventsToPublish[eventType] = [])).push(anEvent);
};
// this.recordForNextTurn = function (anEvent) {
//     var eventsToPublishNextTurn = this._State.eventsToPublishNextTurn, eventType = anEvent.eventType;
//     (eventsToPublishNextTurn[eventType] || (eventsToPublishNextTurn[eventType] = [])).push(anEvent);
// };

this._gatherEventsToPublish = function () {
    var state = this._State;
    var currentEventType = state.currentEventType, eventsToPublishNextTurn = state.eventsToPublishNextTurn;
    var ourEvents = (eventsToPublishNextTurn[currentEventType] || (eventsToPublishNextTurn[currentEventType] = []));
    // FIXME 0.perfectperf, when we use Events: does the length change? check through logs
    // FIXME 0.perfectperf, when we use Events: &#39;while&#39; could be cut into frames, but it would slow the history. Check the time spent through logs
    while (ourEvents.length) {
        var z = ourEvents.length;
        while (z--) {
            this._record(ourEvents.shift());
        }
    }

    // We go to next eventType
    var newEventType = this._nextState(&quot;eventTypes&quot;, currentEventType);
    if (this._debug &amp;&amp; newEventType !== &quot;&quot;) log(this.name, &quot;Gathering events to publish for state: &quot; + newEventType);

    state.currentEventType = newEventType || state.eventTypes[0];
    state.currentActorType = state.actorTypes[0];
    return !newEventType;
};

/** @return {boolean} - true when everything is finished, else false. */
this._populateStack = function () {
    var state = this._State, currentEventType = state.currentEventType, currentActorType = state.currentActorType,
        firstActorType = state.actorTypes[0];
    if (!state.recurrentActionsIsDoneForCurrentEventType) {
        if (this._debug) log(this.name, &quot;Putting recurrent actions onto stack for event type: &quot; + currentEventType + &quot; and actor type: &quot; + state.currentActorType);
        this._putRecurrentActionsOntoStack(currentEventType, currentActorType);

        // We go to next actorType
        var newActorType = this._nextState(&quot;actorTypes&quot;, currentActorType);
        state.currentActorType = newActorType || firstActorType;
        state.recurrentActionsIsDoneForCurrentEventType = !newActorType;
        return false; // No need to use too much time.
    }

    var ourEvents = state.eventsToPublish[currentEventType];
    if (ourEvents.length) {
        this._putEventOntoStack(ourEvents[0], currentActorType);

        // We go to next actorType
        var newActorType2 = this._nextState(&quot;actorTypes&quot;, currentActorType);
        state.currentActorType = newActorType2 || firstActorType;
        // When the event is processed, we remove it from the array.
        newActorType2 || ourEvents.shift();
        return false; // No need to use too much time.
    }

    // We go to next eventType
    state.currentActorType = firstActorType;
    state.recurrentActionsIsDoneForCurrentEventType = false;
    var newEventType = this._nextState(&quot;eventTypes&quot;, currentEventType);
    if (this._debug &amp;&amp; newEventType !== &quot;&quot;) log(this.name, &quot;Gathering events to publish for state: &quot; + newEventType);
    // We may have finished: no more eventType, no more actorType, no more recurrentAction, no more event to respond to.
    state.currentEventType = newEventType || state.eventTypes[0];
    return !newEventType;
};
this._putRecurrentActionsOntoStack = function (currentEventType, currentActorType) {
    var state = this._State, actions = state.recurrentActionsByType[currentEventType][currentActorType],
        actorIds = state.actorsByType[currentActorType], shortStack = state.shortStack;
    var y = actions.length;
    while (y--) {
        var id = actions[y];
        var z = actorIds.length;
        while (z--) {
            shortStack.push({type: &quot;action&quot;, actorId: actorIds[z], recurrentActionId: id});
        }
    }
};
this._putEventOntoStack = function (thatEvent, currentActorType) {
    // FIXME perfectstyle we should use the eventId as arg rather than the whole event
    var eventActorId = thatEvent.actorId, eventEventType = thatEvent.eventType, eventArgs = thatEvent.args,
        state = this._State, actors = state.actors, eventActor = actors[eventActorId],
        observers = eventActor.observers[currentActorType], z = observers.length, shortStack = state.shortStack,
        responses = state.responses;
    while (z--) {
        var observer = actors[observers[z]];
        // First argument: observer, 2nd arg: eventActor, other args: other args
        var someArgs = [observer, eventActor].concat(eventArgs);
        var responseIds = observer.responsesIdByEventType[eventEventType];
        if (!responseIds) {
            continue; // No responses to process for this observer
        }
        var y = responseIds.length;
        while (y--) {
            shortStack.push({
                type: &quot;response&quot;,
                responseFunctionId: responses[responseIds[y]].responseFunctionId,
                args: someArgs
            });
        }
    }
};

/** @return {boolean} true if finished (empty stack), false otherwise. */
this._executeStack = function () {
    var s = this._State;
    var action = s.shortStack.shift();
    if (action === undefined) {
        return true;
    }
    // FIXME 0.perfectperf measure execution time?
    if (action.type == &quot;action&quot;) {
        this._Functions[s.recurrentActions[action.recurrentActionId].actionFunctionId](s.actors[action.actorId]);
    } else { // == &quot;response&quot;
        this._Functions[action.responseFunctionId](action.args);
    }
    return false;
};
this._addFrameCallback = function () {
    this._removeFrameCallback();
    if (this._debug) log(this.name, &quot;Adding frame callback&quot;);
    this._State.callback = addFrameCallback(this._ourFrameCallback);
};
this._removeFrameCallback = function () {
    if (this._State.callback) {
        removeFrameCallback(this._State.callback);
        delete this._State.callback;
        if (this._debug) log(this.name, &quot;Removed frame callback&quot;);
    }
};
this._ourFrameCallback = function (delta) {
    if (this._frame = ((this._frame || 0) + 1) % 10) { // One action each 10 frames
        return; // Only one in n frames is used.
    }

    var state = this._State;
    if (state.isJumpTokenBeingUsed) {
        state.isJumpTokenBeingUsed = !(this._executeStack() &amp;&amp; this._populateStack()); // Still some work to do ?
        return; // we did enough this time
    }

    if (state.jumpTokenNb) { // Do we have an available jump token?
        if (this._gatherEventsToPublish()) { // Finished gathering
            if (this._debug) log(this.name, &quot;Using a jump token&quot;);
            state.jumpTokenNb--;
            state.isJumpTokenBeingUsed = true;
        }
        return; // we did enough this time
    }

    if (this._debug) log(this.name, &quot;No more jump token&quot;);
    this._removeFrameCallback(); // We have finished, we remove the callback
}.bind(this);

/* ************************** Methods to save/restore *****************************************************/

this._functionReplacer = function (key, value) {
    return typeof value == &#39;function&#39; ? &#39;/Function(&#39; + value.toString() + &#39;)/&#39; : value;
};
this._functionReviver = (function () {
    var innerFn = function innerFn(key, value) {
        // All our special cases are strings // FIXME 0.perfectperf check if we get something else than string
        if (typeof value != &#39;string&#39;) {
            return value;
        }

        var that = innerFn; // Closure for recursion
        if (value.match(that._functionRegexp)) { // FIXME 0.perfectperf: benchmark using only one regexp rather than 2
            return eval(value.replace(that._functionReplaceRegexp, &#39;($1)&#39;));
        }
        return value;
    };
    innerFn._functionRegexp = new RegExp(&quot;^\\/Function\\([\\s\\S]*\\)\\/$&quot;);
    innerFn._functionReplaceRegexp = new RegExp(&quot;^\\/Function\\(([\\s\\S]*)\\)\\/$&quot;);
    return innerFn;
}.bind(this))();

/* ************************** Oolite events ***************************************************************/

this._startUp = function () {
    var sa = this._missionVariables.DayDiplomacyEngine_EngineState;
    if (sa &amp;&amp; sa.length) { // Loading if necessary.
        this._loadState(this._State, this._JSON.parse(sa));
        this._loadState(this._Functions, this._JSON.parse(this._missionVariables.DayDiplomacyEngine_Functions, this._functionReviver));
    }

    delete this._startUp; // No need to startup twice
};
this.playerWillSaveGame = function (message) {
    this._removeFrameCallback();
    var start = new Date();
    this._missionVariables.DayDiplomacyEngine_EngineState = this._JSON.stringify(this._State);
    this._missionVariables.DayDiplomacyEngine_Functions = this._JSON.stringify(this._Functions, this._functionReplacer);
    var end = new Date();
    log(&quot;DiplomacyEngine&quot;, &quot;Saved in ms: &quot; + (end.getTime() - start.getTime()));
    this._addFrameCallback();
};
this.shipExitedWitchspace = function () {
    var s = this._State;
    s.jumpTokenNb || (s.jumpTokenNb = 0);
    s.jumpTokenNb++;
    if (this._debug) log(this.name, &quot;Added jump token&quot;);
};
this.shipDockedWithStation = function (station) {
    this._addFrameCallback();
};
this.shipWillLaunchFromStation = function (station) {
    this._removeFrameCallback();
};

/* ************************** Subscribing system for scripts order ****************************************/

this.startUp = function () {
    worldScripts.DayDiplomacy_000_Engine.$subscribe(this.name);
    delete this.startUp; // No need to startup twice
};
this.startUpComplete = function () {
    var s = this._subscribers.sort();
    var z = s.length, y = z - 1;
    while (z--) {
        var startDate = new Date();
        worldScripts[s[y - z]]._startUp();
        log(s[y - z], &quot;startUp in ms: &quot; + (new Date().getTime() - startDate.getTime()));
    }

    this.shipDockedWithStation(null); // When starting, the player is docked.

    delete this.startUpComplete; // No need to startup twice
};

// FIXME create a type ScriptName?
/**  names of scripts
 * @type {string[]} */
this._subscribers = [];

/**
 * Allows an external script to use the Diplomacy API.
 * The external script must implement a function named _startUp() which will be called during the startUpComplete() function of the Diplomacy Engine.
 * @name $subscribe
 * @param {string} scriptName - the name property of the subscribing script object
 * @lends worldScripts.DayDiplomacy_000_Engine.$subscribe
 */
this.$subscribe = function (scriptName) {
    this._subscribers.push(scriptName);
};</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/DayDiplomacy_GNNConnector.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name = &quot;DayDiplomacy_015_GNN&quot;;
this.author = &quot;David (Day) Pradier&quot;;
// noinspection JSUnusedGlobalSymbols Used by Oolite itself
this.copyright = &quot;(C) 2017 David Pradier&quot;;
// noinspection JSUnusedGlobalSymbols Used by Oolite itself
this.licence = &quot;CC-NC-by-SA 4.0&quot;;
this.description = &quot;This script connects to the GNN OXP.&quot;;

/**
 *
 * @param message
 * @lends worldScripts.DayDiplomacy_015_GNN.$publishNews
 */
this.$publishNews = function (message) {
    var news = {ID:this.name, Message:message};
    var returnCode = worldScripts.GNN._insertNews(news);
    if (returnCode &gt; 0) { // A prerequisite is wrong
        log(&quot;DayDiplomacy_015_GNN.$publishNews&quot;, &quot;GNN ERROR: &quot; + returnCode);
    } // else: everything is okay.
};

/**
 *
 * @param message
 * @lends worldScripts.DayDiplomacy_015_GNN.$publishNewsNow
 */
this.$publishNewsNow = function (message) {
    var news = {ID:this.name, Message:message};
    var returnBoolean = worldScripts.GNN._showScreen(news);
    if (!returnBoolean) { // A prerequisite is wrong
        log(&quot;DayDiplomacy_015_GNN.$publishNewsNow&quot;, &quot;GNN ERROR&quot;);
    } // else: everything is okay.
};

/* ************************** Oolite events ***************************************************************/

this._startUp = function () {
    delete this._startUp; // No need to startup twice
};
this.startUp = function () {
    worldScripts.DayDiplomacy_000_Engine.$subscribe(this.name);
    delete this.startUp; // No need to startup twice
};</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/DayDiplomacy_History.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name = &quot;DayDiplomacy_020_History&quot;;
this.author = &quot;David (Day) Pradier&quot;;
// noinspection JSUnusedGlobalSymbols Used by Oolite itself
this.copyright = &quot;(C) 2017 David Pradier&quot;;
// noinspection JSUnusedGlobalSymbols Used by Oolite itself
this.licence = &quot;CC-NC-by-SA 4.0&quot;;
this.description = &quot;This script displays an Interface showing the F7 system history.&quot;;

this._displayF4Interface = function () {
    player.ship.hudHidden || (player.ship.hudHidden = true);
    // for each event in history for this system, we add a line
    var ourMessage = &quot;&quot;, f = this._F, eff = this._eff,
        ourEventsIds = this._Engine.$getActorEvents(this._selectedSystemActorId), events = this._Engine.$getEvents(),
        y = ourEventsIds.length, _clock = clock;
    while (y--) {
        // Anti-chronological order
        var thatEvent = events[ourEventsIds[y]];
        ourMessage += _clock.clockStringForTime(thatEvent.date) + &quot;: &quot; + f[eff[thatEvent.eventType]](thatEvent)+&quot;\n&quot;;
    }
    var opts = {
        screenID: &quot;DiplomacyHistoryScreenId&quot;,
        title: &quot;System history&quot;,
        allowInterrupt: true,
        exitScreen: &quot;GUI_SCREEN_INTERFACES&quot;,
        message: ourMessage
    };
    mission.runScreen(opts);
};
this._initF4Interface = function () {
    player.ship.dockedStation.setInterface(&quot;DiplomacyHistory&quot;,
        {
            title: &quot;System history&quot;,
            category: &quot;Diplomacy&quot;,
            summary: &quot;All the notable events in the system history&quot;,
            callback: this._displayF4Interface.bind(this)
        });
};

/* ************************** OXP public functions ********************************************************/

/**
 * @param {EventType} eventType
 * @param {function} func
 * @lends worldScripts.DayDiplomacy_020_History.$setEventFormattingFunction
 */
this.$setEventFormattingFunction = function(eventType, func) {
    var engine = this._Engine;
    var fid = engine.$getNewFunctionId();
    engine.$setFunction(fid, func);
    this._eff[eventType] = fid;
};

/* ************************** Oolite events ***************************************************************/

this.infoSystemChanged = function (currentSystemId, previousSystemId) {
    this._selectedSystemActorId = this._Systems.$getCurrentGalaxySystemsActorIdsBySystemsId()[currentSystemId];
};
this.shipDockedWithStation = function (station) {
    this._initF4Interface();
};
this.missionScreenEnded = function () {
    player.ship.hudHidden = false;
};

this._startUp = function () {
    worldScripts.XenonUI &amp;&amp; worldScripts.XenonUI.$addMissionScreenException(&quot;DiplomacyHistoryScreenId&quot;);
    worldScripts.XenonReduxUI &amp;&amp; worldScripts.XenonReduxUI.$addMissionScreenException(&quot;DiplomacyHistoryScreenId&quot;);

    var engine = this._Engine = worldScripts.DayDiplomacy_000_Engine;
    this._Systems = worldScripts.DayDiplomacy_010_Systems;
    this._F = engine.$getFunctions();
    this._selectedSystemActorId = this._Systems.$getCurrentGalaxySystemsActorIdsBySystemsId()[system.info.systemID]; // FIXME perfectperf?
    this._eff = engine.$initAndReturnSavedData(&quot;eventFormatingFunctionsIds&quot;, {}); // { eventType =&gt; functionId }

    this._initF4Interface();

    delete this._startUp; // No need to startup twice
};
this.startUp = function () {
    worldScripts.DayDiplomacy_000_Engine.$subscribe(this.name);
    delete this.startUp; // No need to startup twice
};</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/DayDiplomacy_JsDocDiplomacy.js</td>
                    <td><pre>&quot;use strict&quot;;

/**
 * An id identifying an {@link Actor}
 * @typedef ActorId
 * @alias {string}
 */

/**
 * An id identifying an {@link Action}
 * @typedef ActionId
 * @alias {string}
 */

/**
 * An id identifying a {@link DiplomacyEvent}
 * @typedef EventId
 * @alias {string}
 */

/**
 * An id identifying a {@link DiplomacyFunction}
 * @typedef FunctionId
 * @alias {string}
 */

/**
 * An id identifying a {@link DiplomacyResponse}
 * @typedef ResponseId
 * @alias {string}
 */

/**
 * A type qualifying a {@link DiplomacyEvent}
 * @typedef EventType
 * @alias {string}
 */

/**
 * A type of {@link Actor}
 * @typedef ActorType
 * @alias {string}
 */

/**
 @typedef DiplomacyEvent
 @property {EventId} id
 @property {EventType} eventType
 @property {ActorId} actorId - actorId
 @property {Object[]} args
 @property {number} date - seconds since epoch
 */

/**
 @typedef DiplomacyResponse
 @property {ResponseId} id
 @property {EventType} eventType
 @property {ActorType} actorType
 @property {FunctionId} responseFunctionId
 */

/**
 @typedef Actor
 @property {ActorId} id
 @property {ActorType} actorType
 @property {Object&lt;ActorType,ActorId[]&gt;} observers
 @property {Object&lt;EventType,ResponseId[]&gt;} responsesIdByEventType
 */

/**
 @typedef Action
 @property {ActionId} id
 @property {EventType} eventType - anEventType is used to order the actions and events execution. For a same eventType, Actions are executed before Events.
 @property {ActorType} actorType - Only actors of the type will execute the action.
 @property {FunctionId} actionFunctionId - the id of a function which must take one and only one argument: the actor which will &quot;act&quot;.

 */

/**
 * @typedef Script
 * @property {string} name FIXME
 * @property {string} author FIXME
 * @property {string} copyright FIXME
 * @property {string} description FIXME
 * @property {string} licence FIXME
 */

/**
 * The Diplomacy Engine script
 * @type Script
 */
worldScripts.DayDiplomacy_000_Engine;

/**
 * The Diplomacy Planetary Systems script
 * @type Script
 */
worldScripts.DayDiplomacy_010_Systems;

/**
 * The Diplomacy-Snoopers connector script
 * @type Script
 */
worldScripts.DayDiplomacy_015_GNN;

/**
 * The Diplomacy History script
 * @type Script
 */
worldScripts.DayDiplomacy_020_History;

/**
 * The Diplomacy Economy script
 * @type Script
 */
worldScripts.DayDiplomacy_030_EconomyEngine;

/**
 * The Diplomacy War Engine script
 * @type Script
 */
worldScripts.DayDiplomacy_040_WarEngine;

/**
 * The Diplomacy War script
 * @type Script
 */
worldScripts.DayDiplomacy_045_War;

/**
 * The Diplomacy Citizenships script
 * @type Script
 */
worldScripts.DayDiplomacy_060_Citizenships;

/**
 * The XenonUI script, for compatibility
 * @type Script
 */
worldScripts.XenonUI;

/**
 * @function
 */
worldScripts.XenonUI.$addMissionScreenException;

/**
 * The XenonReduxUI script, for compatibility
 * @type Script
 */
worldScripts.XenonReduxUI;

/**
 * @function
 */
worldScripts.XenonReduxUI.$addMissionScreenException;</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/DayDiplomacy_JsDocOolite.js</td>
                    <td><pre>&quot;use strict&quot;;
/**
 * The System class represents the current system. There is always one System object, available through the global property system.
 * @typedef System
 * @property {int} ID {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_System#ID}
 * @property {SystemInfo} info {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_System#info}
 * @property {function} infoForSystem {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_System#infoForSystem}
 * @property {string} name {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_System#name}
 * @property {int} population {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_System#population}
 * @property {int} productivity {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_System#productivity}
 * @property {int} techLevel {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_System#techLevel}
 * @property {int} government {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_System#government}
 * @see {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_System}
 */

/**
 * @function System.infoForSystem
 * @param {int} galaxyID
 * @param {int} systemID
 * @return {SystemInfo}
 * @see {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_System#infoForSystem}
 */

/**
 * SystemInfo objects provide information about a specific system.
 * @typedef SystemInfo
 * @property {int} galaxyID {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_SystemInfo#galaxyID}
 * @property {int} systemID {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_SystemInfo#systemID}
 * @property {int} productivity
 * @property {int} population
 * @property {function} systemsInRange {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_SystemInfo#systemsInRange}
 * @see {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_SystemInfo}
 */

/**
 *  Returns the SystemInfo of the systems nearer than 7 ly from the original SystemInfo
 * @function SystemInfo.systemsInRange
 * @instance
 * @return {SystemInfo[]}
 */

// Note: player.ship doesn&#39;t exist in the Oolite player wiki.
/**
 * The Player class is represents the player. There is always exactly one Player object in existence, which can be accessed through the player global property.
 * @typedef Player
 * @property {PlayerShip} ship
 * @property {Number} credits {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_Player#credits}
 * @property {int} bounty {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_Player#bounty}
 * @property {function} commsMessage  {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_Player#commsMessage}
 * @see {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_Player}
 */

/**
 * @function Player.commsMessage
 * @param {string} message
 * @instance
 * @see {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_Player#commsMessage}
 */

/**
 * The Ship class is an Entity representing a ship, station, missile, cargo pod or other flying item – anything that can be specified in shipdata.plist.
 * @typedef Ship
 * @property {int} homeSystem {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_Ship#homeSystem}
 * @property {function} awardEquipment {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_Ship#awardEquipment}
 * @see {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_Ship}
 */

/**
 * The Station class is an Entity representing a station or carrier (i.e., a ship with a docking port). A Station has all the properties and methods of a Ship, and some others.
 * @typedef {Ship} Station
 * @augments {Ship}
 * @property {function} setInterface {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_Station#setInterface}
 * @see {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_Station}
 */

/**
 * The PlayerShip class is an Entity representing the player’s ship. The PlayerShip has all the properties and methods of a Ship, and several others. There is always exactly one PlayerShip object in existence, which can be accessed through player.ship.
 * @typedef {Ship} PlayerShip
 * @augments {Ship}
 * @property {boolean} hudHidden {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_PlayerShip#hudHidden}
 * @property {Station} dockedStation {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_PlayerShip#dockedStation}
 * @see {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_PlayerShip}
 */

/**
 * The mission global object is used to run mission screens, and perform other actions related to mission scripting.
 * @typedef Mission
 * @property {function} runScreen {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_Mission#runScreen}
 * @see {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_Mission}
 */

/**
 * The clock global object is used to tell the time. Apart from absoluteSeconds, all its properties have to do with game clock time.
 * @typedef Clock
 * @property {int} seconds
 * @property {function} clockStringForTime {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:Clock#clockStringForTime}
 * @see {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_Clock}
 */

/**
 * @name system
 * @type System
 * */
var system;

/**
 * @name player
 * @type Player
 * */
var player;

/**
 * @name mission
 * @type Mission
 * */
var mission;

/**
 * @name missionVariables
 * @type Object
 * @see {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_Global#missionVariables}
 * */
var missionVariables;


/**
 * The dictionary of all available oxp scripts.
 * @name worldScripts
 * @type Object
 * @see {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_Global#worldScripts}
 */
var worldScripts;

/**
 * @name clock
 * @type Clock
 * */
var clock;

/**
 * @function
 * @param {string} prefix prefix
 * @param {string} textToLog text to log
 * @see {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_Global#log}
 */
var log = function(prefix, textToLog) {};

/**
 * @function
 * @param {function} callback
 * @return {string} trackingID
 * @see {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_Global#addFrameCallback}
 */
var addFrameCallback = function (callback) {};

/**
 * @function
 * @param {string} trackingID
 * @see {@link http://wiki.alioth.net/index.php/Oolite_JavaScript_Reference:_Global#removeFrameCallback}
 */
var removeFrameCallback = function (trackingID) {};</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/DayDiplomacy_Systems.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name = &quot;DayDiplomacy_010_Systems&quot;;
this.author = &quot;David (Day) Pradier&quot;;
// noinspection JSUnusedGlobalSymbols Used by Oolite itself
this.copyright = &quot;(C) 2017 David Pradier&quot;;
// noinspection JSUnusedGlobalSymbols Used by Oolite itself
this.licence = &quot;CC-NC-by-SA 4.0&quot;;
this.description = &quot;This script creates systems.&quot;;

/**
 * An object identifying a planetary system
 * @typedef {Object} PlanetarySystem
 * @property {int} galaxyID - the galaxyID of the system
 * @property {int} systemID - the systemID of the system
 * @property {string} name - the name of the system
 */

/* ************************** OXP public functions *******************************************************/

/**
 *
 * @param {int} galaxyID - Identifies the galaxy of the wanted system
 * @param {int} systemID - Identifies the wanted system in the given galaxy
 * @return {Actor}
 * @lends worldScripts.DayDiplomacy_010_Systems.$retrieveActorFromSystem
 */
this.$retrieveActorFromSystem = function (galaxyID, systemID) {
    return this._Engine.$getActors()[this._systemsByGalaxyAndSystemId[galaxyID][systemID]];
};

/**
 * @param {int} galaxyID - Identifies the galaxy of the wanted system
 * @param {int} systemID - Identifies the wanted system in the given galaxy
 * @returns {String} - Returns the system name of the system defined by the given galaxyId and systemId
 * @lends worldScripts.DayDiplomacy_010_Systems.$retrieveNameFromSystem
 */
this.$retrieveNameFromSystem = function (galaxyID, systemID) {
    return this._Engine.$getActors()[this._systemsByGalaxyAndSystemId[galaxyID][systemID]].name;
};

/**
 * @returns {Object} a dictionary with {int} galaxyId key and as value: a dictionary with {int} systemId key and as value: the corresponding {@link ActorId}
 * @lends worldScripts.DayDiplomacy_010_Systems.$getSystemsActorIdsByGalaxyAndSystemId
 */
this.$getSystemsActorIdsByGalaxyAndSystemId = function() {
    return this._systemsByGalaxyAndSystemId;
};
/**
 * For the current galaxy only
 * @returns {Object} a dictionary with {int} systemId key and as value: the corresponding {@link ActorId}
 * @lends worldScripts.DayDiplomacy_010_Systems.$getCurrentGalaxySystemsActorIdsBySystemsId
 */
this.$getCurrentGalaxySystemsActorIdsBySystemsId = function() {
    return this._systemsByGalaxyAndSystemId[system.info.galaxyID];
};

/* ************************** OXP private functions *******************************************************/

/**
 * @param {int} aGalaxyNb
 * @private
 */
this._setObservers = function (aGalaxyNb) {
    // We set the observers. No need to use an initAction as there won&#39;t be any more system.
    var engine = this._Engine;
    var actorsIdByType = engine.$getActorsIdByType(&quot;SYSTEM&quot;);
    var actors = engine.$getActors();

    var galaxyFirstSystem = actors[actorsIdByType[255 + 256 * (7 - aGalaxyNb)]];
    var galaxyLastSystem = actors[actorsIdByType[256 * (7 - aGalaxyNb)]];
    var firstSystemKnownObservers = engine.$getObservers(galaxyFirstSystem, &quot;SYSTEM&quot;);
    var lastSystemKnownObservers = engine.$getObservers(galaxyLastSystem, &quot;SYSTEM&quot;);
    if (firstSystemKnownObservers &amp;&amp; firstSystemKnownObservers.length &amp;&amp; lastSystemKnownObservers.length) {
        return; // Already initialized
    }

    var infoForSystem = System.infoForSystem, sys = this._systemsByGalaxyAndSystemId, z = actorsIdByType.length;
    while (z--) {
        var thisActor = actors[actorsIdByType[z]];
        if (thisActor.galaxyNb === aGalaxyNb &amp;&amp; !thisActor.observers.length) {
            var observers = infoForSystem(aGalaxyNb, thisActor.systemId).systemsInRange();
            var y = observers.length;
            while (y--) {
                var observer = observers[y];
                engine.$addObserverToActor(thisActor, &quot;SYSTEM&quot;, sys[observer.galaxyID][observer.systemID]);
            }
        }
    }
};

this._startUp = function () {
    var engine = this._Engine = worldScripts.DayDiplomacy_000_Engine;
    var sys = this._systemsByGalaxyAndSystemId = engine.$initAndReturnSavedData(&quot;systemsByGalaxyAndSystemId&quot;, {});

    // Not initializing if already done.
    if (engine.$getActorTypes().indexOf(&quot;SYSTEM&quot;) !== -1) {
        return;
    }
    /** @type {ActorType} */
    var actorType = &quot;SYSTEM&quot;;
    engine.$addActorType(actorType, 0);

    // We initiate the systems
    var i = 8;
    while (i--) {
        var j = 256;
        while (j--) {
            var id = engine.$getNewActorId();
            var aSystem = engine.$buildActor(&quot;SYSTEM&quot;, id);
            // FIXME why do I use setField here rather than directly &#39;aSystem.galaxyNb = &#39;?
            engine.$setField(aSystem, &quot;galaxyNb&quot;, i);
            engine.$setField(aSystem, &quot;systemId&quot;, j);
            engine.$addActor(aSystem);
            (sys[i] || (sys[i] = {}))[j] = id; // Needed for quick access in the next part.
        }
    }

    // We init the observers for the current galaxy
    this._setObservers(system.info.galaxyID);
    delete this._startUp; // No need to startup twice
};

/* ************************** Oolite events ***************************************************************/

// noinspection JSUnusedGlobalSymbols - Called by Oolite itself
this.playerEnteredNewGalaxy = function (galaxyNumber) {
    // This function is necessary as we can&#39;t calculate distances in other galaxies.
    this._setObservers(galaxyNumber);
};
this.startUp = function () {
    worldScripts.DayDiplomacy_000_Engine.$subscribe(this.name);
    delete this.startUp; // No need to startup twice
};</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/DayDiplomacy_War.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name = &quot;DayDiplomacy_045_War&quot;;
this.author = &quot;David (Day) Pradier&quot;;
// noinspection JSUnusedGlobalSymbols Used by Oolite itself
this.copyright = &quot;(C) 2017 David Pradier&quot;;
// noinspection JSUnusedGlobalSymbols Used by Oolite itself
this.licence = &quot;CC-NC-by-SA 4.0&quot;;
this.description = &quot;This script makes systems ally to each other,&quot; +
    &quot; break their alliances,&quot; +
    &quot; make peace and war,&quot; +
    &quot; publish the related news,&quot; +
    &quot; draw the war and the diplomatic maps.&quot;;

/* ************************** OXP private functions *******************************************************/

// FIXME 0.14 make that as long as we are not in 1.0, the diplomacy save data is erased when there is a new version?
this._initSystemsScores = function (aGalaxyNb) {
    // Initializing static scores
    // For a given galaxy, for each system in the galaxy, for each system it observes,
    // it must assign a score to some properties, then recalculate the final score.
    // FIXME perfectstyle shouldn&#39;t this script be actorType-agnostic?
    var engine = this._s;
    var actorsIdByType = engine.$getActorsIdByType(&quot;SYSTEM&quot;);
    var actors = engine.$getActors();
    var z = actorsIdByType.length;
    var we = this._we;
    while (z--) {
        var thisActor = actors[actorsIdByType[z]];
        if (thisActor.galaxyNb != aGalaxyNb) {
            continue;
        }
        var observersId = thisActor.observers[&quot;SYSTEM&quot;];
        var y = observersId.length;
        while (y--) {
            we.$recalculateScores(actors[observersId[y]], thisActor);
        }
    }
};
this._drawDiplomaticMap = function () {
    var scores = this._we.$getScores();
    var actors = this._s.$getActors();
    var links = [];

    for (var observedId in scores) {
        if (scores.hasOwnProperty(observedId)) {
            var observed = actors[observedId];
            var observedNb = observed.systemId;
            var galaxyNb = observed.galaxyNb;
            var observedScores = scores[observedId];
            for (var observerId in observedScores) {
                if (observedScores.hasOwnProperty(observerId)) {
                    var observerNb = actors[observerId].systemId;
                    // Doc: &quot;When setting link_color, the lower system ID must be placed first,
                    // because of how the chart is drawn.&quot;
                    if (observerNb &lt; observedNb) {
                        var scoreFromTo = observedScores[observerId].SCORE;
                        var scoreToFrom = scores[observerId][observedId].SCORE;
                        if (scoreFromTo || scoreToFrom) {
                            var color = null;
                            if (scoreFromTo &gt; 0 &amp;&amp; scoreToFrom &gt; 0) {
                                color = &quot;greenColor&quot;;
                            } else if (scoreFromTo &lt; 0 &amp;&amp; scoreToFrom &lt; 0) {
                                color = &quot;redColor&quot;;
                            } else if (scoreFromTo * scoreToFrom &lt; 0) {
                                color = &quot;yellowColor&quot;;
                            } else if (scoreFromTo + scoreToFrom &gt; 0) {
                                color = &quot;blueColor&quot;;
                            } else {
                                color = &quot;orangeColor&quot;;
                            }
                            links.push({galaxyNb: galaxyNb, from: observerNb, to: observedNb, color: color});
                        }
                    }
                }
            }
        }
    }

    this._drawMap(links);
};
this._drawWarMap = function () {
    var alliancesAndWars = this._we.$getAlliancesAndWars();
    var actors = this._s.$getActors();
    var links = [];

    for (var actorId in alliancesAndWars) {
        if (alliancesAndWars.hasOwnProperty(actorId)) {
            var actorAlliancesAndWars = alliancesAndWars[actorId];
            var actor = actors[actorId];
            var systemNb = actor.systemId;
            var galaxyNb = actor.galaxyNb;
            for (var targetId in actorAlliancesAndWars) {
                if (actorAlliancesAndWars.hasOwnProperty(targetId)) {
                    var targetSystemNb = actors[targetId].systemId;
                    // Doc: &quot;When setting link_color, the lower system ID must be placed first,
                    // because of how the chart is drawn.&quot;
                    if (systemNb &lt; targetSystemNb) {
                        links.push({
                            galaxyNb: galaxyNb,
                            from: systemNb,
                            to: targetSystemNb,
                            color: actorAlliancesAndWars[targetId] === 1 ? &quot;greenColor&quot; : &quot;redColor&quot;
                        });
                    }
                }
            }
        }
    }

    this._drawMap(links);
};
this._drawWarringMap = function () {
    var alliancesAndWars = this._we.$getAlliancesAndWars();
    var actors = this._s.$getActors();
    var warringSystems = [];
    var m = mission;

    mainloop:
        for (var actorId in alliancesAndWars) {
            if (alliancesAndWars.hasOwnProperty(actorId)) {
                var actorAlliancesAndWars = alliancesAndWars[actorId];
                var systemNb = actors[actorId].systemId;
                for (var targetId in actorAlliancesAndWars) {
                    if (actorAlliancesAndWars.hasOwnProperty(targetId)) {
                        if (actorAlliancesAndWars[targetId] === -1) {
                            m.markSystem({system: systemNb, name: &quot;DayDiplomacyWarringMap&quot;});
                            continue mainloop;
                        }
                    }
                }
            }
        }
};
this._drawMap = function (links) {
    var systemInfo = SystemInfo;
    var z = links.length;
    while (z--) {
        var link = links[z];
        // Hmm... We calculate and then set the links for all the galaxies...
        // This is useless, but at the same time simpler and maybe useful for the future.
        systemInfo.setInterstellarProperty(link.galaxyNb, link.from, link.to, 2, &quot;link_color&quot;, link.color);
    }
    this._links = links;
};
this._resetLinks = function () {
    var m = mission;
    var i = 256;
    while(i--) {
        m.unmarkSystem({system:i, name:&quot;DayDiplomacyWarringMap&quot;});
    }

    var links = this._links;
    if (!links) return;
    var systemInfo = SystemInfo;
    var z = links.length;
    while (z--) {
        var link = links[z];
        systemInfo.setInterstellarProperty(link.galaxyNb, link.from, link.to, 2, &quot;link_color&quot;, null);
    }
    this._links = null;
};

/**
 * If 2 vectors are given, center is the center of the vectors, and zoom the customChartCentreInLY value
 * necessary to display the 2 vectors and 20% more space around.
 * If only one vector is given, the center is that vector, and the zoom is 1.5.
 * @param {Vector3D} v1
 * @param {Vector3D} v2
 * @return {{center: Vector3D, zoom: number}}
 * @private
 */
this._getCustomZoom = function (v1, v2) {
    var z = 1.5;
    if (v2) {
        var v = v1.subtract(v2).multiply(1.2);
        z = Math.min(4, Math.max(1, Math.abs(v.x) / 100 * 4, Math.abs(v.y) / 50 * 4));
    }
    return {
        center: v2 ? v1.add(v2).multiply(.5) : v1,
        zoom: z
    };
};

/**
 * Save the target system and make as if there was no target system, so that no trajectory appears.
 * @private
 */
this._saveTarget = function () {
    if (!this._savedTarget) {
        this._savedTarget = player.ship.targetSystem;
        player.ship.targetSystem = system.info.systemID;
    }
};
/**
 * Reloads the target system.
 * @private
 */
this._loadTarget = function () {
    if (this._savedTarget) {
        player.ship.targetSystem = this._savedTarget;
        this._savedTarget = undefined;
    }
};

this._F4InterfaceCallback = function (choice) {
    this._loadTarget();

    // Exit
    if (choice === &quot;5_EXIT&quot;) {
        return;
    }

    // Default choice
    choice = choice === &quot;DiplomacyWars&quot; ? &quot;0_WARRING_NO_TRAVEL&quot; : choice;

    // Choice
    var choices = choice.split(&quot;_&quot;);
    var no = choices[0], wd = choices[1], qs = choices[2], td = choices[3];

    // Options
    var wdp = [&quot;WARRING&quot;, &quot;WARS&quot;, &quot;DIPLOMACY&quot;];
    var qsp = [&quot;QUICK&quot;, &quot;SHORT&quot;, &quot;NO&quot;];
    var tdp = [&quot;TARGET&quot;, &quot;TRAVEL&quot;];

    // Next proposed options
    var nextwd = wdp[(wdp.indexOf(wd) + 1) % wdp.length];
    var nextqs = qsp[(qsp.indexOf(qs) + 1) % qsp.length];
    var nexttd = tdp[(tdp.indexOf(td) + 1) % tdp.length];

    var bgs = {QUICK: &quot;CUSTOM_CHART_QUICKEST&quot;, SHORT: &quot;CUSTOM_CHART_SHORTEST&quot;, NO: &quot;CUSTOM_CHART&quot;};

    var texts = {
        WARRING: &quot;Display warring systems&quot;,
        WARS: &quot;Display wars map&quot;,
        DIPLOMACY: &quot;Display diplomacy map&quot;,
        QUICK: &quot;Display quickest travel&quot;,
        SHORT: &quot;Display shortest travel&quot;,
        NO: &quot;Display no travel&quot;,
        TARGET: &quot;Display the target surroundings&quot;,
        TRAVEL: &quot;Display the travel surroundings&quot;
    };

    // Init
    this._resetLinks();
    var playerShip = player.ship;
    playerShip.hudHidden || (playerShip.hudHidden = true);

    var opts = {
        screenID: &quot;DiplomacyWarScreenId&quot;,
        title: &quot;Star wars&quot;,
        allowInterrupt: true,
        exitScreen: &quot;GUI_SCREEN_INTERFACES&quot;,
        choices: {&quot;5_EXIT&quot;: &quot;Exit&quot;}
    };

    if (no === &#39;4&#39;/*Help*/) {
        opts.message = &quot;Warring systems map: red crosses\n\nDiplomacy map:\nGreen: Love\nBlue: Love+Neutrality\nGray: Neutrality\nYellow: Love+Hate\nOrange: Neutrality+Hate\nRed: Hate\n&quot;
            + &quot;\n\nWars map:\nRed: war\nGreen: alliance&quot;;
    } else {
        // Screen
        var info = system.info;

        var currentSystemCoordinates = info.coordinates;
        var targetCoordinates = System.infoForSystem(info.galaxyID, playerShip.targetSystem).coordinates;
        var customZoom = td === &quot;TARGET&quot;
            ? this._getCustomZoom(targetCoordinates, undefined)
            : this._getCustomZoom(currentSystemCoordinates, targetCoordinates);

        if (qs === &quot;NO&quot;) this._saveTarget();

        opts.backgroundSpecial = bgs[qs];

        opts.customChartZoom = customZoom.zoom;
        opts.customChartCentreInLY = customZoom.center;

        switch (wd) {
            case &#39;DIPLOMACY&#39;:
                this._drawDiplomaticMap();
                break;
            case &#39;WARS&#39;:
                this._drawWarMap();
                break;
            case &#39;WARRING&#39;:
                this._drawWarringMap();
                break;
        }
    }

    opts.choices[[1, nextwd, qs, td].join(&#39;_&#39;)] = texts[nextwd];
    opts.choices[[2, wd, nextqs, td].join(&#39;_&#39;)] = texts[nextqs];
    opts.choices[[3, wd, qs, nexttd].join(&#39;_&#39;)] = texts[nexttd];
    opts.choices[[4, wd, qs, td].join(&#39;_&#39;)] = &quot;Help&quot;;

    mission.runScreen(opts, this._F4InterfaceCallback.bind(this));
};

this._initF4Interface = function () {
    if (player.ship.hasEquipmentProviding(&quot;EQ_ADVANCED_NAVIGATIONAL_ARRAY&quot;)) {
        player.ship.dockedStation.setInterface(&quot;DiplomacyWars&quot;,
            {
                title: &quot;Star wars&quot;,
                category: &quot;Diplomacy&quot;,
                summary: &quot;Wars and diplomacy&quot;,
                callback: this._F4InterfaceCallback.bind(this)
            });
    }
};
this._startUp = function () {
    // FIXME 0.perfectstyle hmff, this might have to be into its own function.
    // Nope, it would be contrary to perfectperf. Explain that in TechnicalPrinciples.txt.
    // XenonUI would overlay over our mission screens without these exception.
    // FIXME 0.perfectstyle i should have a list of screens, rather than copying here their names, to avoid forgetting
    // to update here when I add or change a screen.
    worldScripts.XenonUI &amp;&amp; worldScripts.XenonUI.$addMissionScreenException(&quot;DiplomacyWarScreenId&quot;);
    worldScripts.XenonReduxUI &amp;&amp; worldScripts.XenonReduxUI.$addMissionScreenException(&quot;DiplomacyWarScreenId&quot;);

    this._storedNews = []; // No real need to save it
    var engine = this._s;
    var we = this._we = worldScripts.DayDiplomacy_040_WarEngine;
    var sf = we.$getScoringFunctions();

    // Economy comparison
    if (sf.indexOf(&quot;EconomyComparison&quot;) === -1) {
        we.$addScoringFunction(&quot;EconomyComparison&quot;, function (observer, observed) {
            var map = {
                0: {0: +0.5, 1: -1.0, 2: -0.5, 3: -1.0, 4: -1.0, 5: -0.5, 6: -0.5, 7: -0.5}, // Anarchy
                1: {0: +0.0, 1: +0.5, 2: -0.5, 3: -0.5, 4: -1.0, 5: -0.5, 6: -1.0, 7: -0.5}, // Feudal
                2: {0: +0.0, 1: +0.0, 2: +0.5, 3: -0.5, 4: -0.5, 5: +0.5, 6: +0.0, 7: +0.0}, // Multi-government
                3: {0: +0.0, 1: +0.0, 2: +0.0, 3: +0.5, 4: +0.0, 5: +0.0, 6: -0.5, 7: +0.0}, // Dictator
                4: {0: -0.5, 1: -0.5, 2: +0.0, 3: +0.0, 4: +0.5, 5: +0.0, 6: -0.5, 7: -0.5}, // Communist
                5: {0: +0.0, 1: +0.0, 2: +0.5, 3: -0.5, 4: +0.0, 5: +0.5, 6: +0.0, 7: +0.0}, // Confederacy
                6: {0: +0.0, 1: -0.5, 2: +0.0, 3: -0.5, 4: -0.5, 5: +0.0, 6: +0.5, 7: +0.0}, // Democracy
                7: {0: +0.0, 1: +0.0, 2: +0.0, 3: +0.0, 4: -1.0, 5: +0.0, 6: +0.0, 7: +0.5}  // Corporate
            };
            return map[observer.government][observed.government];
        }, 0);
    }

    // Alliances influence on score, this function is and should be last executed.
    if (sf.indexOf(&quot;alliancesAndWarsInfluence&quot;) === -1) {
        we.$addScoringFunction(&quot;alliancesAndWarsInfluence&quot;, function alliancesAndWarsInfluence(observer, observed) {

            /* This function calculates the relation bonus given by observer to observed, depending on observed allies and foes.
             * If their allies are considered nice by observer, they get a bonus.
             * If their foes are considered baddies by observer, they get a bonus.
             * And vice-versa. */
            var that = alliancesAndWarsInfluence;
            var we = that.we || (that.we = worldScripts.DayDiplomacy_040_WarEngine);
            var observedAlliesAndFoes = we.$getAlliancesAndWars()[observed.id];
            var allScores = we.$getScores();
            var observerId = observer.id;

            var result = 0;
            for (var alliedId in observedAlliesAndFoes) {
                if (observedAlliesAndFoes.hasOwnProperty(alliedId)) {
                    var scores = allScores[alliedId][observerId];
                    scores &amp;&amp; (result += observedAlliesAndFoes[alliedId] * scores.SCORE);
                }
            }
            return result &gt; 0 ? .25 : result &lt; 0 ? -.25 : 0;

        }, 1);
    }

    this._initSystemsScores(system.info.galaxyID);

    // We set the response to the ALLY event.
    var allyResponseFunctionId = &quot;diplomacyAlliancesOnSystemAllyFunction&quot;;
    if (!engine.$getFunctions()[allyResponseFunctionId]) {
        // We use a recurrent action to recalculate the scores,
        // as doing it on every event would generate LOTS of calculus.
        // Currently, we only generate the news.
        var diplomacyAlliancesOnSystemAllyFunction = function diplomacyAlliancesOnSystemAllyFunction(argsArray) {

            /** @type {Actor} */
            var respondingActor = argsArray[0];

            /** @type {Actor} */
            var eventActor = argsArray[1];

            /** @type {ActorId} */
            var alliedActorId = argsArray[2];

            // On ALLY event, if the player is in a responder system, a news is generated.
            // This could be optimized, but the role of this function should be to manage all responses.
            if (system.info.name === respondingActor.name) {
                var allyName = worldScripts.DayDiplomacy_000_Engine.$getActors()[alliedActorId].name;
                if (respondingActor.name === allyName) {
                    worldScripts.DayDiplomacy_015_GNN.$publishNews(&quot;YOU might be interested in knowing that &quot; + eventActor.name + &quot; just allied with &quot; + allyName
                        + &quot;.\n\nAs Commander Diziet Sma, currently aboard the \&quot;Blackwidow\&quot; Pitviper S.E., famously said, &#39;the neatest definition of diplomacy I&#39;ve seen is \&quot;The art of saying &#39;nice doggy&#39; while you reach behind you for a rock to throw.\&quot;&#39;.\n\nSo with that in mind, Who will gain? Who will lose?\n\nTruth is, we don&#39;t know!&quot;);
                }
            }

        };
        engine.$setFunction(allyResponseFunctionId, diplomacyAlliancesOnSystemAllyFunction);
        engine.$setResponse(engine.$buildResponse(engine.$getNewResponseId(), &quot;ALLY&quot;, &quot;SYSTEM&quot;, allyResponseFunctionId));
    }

    // We set the response to the BREAK event.
    var breakResponseFunctionId = &quot;diplomacyAlliancesOnSystemBreakFunction&quot;;
    if (!engine.$getFunctions()[breakResponseFunctionId]) {
        // We use a recurrent action to recalculate the scores,
        // as doing it on every event would generate LOTS of calculus.
        // Currently, we only generate the news.
        var diplomacyAlliancesOnSystemBreakFunction = function diplomacyAlliancesOnSystemBreakFunction(argsArray) {

            /** @type {Actor} */
            var respondingActor = argsArray[0];

            /** @type {Actor} */
            var eventActor = argsArray[1];

            /** @type {ActorId} */
            var alliedActorId = argsArray[2];

            // On BREAK event, if the player is in a responder system, a news is generated.
            if (system.info.name === respondingActor.name) {
                var allyName = worldScripts.DayDiplomacy_000_Engine.$getActors()[alliedActorId].name;
                if (respondingActor.name === allyName) {
                    worldScripts.DayDiplomacy_015_GNN.$publishNews(&quot;YOU might be interested in knowing that &quot; + eventActor.name + &quot; just broke their alliance with &quot; + allyName
                        + &quot;.\n\nAs Commander Diziet Sma, currently aboard the \&quot;Blackwidow\&quot; Pitviper S.E., famously said, &#39;the neatest definition of diplomacy I&#39;ve seen is \&quot;The art of saying &#39;nice doggy&#39; while you reach behind you for a rock to throw.\&quot;&#39;.\n\nSo with that in mind, Who will gain? Who will lose?\n\nTruth is, we don&#39;t know!&quot;);
                }
            }

        };
        engine.$setFunction(breakResponseFunctionId, diplomacyAlliancesOnSystemBreakFunction);
        engine.$setResponse(engine.$buildResponse(engine.$getNewResponseId(), &quot;BREAK&quot;, &quot;SYSTEM&quot;, breakResponseFunctionId));
    }

    // We set the response to the WAR event.
    var warResponseFunctionId = &quot;diplomacyAlliancesOnSystemWarFunction&quot;;
    if (!engine.$getFunctions()[warResponseFunctionId]) {
        // We use a recurrent action to recalculate the scores,
        // as doing it on every event would generate LOTS of calculus.
        // Currently, we only generate the news.
        var diplomacyAlliancesOnSystemWarFunction = function diplomacyAlliancesOnSystemWarFunction(argsArray) {

            /** @type {Actor} */
            var respondingActor = argsArray[0];

            /** @type {Actor} */
            var eventActor = argsArray[1];

            /** @type {ActorId} */
            var foeActorId = argsArray[2];

            // On WAR event, if the player is in a responder system, a news is generated.
            if (system.info.name === respondingActor.name) {
                var foeName = worldScripts.DayDiplomacy_000_Engine.$getActors()[foeActorId].name;
                if (respondingActor.name === foeName) {
                    // FIXME 0.14 make different citation for war and peace
                    worldScripts.DayDiplomacy_015_GNN.$publishNews(&quot;YOU might be interested in knowing that &quot; + eventActor.name + &quot; just declared war with &quot; + foeName
                        + &quot;.\n\nAs Commander Diziet Sma, currently aboard the \&quot;Blackwidow\&quot; Pitviper S.E., famously said, &#39;the neatest definition of diplomacy I&#39;ve seen is \&quot;The art of saying &#39;nice doggy&#39; while you reach behind you for a rock to throw.\&quot;&#39;.\n\nSo with that in mind, Who will gain? Who will lose?\n\nTruth is, we don&#39;t know!&quot;);
                }
            }

        };
        engine.$setFunction(warResponseFunctionId, diplomacyAlliancesOnSystemWarFunction);
        engine.$setResponse(engine.$buildResponse(engine.$getNewResponseId(), &quot;WAR&quot;, &quot;SYSTEM&quot;, warResponseFunctionId));
    }

    // We set the response to the PEACE event.
    var peaceResponseFunctionId = &quot;diplomacyAlliancesOnSystemPeaceFunction&quot;;
    if (!engine.$getFunctions()[peaceResponseFunctionId]) {
        // We use a recurrent action to recalculate the scores,
        // as doing it on every event would generate LOTS of calculus.
        // Currently, we only generate the news.
        var diplomacyAlliancesOnSystemPeaceFunction = function diplomacyAlliancesOnSystemPeaceFunction(argsArray) {

            /** @type {Actor} */
            var respondingActor = argsArray[0];

            /** @type {Actor} */
            var eventActor = argsArray[1];

            /** @type {ActorId} */
            var foeActorId = argsArray[2];

            // On PEACE event, if the player is in a responder system, a news is generated.
            if (system.info.name === respondingActor.name) {
                var foeName = worldScripts.DayDiplomacy_000_Engine.$getActors()[foeActorId].name;
                if (respondingActor.name === foeName) {
                    // FIXME 0.14 make different citation for war and peace
                    worldScripts.DayDiplomacy_015_GNN.$publishNews(&quot;YOU might be interested in knowing that &quot; + eventActor.name + &quot; just made peace with &quot; + foeName
                        + &quot;.\n\nAs Commander Diziet Sma, currently aboard the \&quot;Blackwidow\&quot; Pitviper S.E., famously said, &#39;the neatest definition of diplomacy I&#39;ve seen is \&quot;The art of saying &#39;nice doggy&#39; while you reach behind you for a rock to throw.\&quot;&#39;.\n\nSo with that in mind, Who will gain? Who will lose?\n\nTruth is, we don&#39;t know!&quot;);
                }
            }

        };
        engine.$setFunction(peaceResponseFunctionId, diplomacyAlliancesOnSystemPeaceFunction);
        engine.$setResponse(engine.$buildResponse(engine.$getNewResponseId(), &quot;PEACE&quot;, &quot;SYSTEM&quot;, peaceResponseFunctionId));
    }

    this._initF4Interface();

    delete this._startUp; // No need to startup twice
};

/* ************************** Oolite events ***************************************************************/

this.startUp = function () {
    this._s = worldScripts.DayDiplomacy_000_Engine;
    this._s.$subscribe(this.name);
    delete this.startUp; // No need to startup twice
};
this.shipDockedWithStation = function (station) {
    this._initF4Interface();
};
this.equipmentAdded = function (equipmentKey) {
    if (equipmentKey === &quot;EQ_ADVANCED_NAVIGATIONAL_ARRAY&quot;) {
        this._initF4Interface();
    }
};
this.playerEnteredNewGalaxy = function (galaxyNumber) {
    this._initSystemsScores(galaxyNumber);
};
this.missionScreenEnded = function () {
    player.ship.hudHidden = false;
    this._resetLinks();
    this._loadTarget();
};</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/DayDiplomacy_WarEngine.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name = &quot;DayDiplomacy_040_WarEngine&quot;;
this.author = &quot;David (Day) Pradier&quot;;
// noinspection JSUnusedGlobalSymbols Used by Oolite itself
this.copyright = &quot;(C) 2017 David Pradier&quot;;
// noinspection JSUnusedGlobalSymbols Used by Oolite itself
this.licence = &quot;CC-NC-by-SA 4.0&quot;;
this.description = &quot;This script is the war engine of the Diplomacy OXP.&quot;;

/* ************************** OXP public functions ********************************************************/

/**
 * @return {Object.&lt;string,FunctionId&gt;}
 * @lends worldScripts.DayDiplomacy_040_WarEngine.$getScoringFunctions
 */
this.$getScoringFunctions = function () {
    return this._asf;
};

/**
 * @param {FunctionId}keyword the keyword is used as a FunctionId
 * @param {function}f
 * @param {int}position
 * @lends worldScripts.DayDiplomacy_040_WarEngine.$addScoringFunction
 */
this.$addScoringFunction = function (keyword, f, position) {
    this._s.$setFunction(keyword, f);
    this._asf.splice(position, 0, keyword);
};

/**
 * @param {Actor}observedActor
 * @param {Actor}observerActor
 * @lends worldScripts.DayDiplomacy_040_WarEngine.$recalculateScores
 */
this.$recalculateScores = function (observedActor, observerActor) {
    var asf = this._asf, funcs = this._F, as = this._as;
    var observedId = observedActor.id, observerId = observerActor.id;
    var observedAs = as[observedId] || (as[observedId] = {});
    var score = observedAs[observerId] || (observedAs[observerId] = {});
    var finalScore = 0, z = asf.length, z0 = z - 1;
    while (z--) {
        var keyword = asf[z0 - z];
        var thatScore = funcs[keyword](observerActor, observedActor);
        score[keyword] = thatScore;
        finalScore += thatScore;
    }
    score.SCORE = finalScore;
};

/**
 *
 * @param {number}threshold
 * @lends worldScripts.DayDiplomacy_040_WarEngine.$setAllianceThreshold
 */
this.$setAllianceThreshold = function (threshold) {
    // warCouncilRecurrentAction is a function defined at the beginning of this WarEngine.
    this._F.warCouncilRecurrentAction.allianceThreshold = threshold;
    this._s._State.allianceThreshold = threshold;
};

/**
 *
 * @param {number}threshold
 * @lends worldScripts.DayDiplomacy_040_WarEngine.$setWarThreshold
 */
this.$setWarThreshold = function (threshold) {
    // warCouncilRecurrentAction is a function defined at the beginning of this WarEngine.
    this._F.warCouncilRecurrentAction.warThreshold = threshold;
    this._s._State.warThreshold = threshold;
};

/**
 *
 * @return {number}
 * @lends worldScripts.DayDiplomacy_040_WarEngine.$getAllianceThreshold
 */
this.$getAllianceThreshold = function () {
    return this._s._State.allianceThreshold;
};

/**
 *
 * @return {number}
 * @lends worldScripts.DayDiplomacy_040_WarEngine.$getWarThreshold
 */
this.$getWarThreshold = function () {
    return this._s._State.warThreshold;
};

/**
 * Returns a dictionary with an {@link ActorId} as key, and as value: a dictionary with another {@link ActorId} as key,
 * and as value: -1 is there&#39;s a war between those 2 actors, 1 if there&#39;s an alliance.
 * @return {Object.&lt;ActorId,Object.&lt;ActorId,number&gt;&gt;}
 * @lends worldScripts.DayDiplomacy_040_WarEngine.$getAlliancesAndWars
 */
this.$getAlliancesAndWars = function () {
    return this._a;
};

/**
 *
 * @return {Object.&lt;ActorId,Object.&lt;ActorId,Object.&lt;string,number&gt;&gt;&gt;}
 * @lends worldScripts.DayDiplomacy_040_WarEngine.$getScores
 */
this.$getScores = function () {
    return this._as;
};

/**
 *  true if those 2 actors are at war
 * @param {ActorId} actorIdA  an actorId
 * @param {ActorId} actorIdB  another actorId
 * @return {boolean}
 * @lends worldScripts.DayDiplomacy_040_WarEngine.$areActorsWarring
 */
this.$areActorsWarring = function (actorIdA, actorIdB) {
    // FIXME use hasOwnProperty ?
    var tmp = this._a[actorIdA];
    return tmp &amp;&amp; tmp[actorIdB] === -1
};

/* ************************** OXP private functions *******************************************************/

/**
 *
 * @param {ActorId}aSystemId
 * @param {ActorId}anotherSystemId
 * @private
 */
this._ally = function (aSystemId, anotherSystemId) {
    var a = this._a; // alliances and wars
    a[aSystemId] = a[aSystemId] || {};
    a[aSystemId][anotherSystemId] = 1; // Alliance
    a[anotherSystemId] = a[anotherSystemId] || {};
    a[anotherSystemId][aSystemId] = 1; // Alliance
    this._s.$makeActorEventKnownToUniverse(aSystemId, &quot;ALLY&quot;, [anotherSystemId]);
    this._s.$makeActorEventKnownToUniverse(anotherSystemId, &quot;ALLY&quot;, [aSystemId]);
    // Commented out because closure
    // log(&quot;DiplomacyWarEngine&quot;, &quot;Alliance between &quot; + aSystemId + &quot; and &quot; + anotherSystemId);
};

/**
 *
 * @param {ActorId}aSystemId
 * @param {ActorId}anotherSystemId
 * @private
 */
this._breakAlliance = function (aSystemId, anotherSystemId) {
    var a = this._a; // Alliances and wars
    a[aSystemId] &amp;&amp; a[aSystemId] === 1 &amp;&amp; (delete a[aSystemId][anotherSystemId]); // Breaking alliance
    a[anotherSystemId] &amp;&amp; a[anotherSystemId] === 1 &amp;&amp; (delete a[anotherSystemId][aSystemId]); // Breaking alliance
    this._s.$makeActorEventKnownToUniverse(aSystemId, &quot;BREAK&quot;, [anotherSystemId]);
    this._s.$makeActorEventKnownToUniverse(anotherSystemId, &quot;BREAK&quot;, [aSystemId]);
    // Commented out because closure
    // log(&quot;DiplomacyWarEngine&quot;, &quot;Alliance broken between &quot; + aSystemId + &quot; and &quot; + anotherSystemId);
};

/**
 *
 * @param {ActorId}aSystemId
 * @param {ActorId}anotherSystemId
 * @private
 */
this._declareWar = function (aSystemId, anotherSystemId) {
    var a = this._a; // Alliances and wars
    a[aSystemId] = a[aSystemId] || {};
    a[aSystemId][anotherSystemId] = -1; // War
    a[anotherSystemId] = a[anotherSystemId] || {};
    a[anotherSystemId][aSystemId] = -1; // War
    this._s.$makeActorEventKnownToUniverse(aSystemId, &quot;WAR&quot;, [anotherSystemId]);
    this._s.$makeActorEventKnownToUniverse(anotherSystemId, &quot;WAR&quot;, [aSystemId]);
    // Commented out because closure
    // log(&quot;DiplomacyWarEngine&quot;, &quot;War between &quot; + aSystemId + &quot; and &quot; + anotherSystemId);
};

/**
 *
 * @param {ActorId} aSystemId
 * @param {ActorId} anotherSystemId
 * @private
 */
this._makePeace = function (aSystemId, anotherSystemId) {
    var a = this._a; // Alliances and wars
    a[aSystemId] &amp;&amp; a[aSystemId] === -1 &amp;&amp; (delete a[aSystemId][anotherSystemId]); // Making peace
    a[anotherSystemId] &amp;&amp; a[anotherSystemId] === -1 &amp;&amp; (delete a[anotherSystemId][aSystemId]); // Making peace
    this._s.$makeActorEventKnownToUniverse(aSystemId, &quot;PEACE&quot;, [anotherSystemId]);
    this._s.$makeActorEventKnownToUniverse(anotherSystemId, &quot;PEACE&quot;, [aSystemId]);
    // Commented out because closure
    // log(&quot;DiplomacyWarEngine&quot;, &quot;Peace between &quot; + aSystemId + &quot; and &quot; + anotherSystemId);
};

/**
 *
 * @private
 */
this._initAllyScore = function () {
    var engine = this._s;

    if (engine.$getEventTypes().indexOf(&quot;ALLYSCORE&quot;) === -1) {
        engine.$addEventType(&quot;ALLYSCORE&quot;, 1);
        // Function to calculate scores, here is the system for which scores are calculated
        var diplomacyAlliancesScoringRecurrentAction = function diplomacyAlliancesScoringRecurrentAction(aSystem) {
            // FIXME perfectfunc should be actor-agnostic
            var observersId = aSystem.observers[&quot;SYSTEM&quot;];
            if (!observersId) {
                return; // There may be no observer yet.
            }
            var that = diplomacyAlliancesScoringRecurrentAction;
            var we = that.warEngine || (that.warEngine = worldScripts.DayDiplomacy_040_WarEngine);
            var engine = that._engine || (that._engine = worldScripts.DayDiplomacy_000_Engine);
            var actors = engine.$getActors();
            var y = observersId.length;
            while (y--) {
                we.$recalculateScores(actors[observersId[y]], aSystem);
            }
        };
        var fid = &quot;diplomacyAlliancesScoringRecurrentAction&quot;;
        engine.$setFunction(fid, diplomacyAlliancesScoringRecurrentAction);
        engine.$setRecurrentAction(engine.$buildAction(engine.$getNewActionId(), &quot;ALLYSCORE&quot;, &quot;SYSTEM&quot;, fid));
    }
};

/**
 * @private
 */
this._init = function () {
    var engine = this._s;
    var history = worldScripts.DayDiplomacy_020_History;

    if (engine.$getEventTypes().indexOf(&quot;BREAK&quot;) !== -1) {
        return; // Already initialized
    }

    // Creating events
    engine.$addEventType(&quot;WARCOUNCIL&quot;, 2);
    engine.$addEventType(&quot;BREAK&quot;, 3);
    engine.$addEventType(&quot;ALLY&quot;, 4);
    engine.$addEventType(&quot;WAR&quot;, 5);
    engine.$addEventType(&quot;PEACE&quot;, 6);

    // Managing history sentences
    history.$setEventFormattingFunction(&quot;BREAK&quot;,
        /**
         * @param {DiplomacyEvent} breakEvent
         * @return {string} the formatted message
         */
        function breakEventFormattingFunction(breakEvent) {
            var f = breakEventFormattingFunction;
            var engine = f._engine || (f._engine = worldScripts.DayDiplomacy_000_Engine);
            var actors = engine.$getActors();
            return actors[breakEvent.actorId].name + &quot; broke their alliance with &quot; + actors[breakEvent.args[0]].name + &quot;.&quot;;
        });
    history.$setEventFormattingFunction(&quot;ALLY&quot;,
        /**
         * FIXME create a type AllyEvent?
         * @param  {DiplomacyEvent} allyEvent
         * @return {string}
         */
        function allyEventFormattingFunction(allyEvent) {
            var f = allyEventFormattingFunction;
            var engine = f._engine || (f._engine = worldScripts.DayDiplomacy_000_Engine);
            var actors = engine.$getActors();
            return actors[allyEvent.actorId].name + &quot; allied with &quot; + actors[allyEvent.args[0]].name + &quot;.&quot;;
    });
    history.$setEventFormattingFunction(&quot;WAR&quot;,
        /**
         * @param  {DiplomacyEvent} warEvent
         * @return {string}
         */
        function warEventFormattingFunction(warEvent) {
            var f = warEventFormattingFunction;
            var engine = f._engine || (f._engine = worldScripts.DayDiplomacy_000_Engine);
            var actors = engine.$getActors();
            return actors[warEvent.actorId].name + &quot; declared war with &quot; + actors[warEvent.args[0]].name + &quot;.&quot;;
    });
    history.$setEventFormattingFunction(&quot;PEACE&quot;,
        /**
         * @param  {DiplomacyEvent} peaceEvent
         * @return {string}
         */
        function peaceEventFormattingFunction(peaceEvent) {
            var f = peaceEventFormattingFunction;
            var engine = f._engine || (f._engine = worldScripts.DayDiplomacy_000_Engine);
            var actors = engine.$getActors();
            return actors[peaceEvent.actorId].name + &quot; made peace with &quot; + actors[peaceEvent.args[0]].name + &quot;.&quot;;
    });

    // Function to ally, break alliance, declare war or peace: here, aSystem is the system to which the action might be directed.
    var warCouncilRecurrentAction = function warCouncilRecurrentAction(aSystem) {
        var that = warCouncilRecurrentAction;
        var alliancesScores = that.alliancesScores || (that.alliancesScores = worldScripts.DayDiplomacy_000_Engine._State.alliancesScores);
        var a = that.alliancesAndWars || (that.alliancesAndWars = worldScripts.DayDiplomacy_000_Engine._State.alliancesAndWars);
        var allianceThreshold = that.allianceThreshold || (that.allianceThreshold = worldScripts.DayDiplomacy_000_Engine._State.allianceThreshold);
        var warThreshold = that.warThreshold || (that.warThreshold = worldScripts.DayDiplomacy_000_Engine._State.warThreshold);
        var aSystemId = aSystem.id;
        var aSystemScores = alliancesScores[aSystemId];
        var warEngine = that.warEngine || (that.warEngine = worldScripts.DayDiplomacy_040_WarEngine);

        for (var targetId in aSystemScores) {
            if (aSystemScores.hasOwnProperty(targetId)) {
                // Alliance
                if ((!a.hasOwnProperty(targetId) || !a[targetId].hasOwnProperty(aSystemId) || a[targetId][aSystemId] !== 1) // Not yet allied
                    &amp;&amp; aSystemScores[targetId].SCORE &gt;= allianceThreshold
                    &amp;&amp; alliancesScores[targetId][aSystemId].SCORE &gt;= allianceThreshold) { // Both are willing
                    warEngine._ally(aSystemId, targetId);
                }

                // Break
                if ((a.hasOwnProperty(targetId) &amp;&amp; a[targetId][aSystemId] === 1) // Allied
                    &amp;&amp; (aSystemScores[targetId].SCORE &lt; allianceThreshold
                        || alliancesScores[targetId][aSystemId].SCORE &lt; allianceThreshold)) { // One is willing to break
                    warEngine._breakAlliance(aSystemId, targetId);
                }

                // War
                if ((!a.hasOwnProperty(targetId) || !a[targetId].hasOwnProperty(aSystemId) || a[targetId][aSystemId] !== -1) // Not yet warring
                    &amp;&amp; (aSystemScores[targetId].SCORE &lt;= warThreshold || alliancesScores[targetId][aSystemId].SCORE &lt;= warThreshold)) { // One is willing
                    warEngine._declareWar(aSystemId, targetId);
                }

                // Peace
                if ((a.hasOwnProperty(targetId) &amp;&amp; a[targetId][aSystemId] === -1) // Warring
                    &amp;&amp; aSystemScores[targetId].SCORE &gt; warThreshold &amp;&amp; alliancesScores[targetId][aSystemId].SCORE &gt; warThreshold) { // Both are willing
                    warEngine._makePeace(aSystemId, targetId);
                }
            }
        }
    };
    var fid = &quot;warCouncilRecurrentAction&quot;;
    engine.$setFunction(fid, warCouncilRecurrentAction);
    engine.$setRecurrentAction(engine.$buildAction(engine.$getNewActionId(), &quot;WARCOUNCIL&quot;, &quot;SYSTEM&quot;, fid));

    this.$setAllianceThreshold(.5); // Default value for the very first initialization
    this.$setWarThreshold(-1); // Default value for the very first initialization
};

this._startUp = function () {
    var engine = this._s;
    this._F = engine.$getFunctions();

    // Alliances Scoring _Functions: { keyword =&gt; fid }
    this._asf = engine.$initAndReturnSavedData(&quot;alliancesScoringFunctions&quot;, []);
    // Alliances Scores: { observedId =&gt; { observerId =&gt; { keyword =&gt; score } } }
    this._as = engine.$initAndReturnSavedData(&quot;alliancesScores&quot;, {});
    this._a = engine.$initAndReturnSavedData(&quot;alliancesAndWars&quot;, {});

    this._initAllyScore();
    this._init(); // ALLY/BREAK/WAR/PEACE

    this.$setAllianceThreshold(this._s._State.allianceThreshold); // Startup init using saved value
    this.$setWarThreshold(this._s._State.warThreshold); // Startup init using saved value

    delete this._startUp; // No need to startup twice
};

/* ************************** Oolite events ***************************************************************/

this.startUp = function () {
    this._s = worldScripts.DayDiplomacy_000_Engine;
    this._s.$subscribe(this.name);
    delete this.startUp; // No need to startup twice
};</pre></td>
                </tr>
            </table>
        </a>
    </body>
</html>
