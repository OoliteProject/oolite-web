<html>
    <head>
        <title>Expansion Route Planner</title>
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <table border="0" width="100%">
            <tr>
                <td>Back to <a href='../index.html'>Index</a></td>
                <td align="right"><small>Page generated: Oct 11, 2023, 3:16:48 PM</small></td>
            </tr>
        </table>

        <h1>Expansion Route Planner</h1>

        <h2>Content</h2>
        <ul>
          <li><a href="#warnings">Warnings</a></li>
          <li><a href="#manifest">Manifest</a></li>
          <li><a href="#documentation">Documentation</a></li>
          <li><a href="#equipment">0 Equipment</a></li>
          <li><a href="#ships">0 Ships</a></li>
          <li><a href="#models">0 Models</a></li>
          <li><a href="#scripts">3 Scripts</a></li>
        </ul>

          <a name="warnings">
            <h2>Warnings</h2>
            <ol>
                <li>http://wiki.alioth.net/index.php/Route%20Planner -&gt; 404 Not Found</li>
                <li>Low hanging fuit: Information URL exists...</li>
            </ol>
          </a>

        <a name="manifest">
        <h2>Manifest</h2>
            <table border="1">
                <tr>
                    <th></th>
                    <th>from Expansion Manager's OXP list</th>
                    <th>from Expansion Manifest</th>
                </tr>
                <tr>
                    <td>Description</td>
                    <td>Plot a route through multiple systems</td>
                    <td>Plot a route through multiple systems</td>
                </tr>
                <tr>
                    <td>Identifier</td>
                    <td>oolite.oxp.Alnivel.RoutePlanner</td>
                    <td>oolite.oxp.Alnivel.RoutePlanner</td>
                </tr>
                <tr>
                    <td>Title</td>
                    <td>Route Planner</td>
                    <td>Route Planner</td>
                </tr>
                <tr>
                    <td>Category</td>
                    <td>Mechanics</td>
                    <td>Mechanics</td>
                </tr>
                <tr>
                    <td>Author</td>
                    <td>Alnivel</td>
                    <td>Alnivel</td>
                </tr>
                <tr>
                    <td>Version</td>
                    <td>0.3</td>
                    <td>0.3</td>
                </tr>
                <tr>
                    <td>Tags</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Required Oolite Version</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Maximum Oolite Version</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Required Expansions</td>
                    <td>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>Optional Expansions</td>
                    <td>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>Conflict Expansions</td>
                    <td>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>Information URL</td>
                    <td><a target="_blank" href="https://wiki.alioth.net/index.php?title=Route_Planner_OXP">https://wiki.alioth.net/index.php?title=Route_Planner_OXP</a></td>
                    <td><a target="_blank" href="">n/a</a></td>
                </tr>
                <tr>
                    <td>Download URL</td>
                    <td><a target="_blank" href="https://www.dl.dropboxusercontent.com/s/sc0ncl2bil8fcfe/RoutePlanner.0.3.oxz">https://www.dl.dropboxusercontent.com/s/sc0ncl2bil8fcfe/RoutePlanner.0.3.oxz</a></td>
                    <td><a target="_blank" href="">n/a</a></td>
                </tr>
                <tr>
                    <td>License</td>
                    <td>CC BY-NC-SA 4</td>
                    <td>CC BY-NC-SA 4</td>
                </tr>
                <tr>
                    <td>File Size</td>
                    <td>n/a</td>
                </tr>
                <tr>
                    <td>Upload date</td>
                    <td>n/a</td>
                </tr>
            </table>
                </a>

        <a name="documentation">
        <h2>Documentation</h2>
        
        </a>

        <a name="equipment">          
        <h2>Equipment</h2>
            This expansion declares no equipment. This may be related to warnings.
        </a>

        <a name="ships">    
        <h2>Ships</h2>
            This expansion declares no ships. This may be related to warnings.
        </a>

        <a name="models">    
        <h2>Models</h2>
            This expansion declares no models. This may be related to warnings.
        </a>

        <a name="scripts">    
        <h2>Scripts</h2>
            <table>
                <tr>
                    <th>Path</th>
                </tr>
                <tr>
                    <td valign="top">Scripts/route-planner-interface.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name = &quot;RoutePlanner_Interface&quot;;
this.author = &quot;Alnivel&quot;;
this.copyright = &quot;2022 Alnivel&quot;;
this.version = &quot;0.2&quot;;
this.licence = &quot;CC BY-NC-SA 4.0&quot;;

this.$ILib = null;

this.$screens = {};

this.$inverseMapTo = function (map) {
    return Object.keys(map).reduce(function (invMap, key) {
        return invMap[map[key]] = key;
    }.bind(this), {})
}

this.$findKeyByValue = function (dictionary, value) {
    var keys = Object.keys(dictionary);
    for (var i = 0; i &lt; keys.length; i++) {
        var key = keys[i];
        if (dictionary[key] === value)
            return key;
    }
    return undefined;
}

this.$colorToColorSpecifierMap = {
    &quot;Green&quot;: &quot;greenColor&quot;,
    &quot;Yellow&quot;: &quot;yellowColor&quot;,
    &quot;Red&quot;: &quot;redColor&quot;,
    &quot;Blue&quot;: &quot;blueColor&quot;,
    &quot;Cyan&quot;: &quot;cyanColor&quot;,
}
this.$colorSpecifierToColorMap = this.$inverseMapTo(this.$colorToColorSpecifierMap)

this.$markerShapes = {
    &quot;Cross&quot;: &quot;MARKER_X&quot;,
    &quot;Plus&quot;: &quot;MARKER_PLUS&quot;,
    &quot;Square&quot;: &quot;MARKER_SQUARE&quot;,
    &quot;Diamond&quot;: &quot;MARKER_DIAMOND&quot;
}

this.$configureInterface = function () {
    let interfaceScript = this;
    let mainScript = worldScripts[&quot;RoutePlanner&quot;];
    let ILib = this.$ILib = worldScripts[&quot;RoutePlanner_InterfaceLib&quot;];

    mainScreen: {
        const mainScreen = this.$screens.main = new ILib.PagedScreenController({
            title: &quot;Route Planning Interface&quot;,
            screenID: &quot;RoutePlanner_Main&quot;,
            allowInterrupt: true,
            exitScreen: &quot;GUI_SCREEN_INTERFACES&quot;
        });

        mainScreen.addToContent(new ILib.LabelLine(&quot;General&quot;));
        mainScreen.addToContent(
            new ILib.CycleLine(
                expandDescription(&quot;[RoutePlanner_interface_main_wp-order-mode]&quot;),
                mainScript.$waypointOrderModes,
                mainScript.$currentWaypointOrderMode)
                .onSelected(function (selectedIndex, selectedValue) {
                    mainScript.$currentWaypointOrderMode = selectedValue;
                })
        );

        mainScreen.addToContent(
            new ILib.ButtonLine(expandDescription(&quot;[RoutePlanner_interface_main_edit-route]&quot;))
                .onUpdate(function () {
                    return {
                        unselectable: mainScript.$currentWaypointOrderMode === &quot;None&quot;
                    };
                })
                .onSelected(function () {
                    this.$screens.editRouteInstructions.runScreen(mainScript.$currentWaypointOrderMode)
                    return true; // returning true prevent current screen redrawing
                }.bind(this))
        );

        mainScreen.addToContent(
            new ILib.ButtonLine(expandDescription(&quot;[RoutePlanner_interface_main_route-statistics]&quot;))
                .onUpdate(function () {
                    return {
                        unselectable: mainScript.$currentWaypointOrderMode === &quot;None&quot;
                    };
                })
                .onSelected(function () {
                    this.$screens.routeStatisticsScreen.runScreen()
                    return true;
                }.bind(this))
        );

        const wpTypes = mainScript.$wpTypes;
        const wpTypesList = Object.keys(wpTypes);
        for (let i = 0; i &lt; wpTypesList.length; i++)
        {
            let typeKey = wpTypesList[i];
            let type = wpTypes[typeKey];

            let labelText = expandDescription(
                &quot;[RoutePlanner_interface_main_route-through-toggler]&quot;,
                {waypointType: expandDescription(type.nameKey)});
            mainScreen.addToContent(
                new ILib.ToggleLine(labelText, type.isUsed)
                    .onSelected(function (newState) {
                        type.isUsed = newState;
                    })
            )   
        }        

        mainScreen.addToContent(
            new ILib.ButtonLine(expandDescription(&quot;[RoutePlanner_interface_main_appearance-settings]&quot;))
                .onSelected(function () {
                    this.$screens.appearanceSettings.runScreen()
                    return true; // returning true prevent current screen redrawing
                }.bind(this))
        );
    }

    const returnToMain = this.$screens.main.returnToScreen.bind(this.$screens.main);

    appearanceSettingsScreen: {
        const appearanceSettingsScreen = this.$screens.appearanceSettings = new ILib.PagedScreenController({
            title: &quot;Route Planning Interface: Appearance Settings&quot;,
            screenID: &quot;RoutePlanner_Main_AppearanceSettings&quot;,
            allowInterrupt: true,
            exitScreen: &quot;GUI_SCREEN_INTERFACES&quot;
        }, returnToMain);

        const colors = this.$colorToColorSpecifierMap;
        const appearance = mainScript.$appearance;

        appearanceSettingsScreen.addToContent(
            new ILib.CycleLine(
                expandDescription(&quot;[RoutePlanner_interface_appearance_user-wp-marker-shape]&quot;),
                this.$markerShapes,
                this.$findKeyByValue(this.$markerShapes, appearance.userWaypointShape))
                .onSelected(function (selectedShapeIndex, selectedShape) {
                    appearance.userWaypointShape = selectedShape;
                })
        );

        appearanceSettingsScreen.addToContent(
            new ILib.CycleLine(
                expandDescription(&quot;[RoutePlanner_interface_appearance_user-wp-marker-color]&quot;),
                colors,
                this.$findKeyByValue(colors, appearance.userWaypointColor))
                .onSelected(function (selectedColorIndex, selectedColor) {
                    appearance.userWaypointColor = selectedColor;
                })
        );

        appearanceSettingsScreen.addToContent(
            new ILib.CycleLine(
                expandDescription(&quot;[RoutePlanner_interface_appearance_user-route-color-jumps]&quot;),
                colors,
                this.$findKeyByValue(colors, appearance.routeLineColorByJumps))
                .onSelected(function (selectedColorIndex, selectedColor) {
                    appearance.routeLineColorByJumps = selectedColor;
                })
        );

        appearanceSettingsScreen.addToContent(
            new ILib.CycleLine(
                expandDescription(&quot;[RoutePlanner_interface_appearance_user-route-color-time]&quot;),
                colors,
                this.$findKeyByValue(colors, appearance.routeLineColorByTime))
                .onSelected(function (selectedColorIndex, selectedColor) {
                    appearance.routeLineColorByTime = selectedColor;
                })
        );
    }

    function formatWaypoints(waypoints, highlightedSystemId, waypointOrderMode) {
        function getSystemSubstitution(id) {
            if (id &lt; 10) return &quot;%J00&quot; + id;
            if (id &lt; 100) return &quot;%J0&quot; + id;
            else return &quot;%J&quot; + id;
        }

        const wpSubtitutions = waypoints.map(function (wp) {
            if (highlightedSystemId === wp)
                return &quot; \[&quot; + getSystemSubstitution(wp) + &quot;\] &quot;;
            else
                return getSystemSubstitution(wp);
        });

        const wpSeparator = waypointOrderMode === &quot;Auto&quot; ? &quot;, &quot; : &quot; → &quot;;

        return wpSubtitutions.length? expandDescription(wpSubtitutions.join(wpSeparator)) : &quot;None&quot;;
    }

    routeEditingInstruction: {
        const instructionSP = {
            title: &quot;Route Planning Interface: Route editing instruction&quot;,
            screenID: &quot;RoutePlanner_EditRoute_Instructions&quot;,
            allowInterrupt: false,
            exitScreen: &quot;GUI_SCREEN_SHORT_RANGE_CHART&quot;,
        }

        instructionSP.choices = {
            &quot;00_SPACER&quot; : { text: &quot;&quot; },
            &quot;01_RETURN&quot;: {
                text: ILib.$padTextOnSide(
                    expandDescription(&quot;[RoutePlanner_interface_route-editing-instructions_return]&quot;), 
                    &quot;right&quot;, 32),
                color: &quot;cyanColor&quot;
            },
            &quot;02_ADD_START&quot;: {
                text: ILib.$padTextOnSide(
                    expandDescription(&quot;[RoutePlanner_interface_route-editing-instructions_add-start]&quot;), 
                    &quot;right&quot;, 32),
                color: &quot;cyanColor&quot;
            },
            &quot;03_CONTINUE&quot;: {
                text: ILib.$padTextOnSide(
                    expandDescription(&quot;[RoutePlanner_interface_route-editing-instructions_start-edit-on-chart]&quot;), 
                    &quot;right&quot;, 32),
                color: &quot;cyanColor&quot;
            },
            &quot;04_SPACER&quot;: { text: &quot;&quot; },
            &quot;05_SPACER&quot;: { text: &quot;&quot; },
        }

        this.$screens.editRouteInstructions = {
            screenParameters: instructionSP,
            returnToMain: returnToMain,
            userWaypoints: mainScript.$userWaypoints,

            runScreen: function (waypointOrderMode) {
                let targetSystem = player.ship.targetSystem;
                let firstUserWaypoint = this.userWaypoints.length === 0? -1 : this.userWaypoints[0];

                const addToStartChoise = this.screenParameters.choices[&quot;02_ADD_START&quot;];
                if(system.ID === targetSystem || firstUserWaypoint === targetSystem)
                {
                    addToStartChoise.unselectable = true;
                    addToStartChoise.color = &quot;darkGrayColor&quot;;
                }
                else
                {
                    addToStartChoise.unselectable = false;
                    addToStartChoise.color = &quot;cyanColor&quot;;
                }

                let callback = function (choice) {
                    if (choice === &quot;01_RETURN&quot;) this.returnToMain();
                    else if (choice === &quot;02_ADD_START&quot;) 
                    {                                            
                        this.userWaypoints.unshift(targetSystem);
                        interfaceScript.$screens.editRouteInstructions.runScreen(waypointOrderMode);
                    }
                    else mainScript.$routeEditingEnabled = true;
                };
                
                

                instructionSP.message = expandMissionText(&quot;RoutePlanner_interface_route-editing-instructions&quot;, {
                    waypointOrderMode: waypointOrderMode,
                    userWaypoints: formatWaypoints(this.userWaypoints, targetSystem, waypointOrderMode)
                });

                mission.runScreen(this.screenParameters, callback, this);
            },


        }
    }

    routeEditingActions: {
        const routeEditActionSP = {
            title: &quot;Route Planning Interface: &lt;systemname&gt;&quot;,
            screenID: &quot;RoutePlanner_EditRoute_SystemAction&quot;,
            allowInterrupt: false,
            exitScreen: &quot;GUI_SCREEN_SHORT_RANGE_CHART&quot;,
            choices: {}
        }

        this.$screens.editRouteSystemAction = {
            screenParameters: routeEditActionSP,
            returnToMain: returnToMain,
            userWaypoints: mainScript.$userWaypoints,

            selectedSystemId: null,
            selectedSystemIndex: null,

            systemId: null,
            systemIndex: null,

            runScreen: function (systemId, waypointOrderMode) {
                const systemIndex = this.userWaypoints.indexOf(systemId);
                const selectedSystemId = this.selectedSystemId;

                this.systemId = systemId;
                this.systemIndex = systemIndex;


                const systemInWaypoints = systemIndex !== -1;
                const systemName = System.systemNameForID(systemId);
                let selectedSystemName = undefined;
                let systemIsSelected = false;

                if (selectedSystemId === null)
                    this.selectedSystemIndex = null;
                else {
                    this.selectedSystemIndex = this.userWaypoints.indexOf(selectedSystemId);
                    selectedSystemName = System.systemNameForID(selectedSystemId);
                    systemIsSelected = systemId === selectedSystemId;
                }

                this.screenParameters.message = this.getText(systemId, waypointOrderMode);
                this.screenParameters.choices = this.getChoices(systemInWaypoints, systemIsSelected, selectedSystemName);

                this.screenParameters.title = &quot;Route Planning Interface: &quot; + systemName;

                mission.runScreen(this.screenParameters, this.screenCallback, this);
            },

            getText: function (highlightedSystemId, waypointOrderMode) {
                

                return expandMissionText(&quot;RoutePlanner_interface_route-editing-actions&quot;, {
                    waypointOrderMode: waypointOrderMode,
                    userWaypoints: formatWaypoints(this.userWaypoints, highlightedSystemId, waypointOrderMode)
                });
            },

            getChoices: function (systemInWaypoints, systemIsSelected, selectedSystemName) {
                const choices = {};

                if (systemInWaypoints) {
                    if (systemIsSelected)
                        choices[&quot;01_DESELECT&quot;] = &quot;Deselect&quot;;
                    else
                        choices[&quot;01_SELECT&quot;] = &quot;Select&quot;;

                    choices[&quot;02_REMOVE&quot;] = &quot;Remove&quot;;
                    if (selectedSystemName) {
                        choices[&quot;03_SWAP&quot;] = &quot;Swap with &quot; + selectedSystemName;
                    }
                    // choices[&quot;03_SPACER&quot;] = &quot;&quot;;
                }
                else {
                    if (selectedSystemName) {
                        choices[&quot;01_ADD_BEFORE&quot;] = &quot;Add before &quot; + selectedSystemName;
                        choices[&quot;02_ADD_AFTER&quot;] = &quot;Add after &quot; + selectedSystemName;
                    }
                    else {
                        choices[&quot;01_SPACER&quot;] = &quot;&quot;;
                        choices[&quot;02_SPACER&quot;] = &quot;&quot;;
                    }

                    choices[&quot;03_ADD_END&quot;] = &quot;Add to the end&quot;;
                }

                choices[&quot;04_SPACER&quot;] = &quot;&quot;
                choices[&quot;05_BACK_TO_CHART&quot;] = &quot;Back to chart&quot;;
                choices[&quot;06_STOP_EDIT&quot;] = &quot;Stop route editing&quot;;

                return choices;
            },

            screenCallback: function (choice) {
                if (choice === &quot;05_BACK_TO_CHART&quot;) return;
                else if (choice === &quot;06_STOP_EDIT&quot;) {
                    mainScript.$routeEditingEnabled = false;
                    this.returnToMain();
                    return;
                }

                if (this.systemIndex !== -1) {
                    if (choice === &quot;01_SELECT&quot;)
                        this.selectedSystemId = this.systemId;
                    else if (choice === &quot;01_DESELECT&quot;)
                        this.selectedSystemId = null;
                    else if (choice === &quot;02_REMOVE&quot;) {
                        this.userWaypoints.splice(this.systemIndex, 1);
                        if (this.selectedSystemIndex === this.systemIndex)
                            this.selectedSystemId = null
                    }

                    else if (choice === &quot;03_SWAP&quot;) {
                        let temp = this.userWaypoints[this.systemIndex];
                        this.userWaypoints[this.systemIndex] = this.userWaypoints[this.selectedSystemIndex];
                        this.userWaypoints[this.selectedSystemIndex] = temp;

                        this.selectedSystemIndex = this.systemIndex;
                    }
                }
                else {
                    if (choice == &quot;01_ADD_BEFORE&quot;)
                        this.userWaypoints.splice(this.selectedSystemIndex, 0, this.systemId)
                    else if (choice == &quot;02_ADD_AFTER&quot;)
                        this.userWaypoints.splice(this.selectedSystemIndex + 1, 0, this.systemId)
                    else if (choice == &quot;03_ADD_END&quot;)
                        this.userWaypoints.push(this.systemId)
                }

            }
        }
    }

    routeStatistics: {
        const routeStatisticsScreen = this.$screens.routeStatisticsScreen = new ILib.PagedScreenController({
            title: &quot;Route Planning Interface: Statistics&quot;,
            screenID: &quot;RoutePlanner_Main_RouteStatistics&quot;,
            allowInterrupt: true,
            exitScreen: &quot;GUI_SCREEN_INTERFACES&quot;
        }, returnToMain);

        let formatToColumns = function (name, type, remainTime, travelTime, distance){
            return &quot;&quot; +
                ILib.$padTextOnSide(name, &quot;right&quot;, 6) + 
                ILib.$padTextAround(type, 8) +
                ILib.$padTextOnSide(remainTime, &quot;left&quot;, 6) +
                ILib.$padTextOnSide(travelTime, &quot;left&quot;, 6) +
                ILib.$padTextOnSide(distance, &quot;left&quot;, 6);
        } 
        
        routeStatisticsScreen.addToHeader(
            new ILib.LabelLine(formatToColumns(&quot;Name&quot;, &quot;Type&quot;, &quot;Remain time&quot;, &quot;Travel time&quot;, &quot;Distance, LY&quot;))
        );

        routeStatisticsScreen.addToHeader(new ILib.LabelLine(ILib.$repeatPattern(&quot;-&quot;, 32)));        
        
        let rsScreenRun = routeStatisticsScreen.runScreen.bind(routeStatisticsScreen);
        let updateTable = function (){
            const playerShip = player.ship;
            const targetSystem = playerShip.targetSystem;

            const memoizedRoutes = mainScript.$memoizedRoutes;
            const routeMode = playerShip.routeMode;
            const distanceMeasurement = routeMode === &quot;OPTIMIZED_BY_JUMPS&quot; ? &quot;distance&quot; : &quot;distanceWhenTime&quot;;
            const timeMeasurement     = routeMode === &quot;OPTIMIZED_BY_JUMPS&quot; ? &quot;timeWhenDistance&quot; : &quot;time&quot;;

            const waypointsOnCurrentRoute = mainScript.$waypointsOnCurrentRoute;
            const waypointsOnCurrentRouteCount = waypointsOnCurrentRoute.length;

            const storedRoutes = mainScript.$storedRoutes;
            const storedRoutesCount = storedRoutes.length;

            
            routeStatisticsScreen.clearContent();

            let totalTime = 0;
            let totalDistance = 0;
            let previousWaypointId = system.ID;   

            for(let i = waypointsOnCurrentRouteCount - 1; i &gt;= 0; i--)
            {
                let waypointInfo = waypointsOnCurrentRoute[i];
                if(waypointInfo === undefined) // if something went wrong then just ignore it and hope for better
                    continue;
                let waypointId = waypointInfo.ID;

                let name = System.systemNameForID(waypointId);
                let costs = memoizedRoutes.routeCost(previousWaypointId, waypointId);
                totalDistance += costs[distanceMeasurement];
                totalTime += costs[timeMeasurement];

                let type = &quot;&quot;, remainTime = &quot;&quot;;
                if(waypointInfo.type)
                    type = expandDescription(waypointInfo.type.nameKey);
                if(waypointId === targetSystem)
                    type += &quot;, &quot; + expandDescription(&quot;[RoutePlanner_wpType_targetSystem]&quot;);
                if(waypointInfo.eta)
                    remainTime = ((waypointInfo.eta - clock.seconds) / 3600).toFixed(1);

                routeStatisticsScreen.addToContent(
                    new ILib.LabelLine(formatToColumns(name, type, remainTime, totalTime.toFixed(1), totalDistance.toFixed(1)))
                );

                previousWaypointId = waypointId;
            }   

            if(targetSystem !== previousWaypointId) {
                let name = System.systemNameForID(targetSystem);
                let costs = memoizedRoutes.routeCost(system.ID, targetSystem);
                totalDistance = costs[distanceMeasurement];
                totalTime = costs[timeMeasurement];

                routeStatisticsScreen.addToContent(
                    new ILib.LabelLine(formatToColumns(
                        name, expandDescription(&quot;[RoutePlanner_wpType_targetSystem]&quot;), 
                        &quot;&quot;, totalTime.toFixed(1), totalDistance.toFixed(1)))
                );

                previousWaypointId = targetSystem;
            }

            for(let i = 0; i &lt; storedRoutesCount; i++)
            {
                let waypointInfo = storedRoutes[i].endWaypointInfo;
                if(waypointInfo === undefined) // if something went wrong then just ignore it and hope for better 2
                    continue;
                let waypointId = waypointInfo.ID;

                let name = System.systemNameForID(waypointId);
                let costs = memoizedRoutes.routeCost(previousWaypointId, waypointId);
                totalDistance += costs[distanceMeasurement];
                totalTime += costs[timeMeasurement];

                let type = &quot;&quot;, remainTime = &quot;&quot;;
                if(waypointInfo.type)
                    type = expandDescription(waypointInfo.type.nameKey);
                if(waypointInfo.eta)
                    remainTime = ((waypointInfo.eta - clock.seconds) / 3600).toFixed(1);

                routeStatisticsScreen.addToContent(
                    new ILib.LabelLine(formatToColumns(name, type, remainTime, totalTime.toFixed(1), totalDistance.toFixed(1)))
                );

                previousWaypointId = waypointId;
            }
            
            routeStatisticsScreen.clearFooter();

            routeStatisticsScreen.addToFooter(new ILib.LabelLine(ILib.$repeatPattern(&quot;-&quot;, 32)));  

            routeStatisticsScreen.addToFooter(
                new ILib.LabelLine(formatToColumns(&quot;Total&quot;, &quot;&quot;, &quot;&quot;, totalTime.toFixed(1), totalDistance.toFixed(1)))
            );

        }

        
        routeStatisticsScreen.runScreen = function() { updateTable(); rsScreenRun(); }

    }
}
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/route-planner-interfaceLib.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name = &quot;RoutePlanner_InterfaceLib&quot;;
this.author = &quot;Alnivel&quot;;
this.copyright = &quot;2022 Alnivel&quot;;
this.version = &quot;0.2&quot;;
this.licence = &quot;CC BY-NC-SA 4.0&quot;;

(function() {
    let ILib = this;

    this.__BasePagedController = function __BasePagedController(screenParameters) {
        __BasePagedController_init(screenParameters);
    }

    this.__BasePagedController.prototype.__BasePagedController_init = function (screenParameters)  {
        this.screenParameters = screenParameters;
        this.headerLines = [];
        this.contentLines = [];
        this.footerLines = [];

        this.headerPrefix = &quot;00HEADER&quot;;
        this.contentPrefix = &quot;20CONTENT&quot;;
        this.footerPrefix = &quot;40FOOTER&quot;;

        this.currentPage = 0;
        this.pages = 0;

        this.selectedChoicesKey = undefined;
    }

    this.__BasePagedController.prototype.addToHeader = function addToHeader(line) {
        const headerLinesCount = this.headerLines.length;
        const key = (headerLinesCount &lt; 10 ? (&quot;0&quot; + headerLinesCount) : headerLinesCount) + &quot;_NO_KEY&quot;;
        this.headerLines.push({ key: key, line: line });
    }

    this.__BasePagedController.prototype.addToContent = function addToContent(line) {
        const contentLinesCount = this.contentLines.length;
        const key = (contentLinesCount &lt; 10 ? (&quot;0&quot; + contentLinesCount) : contentLinesCount) + &quot;_NO_KEY&quot;;
        this.contentLines.push({ key: key, line: line });
    }

    this.__BasePagedController.prototype.addToFooter = function addToFooter(line) {
        const footerLinesCount = this.footerLines.length;
        const key = (footerLinesCount &lt; 10 ? (&quot;0&quot; + footerLinesCount) : footerLinesCount) + &quot;_NO_KEY&quot;;
        this.footerLines.push({ key: key, line: line });
    }

    /*
        Remove line from ...
        this.__BasePagedScreenController.prototype.removeLineFromContent = function removeFromContent(line) {
        let removePos = -1;
        let i = this.contentLines.length;
        while (i--) {
            if (this.contentLines[i].line === line) {
                removePos = i;
                break;
            }
        }
        if (removePos === -1)
            return false;
        else {
            this.contentLines.splice(removePos, 1);
            return true;
        }
    }
    */

    this.__BasePagedController.prototype.clearHeader = function clearHeader() {
        this.headerLines.length = 0;
    }

    this.__BasePagedController.prototype.clearContent = function clearHeader() {
        this.contentLines.length = 0;
    }

    this.__BasePagedController.prototype.clearFooter = function clearHeader() {
        this.footerLines.length = 0;
    }

    /***
     * Update every line in header and fill &quot;choises&quot; parameter with them  
     * @param {object} choises
     * @returns {number} Header height in lines
     */
    this.__BasePagedController.prototype.updateHeader = function updateHeader(choises) {
        const linesForHeader = this.headerLines.length;

        for (let i = 0; i &lt; linesForHeader; i++) {
            let pair = this.headerLines[i];
            let key = this.headerPrefix + (i &lt; 10 ? (&quot;0&quot; + i) : i) + &quot;_&quot; + pair.key;
            choises[key] = pair.line.update();
        }

        return linesForHeader;
    }

    /**
     * Update content lines on specified page and fill &quot;choises&quot; parameter with them
     * @param {object} choises
     * @param {number} linesPerPage Maximum number of lines per page
     * @param {number} page Page number
     * @returns {number} Content height on specified page in lines
     */
    this.__BasePagedController.prototype.updateContent = function updateContent(choises, linesPerPage, page) {
        let linesStartIndex = linesPerPage * page;
        let linesEndIndex = linesStartIndex + linesPerPage;
        let contentLinesCount = this.contentLines.length;

        let linesEndIndexLimited = contentLinesCount &lt; linesEndIndex ? contentLinesCount : linesEndIndex;

        for (let i = linesStartIndex; i &lt; linesEndIndexLimited; i++) {
            let pair = this.contentLines[i];
            let key = this.contentPrefix + (i &lt; 10 ? (&quot;0&quot; + i) : i) + &quot;_&quot; + pair.key;
            choises[key] = pair.line.update();
        }

        return linesEndIndexLimited - linesStartIndex;
    }

    /***
     * Update every line in footer and fill &quot;choises&quot; parameter with them  
     * @param {object} choises
     * @returns {number} Footer height in lines
     */
    this.__BasePagedController.prototype.updateFooter = function updateFooter(choises) {
        const linesForFooter = this.footerLines.length;
        
        for (let i = 0; i &lt; linesForFooter; i++) {
            let pair = this.footerLines[i];
            let key = this.footerPrefix + (i &lt; 10 ? (&quot;0&quot; + i) : i) + &quot;_&quot; + pair.key;
            choises[key] = pair.line.update();
        }

        return linesForFooter;
    }

    this.__BasePagedController.prototype.proccessChoises = function proccessChoises(choise) {
        for (let i = 0; i &lt; this.headerLines.length; i++) {
            let pair = this.headerLines[i];
            let key = this.headerPrefix + (i &lt; 10 ? (&quot;0&quot; + i) : i) + &quot;_&quot; + pair.key;
            let line = pair.line;
            if (choise === key) {
                return line.select &amp;&amp; line.select(); // if true returned then don`t redraw this screen
            }
        }
        
        for (let i = 0; i &lt; this.contentLines.length; i++) {
            let pair = this.contentLines[i];
            let key = this.contentPrefix + (i &lt; 10 ? (&quot;0&quot; + i) : i) + &quot;_&quot; + pair.key;
            let line = pair.line;
            if (choise === key) {
                return line.select &amp;&amp; line.select();
            }
        }

        for (let i = 0; i &lt; this.footerLines.length; i++) {
            let pair = this.footerLines[i];
            let key = this.footerPrefix + (i &lt; 10 ? (&quot;0&quot; + i) : i) + &quot;_&quot; + pair.key;
            let line = pair.line;
            if (choise === key) {
                return line.select &amp;&amp; line.select();
            }
        }

        // Restarting the screen, if necessary, is performed by the child 
        /* 
        this.screenParameters.choices = this.getPage(this.currentPage);
        this.screenParameters.initialChoicesKey = initialChoicesKey;
        mission.runScreen(this.screenParameters, this.onChoiceSelected.bind(this));
        */
    }

    this.__BasePagedController.prototype.runScreen = function runScreen() {
        log(&quot;ROUTEPLANER_INTERFACELIB_DEBUG&quot;, &quot;Started &quot; + this.screenParameters.title + &quot; mission screen&quot;);
        this.currentPage = 0;
        this.screenParameters.choices = this.getPage(0);
        mission.runScreen(this.screenParameters, this.onChoiceSelected.bind(this));
    }

    this.__BasePagedController.prototype.returnToScreen = function returnToScreen() {
        if(this.currentPage === undefined || this.currentPage &gt; this.pages)
            this.currentPage = 0;

        log(&quot;ROUTEPLANER_INTERFACELIB_DEBUG&quot;, &quot;Returned to &quot; + this.screenParameters.title + &quot; mission screen on page &quot; + this.currentPage);
        this.screenParameters.choices = this.getPage(this.currentPage);
        this.screenParameters.initialChoicesKey = this.selectedChoicesKey;
        mission.runScreen(this.screenParameters, this.onChoiceSelected.bind(this));
    }

    /**
     * Create paged screen that can be filled with line objects.
     * Each time the line is selected, it will re-render, 
     * unless the Return option is selected (then will be called callbackOnReturn)
     * or the onSelect callback of the selected line returns true
     * @param {*} screenParameters 
     * @param {Function} [callbackOnReturn]
     */
    this.PagedScreenController = function PagedScreenController(screenParameters, callbackOnReturn) {
        this.__BasePagedController_init(screenParameters); // Don`t know how to get base constructor properly
        this.callbackOnReturn = callbackOnReturn ?  callbackOnReturn : null;
    }

    this.PagedScreenController.prototype = Object.create(__BasePagedController.prototype);

    this.PagedScreenController.prototype.onReturn = function onReturn(callback) {
        this.callbackOnReturn = callback;
    }

    this.PagedScreenController.prototype.getPage = function getPage(page) {
        const screenHeight = (player.ship.hudAllowsBigGui ? 27 : 21);

        const choises = {};

        const headerHeight = this.updateHeader(choises);
        const footerHeight = this.updateFooter(choises);
        const controlsHeight = 5;

        const maxContentHeight = screenHeight - headerHeight - footerHeight - controlsHeight;
        const pages = this.pages = Math.ceil(this.contentLines.length / maxContentHeight);

        const contentHeight = this.updateContent(choises, maxContentHeight, page);
        const remainHeight = maxContentHeight - contentHeight;
        log(&quot;ROUTEPLANER_INTERFACELIB_DEBUG&quot;, &quot;Remain lines after content &quot; + remainHeight + &quot; from &quot; + maxContentHeight)
        /*** Fill empty ***/
        const spacer = { text: &quot;&quot; };
        for (let i = 0; i &lt; remainHeight; i++) {
            let key = &quot;21EMPTY_&quot; + (i &lt; 10 ? (&quot;0&quot; + i) : i) + &quot;_EMPTY&quot;;
            choises[key] = spacer;
        }

        /*** Controlls ***/
        if (pages &gt; 1) {
            choises[&quot;70_SPACER&quot;] = spacer;
            choises[&quot;71_PAGE_NUM&quot;] = {
                text: &quot;Page &quot; + (1 + page) + &quot; of &quot; + pages,
                unselectable: true
            }
            choises[&quot;73_NEXT_PAGE&quot;] = {
                text: &quot;Next page&quot;,
                unselectable: page + 1 === pages
            };
            choises[&quot;74_PREV_PAGE&quot;] = {
                text: &quot;Previous page&quot;,
                unselectable: page === 0
            };

        } else {
            choises[&quot;70_SPACER&quot;] = spacer;
            choises[&quot;71_SPACER&quot;] = spacer;
            choises[&quot;73_SPACER&quot;] = spacer;
            choises[&quot;74_SPACER&quot;] = spacer;
        }

        choises[&quot;80_RETURN&quot;] = { text: &quot;Return&quot; };

        return choises;
    }

    this.PagedScreenController.prototype.onChoiceSelected = function onChoiceSelected(choise) {
        if (choise === &quot;80_RETURN&quot;) {
            if (this.callbackOnReturn) this.callbackOnReturn();
            return;
        }
        this.selectedChoicesKey = choise;
        if (choise === &quot;74_PREV_PAGE&quot;) {
            this.currentPage--;
            if (this.currentPage === 0)
                this.selectedChoicesKey = &quot;73_NEXT_PAGE&quot;;
        }
        else if (choise === &quot;73_NEXT_PAGE&quot;) {
            this.currentPage++;
            if (this.currentPage + 1 === this.pages)
                this.selectedChoicesKey = &quot;74_PREV_PAGE&quot;;
        }
        else {
            const stopRestartingScreen = this.proccessChoises(choise);
            
            if(stopRestartingScreen)
            {
                log(&quot;ROUTEPLANER_INTERFACELIB_DEBUG&quot;, &quot;Screen \&quot;&quot; + this.screenParameters.title + &quot;\&quot; restarting has been stopped by key &quot; + choise)
                return;
            }
                
        }

        this.screenParameters.choices = this.getPage(this.currentPage);
        this.screenParameters.initialChoicesKey = this.selectedChoicesKey;
        mission.runScreen(this.screenParameters, this.onChoiceSelected.bind(this));
    }

    

    this.$limitText = function $limitText(text, limitWidth) {
        const ellipsis = &quot;…&quot;;

        let tmp = text;
        while (defaultFont.measureString(tmp) &gt; limitWidth) {
            tmp = tmp.substring(0, tmp.length - 2) + ellipsis;
        }

        return tmp;
    }

    /**
     * 
     * @param {string} text 
     * @param {&quot;left&quot;|&quot;right&quot;} padSide 
     * @param {number} desiredWidth 
     * @returns Padded text 
     */
    this.$padTextOnSide = function $padTextOnSide(text, padSide, desiredWidth) {
        const hairSpace = String.fromCharCode(31);
        const hairSpaceWidth = defaultFont.measureString(hairSpace);


        const textWidth = defaultFont.measureString(text);

        const padsNeeded = Math.floor((desiredWidth - textWidth) / hairSpaceWidth);

        let resultText;
        if (padsNeeded &gt; 1)
            if (padSide == &quot;left&quot;)
                resultText = new Array(padsNeeded).join(hairSpace) + text;
            else
                resultText = text + new Array(padsNeeded).join(hairSpace);
        else
            resultText = this.$limitText(text, desiredWidth);

        return resultText;
    }

    this.$padTextAround = function $padTextAround(text, desiredWidth) {
        const hairSpace = String.fromCharCode(31);
        const hairSpaceWidth = defaultFont.measureString(hairSpace);

        const textWidth = defaultFont.measureString(text);

        const padsNeeded = Math.floor((desiredWidth - textWidth) / (2 * hairSpaceWidth));

        let resultText;
        if (padsNeeded &gt; 1) {
            let sidePadding = new Array(padsNeeded).join(hairSpace);
            resultText = sidePadding + text + sidePadding;
        }
        else
            resultText = this.$limitText(text, desiredWidth);

        return resultText;
    }

    this.$repeatPattern = function $repeatPattern(pattern, desiredWidth) {
        const patternWidth = defaultFont.measureString(pattern);
        const repeatsNeeded = Math.ceil(desiredWidth / patternWidth);

        let tmp = new Array(repeatsNeeded).join(pattern);
        while (defaultFont.measureString(tmp) &gt; desiredWidth) {
            tmp = tmp.substring(0, tmp.length - 1);
        }

        return tmp
    }

    this.__LineWithCallbacksPrototype = {
        /**
         * Set callback that will be called when line is redrawing. 
         * The arguments for the function are same as for select callback, 
         * but it can return dictionary whose 
         * key-value pairs will be setted as choice parameters
         * @param {Function} updateCallback 
         * @returns Line object
         */
        onUpdate: function onUpdate(updateCallback) {
            this.updateCallback = updateCallback;
            return this;
        },
        /**
         * Set callback that will be called when line is selected. 
         * The arguments for the function depends on line type.
         * Is callback return true than screen will not redrawed. 
         * It can be used to change to another mission screen.
         * @param {*} selectCallback 
         * @returns Line object
         */
        onSelected: function onSelected(selectCallback) {
            this.selectCallback = selectCallback;
            return this;
        }
    }

    // TODO: Add lines hiding?

    /**
     * Create empty line object
     */
    this.EmptyLine = function () {}

    this.EmptyLine.prototype.update = function update() {
        return { text: &quot;&quot; };
    }

    /**
     * Create line object that can`t be selected
     * @param {string} text 
     */
    this.LabelLine = function (text, alignment) {
        this.choiceObject = {
            text: ILib.$padTextAround(text, 32),
            unselectable: true,
            color: &quot;whiteColor&quot;,
            alignment: alignment? alignment : &quot;CENTER&quot;
        }
    }

    this.LabelLine.prototype = Object.create(__LineWithCallbacksPrototype);
    this.LabelLine.prototype.update = function update() {
        if (this.updateCallback) {
            let updated = this.updateCallback();

            const updatedKeys = Object.keys(updated);
            for (let i = 0; i &lt; updatedKeys.length; i++) {
                const key = updatedKeys[i];
                const value = updated[key];
                if (value !== undefined &amp;&amp;
                    key !== &quot;unselectable&quot;) {

                    if (key === &quot;text&quot;)
                        this.choiceObject[key] = ILib.$padTextOnSide(value, &quot;right&quot;, 32);
                    else
                        this.choiceObject[key] = value;
                }
            }

        }
        return this.choiceObject;
    };

    /**
     * Create line object that can be selected.
     * When selected onSelected callback will be called without any arguments
     * @param {string} text 
     */
    this.ButtonLine = function (text) {
        this.choiceObject = {
            text: ILib.$padTextOnSide(text, &quot;right&quot;, 32),
            color: &quot;cyanColor&quot;,
            alignment: &quot;LEFT&quot;
        };
        this.selectableColor = &quot;cyanColor&quot;;
        this.unselectableColor = &quot;darkGrayColor&quot;;
    }

    this.ButtonLine.prototype = Object.create(__LineWithCallbacksPrototype);
    this.ButtonLine.prototype.update = function update() {
        if (this.updateCallback) {
            let updated = this.updateCallback();
            const updatedKeys = Object.keys(updated);
            for (let i = 0; i &lt; updatedKeys.length; i++) {
                const key = updatedKeys[i];
                const value = updated[key];
                if (value !== undefined) {
                    if (key === &quot;color&quot;)
                        this.selectableColor = value;
                    else if (key === &quot;text&quot;)
                        this.choiceObject[key] = ILib.$padTextOnSide(value, &quot;right&quot;, 32);
                    else
                        this.choiceObject[key] = value;
                }
            }
            if (this.choiceObject.unselectable)
                this.choiceObject.color = this.unselectableColor;
            else
                this.choiceObject.color = this.selectableColor;
        }

        return this.choiceObject;
    }
    this.ButtonLine.prototype.select = function select() {
        if (this.selectCallback)
            return this.selectCallback();
    }


    /**
     * Create line object that toggles between true and false when selected.
     * When selected onSelected callback will be called with new state as argument
     * @param {string} text 
     * @param {Boolean} initialState 
     */
    this.ToggleLine = function (text, initialState) {
        this.choiceObject = {
            color: &quot;cyanColor&quot;
        };
        this.selectableColor = &quot;cyanColor&quot;;
        this.unselectableColor = &quot;darkGrayColor&quot;;
        this.text = text;
        this.state = !!initialState;
    }

    this.ToggleLine.prototype = Object.create(__LineWithCallbacksPrototype);
    this.ToggleLine.prototype.update = function update() {
        if (this.updateCallback) {
            let updated = this.updateCallback(this.state);

            const updatedKeys = Object.keys(updated);
            for (let i = 0; i &lt; updatedKeys.length; i++) {
                const key = updatedKeys[i];
                const value = updated[key];
                if (value !== undefined) {
                    if (key === &quot;color&quot;)
                        this.selectableColor = value;
                    else if (key === &quot;text&quot;)
                        this.text = value;
                    else if (key === &quot;state&quot;)
                        this.state = !!value;
                    else
                        this.choiceObject[key] = value;
                }
            }
            if (this.choiceObject.unselectable)
                this.choiceObject.color = this.unselectableColor;
            else
                this.choiceObject.color = this.selectableColor;
        }

        this.choiceObject.text =
            ILib.$padTextOnSide(this.text, &quot;right&quot;, 24) +
            ILib.$padTextAround(&quot; &lt; &quot; + (this.state ? &quot;On&quot; : &quot;Off&quot;) + &quot; &gt; &quot;, 8);
        return this.choiceObject;
    }
    this.ToggleLine.prototype.select = function select() {
        this.state = !this.state;
        if (this.selectCallback)
            return this.selectCallback(this.state);
    }


    /**
     * Create line object that cycles between the specified values when selected.
     * When selected onSelected callback will be called with new index and value as arguments
     * @param {string} text
     * @param {Array|Object.&lt;string, any&gt;} items If it is an array the values are 
     * the same as the labels, otherwise it is treated as a dictionary of labels to values
     * @param {any} [initialItem] 
     */
    this.CycleLine = function (text, items, initialItem) {
        const itemsIsArray = Array.isArray(items);
        const itemKeys = itemsIsArray ? items : Object.keys(items);

        let itemValues;
        if (itemsIsArray)
            itemValues = items
        else { // Object.values(items);
            itemValues = Array(itemKeys.length)
            for (let i = 0; i &lt; itemKeys.length; i++)
                itemValues[i] = items[itemKeys[i]]
        }

        let initialIndex = itemKeys.indexOf(initialItem);
        if (initialIndex === -1)
            initialIndex = 0;

        this.choiceObject = {
            color: &quot;cyanColor&quot;,
        };
        this.items = itemKeys;
        this.values = itemValues;
        this.currentIndex = initialIndex;
        this.text = text;
        this.selectableColor = &quot;cyanColor&quot;;
        this.unselectableColor = &quot;darkGrayColor&quot;;
    }

    this.CycleLine.prototype = Object.create(__LineWithCallbacksPrototype);
    this.CycleLine.prototype.update = function update() {
        if (this.updateCallback) {
            let updated = this.updateCallback(this.currentIndex, this.values[this.currentIndex]);

            const updatedKeys = Object.keys(updated);
            for (let i = 0; i &lt; updatedKeys.length; i++) {
                const key = updatedKeys[i];
                const value = updated[key];
                if (value !== undefined) {
                    if (key === &quot;text&quot;)
                        this.text = value;
                    else if (key === &quot;currentIndex&quot;) {
                        this.currentIndex = value;
                    }
                    else
                        this.choiceObject[key] = value;
                }
            }
            if (this.choiceObject.unselectable)
                this.choiceObject.color = this.unselectableColor;
            else
                this.choiceObject.color = this.selectableColor;
        }

        const currentItem = this.items[this.currentIndex];
        this.choiceObject.text =
            ILib.$padTextOnSide(this.text, &quot;right&quot;, 24) +
            ILib.$padTextAround(&quot; &lt; &quot; + currentItem + &quot; &gt; &quot;, 8);

        return this.choiceObject;
    }
    this.CycleLine.prototype.select = function select() {
        this.currentIndex = (this.currentIndex + 1) % this.values.length;
        if (this.selectCallback)
            return this.selectCallback(this.currentIndex, this.values[this.currentIndex]);
    }

}).call(this);</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/route-planner-main.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name = &quot;RoutePlanner&quot;;
this.author = &quot;Alnivel&quot;;
this.copyright = &quot;2022 Alnivel&quot;;
this.version = &quot;0.2&quot;;
this.licence = &quot;CC BY-NC-SA 4.0&quot;;

/*************** Loading and saving variables ***************/
this.startUp = function () {
    this.$storedRoutes = [];

    const storedRoutes = JSON.parse(missionVariables.routePlanner_storedRoutes);
    if (storedRoutes)
        this.$storedRoutes = storedRoutes;

    const storedUserWaypoints = JSON.parse(missionVariables.routePlanner_storedUserWaypoints);
    if (storedUserWaypoints)
        this.$userWaypoints = storedUserWaypoints;

    const storedWaypointOrderMode = JSON.parse(missionVariables.routePlanner_waypointOrderMode);
    if (storedWaypointOrderMode)
        this.$currentWaypointOrderMode = storedWaypointOrderMode;

    const savedAppearanceParams = JSON.parse(missionVariables.routePlanner_appearanceParams);
    if (savedAppearanceParams)
        this.$appearance = savedAppearanceParams;

    const wpTypesList = Object.keys(this.$wpTypes)
    for(let i = 0; i &lt; wpTypesList.length; i++)
    {
        const typeKey = wpTypesList[i];
        const savedIsUsed = missionVariables[&quot;routePlanner_wpType_isUsed&quot; + typeKey];
        this.$wpTypes[typeKey].isUsed = savedIsUsed === null ? true : Boolean(Number(savedIsUsed));
    }    

    // log(&quot;RoutePlannerDebug&quot;, 
    //     &quot;Loaded:&quot;.concat(
    //     &quot;\nStored routes&quot;, JSON.stringify(this.$storedRoutes),
    //     &quot;\nUser waypoints: &quot;, JSON.stringify(this.$userWaypoints),
    //     &quot;\nOrder mode: &quot;, this.$currentWaypointOrderMode,
    //     &quot;\nAppearence: &quot;, JSON.stringify(this.$appearance),
    //     &quot;\nEnd&quot;
    // ));

    this.$waypointsOnCurrentRoute = [];
}

this.playerWillSaveGame = function (message) {
    const equipmentStatus = player.ship.equipmentStatus(&quot;EQ_ADVANCED_NAVIGATIONAL_ARRAY&quot;);
    if (equipmentStatus === &quot;EQUIPMENT_OK&quot; || equipmentStatus === &quot;EQUIPMENT_DAMAGED&quot;) {
        missionVariables.routePlanner_storedRoutes = JSON.stringify(this.$storedRoutes);
        missionVariables.routePlanner_storedUserWaypoints = JSON.stringify(this.$userWaypoints);
        missionVariables.routePlanner_waypointOrderMode = JSON.stringify(this.$currentWaypointOrderMode)
        missionVariables.routePlanner_appearanceParams = JSON.stringify(this.$appearance);

        const wpTypesList = Object.keys(this.$wpTypes)
        for(let i = 0; i &lt; wpTypesList.length; i++)
        {
            const typeKey = wpTypesList[i];
            missionVariables[&quot;routePlanner_wpType_isUsed&quot; + typeKey] = Number(this.$wpTypes[typeKey].isUsed);
        }        
    }
    else {
        missionVariables.anlivel_routePlanner_storedRoutes = null; 
    }
}

/*************** Parameters ***************/

this.$waypointOrderModes = [&quot;Manual&quot;, &quot;Auto&quot;, &quot;None&quot;];
this.$currentWaypointOrderMode = &quot;Auto&quot;;
this.$routeEditingEnabled = false;

this.$appearance = {
    userWaypointColor: &quot;blueColor&quot;,
    userWaypointShape: &quot;MARKER_X&quot;,
    routeLineColorByJumps: &quot;cyanColor&quot;,
    routeLineColorByTime: &quot;redColor&quot;
}

/*************** Waypoint types ***************/
/**
 * @typedef {Object} WaypointType
 * @property {Boolean} isUsed
 * @property {Boolean} requiresMainStation
 * @property {string} nameKey
 * @property {Boolean} isTargetSystem
 */

/** @type {Object.&lt;string, WaypointType&gt;}*/
this.$wpTypes = {
    cargoContract:     { isUsed: true, requiresMainStation: true,  nameKey: &quot;[RoutePlanner_wpType_cargo]&quot; },
    parcelContract:    { isUsed: true, requiresMainStation: true,  nameKey: &quot;[RoutePlanner_wpType_parcel]&quot; },
    passengerContract: { isUsed: true, requiresMainStation: true,  nameKey: &quot;[RoutePlanner_wpType_passenger]&quot; }, 
    userSpecified:     { isUsed: true, requiresMainStation: false, nameKey: &quot;[RoutePlanner_wpType_userSpecified]&quot; }
}

/** @type {WaypointType}*/
this.$wpTypeTargetSystem = { 
    isUsed: true, 
    requiresMainStation: false, 
    nameKey: &quot;[RoutePlanner_wpType_targetSystem]&quot;, 
    isTargetSystem: true
}

/*************** Interface ***************/
this.$startUpCompleted = false;

this.shipDockedWithStation = this.startUpComplete = function () {
    this.$startUpCompleted = true;

    const equipmentStatus = player.ship.equipmentStatus(&quot;EQ_ADVANCED_NAVIGATIONAL_ARRAY&quot;);
    if (equipmentStatus === &quot;EQUIPMENT_OK&quot; || equipmentStatus === &quot;EQUIPMENT_DAMAGED&quot;) {
        this.$setInterfaceToStation();
    }
}

this.equipmentAdded = function (equipmentKey) {
    if (player.ship.docked &amp;&amp; equipmentKey === &quot;EQ_ADVANCED_NAVIGATIONAL_ARRAY&quot;) {
        this.$setInterfaceToStation();
    }
}

this.equipmentRemoved  = function (equipmentKey) {
    const station = player.ship.dockedStation;
    if (station &amp;&amp; equipmentKey === &quot;EQ_ADVANCED_NAVIGATIONAL_ARRAY&quot;) {
        station.setInterface(&quot;RoutePlanner_Interface&quot;, null);

    }
}

this.$setInterfaceToStation = function $setInterfaceToStation(){
    if (!this.$startUpCompleted) 
        return;

    if (!this.$interface) {
        let interfaceScript = worldScripts[&quot;RoutePlanner_Interface&quot;];
        interfaceScript.$configureInterface();
        this.$interface = interfaceScript.$screens

        // log(&quot;RoutePlannerDebug&quot;, 
        //     &quot;Interface initiated with:&quot;.concat(
        //     &quot;\nUser waypoints: &quot;, JSON.stringify(this.$userWaypoints),
        //     &quot;\nOrder mode: &quot;, this.$currentWaypointOrderMode,
        //     &quot;\nAppearence: &quot;, JSON.stringify(this.$appearance),
        //     &quot;\nEnd&quot;
        // )); 
    }

    const interfaceMain = this.$interface.main;
    const station = player.ship.dockedStation;
    station.setInterface(&quot;RoutePlanner_Interface&quot;, {
        title: &quot;Route planning&quot;,
        category: &quot;Ship Systems&quot;, // String.fromCharCode(&quot;0x1D&quot;) + &quot;Ship Systems&quot;, // \u200b - zws
        summary: &quot;Edit the current route, change the planning mode or other planner options&quot;,
        callback: interfaceMain.runScreen.bind(interfaceMain)
    });
}

/*************** Updating route in flight ***************/
// Route for previous galaxy makes no sense in new
this.playerEnteredNewGalaxy = function () {
    this.$storedRoutes = [];
    this.$userWaypoints = [];
    this.$storedUserWaypoints = [];
}

// When player launched without target system and have planed routes select first route automatically
this.shipWillLaunchFromStation = function () {
    if (player.ship.targetSystem === system.ID &amp;&amp; this.$storedRoutes.length !== 0) {
        const autoRouteInfo = this.$removeFirstStoredRoute()

        const autoRoute = autoRouteInfo.route;
        const newTargetSystem = autoRoute[autoRoute.length - 1];
        player.ship.targetSystem = newTargetSystem;
        this.$waypointsOnCurrentRoute = [autoRouteInfo.endWaypointInfo];

        player.consoleMessage(
            expandMissionText(&quot;RoutePlanner_message_automatically-setted-destination&quot;, {
                nextWaypointName: System.systemNameForID(newTargetSystem)
            }), 5);
    }
}

/// TODO
this.shipExitedWitchspace = function () {

    if (this.$currentWaypointOrderMode !== &quot;None&quot; ) {
        const targetSystem = player.ship.targetSystem;
        if(targetSystem === system.ID) 
        {
            // log(&quot;RP TEST&quot;, JSON.stringify(this.$waypointsOnCurrentRoute))
            if (this.$storedRoutes.length !== 0) {
                const nextRouteInfo = this.$storedRoutes[0];
    
                const currentWpInfo = nextRouteInfo.startWaypointInfo;
                const wpRequiresMainStation = currentWpInfo.type.requiresMainStation;
                const wpType = currentWpInfo.type.nameKey;
                
                const nextWpInfo = nextRouteInfo.endWaypointInfo;
    
                let message = wpRequiresMainStation? 
                    &quot;RoutePlanner_message_reached-waypoint_requires-main-station&quot; : 
                    &quot;RoutePlanner_message_reached-waypoint&quot;;
    
                player.consoleMessage(
                    expandMissionText(message, {
                        nextWaypointName: System.systemNameForID(nextWpInfo.ID),
                        waypointType: expandDescription(wpType)
                    }), 8);
            }
            else if(this.$waypointsOnCurrentRoute.length == 1)
            {
                const lastWp = this.$waypointsOnCurrentRoute[0];

                let message = lastWp.type.requiresMainStation? 
                    &quot;RoutePlanner_message_reached-last-waypoint_requires-main-station&quot; : 
                    &quot;RoutePlanner_message_reached-last-waypoint&quot;;
                player.consoleMessage(
                    expandMissionText(message, {
                        waypointType: expandDescription(lastWp.type.nameKey)
                    }), 8);
            }
        }
        else if(this.$waypointsOnCurrentRoute.length &gt; 1){
            const wp = this.$waypointsOnCurrentRoute[0];
            
            if(wp.ID === targetSystem) {
                let message = wp.type.requiresMainStation? 
                    &quot;RoutePlanner_message_reached-midroute-waypoint_requires-main-station&quot; : 
                    &quot;RoutePlanner_message_reached-midroute-waypoint&quot;;
                player.consoleMessage(
                    expandMissionText(message, {
                        waypointType: expandDescription(wp.type.nameKey)
                    }), 8);
                
                    this.$waypointsOnCurrentRoute.shift();
            }
        }        

    }

    const userWpIndex = this.$userWaypoints.indexOf(system.ID);
    if (userWpIndex !== -1) {
        this.$userWaypoints.splice(userWpIndex, 1);

        this.$redrawUserWaypoints(
            this.$userWaypoints, 
            this.$appearance.userWaypointColor, 
            this.$appearance.userWaypointShape
        );
    }
}

/*************** Operation with waypoints ***************/
/**
 * @typedef {Object} WaypointInfo
 * @property {Number} ID
 * @property {WaypointType} type
 * @property {Number|null} eta
 */

/** @type {WaypointInfo[]} */
this.$userWaypoints = [];

this.$collectWaypoints = function $collectWaypoints() {
    const playerShip = player.ship;
    const targetSystem = playerShip.targetSystem;
    const seenSystems = {/* wpDestination0: outIndex0, ... */}; 
    const currentRouteSystems = {/* wpDestination0: routeWpIndex, ... */}; 

    const plannedWps = [];
    let plannedWpsIndex = 0;

    const currentRouteWps = []; // waypoints that already on current route
    let currentRouteWpsIndex = 0;

    let targetSystemWp = { // waypoints that on current targetSystem
        ID: targetSystem,
        type: this.$wpTypeTargetSystem,
        eta: undefined
    };

    // do this to remove waypoints that are already on the current route
    const currentRouteInfo = system.info.routeToSystem(
        System.infoForSystem(galaxyNumber, targetSystem),
        playerShip.routeMode);

    if (currentRouteInfo) {
        let i = currentRouteInfo.route.length;
        while (i--) {
            currentRouteSystems[currentRouteInfo.route[i]] = i;
        }
    }
    
    const wpCollections = [
        {collection: playerShip.contracts,  type: this.$wpTypes.cargoContract},
        {collection: playerShip.parcels,    type: this.$wpTypes.parcelContract},
        {collection: playerShip.passengers, type: this.$wpTypes.passengerContract}
    ];

    const userWp = this.$userWaypoints.map(function (systemId) {
        return { destination: systemId }
    });
    wpCollections.push({collection: userWp, type: this.$wpTypes.userSpecified});


    

    let wpCollectionIndex = wpCollections.length;
    while (wpCollectionIndex--) {
        const wpCollection = wpCollections[wpCollectionIndex].collection;
        const wpType = wpCollections[wpCollectionIndex].type;
        if(!wpType.isUsed)
            continue;

        let i = wpCollection.length;
        while (i--) {

            let wp = wpCollection[i];
            let wpEta = wp.eta + clock.seconds; // Not sure if it can be called now eta, but whatever
            let wpDestination = wp.destination;

            let indexInCurrentRoute = currentRouteSystems[wpDestination];
            let wpLiesOnCurrentRoute = indexInCurrentRoute !== undefined;

            if (seenSystems[wpDestination] === undefined) {
                let storedWaypoint = {
                    ID: wpDestination,
                    type: wpType,
                    eta: wpEta
                };

                if(wpLiesOnCurrentRoute)
                {
                    if(targetSystemWp.ID === wpDestination)
                    {
                        if(targetSystemWp.type.isTargetSystem) // it target system type then just replace
                        {
                            targetSystemWp = storedWaypoint;
                        }
                        else if(targetSystemWp.type !== wpType)
                        {
                            seenWp.type = {
                                isUsed: targetSystemWp.isUsed || wpType.isUsed,
                                requiresMainStation: targetSystemWp.requiresMainStation || wpType.requiresMainStation,
                                nameKey: &quot;[RoutePlanner_wpType_several]&quot;
                            }
                        }
                    }

                    storedWaypoint.indexInCurrentRoute = indexInCurrentRoute;
                    seenSystems[wpDestination] = currentRouteWpsIndex;
                    currentRouteWps[currentRouteWpsIndex] = storedWaypoint;
                    currentRouteWpsIndex++;
                }
                else
                {
                    seenSystems[wpDestination] = plannedWpsIndex;
                    plannedWps[plannedWpsIndex] = storedWaypoint;

                    plannedWpsIndex++;
                }                
            }
            else 
            {   
                let wpIndex = seenSystems[wpDestination];
                
                let seenWp = wpLiesOnCurrentRoute? currentRouteWps[wpIndex] : plannedWps[wpIndex];
                let seenWpType = seenWp.type;

                if(seenWpType !== wpType)
                {
                    seenWp.type = {
                        isUsed: seenWpType.isUsed || wpType.isUsed,
                        requiresMainStation: seenWpType.requiresMainStation || wpType.requiresMainStation,
                        nameKey: &quot;[RoutePlanner_wpType_several]&quot;
                    }
                }
                
                seenWp.eta = seenWp.eta &lt; wpEta? seenWp.eta : wpEta;
            }
        }  
    }

    currentRouteWps.sort(function (a, b) {
        return a.indexInCurrentRoute &lt; b.indexInCurrentRoute;
    });
    return {onRoute: currentRouteWps, notOnRoute: plannedWps, targetSystem: targetSystemWp};
}

this.$getUserWaypoints = function $getUserWaypoints() {
    const that = this;
    const targetSystem = player.ship.targetSystem;   
    const userWaypoints = this.$userWaypoints;

    let startI;
    let targetSystemWp; // waypoints that on current targetSystem
    if(targetSystem &amp;&amp; userWaypoints[0] === targetSystem) {
        startI = 1;
        targetSystemWp = { 
            ID:  targetSystem,
            type: this.$wpTypeTargetSystem,
            eta: undefined
        };
    }
    else {
        startI = 0;
        targetSystemWp = {
            ID: userWaypoints[0], 
            type: this.$wpTypes.userSpecified
        }
    }     

    const plannedWps = [];
    for(let i = startI; i &lt; userWaypoints.length; i++) {
        plannedWps.push({
            ID: userWaypoints[i], 
            type: that.$wpTypes.userSpecified
        });
    }

    return {onRoute: [targetSystemWp], notOnRoute: plannedWps, targetSystem: targetSystemWp};
}

this.$recalculateRoutes = function $recalculateRoutes() {
    let newRoutesInfo = undefined;
    const storedRoutes = this.$storedRoutes;
    const currentWaypointOrderMode = this.$currentWaypointOrderMode;

    const targetSystem = player.ship.targetSystem;
    const routeMode = player.ship.routeMode;

    if (currentWaypointOrderMode === &quot;None&quot; || routeMode === &quot;OPTIMIZED_BY_NONE&quot;) {
        this.$redrawRoutes([], lineColor);
        this.$redrawUserWaypoints([], this.$appearance.userWaypointColor, this.$appearance.userWaypointShape);
        return 
    }
        

    let waypoints;
    // There was a check to see if it was possible not to recalculate the path, 
    // but it became too complicated. Maybe should return it later
    if (true) {

        this.$prevRouteMode = routeMode;

        const autoOrderMode = currentWaypointOrderMode === &quot;Auto&quot;;

        
        if(autoOrderMode)
        {
            waypoints = this.$collectWaypoints();
            newRoutesInfo = this.$routeWithCheapestInsertion(waypoints.targetSystem, waypoints.notOnRoute, routeMode);
        }
        else
        {
            waypoints = this.$getUserWaypoints();
            newRoutesInfo = this.$routeKeepingOrder(waypoints.targetSystem, waypoints.notOnRoute, routeMode);
        }
    }

    this.$waypointsOnCurrentRoute = waypoints.onRoute;

    const lineColor = routeMode === &quot;OPTIMIZED_BY_JUMPS&quot; ?
        this.$appearance.routeLineColorByJumps :
        this.$appearance.routeLineColorByTime;

    this.$redrawRoutes(newRoutesInfo, lineColor);
    this.$redrawUserWaypoints(this.$userWaypoints, this.$appearance.userWaypointColor, this.$appearance.userWaypointShape);
}

this.playerEnteredContract = function () { this.$recalculateRoutes() };

this.guiScreenChanged = function (to, from) {
    if (this.$routeEditingEnabled) {
        const fromChartScreen = from === &quot;GUI_SCREEN_SHORT_RANGE_CHART&quot; || from === &quot;GUI_SCREEN_LONG_RANGE_CHART&quot;;
        const toChartScreen = to === &quot;GUI_SCREEN_SHORT_RANGE_CHART&quot; || to === &quot;GUI_SCREEN_LONG_RANGE_CHART&quot;;
        const toSystemDataScreen = to === &quot;GUI_SCREEN_SYSTEM_DATA&quot;;

        if (fromChartScreen &amp;&amp; toSystemDataScreen) {
            const editScreen = this.$interface.editRouteSystemAction;
            editScreen.runScreen.call(editScreen, player.ship.infoSystem, this.$currentWaypointOrderMode);
        }
        else if ((fromChartScreen &amp;&amp; toChartScreen) || mission.screenID) { }
        else {
            this.$routeEditingEnabled = false;
        }

    }

    // Start periodicaly check if route mode or cursor position changed if user on chart screen
    if (guiScreen === &quot;GUI_SCREEN_SHORT_RANGE_CHART&quot; ||
        guiScreen === &quot;GUI_SCREEN_LONG_RANGE_CHART&quot;) {

        this.$prevRouteMode = player.ship.routeMode;
        this.$prevCursorCoordinates = player.ship.cursorCoordinates;
        this.$cursorMoving = false;
        this.$routeUndrawed = true;

        this.$checkChartInterfaceChangesTimer.start();
    }
    else {
        this.$checkChartInterfaceChangesTimer.stop();
        if ((from === &quot;GUI_SCREEN_SHORT_RANGE_CHART&quot; ||
            from === &quot;GUI_SCREEN_LONG_RANGE_CHART&quot;) &amp;&amp;
            this.$routeUndrawed === false) {

            this.$eraseStoredRoutes();
        }

    }
}

this.$checkChartInterfaceChangesTimer = new Timer(this, function $checkChartInterfaceChangesTimer() {
    const cursorCoordinates = player.ship.cursorCoordinates;

    if (cursorCoordinates.x != this.$prevCursorCoordinates.x ||
        cursorCoordinates.y != this.$prevCursorCoordinates.y)
        this.$cursorMoving = true;
    else
        this.$cursorMoving = false;


    if (player.ship.routeMode != this.$prevRouteMode) {
        this.$recalculateRoutes();
    }
    else if (this.$cursorMoving &amp;&amp; this.$routeUndrawed === false) {
        this.$eraseStoredRoutes();
        this.$routeUndrawed = true;
    } else if (this.$cursorMoving == false &amp;&amp; this.$routeUndrawed) {
        this.$routeUndrawed = false;
        this.$recalculateRoutes();
    }

    this.$prevCursorCoordinates = cursorCoordinates;
}, -1, 0.25);

/**
 * Builds hopefully approximate optimal route from starting system thought waypoints
 * @param {WaypointInfo} startSystem
 * @param {WaypointInfo[]} waypoints 
 * @param {&quot;OPTIMIZED_BY_NONE&quot;|&quot;OPTIMIZED_BY_JUMPS&quot;|&quot;OPTIMIZED_BY_TIME&quot;} routeMode 
 * @returns {RouteInfo[]}
 */
this.$routeWithCheapestInsertion = function $routeWithCheapestInsertion(startSystem, waypoints, routeMode) {
    if (routeMode === &quot;OPTIMIZED_BY_NONE&quot; || waypoints.length === 0) return [];

    const measurement = routeMode === &quot;OPTIMIZED_BY_JUMPS&quot; ? &quot;distance&quot; : &quot;time&quot;;

    waypoints.sort((function (a, b) {
        return this.$memoizedRoutes.routeCost(startSystem.ID, b.ID)[measurement] -
            this.$memoizedRoutes.routeCost(startSystem.ID, a.ID)[measurement];
    }).bind(this));

    const waypointsCount = waypoints.length;
    const bestRoute = [startSystem];

    const noRoute = { route: { length: Infinity }, distance: Infinity, time: Infinity };

    //bestRoute[0] = { ID: startSystem.ID };

    for (let i = 0; i &lt; waypointsCount; i++) {
        const newWp = waypoints[i];
        if (!newWp.ID) break;

        const endPos = bestRoute.length - 1;

        let bestInsertPos, bestCostDifference, bestNewCostStart, bestNewCostEnd = null;

        if (true) { // check cost of inserting in end
            const endRouteWp = bestRoute[endPos];
            const cost = this.$memoizedRoutes.routeCost(endRouteWp.ID, newWp.ID);

            let costDifference = cost[measurement];// * 2*(1 + i/waypointsCount);//* 2;
            bestInsertPos = endPos + 1;
            bestCostDifference = costDifference;
            bestNewCostStart = cost;
        }
        for (let j = 0; j &lt; endPos; j++) {
            const startWp = bestRoute[j];
            const endWp = bestRoute[j + 1];

            const oldCost = this.$memoizedRoutes.routeCost(startWp.ID, endWp.ID);
            const newCostStart = this.$memoizedRoutes.routeCost(startWp.ID, newWp.ID);
            const newCostEnd = this.$memoizedRoutes.routeCost(newWp.ID, endWp.ID);

            let costDifference = (newCostStart[measurement] + newCostEnd[measurement]) - oldCost[measurement];
            if (costDifference &lt; bestCostDifference) {
                bestInsertPos = j + 1;
                bestCostDifference = costDifference;
                bestNewCostStart = newCostStart;
                bestNewCostEnd = newCostEnd;
            }
        }

        // Had plans to posibillity to add transitions between systems that cann`t be done with usual witchjump
        // Maybe someday I`ll do it. Maybe
        //
        // if(bestNewCostStart.through)
        //     if(bestEndCostStart &amp;&amp; bestEndCostStart.through)
        //         bestRoute.splice(bestInsertPos, 0, bestNewCostStart.through, newWp, bestEndCostStart.through);
        //     else
        //         bestRoute.splice(bestInsertPos, 0, bestNewCostStart.through, newWp);
        // else
        //     if(bestEndCostStart &amp;&amp; bestEndCostStart.through)
        //         bestRoute.splice(bestInsertPos, 0, newWp, bestEndCostStart.through);
        //     else
        //         bestRoute.splice(bestInsertPos, 0, newWp);    

        bestRoute.splice(bestInsertPos, 0, newWp);
    }

    const partialRoutesCount = bestRoute.length - 1;
    const partialRoutes = new Array(partialRoutesCount);

    let startWaypointInfo = bestRoute[0];
    let aInfo, bInfo = System.infoForSystem(galaxyNumber, bestRoute[0].ID);
    for (let i = 1; i &lt; bestRoute.length; i++) {
        aInfo = bInfo;
        bInfo = System.infoForSystem(galaxyNumber, bestRoute[i].ID);

        let routeInfo = aInfo.routeToSystem(bInfo, routeMode);
        routeInfo.startWaypointInfo = bestRoute[i-1];
        routeInfo.endWaypointInfo = bestRoute[i];
        partialRoutes[i - 1] = routeInfo;
    }

    return partialRoutes;
}

/**
 * Builds a route from the starting system through waypoints in their exact order
 * @param {WaypointInfo} startSystem
 * @param {WaypointInfo[]} waypoints 
 * @param {&quot;OPTIMIZED_BY_NONE&quot;|&quot;OPTIMIZED_BY_JUMPS&quot;|&quot;OPTIMIZED_BY_TIME&quot;} routeMode 
 * @returns {RouteInfo[]}
 */
this.$routeKeepingOrder = function $routeKeepingOrder(startSystem, waypoints, routeMode) {
    if (routeMode === &quot;OPTIMIZED_BY_NONE&quot; || waypoints.length === 0) return [];

    const partialRoutesCount = waypoints.length;
    const partialRoutes = new Array(partialRoutesCount);

    let previusWaypoint, currentWaypoint = startSystem;
    let aInfo, bInfo = System.infoForSystem(galaxyNumber, startSystem.ID);
    for (let i = 0; i &lt; partialRoutesCount; i++) {
        previusWaypoint = currentWaypoint;
        currentWaypoint = waypoints[i];
        aInfo = bInfo;
        bInfo = System.infoForSystem(galaxyNumber, currentWaypoint.ID);

        let routeInfo = aInfo.routeToSystem(bInfo, routeMode);
        routeInfo.startWaypointInfo = previusWaypoint;
        routeInfo.endWaypointInfo = currentWaypoint;
        partialRoutes[i] = aInfo.routeToSystem(bInfo, routeMode);
    }

    return partialRoutes;
}

this.$memoizedRoutes = {
    routeCost: function (from, to) {
        if (to === null || to === undefined || from === to)
            return { distance: 0, time: 0, through: null };

        // routes are symmetric, right?
        if (from &lt;= to) {
            a = from;
            b = to
        } else {
            a = to;
            b = from;
        }

        const a = from &lt; to ? from : to;
        const b = a === from ? to : from;

        let aCosts = this.$costsMatrix[a];
        if (aCosts === undefined) {
            aCosts = this.$costsMatrix[a] = {};
        }

        let routeCost = aCosts[b];
        if (routeCost === undefined) {
            const aSystemInfo = System.infoForSystem(galaxyNumber, a);
            const bSystemInfo = System.infoForSystem(galaxyNumber, b);

            const routeInfoByJumps = aSystemInfo.routeToSystem(bSystemInfo, &quot;OPTIMIZED_BY_JUMPS&quot;);
            const routeInfoByTime = aSystemInfo.routeToSystem(bSystemInfo, &quot;OPTIMIZED_BY_TIME&quot;);

            if (routeInfoByJumps == null)
                routeCost = aCosts[b] = null;
            else {
                routeCost = aCosts[b] = {
                    distance: routeInfoByJumps.distance,
                    timeWhenDistance: routeInfoByJumps.time,
                    time: routeInfoByTime.time,
                    distanceWhenTime: routeInfoByTime.distance,
                    through: null
                };
            }
        }

        return routeCost;
    },

    $costsMatrix: {
        /*
        systemNumberFrom: {
            systemNumberTo: {
                distance: 0
                timeWhenDistance: 0, // time when optimized by distance
                time: 0
                distanceWhenTime: 0, // distance when optimized by time
                through: null
            }
        }
        */
    }
}

/*************** Chart drawing operations ***************/

/**
 * Remove stored routes from chart but keep them stored
 */
this.$eraseStoredRoutes = function () {
    for (let i = 0; i &lt; this.$storedRoutes.length; i++) {
        this.$eraseRoute(this.$storedRoutes[i]);
    }
}

/**
 * Remove stored routes from chart, draw and store new routes.
 * If need remove current routes and do not draw new pass [] as newRoutes
 * @param {RouteInfo[]} newRoutes 
 */
this.$redrawRoutes = function (newRoutes, lineColor) {
    if (newRoutes) {
        for (let i = 0; i &lt; this.$storedRoutes.length; i++) {
            this.$eraseRoute(this.$storedRoutes[i]);
        }
    } else {
        newRoutes = this.$storedRoutes;
    }

    for (let i = 0; i &lt; newRoutes.length; i++) {
        /*let a = i;
        new Timer(this, function() {
            this.$drawRoute(newRoutes[a]);
        }, i);
        */
        this.$drawRoute(newRoutes[i], lineColor);
    }
    this.$storedRoutes = newRoutes;
}

/**
 * Remove first stored route, erase it from chart and return
 * @returns {RouteInfo} Removed route
 */
this.$removeFirstStoredRoute = function () {
    const route = this.$storedRoutes.shift();
    this.$eraseRoute(route);

    return route;
}

this.$drawRoute = function (routeInfo, lineColor) {
    for (var i = 0; i &lt; routeInfo.route.length - 1; i++) {
        if (routeInfo.route[i] &lt; routeInfo.route[i + 1]) {
            SystemInfo.setInterstellarProperty(galaxyNumber, routeInfo.route[i], routeInfo.route[i + 1], 2, &quot;link_color&quot;, lineColor);
        } else {
            SystemInfo.setInterstellarProperty(galaxyNumber, routeInfo.route[i + 1], routeInfo.route[i], 2, &quot;link_color&quot;, lineColor);
        }
    }
}

this.$eraseRoute = function (routeInfo) {
    mission.unmarkSystem({
        system: routeInfo.route[0],
        name: this.name
    });

    for (var i = 0; i &lt; routeInfo.route.length - 1; i++) {
        if (routeInfo.route[i] &lt; routeInfo.route[i + 1]) {
            SystemInfo.setInterstellarProperty(galaxyNumber, routeInfo.route[i], routeInfo.route[i + 1], 2, &quot;link_color&quot;, null);
        } else {
            SystemInfo.setInterstellarProperty(galaxyNumber, routeInfo.route[i + 1], routeInfo.route[i], 2, &quot;link_color&quot;, null);
        }
    }
}

this.$storedUserWaypoints = [];

/**
 * Erase stored user waypoints from chart, draw and store new.
 * @param {WaypointInfo[]} newUserWaypoints 
 * @param {string} userWaypointColor 
 * @param {string} userWaypointShape 
 */
this.$redrawUserWaypoints = function $redrawUserWaypoints (newUserWaypoints, userWaypointColor, userWaypointShape) {
    const storedUserWaypoints = this.$storedUserWaypoints;
    for(let i = 0; i &lt; storedUserWaypoints.length; i++) {
        mission.unmarkSystem({
            system: storedUserWaypoints[i],
            name: this.name
        });
    }

    this.$storedUserWaypoints = (newUserWaypoints || []).slice();

    for(let i = 0; i &lt; storedUserWaypoints.length; i++) {
        mission.markSystem({
            system: newUserWaypoints[i],
            name: this.name,
            markerColor: userWaypointColor,
            markerShape: userWaypointShape
        });
    }
}</pre></td>
                </tr>
            </table>
        </a>
    </body>
</html>
