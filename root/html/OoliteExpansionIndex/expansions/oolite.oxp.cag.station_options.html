<html>
    <head>
        <title>Expansion Station Options</title>
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <table border="0" width="100%">
            <tr>
                <td>Back to <a href='../index.html'>Index</a></td>
                <td align="right"><small>Page generated: Oct 11, 2023, 3:16:49 PM</small></td>
            </tr>
        </table>

        <h1>Expansion Station Options</h1>

        <h2>Content</h2>
        <ul>
          <li><a href="#warnings">Warnings</a></li>
          <li><a href="#manifest">Manifest</a></li>
          <li><a href="#documentation">Documentation</a></li>
          <li><a href="#equipment">0 Equipment</a></li>
          <li><a href="#ships">0 Ships</a></li>
          <li><a href="#models">0 Models</a></li>
          <li><a href="#scripts">2 Scripts</a></li>
        </ul>

          <a name="warnings">
            <h2>Warnings</h2>
            <ol>
                <li>Information URL mismatch between OXP Manifest and Expansion Manager string length at character position 0</li>
            </ol>
          </a>

        <a name="manifest">
        <h2>Manifest</h2>
            <table border="1">
                <tr>
                    <th></th>
                    <th>from Expansion Manager's OXP list</th>
                    <th>from Expansion Manifest</th>
                </tr>
                <tr>
                    <td>Description</td>
                    <td>Utility for OXP&#39;s to allow pilots to configure equipment, read text when docked.</td>
                    <td>Utility for OXP&#39;s to allow pilots to configure equipment, read text when docked.</td>
                </tr>
                <tr>
                    <td>Identifier</td>
                    <td>oolite.oxp.cag.station_options</td>
                    <td>oolite.oxp.cag.station_options</td>
                </tr>
                <tr>
                    <td>Title</td>
                    <td>Station Options</td>
                    <td>Station Options</td>
                </tr>
                <tr>
                    <td>Category</td>
                    <td>Miscellaneous</td>
                    <td>Miscellaneous</td>
                </tr>
                <tr>
                    <td>Author</td>
                    <td>cag</td>
                    <td>cag</td>
                </tr>
                <tr>
                    <td>Version</td>
                    <td>1.1.1</td>
                    <td>1.1.1</td>
                </tr>
                <tr>
                    <td>Tags</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Required Oolite Version</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Maximum Oolite Version</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Required Expansions</td>
                    <td>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>Optional Expansions</td>
                    <td>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>Conflict Expansions</td>
                    <td>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>Information URL</td>
                    <td><a target="_blank" href=""></a></td>
                    <td><a target="_blank" href="">n/a</a></td>
                </tr>
                <tr>
                    <td>Download URL</td>
                    <td><a target="_blank" href="https://wiki.alioth.net/img_auth.php/2/24/Cag.station_options.oxz">https://wiki.alioth.net/img_auth.php/2/24/Cag.station_options.oxz</a></td>
                    <td><a target="_blank" href="">n/a</a></td>
                </tr>
                <tr>
                    <td>License</td>
                    <td>CC BY-NC-SA 4</td>
                    <td>CC BY-NC-SA 4</td>
                </tr>
                <tr>
                    <td>File Size</td>
                    <td>n/a</td>
                </tr>
                <tr>
                    <td>Upload date</td>
                    <td>1645495484</td>
                </tr>
            </table>
                </a>

        <a name="documentation">
        <h2>Documentation</h2>
        <p>Also read <a href='http://wiki.alioth.net/index.php/Station%20Options'>http://wiki.alioth.net/index.php/Station%20Options</a></p>
        <h3>Station_Options_readme.txt</h3>
        <pre>Station Options OXP

Instructions for pilots:

Do not unzip the .oxz file, just move into the AddOns folder of your 
Oolite installation.

Instructions for authors:

As the title suggests, this utility allows an oxp author to give pilots the 
ability to edit options at the station, as well as read any text you wish
to supply (e.g. the contents of the readme file).

Apart from a single JS script line to register your oxp, this utility is 
driven completely from the missiontext.plist file, thus having everything in
one file.

Included in the root folder of this oxp is a template file with all the
instructions and some examples.  Simply copy this file into your oxp&#39;s
Config folder and customize it (don&#39;t forget to remove the examples!).  If 
you already have a missiontext.plist file, you will have to merge the two, 
otherwise, just rename the template file to missiontext.plist.


Changelog:

v 1.0   initial release
</pre>
        </a>

        <a name="equipment">          
        <h2>Equipment</h2>
            This expansion declares no equipment. This may be related to warnings.
        </a>

        <a name="ships">    
        <h2>Ships</h2>
            This expansion declares no ships. This may be related to warnings.
        </a>

        <a name="models">    
        <h2>Models</h2>
            This expansion declares no models. This may be related to warnings.
        </a>

        <a name="scripts">    
        <h2>Scripts</h2>
            <table>
                <tr>
                    <th>Path</th>
                </tr>
                <tr>
                    <td valign="top">Scripts/cagsdebug.js</td>
                    <td><pre>this.name		 = &quot;cagsdebug&quot;;
this.author		 = &quot;cag&quot;;
this.copyright	 = &quot;2017 cag&quot;;
this.licence	 = &quot;CC BY-NC-SA 3.0&quot;;
this.description = &quot;debugging helper fns&quot;;
this.version	 = &quot;1.0&quot;;

/* jshint elision:true, shadow:false, esnext: true, curly: false, maxerr: 1000, asi: true, laxbreak: true, undef: true, unused:true
*/
/* global log, worldScripts, Script, Vector3D, Quaternion
*/

(function(){
/* validthis: true
*/
&quot;use strict&quot;;

// false prevents output, though functions are still tracked
// - except with start&#39;s header, if it&#39;s forced by a child fn&#39;s msg or by its stop&#39;s msg.
// So putting text in a stop will force output of start&#39;s header when there&#39;s no regular
// output from add, begin or end
// - useful for exceptional situations, where a fn quits early: put a stop w/ msg before the return
//	 and output start&#39;s header as well; only see the fn output when something interesting happens
this.$fns_watched = {
&#39;shipSpawned&#39;:				false,
&#39;shipScoopedOther&#39;:			false,
&#39;update_one_Sighting&#39;:		true,
&#39;_update_some_Sighting&#39;:	true,
&#39;_update_Sightings&#39;:		false,
&#39;_delete_Sighting&#39;:			true,
&#39;_add_Sighting&#39;:			true
};

// worldScripts.telescope.$cag.init();

this.$project_name = &#39;telescope&#39;;

this.$DEBUG_CONSOLE_WIDTH = 200;
this.$DEBUG_OFF = true;
//this.$DEBUG_OFF = false;

this._display_map = function _display_map( map ) {
	var that = _display_map;
	var _showProps = ( that._showProps = that._showProps || worldScripts.cagsdebug._showProps );
	
	if( map.hasOwnProperty( &#39;map&#39; ) ) {
		map = map.map;
	}
	var tmp = _showProps( map, &#39;map&#39;, false, true, true );
	const MFD_FRIENDLY = 1,			// bounty === 0 &amp;&amp; !markedForFines
		  MFD_UNSOCIABLE = 2,		// bounty || markedForFines
		  MFD_ACTIVE = 4,			// .target || defenseTargets.length &gt; 0
		  MFD_HOSTILE = 8,			// in_ents_Targets ||
		  MFD_NEARBY = 16,			// distance &lt; scannerRange
		  MFD_FARAWAY = 32,			// distance &gt; scannerRange
		  MFD_PROTECTED = 64;		// .withinStationAegis
	const MFD_SALVAGE = 1,			// cargo, escape pods, derelicts
		  MFD_MINING = 2,			// asteroids, boulders, splinters &amp; metal fragments
		  MFD_WEAPONS = 4,			// mines &amp; missiles
		  MFD_TRADERS = 8,			// ships .isTrader &amp; escorts
		  MFD_POLICE = 16,			// .isPolice
		  MFD_PIRATES = 32,			// .isPirate &amp; .isPirateVictim
		  MFD_MILITARY = 64,		// scanClass === &#39;CLASS_MILITARY&#39;
		  MFD_ALIENS = 128,			// scanClass === &#39;CLASS_THARGOID&#39;
		  MFD_STATION = 512,		// scanClass === &#39;CLASS_STATION&#39;
		  MFD_NAVIGATION = 512,		// some stations &amp; beacons (may include a ship if emitting a beacon)
		  MFD_CELESTIAL = 1024;		// sun,  planets, moons

	tmp += &#39;\ndynamic flags&#39;;
	var flags = map.dynamicMFD;
	if( flags ) {
		if( flags &amp; MFD_FRIENDLY ) tmp += &#39;:  FRIENDLY&#39;;
		if( flags &amp; MFD_UNSOCIABLE ) tmp += &#39;:	UNSOCIABLE&#39;;
		if( flags &amp; MFD_ACTIVE ) tmp += &#39;:	ACTIVE&#39;;
		if( flags &amp; MFD_HOSTILE ) tmp += &#39;:	 HOSTILE&#39;;
		if( flags &amp; MFD_NEARBY ) tmp += &#39;:	NEARBY&#39;;
		if( flags &amp; MFD_FARAWAY ) tmp += &#39;:	 FARAWAY&#39;;
		if( flags &amp; MFD_PROTECTED ) tmp += &#39;:  PROTECTED&#39;;
	}
	tmp += &#39;\nstatic flags&#39;;
	flags = map.staticMFD;
	if( flags ) {
		if( flags &amp; MFD_SALVAGE ) tmp += &#39;:	 SALVAGE&#39;;
		if( flags &amp; MFD_MINING ) tmp += &#39;:	MINING&#39;;
		if( flags &amp; MFD_WEAPONS ) tmp += &#39;:	 WEAPONS&#39;;
		if( flags &amp; MFD_TRADERS ) tmp += &#39;:	 TRADERS&#39;;
		if( flags &amp; MFD_POLICE ) tmp += &#39;:	POLICE&#39;;
		if( flags &amp; MFD_PIRATES ) tmp += &#39;:	 PIRATES&#39;;
		if( flags &amp; MFD_MILITARY ) tmp += &#39;:  MILITARY&#39;;
		if( flags &amp; MFD_ALIENS ) tmp += &#39;:	ALIENS&#39;;
		if( flags &amp; MFD_STATION ) tmp += &#39;:	 STATION&#39;;
		if( flags &amp; MFD_NAVIGATION ) tmp += &#39;:	NAVIGATION&#39;;
		if( flags &amp; MFD_CELESTIAL ) tmp += &#39;:  CELESTIAL&#39;;
	}
	log( tmp );
}

this._dump_map = function _dump_map() {		// dump Sightings list for telescope
	var that = _dump_map;
	var cd = ( that.cd = that.cd || worldScripts.cagsdebug );
	var ws = ( that.ws = that.ws || worldScripts.telescope );
	var curr_S = ( that.curr_S = that.curr_S || ws.$curr_Sighting );
	
	var pst = curr_S.ent || null;
	var mapping = ws.$SightingsMap, maplen = mapping.length;
	var map, ent, target, thargoids = &#39;&#39;;
	var out = &#39;____ent_dist.rank   index	 rel. dir.n		 person	   [entity description minus position, scanClass &amp; status labels ...]	 [ve_colour,  lb_size,	ml_size]\n&#39;;
	// var out = &#39;____ent_dist.rank   index	 rel. dir.n	   curr.grav.D	 person	   [entity description minus position, scanClass &amp; status labels ...]	 [ve_colour,  lb_size,	ml_size]\n&#39;;
	var i, padding = &#39;________________&#39;;
	var	 ent_dist, rank, index, rel_dir, gs_curr, entID, descrn, gs_maxed;
	for( i = 0; i &lt; maplen; i++ ) {
		map = mapping[i]; ent = map.ent;
		gs_curr = map.gs_curr_dist;
		gs_maxed = gs_curr &gt; 0 &amp;&amp; gs_curr === map.gs_max_dist;
		target = pst &amp;&amp; pst === ent;
		if(ent.isThargoid) { out += ent+&#39;\n&#39;;
			thargoids += &#39;.	   dataKey = &#39;+map.dataKey+&#39;, last_posn = &#39;+map.last_posn+&#39; roles = &#39;+map.roles+&#39;\n&#39;;
		}
		ent_dist = map.ent_dist;
		if( ent_dist &gt; 999999999 )
			ent_dist = cd._number_str( ent_dist / 1000000000 ) + &#39; e9&#39;;
		else
			ent_dist = cd._number_str( ent_dist );
		ent_dist = padding.slice( ent_dist.length-10 )+ ent_dist;
		if( target ) {
			// ent_dist = ent_dist.replace(/^_*/, &#39;==&gt;&#39;);
			ent_dist = ent_dist[1] == &#39;_&#39; ? &#39;=&gt;&#39; + ent_dist.substring(2) :
					   ent_dist[0] == &#39;_&#39; ? &#39;|&gt;&#39; + ent_dist.substring(1) :
					   &#39;&gt;&#39; + ent_dist;
		}
		rank = map.rank.toUpperCase();
		index = i &lt; 10 ? &#39;__&#39; + i : i &gt; 99 ? i : &#39;_&#39; + i;
		rel_dir = ws._relativeDirection( ent.position, map );		
		rel_dir = rel_dir ? padding.slice( rel_dir.length-9 ) + rel_dir : &#39;???&#39;;
		// gs_curr = cd._number_str( gs_curr );							
		// gs_curr = padding.slice( gs_curr.length-(gs_maxed ? 10 : 11) ) + gs_curr;
		entID = ent.entityPersonality;
		entID = entID === undefined ? &#39;xxxxx&#39; : entID.toString();	
		entID = padding.slice( entID.length-6 ) + entID;
		descrn = ent.toString();
		descrn = descrn.replace(/position\: /, &#39;&#39; );
		descrn = descrn.replace(/scanClass\: /, &#39;__&#39; );
		descrn = descrn.replace(/CLASS_/, &#39;&#39; );
		descrn = descrn.replace(/status\: /, &#39;__&#39; );
		descrn = descrn.replace(/STATUS_/, &#39;&#39; );
		out += ent_dist+&#39;_&#39;+rank
		out += map.swapable ? &#39;%&#39; : &#39;_&#39;;
		out += &#39;	[&#39;+index+&#39;]&#39;+(target ? &#39;|&gt;&#39; : &#39;  &#39;)+&#39;[&#39;+rel_dir+&#39;]&#39;
			+(target ? &#39;|&gt;&#39; : &#39;  &#39;)
			// +&#39;[&#39;+gs_curr+(gs_maxed ? &#39; M&#39; : &#39;]&#39;)
			+&#39; #&#39;+entID+&#39;  &#39;
			+descrn+&#39;	[&#39;+map.ve_colour+&#39;, &#39;+map.lb_size+&#39;, &#39;+map.ml_size+&#39;]&#39;+(target ? &#39;&lt;==&#39; : &#39;&#39;)
//			  +&#39; Ms: &#39;+ map.staticMFD.toString(2)+&#39; Md: &#39;+map.dynamicMFD.toString(2)
			+&#39; stat: &#39;+ cd._number_str( map.staticMFD, 0, 2 ) + &#39; dyn: &#39;+ cd._number_str( map.dynamicMFD, 0, 2)
			+ (map.have_scanned ? &#39; h_s: &#39; + map.have_scanned :&#39;&#39;)
			+&#39;\n&#39;;
	}
	out += &#39;ws.$SightingsMap.length = &#39; + mapping.length;
	log(out);
	if( thargoids ) log( &#39;Thargoids:\n&#39; + thargoids );
}

this._rel2PS = function rel2PS( name, position, distance ) {
	var cd = worldScripts.cagsdebug;
	var ps = player &amp;&amp; player.ship;
	var ps_position = ps.position;
	let posn =	position.constructor === Vector3D ? position :
				Array.isArray(position) ? new Vector3D( position ) :
				position.position || null;
	if( !posn ) {
		return &#39;missing position for &#39; + name;
	}
	let dist = distance || posn.distanceTo( ps_position );
	let padding = &#39;________________&#39;;
	let pname = padding.slice( name.length - 16 ) + name;
	if( name === &#39;lightball&#39; ) pname = &#39;__&#39; + pname;
	let vector = posn.subtract( ps_position );
	let fwd, right, up, rpt = &#39;&#39;;
	fwd =	( ps.vectorForward.angleTo( vector ) *180/3.1415927 ).toFixed();
	right =	( ps.vectorRight.angleTo( vector ) *180/3.1415927 ).toFixed();
	up =	( ps.vectorUp.angleTo( vector ) *180/3.1415927 ).toFixed();
	rpt += pname + &#39; is &#39; + ( fwd &lt;= 90 ? &#39;forward &#39; : &#39;astern &#39; ) + fwd + &#39;°, &#39;
							+ ( right &lt;= 90 ? &#39;	 starboard &#39; : &#39;		port &#39;) + right + &#39;°, &#39;
							+ ( up &lt;= 90 ? &#39;	above &#39; : &#39;	   below &#39;) +  up
							+ &#39;° at &#39; + cd._number_str( dist ) + &#39; m&#39;;
	// vector = vector.direction();
	// fwd =	ps.vectorForward.dot( vector ).toFixed(5);
	// right =	ps.vectorRight.dot( vector ).toFixed(5);
	// up =	ps.vectorUp.dot( vector ).toFixed(5);
	// rpt += &#39;\n\t&#39; + pname + &#39; is &#39; + ( fwd &gt;= 0 ? &#39;forward &#39; : &#39;astern &#39; ) + ( Math.acos(fwd) *180/3.1415927 ).toFixed() + &#39;°, &#39;
							// + ( right &gt;= 0 ? &#39;  starboard &#39; : &#39;		  port &#39;) + ( Math.acos(right) *180/3.1415927 ).toFixed() + &#39;°, &#39;
							// + ( up &gt;= 0 ? &#39;	  above &#39; : &#39;	 below &#39;) +	 ( Math.acos(up) *180/3.1415927 ).toFixed()
							// + &#39;° at &#39; + cd._number_str( dist ) + &#39; m&#39;;
	return rpt;
}

this._curr_S_report = function _curr_S_report() {
	var cd = worldScripts.cagsdebug;
	var cs = worldScripts.telescope.$curr_Sighting;
	var ps = player &amp;&amp; player.ship;
	var scannerRange = ps.scannerRange;

	let map = cs.map;
	if( !map ) {
		log(&#39;telescope&#39;, &#39;_curr_S_report, $curr_Sighting.map is &#39; + map );
		return;
	}
	let ent = cs.ent;
	let map_ent_dist = cs.map.ent_dist;
	let marker = cs.marker;
	let lightball = cs.map.lightball;
	let tmp = &#39;ps.speed = &#39; + ps.speed + &#39;,	   viewDirection = &#39; + ps.viewDirection + &#39;,  for &#39; + ent;
	tmp += &#39;\n &#39; + cd._rel2PS( &#39;ent&#39;, ent, map.ent_dist );
	if( marker )
		tmp += &#39;\n &#39; + cd._rel2PS( &#39;marker&#39;, marker	 );
	if( lightball )
		tmp += &#39;\n &#39; + cd._rel2PS( &#39;lightball&#39;, lightball );
//	let ent_posn = map.rank === &#39;ukn&#39;  ? map.last_posn : ent.position;

	let marker_dist = scannerRange - 499.6;
	if( map_ent_dist &lt; scannerRange ) {
		if( map_ent_dist &lt; marker_dist )
			marker_dist = map_ent_dist;
	}
//	let targ_dir = ent_posn.subtract( ps_position ).direction();
//	let targ_posn = ps_position.add( targ_dir.multiply( marker_dist ) );//.add( speed_adj );
//	tmp += &#39;\n &#39; + cd._rel2PS( &#39;new marker&#39;, targ_posn, marker_dist );

	log(&#39;telescope&#39;, tmp );
}

// debugger ///////////////////////////////////////////////////////////////////////////////////////

/*	(function () {
WS.telescope.$cag = worldScripts.cagsdebug._debug_msgs();
WS.telescope.$cag.init();
})()	// */

this._debug_msgs = function _debug_msgs() {
	function break_line( str, limit ) {			// break str into lines, avoiding splitting on an &#39;=&#39; if poss.
		function trim( x ) {											// return index of 1st non-whitespace char.
			var space;
			var index = x;											// never modify arguments
			do {
				space = str[ index ];
				if( space !== &#39; &#39; &amp;&amp; space !== &#39;\t&#39; ) break;
				index++;
			} while( index &lt; str.length );
			return index;
		}
		function output( x ) {										// push indices for next line; return true if finished w/ str
			var index = x;											// never modify arguments
			strptr = trim( strptr );
			lines.push( [ strptr, index ] );
			index = trim( index );
			if( index + limit &gt;= str.length ) {						// just tail end remains
				lines.push( [ index, -1 ] );
				return true;										// finished w/ str
			}
			strptr = index;		i = index + limit;		first = -1;		newline = -1;
			return false;											// still more to output
		}
		function _seek( dir ) {										// walk str in direction dir across whitespace; return presence of an &#39;=&#39;
			var equals = false;
			do {													// scan in direction dir for end of whitespace or an &#39;=&#39;
				if( i + dir &lt; 0 || i + dir &gt;= str.length ) break;	// protect limits
				i += dir;
				letter = str[ i ];
				if( letter === &#39;=&#39; ) equals = true;
			} while( letter === &#39; &#39; || letter === &#39;\t&#39; || letter === &#39;=&#39; );
			i -= dir;
			return equals;											// return presence of an &#39;=&#39;
		}
		var first = -1;		var letter, i;		var newline = -1;
		var lines = [];		var strptr = 0;
		for( i = strptr + limit; i &gt; strptr; i-- ) {
			if( newline === -1 ) {
				newline = str.indexOf( &#39;\n&#39;, strptr );
				if( newline &gt;= strptr &amp;&amp; newline &lt;= i )				// respect imbedded newlines
					if( output( newline + 1 ) ) break;
			} else
				newline = 0;										// only check once per output()
			letter = str[ i ];
			if( letter === &#39; &#39; || letter === &#39;\t&#39; ) {
				if( _seek( 1 ) || _seek( -1 ) ) {					// look fwd &amp; back for &#39;=&#39;s; found a bad break, ie. has &#39;=&#39;
					if( first &lt; 0 ) first = i;						// save the first, just in case
				} else {
					if( output( i ) ) break;						// i pts to 1st letter in break
					continue;
				}
			}
			if( i - strptr &lt;= 20 ) {								// no good break bound; reasonable lower limit on line length
				if( first &gt; -1 ) {									// use previously found (bad) break
					if( output( first ) ) break;
				} else {											// no break found, arbitrary cut using limit
					if( output( strptr + limit ) ) break;
				}
			}
		}
		return lines;
	}

	function insert( str, frame ) {				// insert str into frame&#39;s msg buffer
		var msg_len = frame.msg.length;
		var pad_len = frame.pad.length;
		var str_len = str.length;
		if( msg_len === 0 ) {										// pad the 1st line
			frame.len = pad_len;									// will be added on output but need to account for its length now
		}
		if( str_len + frame.len	 &gt; DEBUG_CONSOLE_WIDTH ) {			// begin a new line
			var lines = break_line( str, DEBUG_CONSOLE_WIDTH - pad_len );
			var start, end, i;
			for( i = 0; i &lt; lines.length; i ++ ) {
				[start, end] = lines[ i ];
				frame.msg += str.substring( start, ( end === -1 ? str_len : end ) ) + &#39;\n&#39;;
			}
		} else {
			frame.msg += ( msg_len &gt; 0 ? &#39;	&#39; : &#39;&#39; ) + str;
		}
		var nl_index = frame.msg.lastIndexOf( &#39;\n&#39;, msg_len );
		if( nl_index &gt; -1 ) {										// calc length of last line in msg
			frame.len = msg_len - nl_index;							// &#39;\n&#39; has length of 1
		} else {
			frame.len = msg_len;
		}
	}

	function is_watched_fn( dbgfn, str ) {		// check user supplied $fns_watched to determine if msg should proceed
		var caller = frame.caller;
		if( fns_watched.length === 0 ) return true;					// fn limiting not used
		if( frame === null ) {
			log( project_name, &#39;ERR: _debug, null frame: debug cmd outside start...stop sequence.  is_watched_fn:  &#39;+dbgfn+&#39;:  str = &#39;+str+&#39;\n############&#39;);
			return true; // allow in hopes of locating errant cmd
		}
		if( !fns_watched.hasOwnProperty( caller ) ) return false;	// fn limiting is in play but fn missing -&gt; deny by default
		if( fns_watched[ caller ] !== true )						// its in use, fn found but turned off
			return false;
		return true;												// fn in list &amp; set true!
	}

	function trim_space( str ) {				// trim white space at start &amp; end of line; -can&#39;t use .trim() as it removes line breaks!
		return str.replace(/^[ \t\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]+|[ \t\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]+$/g, &#39;&#39;);
	}

	function change_breaks( line ) {			// collapse &amp; convert all line breaks
		return line.replace(/[\n\r\f\v\u00a0\u2028\u2029]+/g, &#39;&lt;BR&gt;&#39;);
	}

	function output() {							// called by stop to output or start to flush pre-existing msg
		if( DEBUG_OFF ) return;
		var incl_hd = frame.incl_hd;
		var msg = frame.msg;
		if( !incl_hd &amp;&amp; !msg )										// unless directed to output hd, only log if there&#39;s a msg
			return;													// excl. header when no msg
		if( incl_hd &amp;&amp; frame.out_len &gt; 0 )							// a force_hd not necess, as frame already has output
			return;
		var head = frame.head;
		var out = curr_pad + &#39;	&#39; + frame.caller + &#39;:: &#39;;			// 1st line of output always starts w/ the caller (.len incr&#39;d in .add)
		if( head ) out += head;										// .head contains a newline char
		out += msg;
		out = trim_space( out );
		out = change_breaks( out );
		out = out.replace( /(&lt;BR&gt;)+$/g, &#39;&#39; );						// trim any trailing line break
		out = out.replace( /(&lt;BR&gt;)+/g, &#39;\n&#39; + curr_pad + &#39;	&#39; );	// add padding to start of each line
		if( out.slice( - curr_pad.length ) === curr_pad )			// out ends w/ just a pad
			out = out.slice( 0, - curr_pad.length );
		if( frame.logging ) log( project_name, out );				// writes to console and log file
		else				log( out );								// writes only to console
		frame.out_len += out.length;
		frame.head = &#39;&#39;;	msg = &#39;&#39;;	frame.len = 0;
		frame.incl_hd = false;										// reset for next time
	}

	function add_msg( via, str, format ) {		// insert format str into msg buffer
		if( !is_watched_fn( via, str ) ) return;
		if( !str ) return;
		if( stack.length === 0 )
			log( project_name, &#39;ERR: debug, no debug frame: check for premature &quot;.stop()&quot; or add a &quot;.start()&quot; statement. .&#39; + via + &#39;:	str = &#39; + str +&#39;\n############&#39;);
		insert( format, frame );
	}

	// add( str ) - append str to output msg
	function add( str ) {						// user fn to append str to msg
		if( DEBUG_OFF ) return;
		add_msg( &#39;add&#39;, str, str );
	}

	// begin( str ) - output str at start of a new line (prepends a newline)
	function begin( str ) {						// user fn to begin a new line w/ str
		if( DEBUG_OFF ) return;
		add_msg( &#39;begin&#39;, str, (frame.len &gt; 0 ? &#39;\n&#39; + str : str) );
	}

	// end( str ) - output str at end of curr. line (appends a newline)
	function end( str ) {						// user fn to end the current line w/ str
		if( DEBUG_OFF ) return;
		add_msg( &#39;end&#39;, str, str +&#39;\n&#39; );
	}

	// log_file( str, [con_log], [caller] )	 - stand-alone user fn to add output to log file
	//										 - it ignores $DEBUG_OFF flag but terminates any further action if true
	//										 - con_log flag can be used to output to console as well, in curr. frame
	//										 - caller may be from any previous frame; if not found &amp; con_log is true, output added to current frame
	function log_file( str, con_log, caller ) {	// output data to log file independent of the current frame
		log( project_name, caller + &#39;, &#39; + str );					// writes to log file
		if( DEBUG_OFF ) return;										// debugger if off, so just log msg
		if( stack.length === 0 )	return;							// no active frame
		if( con_log === undefined ) return;
		if( caller === undefined ) {								// add str to curr. frame
			add( str );
			return;
		}
		var prev;
		var len = stack.length;
		for( var i = 0; i &lt; len; i ++ ) {
			prev = stack[ i ].caller;
			if( prev === caller ) {
				insert( str, prev )									// add str to caller&#39;s frame
				return;
			}
		}
		add( str );													// failed to locate caller, add to curr. frame
	}

	function Frame( c ) {	this.caller = c;		this.head = &#39;&#39;;			this.msg = &#39;&#39;;
							this.pad = &#39;&#39;;			this.out_len = 0;		this.len = 0;
							this.incl_hd = false;	this.force_hd = 1;		this.logging = false;		}
	var used_frames = [];
	var used_frame_num = 0;
	function free_frame( frame ) {
//log(&#39;telescope&#39;, &#39;free_frame, for caller = &#39; + frame.caller + &#39;, pool totals &#39; + (used_frame_num + 1)+ &#39;, on stack: &#39; + (stack.length - 1) );
		frame.caller = null;	frame.head = &#39;&#39;;		frame.msg = &#39;&#39;;
		frame.pad = &#39;&#39;;			frame.out_len = 0;		frame.len = 0;
		frame.incl_hd = false;	frame.force_hd = 1;		frame.logging = false;
		used_frames.push( frame );
		used_frame_num++;
	}
	function alloc_frame( caller ) {
		var frame;
		if( used_frame_num &gt; 0 ) {
			frame = used_frames.pop();
			used_frame_num--
			frame.caller = caller;
//log(&#39;telescope&#39;, &#39;alloc_frame for caller = &#39; + caller + &#39;, allocating recycled frame, pool totals &#39; + used_frame_num + &#39;, on stack: &#39; + (stack.length + 1) );
		} else {
			frame = new Frame( caller );
log(&#39;telescope&#39;, &#39;alloc_frame, for caller = &#39; + caller + &#39;, allocating NEW frame, pool totals &#39; + used_frame_num + &#39;, on stack: &#39; + (stack.length + 1) );
		}
		stack.push( frame );
		return frame;
	}

	// start( caller, [hd], [force_hd], [logging] )	 - open new debug level; caller is function&#39;s name (output toggled in $fns_watched)
	//												 - hd is str (heading) that is output only if more str&#39;s comes in
	//												 - force_hd, an int, over-rules this (default = 1; see Frame object).
	//												   this give some context when a normally silent fn outputs a msg,
	//												   by showing who called it. The higher the number, the farther up the frame stack
	//												   headers are forced to output
	//												 - logging is a boolean to also write to log file (vs. debug console only)
	function start( caller, hd,					// user fn to init a msg frame, start&#39;s hd string is not counted in len, so if
					force_hd, logging ) {		// no fn msg&#39;s between start &amp; stop, no output
		if( DEBUG_OFF ) return;
		var len = stack.length;
		if( len &gt; 0 ) {												// not the root frame
			output();												// flush any pending output
			var fn_name = caller !== undefined ? caller
											   : &#39;Anonomous&#39; + stack.length;
			var prev;
			for( var i = len -1; i &gt;= 0; i-- ) {					// check not already on stack (fix for GDERM bug)
				prev = stack[ i ].caller;
				if( prev === fn_name ) {
					free_frame( stack.splice( i, 1 )[0] );
					curr_pad = curr_pad.slice( 0, -PAD_LEN );		// just remove that one entry, as we know we&#39;re not recursing
				}
			}
		}
		frame = alloc_frame( caller );
		var tmp_pad;
		if( stack.length % 2 === 0 ) tmp_pad = &#39;=========&#39;;			// alternate padding char&#39;s
		else						 tmp_pad = &#39;+++++++++&#39;;
		frame.pad = tmp_pad.substr( 0, PAD_LEN );
		curr_pad += frame.pad;
		if( caller !== undefined ) {
			frame.caller = caller;
			frame.len += frame.caller.length;
		} else {
			log( project_name, &#39;ERR: _debug, invalid caller: function name needed for output to be formatted correctly. .start: str = &#39; + hd +&#39;\n############&#39;);
		}
		if( frame === null ) {
			log( project_name, &#39;ERR: _debug, internal error: unable to create frame; stack len = &#39; + len + &#39;, .start:  caller: &#39;+caller+&#39;(),  str = &#39; + hd +&#39;\n############&#39;);
		}
		if( logging !== undefined )	 frame.logging = logging;
		if( force_hd !== undefined ) frame.force_hd = force_hd;
		if( hd !== undefined ) {
			tmp_pad = curr_pad;										// save current padding str and clear curr_pad
			curr_pad = &#39;&#39;;											//	 so we don&#39;t put any padding on the header
			insert( hd + &#39;\n&#39;, frame );								// a start header always ends its output line
			curr_pad = tmp_pad;										// restore current padding
		}
		frame.head = trim_space( frame.msg );						// move to head
		frame.msg = &#39;&#39;;
		frame.len = 0;												// reset len as header doesn&#39;t count
	}

	// _stop( caller, [str], [nolog] ) - close curr. level or regress to it if events interruped sequence; nolog suppresses log file output,
	//									 over-ruling logging flag in start
	function stop( caller, str, nolog ) {		// user fn to terminate a frame, ouputting any pending messages
		if( DEBUG_OFF ) return;
var have_str = str &amp;&amp; str.length &gt; 0; // debug
		if( caller === undefined )
			log( project_name, &#39;ERR: _debug, missing caller: function name needed for output to be formatted correctly. .stop:	str = &#39; + str +&#39;\n############&#39;);
		if( frame === null )
			log( project_name, &#39;ERR: _debug, no debug frame: add a &quot;start()&quot; statement. .stop:	caller: &#39;+caller+&#39;(), str = &#39; + str +&#39;\n############&#39;);
		if( str &amp;&amp; caller === frame.caller ) {
			insert( &#39;\n&#39; + str, frame );
have_str = false;
		}
		if( nolog !== undefined ) frame.logging = !nolog;			// nolog over-rules frame.logging
		if( stack.length &gt; 0 ) {
			var msg_len = frame.msg.length;
			output();												// flush any pending output
			if( stack.length &gt; 1 ) {								// not the root frame
				var force_hd = ( msg_len &gt; 0 ? frame.force_hd : 0 );
				if( force_hd &gt; 0 ) {								// set higher frame(s) to output
					var i = stack.length;
					while( i-- &amp;&amp; force_hd &gt; 0 ) {
						stack[ i ].incl_hd = true;
						force_hd--;
					}
				}
			}
			free_frame( frame );
			frame = stack.pop();
			if( str &amp;&amp; caller === frame.caller ) {				// for when a .stop is skipped
				log( project_name, &#39;ERR: _debug, missed .stop(): &#39; + frame.caller + &#39;() stopped while &#39; + caller + &#39;() still active. .stop:	 str = &#39; + str +&#39;\n############&#39;);
				insert( &#39;\n&#39; + str, frame );					// still output msg
have_str = false;
			}
			curr_pad = curr_pad.slice( 0, -PAD_LEN );
		} else {
			frame = alloc_frame( caller );							// re-init safely after having lost track!
		}
if( have_str ) log(&#39;telescope&#39;, &#39;debug.stop, failed to output: &#39; + str );
	}

	function reset() {							// reset msg stack; meant for debug console but is also a user fn
		var len;
		len = stack.length;
		while( len-- ) {
			free_frame( stack[ len ] );
		}
		stack.length = 0;						// this will clear all ref&#39;s to frame objects
		frame = null;
		PAD_LEN = 3;
		curr_pad = &#39;&#39;;
	}
	function init( project ) {					// import local var&#39;s at runtime by calling this fn
		var wc = worldScripts.cagsdebug;
		if( project ) {
			project_name = wc.$project_name = project;
		} else {
			project_name = wc.$project_name;
		}
		fns_watched = wc.$fns_watched;
		DEBUG_CONSOLE_WIDTH = wc.$DEBUG_CONSOLE_WIDTH;
		DEBUG_OFF = wc.$DEBUG_OFF;
	}

	var frame = null;
	var stack = [];		// stack built of Frame&#39;s when debugging fns are nested
	var PAD_LEN = 3;	// max 9 unless you enlarge 2 padding str&#39;s in start
	var curr_pad = &#39;&#39;;
	var project_name, fns_watched, DEBUG_CONSOLE_WIDTH, DEBUG_OFF;

	return {	 init:	init,
				  add:	add,
				begin:	begin,
				  end:	end,
			 log_file:	log_file,
				reset:	reset,
				start:	start,
				 stop:	stop
	};
}

// debugger ends //////////////////////////////////////////////////////////////////////////////////

this._reportError = function _reportError( err, func, parms, depth, goDeep ) {
	// constants - adjust as needed
	var FILE_LEN = 100;		// cut-off len for file spec.
	var FNAME_LEN = 40;		// cut-off len for function name
	var ARGS_LEN = 60;		// cut-off len for arguments string
	var STRING_LEN = 80;	// cut-off for long strings
	var IPAD = &#39; &#39;;			// inside padding, eg. after array open bracket, before close bracket
/*	
	err		(required) value passed in the catch statement
	
	func	(required) function that caught the error
			- can also be a string with the function&#39;s name if the
			  function is not named
			  eg. this.startUp = function() { ...			-&gt; pass &#39;startUp&#39;
			      this.startUp = function startUp() { ...	-&gt; pass startUp
			- using a named function has the advantage of reporting 
			  any function properties  
				
	parms	(optional) parameters passed to func
			- if there are multiple parms, pass them in an array
			- can also include function variables if you want more 
			  information dumped
			  eg. this.shipSpawned = function shipSpawned( ship ) { 
					var dist = player.ship.position.distanceTo( ship ); ...
			      -&gt; pass as parms: [ship, dist] to have both displayed
				  
	depth	(optional) # levels to expose contents of parameters/properties
			- default is 1, use 0 to suppress overly long output
			  eg. if a parm is an array of 3 items, 0 will print &quot;&lt;array of 3&gt;&quot;,
				  1 will print &quot;[ item1, item2, item3 ]&quot;
				  - if item3 is an object: &quot;[ item1, item2, &lt;object of ..&gt; ]&quot;
				  2 will print the contents of each item, in this case, 
				    expanding the object
				  3 will expand the object&#39;s properties, etc
				  (ditto for nested arrays)
			- NB: depth &gt; 2 will likely produce large output, eg. ships
			- will accept a 2 item array if you want different depths for 
			  parameters vs. properties, ie. [ parm depth, prop depth ]
			  eg. [ 2, 1 ]
			
	goDeep	(optional) boolean indicating whether or not to test hasOwnProperty
			when exposing properties
			- default is false meaning inherited properties won&#39;t be shown
			- eg. if you dump player.ship, false shows 63 properties, while true 
				  shows 226! (player properties + ship properties + entity properties)
			- inherited properties are prefixed by a caret &#39;^&#39;
				
	example usage:
	=============
	
	this.relativeDirection = function relativeDirection( position, map ) {
		var that = relativeDirection;
		var ws = ( that.ws = that.ws || worldScripts.telescope );
		var ps = player &amp;&amp; player.ship;
		
		try {
			var dist = map.ent.positon.distanceTo( ps );			&lt;== position mis-spelled
			...
			return relative_dirn;
		} catch( err ) {
			log( &#39;telescope&#39;, ws._reportError( err, relativeDirection, [position, map], 1 ) );
			if( debug ) 
				throw err;									
		}
	}

	Latest.log output:
	=================
		
	18:48:27.293 [LogEvents]: Asteroid 28897 spawned at 413 km
	18:48:27.898 [telescope]:
	function relativeDirection() 	 caught: 	TypeError: map.ent.positon is undefined
		parameters: [ (70839.2, -96302.7, 664477), &lt;object of 6&gt; ]
		properties: { ws: &lt;object of 169&gt; }
		file: ../AddOns/Norby.cag.Telescope.oxp/Scripts/telescope.js
			line: 6204,	relativeDirection( [object Vector3D], [object Object] )
		file: ../AddOns/Norby.cag.Telescope.oxp/Scripts/cagsdebug.js
			line:   47,	_display_map( [object Object] )
	18:48:27.899 [script.javaScript.exception.unexpectedType]: ***** JavaScript exception (oolite-debug-console 1.89): TypeError: map.ent.positon is undefined
	18:48:27.899 [script.javaScript.exception.unexpectedType]:       ../AddOns/Basic-debug.oxp/Scripts/oolite-debug-console.js, line 1117.
*/
		
	function trim_str( str ) {
		var result, len = str.length;
		if( len === 0 ) 
			return &#39;&lt;empty string&gt;&#39;;
		result = str.replace( /[\u180e\u2000-\u200a\u202f\u205f\u3000]+/g, &#39; &#39; );
		result = result.replace( /[\n]+/g, &#39;\\n&#39; ).replace( /[\t]+/g, &#39;\\t&#39; )
		result = &#39;&quot;&#39; + (len &gt; STRING_LEN ? result.substr(0, STRING_LEN) + &#39; ...&#39; : result) + &#39;&quot;&#39;;
		return result
	}

	var padding = [];
	function mkSpacePad( count ) {
		if( typeof count === &#39;number&#39; ) {
			padding.length = count + 1;
			return padding.join(&#39; &#39;);
		}
		return &#39; &#39;;
	}
 
	function countObjKeys( obj, deep ) {	// Object.keys( obj ).length only counts hasOwnProperty ones
		var count = 0;						// deep overrides goDeep
		if( goDeep || deep ) {
			for( let prop in obj ) 
				if( prop )					// this is just to silence JSLint
					count++;
		} else {
			count = Object.keys( obj ).length;
		}
		return count;
	}
	
	function rptType( obj ) {
		if( Array.isArray( obj ) ) {
			let len = obj.length;
			return len &gt; 0 ? &#39;&lt;array of &#39; + len + &#39;&gt;&#39; : &#39;[]&#39;;
		} else if( obj instanceof Script ) {
			return &#39;[Script &quot;&#39; + obj.name + &#39;&quot; version &#39; + obj.version + &#39;]&#39;;
		} else if( typeof obj === &#39;object&#39; ) {
			let len = countObjKeys( obj, true );	// ignore goDeep when counting
			return len &gt; 0 ? &#39;&lt;object of &#39; + len + &#39;&gt;&#39; : &#39;{}&#39;;
		} else {
			return obj;
		} 
	}
	
	function hasComplex( obj ) {
		for( let prop in obj ) {
			if( goDeep || obj.hasOwnProperty( prop ) ) {
				let item = obj[ prop ];
				if( Array.isArray( item ) || (typeof item === &#39;object&#39; &amp;&amp; item !== null) )
					return true;
			}
		}
		return false;
	}

	function showComplex( obj, recurse ) {		
		var isArray = Array.isArray( obj );
		var len = isArray ? obj.length : countObjKeys( obj );
		if( len === 0 ) return isArray ? &#39;[]&#39; : &#39;{}&#39;;
		var index = 0, 
			str = (isArray ? &#39;[&#39; : &#39;{&#39;) + IPAD, 
			strLen = str.length;
		var recursable = recurse &gt; 0 &amp;&amp; hasComplex( obj );
		for( let prop in obj ) {
			if( goDeep || obj.hasOwnProperty( prop ) ) {
				let item = obj[ prop ];
				let propStr = isArray ? &#39;&#39; : 
							(goDeep &amp;&amp; !obj.hasOwnProperty( prop ) ? &#39;^&#39; : &#39;&#39;) + prop + &#39;: &#39;;
				let propLen = propStr.length;
				str += propStr;
				if( recursable ) {
					if( index === 0 ) {
						outStarts.push( (outStarts.length &gt; 0 
										? outStarts[outStarts.length-1] + propLen + strLen
										: strLen + propLen + strLen) );
					}
					str += fmt_parm( item, recurse );
					if( index &lt; len - 1 ) {		// not the last one
						let inset = outStarts.length &gt; 1 ? outStarts[outStarts.length-2] : strLen;
						str += &#39;,\n&#39; + mkSpacePad( indentLen + inset );
					} else {
						str += IPAD;
					}
				} else {
					str += hasComplex( item ) ? rptType( item ) : fmt_parm( item, 0 );
					str += index &lt; len - 1 ? &#39;, &#39; : IPAD;
				}
				index++;
			}
		}
		if( recursable &amp;&amp; index ) outStarts.pop();
		return str + (isArray ? &#39;]&#39; : &#39;}&#39;);
	}
	
	var outStarts = [];	// stack of running total of recursed insets
	var parents = [];	// check parm not in parents to avoid endless recursion
	function fmt_parm( parm, recurse ) {
		if( parents.indexOf( parm ) &lt; 0 ) {
			parents.push( parm );
		} else  {
			return parm;
		} 
		var type = typeof parm;
		var str = &#39;&#39;;
		if( parm === null ) {
			str += &#39;null&#39;;
		} else if( type === &#39;undefined&#39; ) {
			str += &#39;undefined&#39;;
		} else if( type === &#39;string&#39; ) {
			str += trim_str( parm );
		} else if( type === &#39;boolean&#39; ) {
			str += (parm ? &#39;true&#39; : &#39;false&#39;);
		} else if( type === &#39;function&#39; ) {
			str += &#39;function &#39; + parm.name + &#39;()&#39;;
		} else if( parm instanceof Script ) {
			str += &#39;[Script &quot;&#39; + parm.name + &#39;&quot; version &#39; + parm.version + &#39;]&#39;;
		} else if( parm instanceof Vector3D ) {
			str += &#39;Vector3D: (&#39; + parm.x.toFixed() + &#39;, &#39; 
					+ parm.y.toFixed() + &#39;, &#39; + parm.z.toFixed() + &#39;)&#39;;
		} else if( parm instanceof Quaternion ) {
			str += &#39;Quaternion: (&#39; + parm.w.toFixed() + &#39; + &#39; + parm.x.toFixed() + &#39;i + &#39; 
					+ parm.y.toFixed() + &#39;j + &#39; + parm.z.toFixed() + &#39;k)&#39;;
		} else if( Array.isArray( parm ) ) {
			str += showComplex( parm, recurse &lt;= 1 ? 0 : recurse - 1 );
		} else if( type === &#39;object&#39; &amp;&amp; parm ) {
			str += showComplex( parm, recurse &lt;= 1 ? 0 : recurse - 1 );
		} else {
			str += rptType( parm );
		}
		parents.pop();
		return str;
	}

	var funcProps = {};
	function propsNotName( obj ) {
		if( typeof obj !== &#39;function&#39; ) return 0;	// backwards compatibity
		for( let key in funcProps ) {				// reset object
			if( funcProps.hasOwnProperty( key ) )
				delete funcProps[ key ];
		}
		for( let key in obj ) {
			if( key !== &#39;name&#39; )
				funcProps[ key ] = obj[ key ];
		}
		return Object.keys( funcProps ).length;
	}
	
	var parmsLabel = &#39;\n    parameters: &#39;;
	var indentLen = parmsLabel.length - 1;	// -1 for \n
	var fnName = typeof func === &#39;function&#39; ? func.name : func; // backwards compatibity
	var rpt, parmMax, propMax,
		bonus = Array.isArray( parms ) ? 1 : 0;			// don&#39;t count parms being an array as recursion (+ 1)
	if( Array.isArray( depth ) ) {
		parmMax = (depth.length &gt; 0 &amp;&amp; typeof depth[ 0 ] === &#39;number&#39; ? ~~(depth[ 0 ]) : 1) + bonus;
		propMax = (depth.length &gt; 1 &amp;&amp; typeof depth[ 1 ] === &#39;number&#39; ? ~~(depth[ 1 ]) : 1) + bonus;
	} else {
		parmMax = propMax = (typeof depth === &#39;number&#39; ? ~~(depth) : 1) + bonus;
	}
	if( err instanceof Error ) {
		rpt = &#39;\nfunction &#39; + fnName + &#39;() \t caught: \t&#39; + err.name + &#39;: &#39; + err.message;
	} else {		// for thrown strings (user defined errors)
		rpt = &#39;\nfunction &#39; + fnName + &#39;() \t caught: \t&#39; + err;
	}
	if( parms ) {
		rpt += parmsLabel + fmt_parm( parms, parmMax );
	}
	if( propsNotName( func ) ) {
		parmsLabel = &#39;\n    properties: &#39;;
		indentLen = parmsLabel.length - 1;	// -1 for \n
		rpt += parmsLabel + fmt_parm( funcProps, propMax + 1 );	// + 1 as funcProps is an object
	}
	
	// err is the stack object with properties: message, fileName, lineNumber, stack, name
	//  - stack is a long string containing &lt;function call&gt;@&lt;filename&gt;:&lt;line #&gt; separated by
	//    &#39;\n&#39; for each call in the stack
	if( err &amp;&amp; err.stack ) {
		var lastFile, parsed, frame, fnCall, args, file, line, pad;
		var stk = err.stack.split( /[\n\r]+/ ); // split on line breaks
		for( let i = 0, len = stk.length; i &lt; len; i ++ ) {
			// stack line format: fn(parms)@../AddOns/.../script.js:123
			parsed = stk[ i ].match( /^\s*(\w+)\((.*?)\)@(.*?):(.*?)$/ );
			if( !parsed || parsed.length &lt; 5 ) break;
			[frame, fnCall, args, file, line] = parsed;
			if( file &amp;&amp; file !== lastFile ) {	// suppress repeat of same filename
				if( file.length &gt; FILE_LEN ) 
					file = file.substring( file.length - FILE_LEN ) + &#39;...&#39;;
				rpt += &#39;\n    file: &#39; + file;
				lastFile = file;
			}
			pad = line &lt; 10 ? &#39;   &#39; : line &lt; 100 ? &#39;  &#39; : line &lt; 1000 ? &#39; &#39; : &#39;&#39; ;
			rpt += &#39;\n        line: &#39; + pad + line + &#39;,	&#39;; 
			if( fnCall.length &gt; FNAME_LEN ) fnCall = fnCall.substring(0, FNAME_LEN) + &#39;...&#39;;
			if( args.length &gt; ARGS_LEN ) args = args.substring(0, ARGS_LEN) + &#39;...&#39;;
			if( args.length ) 					// add spaces inside function&#39;s parenthices
				args = &#39; &#39; + args.replace( /,/g, &#39;, &#39; ) + &#39; &#39;;
			rpt += fnCall + &#39;(&#39; + args + &#39;)&#39;;	
		}
	}
	return rpt;
}
	
this._number_str = function _number_str( n, fixed, base ) {
	var that = _number_str;
	var round = ( that.round = that.round || Math.round );
	var working = ( that.working = that.working || [] );

	var comma, index, wk, len, str;
	str = typeof n === &#39;string&#39; ? parseFloat( n ) : n;
	if( !isFinite( str ) ) return n.toString();
	str = fixed &gt; 0 ? str.toFixed( fixed ).toString( base || 10 )
					: round( str ).toString( base || 10 );
	len = str.length;
	working.length = wk = 0;
	for( index = 0; index &lt; len; index++ ) working[ index ] = str[ index ];
	index = str.indexOf( &#39;.&#39; );
	comma = index &gt;=0 ? (index &gt; 0 ? index - 1 : 0) : len - 1;
	for( ; comma &gt; 0 ; comma -= 3 ) {
		index = comma - 2;
		if( (n &lt; 0 ? index-1 : index) &lt;= 0 ) break;
		for( wk = len - 1; wk &gt;= index; wk-- )
			working[ wk + 1 ] = working[ wk ];
		working[ index ] = &#39;,&#39;;
		len = working.length;
	}
	return working.join( &#39;&#39; );
}

//	worldScripts.cagsdebug
//	worldScripts.cagsdebug._showProps( cs.map, &#39;map&#39; )
//	worldScripts.cagsdebug._showProps( cs.map, &#39;map&#39;, false,	false,	true )
//	worldScripts.cagsdebug._showProps( cs.map, &#39;map&#39;, true )
//	worldScripts.cagsdebug._showProps( cs.map, &#39;map&#39;, true,		false,	true )
//	worldScripts.cagsdebug._showProps( cs.map, &#39;map&#39;, false,	true )
//	worldScripts.cagsdebug._showProps( cs.map, &#39;map&#39;, false,	true,	true )
//	worldScripts.cagsdebug._showProps( cs.map, &#39;map&#39;, true,		true,	true )
//	worldScripts.cagsdebug._showProps( cs.map, &#39;map&#39;, false,	2,		true )

//	worldScripts.cagsdebug._showProps =

this._showProps =	function _showProps( obj, objName, newLine, show_deep, expand_arrays, show_type ) {
	//										default:	true	true (1)		true			false
	function trim_str( str ) {
		var result, len = str.length;
		if( len === 0 ) 
			return &#39;&lt;empty string&gt;&#39;;
		result = str.replace( /[\u180e\u2000-\u200a\u202f\u205f\u3000]+/g, &#39; &#39; );
		result = result.replace( /[ ]{3:}/g, &#39;  &#39; );
		result = result.replace( /[\n]+/g, &#39;\\n&#39; ).replace( /[\t]+/g, &#39;\\t&#39; )
		// result = str.replace( /[\s]+/g, &#39; . &#39; );
		result = &#39;&quot;&#39; + (len &gt; 90 ? result.substr(0, 90) + &#39; ...&#39; : result) + &#39;&quot;&#39;;
		return result
	}

	function mkPad( i, suppress ) {
		if( i &lt;= 0 || suppress ) return &#39;&#39;;
		padding.length = newLine ? i : 1;
		return (newLine ? &#39;.&#39; :&#39;&#39;) + padding.join( &#39;    &#39; ); // &#39;.&#39; needed for console, as leading space trimmed
	}
	 
	function rptType( obj, showIt ) {
		if( Array.isArray( obj ) )
			return show_type || showIt ? &#39; &lt;array: &#39; + obj.length + &#39; elements&gt; &#39; : &#39;&#39;; 
		else if( typeof obj === &#39;object&#39; )
			return show_type || showIt ? &#39; &lt;object: &#39; + Object.keys( obj ).length + &#39; keys&gt; &#39; : &#39;&#39;; 
		else
			return &#39; &lt;&#39; + typeof obj + &#39;&gt; &#39;;
	}
 
	function show_array( array, recurse ) {
		if( array.length === 0 ) return &#39;[ ]&#39;;
		ilevel++;
		var str = &#39;[ &#39;;
		var pad = mkPad( ilevel, !expand_arrays );
		var len = array.length;
		for( var index = 0; index &lt; len; index ++ ) {
			str += !expand_arrays || !newLine ? (index &gt; 0 ? &#39;, &#39; : &#39;&#39;) : &#39;\n&#39;;
			str += pad;
			if( expand_arrays )
				str += index + &#39;: &#39; + fmt_prop( array[ index ], recurse );
			else
				str += fmt_prop( array[ index ], (recurse &lt;= 1 ? 0 : recurse - 1) );
		}
		ilevel--;
		if( len &gt; 0 &amp;&amp; expand_arrays &amp;&amp; newLine ) str += &#39;\n&#39;;
		str += mkPad( ilevel, !len || !expand_arrays ) + &#39; ]&#39; + rptType( array );
		return str;
	}

	function show_obj( obj, recurse ) {
		ilevel++;
		var str = &#39;{ &#39;;
		var pad = mkPad( ilevel );
		var len = Object.keys( obj ).length;
		for( var item in obj ) {
			str += newLine ? &#39;\n&#39; : &#39;    &#39;;
			str += pad;
			if( Array.isArray( obj ) ) {
				str += show_array( obj[ item ], recurse );
			} else {
				str += (obj.hasOwnProperty( item ) ? &#39;&#39; : &#39;^&#39;) + item + &#39;: &#39;;
				str += fmt_prop( obj[ item ], recurse );
			}
			str += &#39;;&#39;;
		}
		ilevel--;
		if( len &gt; 0 &amp;&amp; newLine ) str += &#39;\n&#39;;
		str += mkPad( ilevel, !len ) + &#39; }&#39; + rptType( obj );
		return str;
	}
	
	function fmt_prop( prop, recurse ) {
		if( parents.indexOf( prop ) &lt; 0 )
			parents.push( prop );
		else 
			return prop;
		var type = typeof prop;
		var str = &#39;&#39;;
		if( prop === null ) {
			str += &#39;null&#39;;
		} else if( type === &#39;undefined&#39; ) {
			str += &#39;undefined&#39;;
		} else if( type === &#39;string&#39; ) {
			str += trim_str( prop ) + (show_type ? &#39; &lt;string: &#39; + prop.length + &#39; char.s&gt;&#39; : &#39;&#39;);
		} else if( type === &#39;number&#39; ) {
			str +=	cd._number_str( prop, prop % 1 === 0 ? 0 : expand_arrays ? 3 : 1 )
					+ (show_type ? &#39; &lt;number&gt;&#39; : &#39;&#39;);
		} else if( type === &#39;boolean&#39; ) {
			str += prop + (show_type ? &#39; &lt;boolean&gt;&#39; : &#39;&#39;);
		} else if( type === &#39;function&#39; ) {
			str += &#39; function &#39; + prop.name + &#39;()&#39;;
		} else if( Array.isArray( prop ) ) {
			if( expand_arrays ) {
				str += show_array( prop, (recurse &lt;= 1 ? 0 : recurse - 1) );
			} else {
				str += rptType( prop, true );
			}
		} else if( type === &#39;object&#39; &amp;&amp; prop ) {
			if( recurse &gt; 0 ) {
				str += show_obj( prop, (recurse &lt;= 1 ? 0 : recurse - 1) );
			} else {
				str += rptType( prop, true );
			}
		} else {
			str += prop + (show_type ? &#39; &lt;&#39;+type+&#39;&gt;&#39; : &#39;&#39;);
		}
		parents.pop();
		return str;
	}
	
	var that = _showProps;
	var cd = ( that.cd = that.cd || worldScripts.cagsdebug );
	
	var padding = [], parents = [];
	if( show_type === undefined ) 		show_type = false;
	if( expand_arrays === undefined )	expand_arrays = true;	
	if( show_deep === undefined ) 		show_deep = 1;
	if( newLine === undefined ) 		newLine = true;
	var rmax = !show_deep ? 0 : show_deep === true ? 1 : ~~(show_deep);
	var ilevel = 1;

	return (newLine ? &#39;\n&#39; : &#39; &#39;) + objName + &#39;: &#39; + fmt_prop( obj, rmax ) + (newLine ? &#39;\n&#39; : &#39;&#39;);
}

}).call(this);














</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/station_options.js</td>
                    <td><pre>this.name		 = &quot;station_options&quot;;
this.author		 = &quot;cag&quot;;
this.copyright	 = &quot;2018 cag&quot;;
this.licence	 = &quot;CC BY-NC-SA 4.0&quot;;
this.description = &quot;Station interface for setting Telescope options.&quot;;
this.version	 = &quot;1.1&quot;;

/* jshint elision: true, shadow: true, esnext: true, curly: false, maxerr: 1000, asi: true,
		  laxbreak: true, undef: true, unused: true, evil: true,  forin: true, eqnull: true,
		  noarg: true, eqeqeq: true, boss: true, loopfunc: true, strict: true, nonew: true, noempty: false
*/

/*jslint indent: 4, white: true, debug: true, continue: true, sub: true, css: false, todo: true,
		 on: false, fragment: false, vars: true, nomen: true, plusplus: true, bitwise: true,
		 regexp: true, newcap: true, unparam: true, sloppy: true, eqeq: true, stupid: true
*/

/* global log, player, worldScripts, Script, Vector3D, Quaternion
*/

(function(){
/* validthis: true */

&quot;use strict&quot;;

this.$O_initStationOptions = function _initStationOptions(
		hostOxp,				// reference to oxp script
		keyPrefix,				// string
		optionsAllowedCallback,	// reference to script function
		callPWSG,				// boolean
		notifyCallback,			// reference to script function
		suppressSummary,		// boolean
		missionKeys				// object
	 ) {
/*
	hostOxp
		(required) a reference to your oxp, ie. worldScripts.myOxp

	keyPrefix
		(required) a string that is the common prefix to all of the entries
		in your missiontext.plist that are to be used here (usually some
		form of your oxp&#39;s name)
		- see the missiontext-template.plist file

	optionsAllowedCallback
		(optional) a callback function in your oxp that returns true/false
		indicating if your options facility is to be allowed
		You may wish to restrict access to main stations only, systems of
		a certain tech level/government, or based on device health
		- default is to always allow the interface

	callPWSG
		(optional) a boolean indicating if you want playerWillSaveGame called
		- if true, it will called after all the option changes have been
		assigned to your oxp&#39;s variables
		(assuming playerWillSaveGame is where you update your missionVariables)

	notifyCallback
		(optional) a callback function to notify your oxp that some option
		have been altered.	Your oxp variables will already have been set;
		this is for cases where some follow-up code may need to be run
		- it returns 2 arrays of strings:
			1st is names of variables changed
			2nd is names of options pages containing these
		- see the missiontext-template.plist file

	suppressSummary
		(optional) indicates if you want the summary page displayed
		when the player exits the interface after having made any changes
		- default is to show it
		- true will shut it down completely
		The summary page also reminds (nags) the player to save game if
		autosave is turned off, so &quot;summary&quot; will only suppress the summary
		but continue to nag and for completeness, &quot;autosave&quot; will show the
		summary but suppress the reminder

	missionKeys
		(optional) an object containing keys referenced in missiontext.plist,
		When expandMissionText is called, the 2nd parameter is an object used
		in the expansion.  Since that is done here instead, a way is provided
		to get your keys through (for substitution when inside square brackets)
		- in addition to all the keys in station_options&#39; missiontext.plist,
		  the following are also available:

			stn_optns_clockString		current value of clock.clockStringForTime( clock.adjustedSeconds )
			stn_optns_curr_system		name of current system
			// the rest are oxp dependent
			stn_optns_page				name of the option page (from your _optionPages)
			stn_optns_page_num			number of current page (eg. &quot;Page [stn_optns_page_num] of 5&quot;)
			stn_optns_next_page_num		number of next page (eg. &quot;Switch to page [stn_optns_next_page_num]&quot;)
			stn_optns_page_count		number of pages currently loaded
			stn_optns_option			name of the current option when in an option page, null otherwise
			stn_optns_changes_count		number of changes made in current session
			stn_optns_changed			a map of {option: value} for changes made in current session
*/

	try {
		var that = _initStationOptions;
		var so = (that.so = that.so || worldScripts.station_options);

		if( !so._setInterfaces ) {						// 1st time through, create the closure
			let closure = so._options_closure();
			so._setInterfaces = closure._setInterfaces;
			so._registerHostOxp = closure._registerHostOxp;
			so._purgepools = closure._purgepools;
			so._resetLocalVars = closure._resetLocalVars;

			// longer prefix needed to avoid circular assignment
			so._$_getReminder4Oxp = closure._getReminder4Oxp;
			so._$_getAllowedCallback = closure._getAllowedCallback;
			so._$_getCallPWSG = closure._getCallPWSG;
			so._$_getNotifyCallback = closure._getNotifyCallback;
			so._$_getSuppressSummary = closure._getSuppressSummary;
			so._$_getMissionKeys = closure._getMissionKeys;

			so._$_setAllowedCallback = closure._setAllowedCallback;
			so._$_setCallPWSG = closure._setCallPWSG;
			so._$_setNotifyCallback = closure._setNotifyCallback;
			so._$_setSuppressSummary = closure._setSuppressSummary;
			so._$_setMissionKeys = closure._setMissionKeys;

			so._$_updateMissionKeys = closure._updateMissionKeys;

			// delayed these worldScripts to avoid unnecessary calls at startup
			so.playerBoughtNewShip = so.playerBoughtEquipment =
				so.equipmentAdded = so.equipmentRemoved = so.equipmentRepaired =
				so.shipDockedWithStation = so.startUpComplete = so._setStationInterfaceEntries;
		}
		var registered = so._registerHostOxp( hostOxp, keyPrefix, optionsAllowedCallback,
											callPWSG, notifyCallback, suppressSummary, missionKeys );

		so._setStationInterfaceEntries();
		return registered;
	} catch( err ) {
		//  err, functn, parms, depth, goDeep
		log( so.name, so._reportError( err, _initStationOptions,
								[hostOxp, keyPrefix, optionsAllowedCallback, callPWSG,
								notifyCallback, suppressSummary, missionKeys ] ) );
	}
}

///////////////////////////////////////////////////////////////////////////////
// post init functions ////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// use these funcitons if you wish to alter the values you sent when
// you called $O_initStationOptions() to register

// Especially useful are the get/set/update functions for the missionKeys,
// which can override any of the keys defined in your missiontext.plist file
// and even any of those in this oxp&#39;s missiontext.plist (in case you want
// to change, for example, the text/color of the buttons or any other text)

this.$O_setAllowedCallback = function _setAllowedCallback( keyPrefix, newFunc ) {
	var that = _setAllowedCallback;
	var so = (that.so = that.so || worldScripts.station_options);

	so._$_setAllowedCallback( keyPrefix, newFunc );
}

this.$O_getAllowedCallback = function _getAllowedCallback( keyPrefix ) {
	var that = _getAllowedCallback;
	var so = (that.so = that.so || worldScripts.station_options);

	return so._$_getAllowedCallback( keyPrefix );
}

this.$O_setCallPWSG = function _setCallPWSG( keyPrefix, newBool ) {
	var that = _setCallPWSG;
	var so = (that.so = that.so || worldScripts.station_options);

	so._$_setCallPWSG( keyPrefix, newBool );
}

this.$O_getCallPWSG = function _getCallPWSG( keyPrefix ) {
	var that = _getCallPWSG;
	var so = (that.so = that.so || worldScripts.station_options);

	return so._$_getCallPWSG( keyPrefix );
}

this.$O_setNotifyCallback = function _setNotifyCallback( keyPrefix, newFunc ) {
	var that = _setNotifyCallback;
	var so = (that.so = that.so || worldScripts.station_options);

	so._$_setNotifyCallback( keyPrefix, newFunc );
}

this.$O_getNotifyCallback = function _getNotifyCallback( keyPrefix ) {
	var that = _getNotifyCallback;
	var so = (that.so = that.so || worldScripts.station_options);

	return so._$_getNotifyCallback( keyPrefix );
}

this.$O_setSuppressSummary = function _setSuppressSummary( keyPrefix, newBool ) {
	var that = _setSuppressSummary;
	var so = (that.so = that.so || worldScripts.station_options);

	so._$_setSuppressSummary( keyPrefix, newBool );
}

this.$O_getSuppressSummary = function _getSuppressSummary( keyPrefix ) {
	var that = _getSuppressSummary;
	var so = (that.so = that.so || worldScripts.station_options);

	return so._$_getSuppressSummary( keyPrefix );
}

this.$O_setMissionKeys = function _setMissionKeys( keyPrefix, newKeys ) {
	var that = _setMissionKeys;
	var so = (that.so = that.so || worldScripts.station_options);

	so._$_setMissionKeys( keyPrefix, newKeys );
}

this.$O_getMissionKeys = function _getMissionKeys( keyPrefix ) {
	var that = _getMissionKeys;
	var so = (that.so = that.so || worldScripts.station_options);

	return so._$_getMissionKeys( keyPrefix );
}

this.$O_updateMissionKeys = function _updateMissionKeys( keyPrefix, newKeys ) {
	var that = _updateMissionKeys;
	var so = (that.so = that.so || worldScripts.station_options);

	so._$_updateMissionKeys( keyPrefix, newKeys );
}

/*
this fetches an object containing the current state of the summary
report mechanism (if you didn&#39;t register with suppressSummary = true)
		.reportSummary			boolean
		.remindAutosave			boolean
		.autosaveStopRemind		int, counter of how many times user reminded about Autosave
		.suppressSummary		boolean
 */
this.$O_getReminder4Oxp = function _getReminder4Oxp( keyPrefix ) {
	var that = _getReminder4Oxp;
	var so = (that.so = that.so || worldScripts.station_options);

	return so._$_getReminder4Oxp( keyPrefix );
}

///////////////////////////////////////////////////////////////////////////////
// world event handlers ///////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

this.startUp = function startUp() {
	var that = startUp;
	var so = (that.so = that.so || worldScripts.station_options);

	so.$Remind2Savegame = JSON.parse( missionVariables.$StationOptionsRemind2Savegame );
}

this._setStationInterfaceEntries = function _setStationInterfaceEntries() {
	var that = _setStationInterfaceEntries;
	var so = (that.so = that.so || worldScripts.station_options);

	var ps = player &amp;&amp; player.ship;
	if( ps &amp;&amp; ps.dockedStation ) {
		if( so._setInterfaces ) {						// undefined if have not called _initStationOptions
			so._setInterfaces();
			so.$optionsStarted = false;					// flag used for hidding hud
		}
	}
}

this.shipWillLaunchFromStation = function shipWillLaunchFromStation() {
	var that = shipWillLaunchFromStation;
	var so = (that.so = that.so || worldScripts.station_options);
	var ps = player &amp;&amp; player.ship;

	ps.hudHidden = false;
	so.$optionsStarted = false;
}

this.playerWillSaveGame = function playerWillSaveGame( /*message*/ ) {
	var that = playerWillSaveGame;
	var so = (that.so = that.so || worldScripts.station_options);

	missionVariables.$StationOptionsRemind2Savegame = JSON.stringify( so.$Remind2Savegame );
}

// rather than contend w/ the vagaries of guiScreenChanged,
// we simply hide HUD on entry (initOptions) &amp; restore it here
this.missionScreenEnded = function missionScreenEnded() {
	var that = missionScreenEnded;
	var so = (that.so = that.so || worldScripts.station_options);
	var ps = player &amp;&amp; player.ship;

	if( so.$optionsStarted ) {
		ps.hudHidden = so.$hudHidden;					// state save upon options entry
		so.$optionsStarted = false;
		so._resetLocalVars();
		so._purgepools();
	}
}

this._reportError = function _reportError( err, functn, parms, depth, goDeep ) {
	// constants - adjust as needed
	var FILE_LEN = 100;		// cut-off len for file spec.
	var FNAME_LEN = 60;		// cut-off len for function name
	var ARGS_LEN = 80;		// cut-off len for arguments string
	var STRING_LEN = 120;	// cut-off for long strings
	var IPAD = &#39; &#39;;			// inside padding, eg. after array open bracket, before close bracket

	function trim_str( str ) {
		var result, len = str.length;
		if( len === 0 )
			return &#39;&lt;empty string&gt;&#39;;
		result = str.replace( /[\u180e\u2000-\u200a\u202f\u205f\u3000]+/g, &#39; &#39; );
		result = result.replace( /[\n]+/g, &#39;\\n&#39; ).replace( /[\t]+/g, &#39;\\t&#39; )
		result = &#39;&quot;&#39; + (len &gt; STRING_LEN ? result.slice(0, STRING_LEN) + &#39; ...&#39; : result) + &#39;&quot;&#39;;
		return result
	}

	var padding = [];
	function mkSpacePad( count ) {
		if( typeof count === &#39;number&#39; ) {
			padding.length = count + 1;
			return padding.join(&#39; &#39;);
		}
		return &#39; &#39;;
	}

	function countObjKeys( obj, deep ) {	// Object.keys( obj ).length only counts hasOwnProperty ones
		var count = 0;						// deep overrides goDeep
		if( goDeep || deep ) {
			for( let prop in obj )
				if( prop )					// this is just to silence JSLint
					count++;
		} else {
			count = Object.keys( obj ).length;
		}
		return count;
	}

	function rptType( obj ) {
		if( Array.isArray( obj ) ) {
			let len = obj.length;
			return len &gt; 0 ? &#39;&lt;array of &#39; + len + &#39;&gt;&#39; : &#39;[]&#39;;
		} else if( obj instanceof Script ) {
			return &#39;[Script &quot;&#39; + obj.name + &#39;&quot; version &#39; + obj.version + &#39;]&#39;;
		} else if( typeof obj === &#39;object&#39; ) {
			let len = countObjKeys( obj, true );	// ignore goDeep when counting
			return len &gt; 0 ? &#39;&lt;object of &#39; + len + &#39;&gt;&#39; : &#39;{}&#39;;
		} else {
			return obj;
		}
	}

	function hasComplex( obj ) {
		for( let prop in obj ) {
			if( goDeep || obj.hasOwnProperty( prop ) ) {
				let item = obj[ prop ];
				if( Array.isArray( item ) || (typeof item === &#39;object&#39; &amp;&amp; item !== null) )
					return true;
			}
		}
		return false;
	}

	function showComplex( obj, recurse ) {
		var isArray = Array.isArray( obj );
		var len = isArray ? obj.length : countObjKeys( obj );
		if( len === 0 ) return isArray ? &#39;[]&#39; : &#39;{}&#39;;
		var index = 0,
			str = (isArray ? &#39;[&#39; : &#39;{&#39;) + IPAD,
			strLen = str.length;
		var recursable = recurse &gt; 0 &amp;&amp; hasComplex( obj );
		for( let prop in obj ) {
			if( goDeep || obj.hasOwnProperty( prop ) ) {
				let item = obj[ prop ];
				let propStr = isArray ? &#39;&#39; :
							(goDeep &amp;&amp; !obj.hasOwnProperty( prop ) ? &#39;^&#39; : &#39;&#39;) + prop + &#39;: &#39;;
				let propLen = propStr.length;
				str += propStr;
				if( recursable ) {
					if( index === 0 ) {
						outStarts.push( (outStarts.length &gt; 0
										? outStarts[outStarts.length-1] + propLen + strLen
										: strLen + propLen + strLen) );
					}
					str += fmt_parm( item, recurse );
					if( index &lt; len - 1 ) {		// not the last one
						let inset = outStarts.length &gt; 1 ? outStarts[outStarts.length-2] : strLen;
						str += &#39;,\n&#39; + mkSpacePad( indentLen + inset );
					} else {
						str += IPAD;
					}
				} else {
					str += hasComplex( item ) ? rptType( item ) : fmt_parm( item, 0 );
					str += index &lt; len - 1 ? &#39;, &#39; : IPAD;
				}
				index++;
			}
		}
		if( recursable &amp;&amp; index ) outStarts.pop();
		return str + (isArray ? &#39;]&#39; : &#39;}&#39;);
	}

	var outStarts = [];	// stack of running total of recursed insets
	var parents = [];	// check parm not in parents to avoid endless recursion
	function fmt_parm( parm, recurse ) {
		if( parents.indexOf( parm ) &lt; 0 ) {
			parents.push( parm );
		} else  {
			return parm;
		}
		var type = typeof parm;
		var str = &#39;&#39;;
		if( parm === null ) {
			str += &#39;null&#39;;
		} else if( type === &#39;undefined&#39; ) {
			str += &#39;undefined&#39;;
		} else if( type === &#39;string&#39; ) {
			str += trim_str( parm );
		} else if( type === &#39;boolean&#39; ) {
			str += (parm ? &#39;true&#39; : &#39;false&#39;);
		} else if( type === &#39;function&#39; ) {
			str += &#39;function &#39; + parm.name + &#39;()&#39;;
		} else if( parm instanceof Script ) {
			str += &#39;[Script &quot;&#39; + parm.name + &#39;&quot; version &#39; + parm.version + &#39;]&#39;;
		} else if( parm instanceof Vector3D ) {
			str += &#39;Vector3D: (&#39; + parm.x.toFixed() + &#39;, &#39;
					+ parm.y.toFixed() + &#39;, &#39; + parm.z.toFixed() + &#39;)&#39;;
		} else if( parm instanceof Quaternion ) {
			str += &#39;Quaternion: (&#39; + parm.w.toFixed() + &#39; + &#39; + parm.x.toFixed() + &#39;idx + &#39;
					+ parm.y.toFixed() + &#39;j + &#39; + parm.z.toFixed() + &#39;k)&#39;;
		} else if( Array.isArray( parm ) ) {
			str += showComplex( parm, recurse &lt;= 1 ? 0 : recurse - 1 );
		} else if( type === &#39;object&#39; &amp;&amp; parm ) {
			str += showComplex( parm, recurse &lt;= 1 ? 0 : recurse - 1 );
		} else {
			str += rptType( parm );
		}
		parents.pop();
		return str;
	}

	var funcProps = {};
	function propsNotName( obj ) {
		if( typeof obj !== &#39;function&#39; ) return 0;	// backwards compatibity
		for( let key in funcProps ) {				// reset object
			if( funcProps.hasOwnProperty( key ) )
				delete funcProps[ key ];
		}
		for( let key in obj ) {
			if( key !== &#39;name&#39; &amp;&amp; obj.hasOwnProperty( key ) )
				funcProps[ key ] = obj[ key ];
		}
		return Object.keys( funcProps ).length;
	}

	var parmsLabel = &#39;\n    parameters: &#39;;
	var indentLen = parmsLabel.length - 1;	// -1 for \n
	var fnName = typeof functn === &#39;function&#39; ? functn.name : functn; // backwards compatibity
	var rpt, parmMax, propMax,
		bonus = Array.isArray( parms ) ? 1 : 0;			// don&#39;t count parms being an array as recursion (+ 1)
	if( Array.isArray( depth ) ) {
		parmMax = (depth.length &gt; 0 &amp;&amp; typeof depth[ 0 ] === &#39;number&#39; ? ~~(depth[ 0 ]) : 1) + bonus;
		propMax = (depth.length &gt; 1 &amp;&amp; typeof depth[ 1 ] === &#39;number&#39; ? ~~(depth[ 1 ]) : 1) + bonus;
	} else {
		parmMax = propMax = (typeof depth === &#39;number&#39; ? ~~(depth) : 1) + bonus;
	}
	if( err instanceof Error ) {
		rpt = &#39;\nfunction &#39; + fnName + &#39;() \t caught: \t&#39; + err.name + &#39;: &#39; + err.message;
	} else {		// for thrown strings (user defined errors)
		rpt = &#39;\nfunction &#39; + fnName + &#39;() \t caught: \t&#39; + err;
	}
	if( parms ) {
		rpt += parmsLabel + fmt_parm( parms, parmMax );
	}
	if( propsNotName( functn ) ) {
		parmsLabel = &#39;\n    properties: &#39;;
		indentLen = parmsLabel.length - 1;	// -1 for \n
		rpt += parmsLabel + fmt_parm( funcProps, propMax + 1 );	// + 1 as funcProps is an object
	}

	// err is the stack object with properties: message, fileName, lineNumber, stack, name
	//  - stack is a long string containing &lt;function call&gt;@&lt;filename&gt;:&lt;line #&gt; separated by
	//    &#39;\n&#39; for each call in the stack
	if( err &amp;&amp; err.stack ) {
		var lastFile, parsed, frame, fnCall, args, file, line, pad;
		var stk = err.stack.split( /[\n\r]+/ ); // split on line breaks
		for( let idx = 0, len = stk.length; idx &lt; len; idx ++ ) {
			// stack line format: fn(parms)@../AddOns/.../script.js:123
			parsed = stk[ idx ].match( /^\s*(\w+)\((.*?)\)@(.*?):(.*?)$/ );
			if( !parsed || parsed.length &lt; 5 ) break;
			[frame, fnCall, args, file, line] = parsed;
			if( file &amp;&amp; file !== lastFile ) {	// suppress repeat of same filename
				if( file.length &gt; FILE_LEN )
					file = file.slice( file.length - FILE_LEN ) + &#39;...&#39;;
				rpt += &#39;\n    file: &#39; + file;
				lastFile = file;
			}
			pad = line &lt; 10 ? &#39;   &#39; : line &lt; 100 ? &#39;  &#39; : line &lt; 1000 ? &#39; &#39; : &#39;&#39; ;
			rpt += &#39;\n        line: &#39; + pad + line + &#39;,	&#39;;
			if( fnCall.length &gt; FNAME_LEN ) fnCall = fnCall.slice(0, FNAME_LEN) + &#39;...&#39;;
			if( args.length &gt; ARGS_LEN ) args = args.slice(0, ARGS_LEN) + &#39;...&#39;;
			if( args.length ) 					// add spaces inside function&#39;s parenthices
				args = &#39; &#39; + args.replace( /,/g, &#39;, &#39; ) + &#39; &#39;;
			rpt += fnCall + &#39;(&#39; + args + &#39;)&#39;;
		}
	}
	return rpt;
}

///////////////////////////////////////////////////////////////////////////////
// station options closure ////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


this.$hudHidden = false;
this.$optionsStarted = false;
this.$Remind2Savegame = null;

/*		(function() { // station options IIFE for debugging
	player.credits += 10000;	// to buy stuff
	if( worldScripts.logevents ) {
		delete worldScripts.logevents.guiScreenChanged;
//		delete worldScripts.logevents.guiScreenWillChange;
	}
	worldScripts.telescope.$DebugMessages = false;
	worldScripts.telescope._reload_config();

})()	// */

/*		(function() { // station options IIFE for reloading new closure code
	console.clearConsole();
	var ws = worldScripts.telescope;
	var so = worldScripts.station_options;
	delete so._setInterfaces; // so closure will be re-invoked

	// so.$O_initStationOptions( ws, &#39;telescope_&#39;, ws._stnOptionsAllowed, true, ws._reloadFromStn ); // , true	, &#39;summary&#39;	, &#39;autosave&#39;
    ws._startStationOptions();

// for testing multiple oxps
//var fs = worldScripts.fps_monitor;
//so.$O_initStationOptions( fs, &#39;fps_monitor_&#39;, null, false, fs._reload_options );

	so._setInterfaces();

	// player.ship.hudHidden = false;
	so.$optionsStarted = false;

})()	// */

// ^gui screen.*?[\w\s]+(?=[\n]^[^g])
// : &#39; +  + &#39;

///
this._options_closure = function _options_closure() {
	var so = worldScripts.station_options;

var cd = worldScripts.cagsdebug; /// disable B4publish

	/*
	 *	constants
	 */
	var ARROW = &#39;  -&gt;  &#39;,			// these are for summary pages
		COMMA = &#39;,  &#39;, COLON = &#39;:&#39;;
	var PUNCTUATION = &#39;,./&lt;&gt;?;\&#39;:&quot;[]{}-=_+!@#$%^&amp;*&#39;;
	// from the wiki:
	//	 &quot;There are 21 lines available for display of the message and choices combined.
	//	  (In 1.77, this is extended to 27 lines if the player&#39;s HUD is hidden)&quot;
	// - we always hide the HUD
//	  var MAXSCREENLINES = oolite.compareVersion( &#39;1.77&#39; ) &gt; 0 ? 21 : 27; // 21 for versions &lt; 1.77
	var MAXSCREENLINES = 27; 		// 21 for versions &lt; 1.77 but we require min ver 1.79
	var MAXSCREENWIDTH = 32.04;		// in em&#39;s, max length for text, oolite is a little forgiving
	var SO_PREFIX = &#39;$O_&#39;;			// need a unique prefix for station_options

	/*
	 *	system functions
	 */
	var floor = Math.floor, pow = Math.pow, abs = Math.abs,
		strFontLen = defaultFont.measureString,
		SpaceLen = strFontLen( &#39; &#39; ),
		gameSettings = oolite.gameSettings;

	/*
	 *	oxp dependent variables from _initStationOptions
	 */
	var hostOxp, keyPrefix, optionsAllowedCallback, callPWSG,
		notifyCallback, suppressSummary;

	/*
	 *	oxp dependent variables read/derived from missiontext
	 */
	var hostVarPrefix, lowestValue, highestValue, maxPrecision,
		maxVectorLen, allow_reset, formatting,
		optionPages = {}, pageLabels = [], optionTabStops = [];

	/*
	 *	other oxp dependent variables
	 */
	var decodeExprn, decodeTerm, // oxp specific regular expressions (see initREs)
		decodeAssign, decodeFnCall;//  &quot;
	var registeredOxps = {};	// dictionary of oxp specific variables
	var optionInfo = {};		// dictionary of options for an oxp

	/*
	 *	local variables globally available (&#39;glocals&#39;)
	 */
	var changesMade = {}; 		// dictionary of pending variable changes
	var currentChoice = {};		// objects for info common to functions
	var decodedChoice = {};		// - properties include key, type, defawlt, min, max, numBits, selection, error, currently
	var missionKeys;			// oxp specific map of expansion keys, initialized with defaultMissionKeys
	var expandKeys = {};		// map of internal expansion keys used for expandText
	var validOptions = {};		// working map of available options
	// regular expressions used in more than 1 function; the rest are w/ their function
	var matchListOfStr = /[^&#39;]+(?=(?:&#39;\s*,\s*&#39;)|(?:&#39;\s*[,]?\s*$))/g;
	var matchNumbers = /([+-]?\d+[.]?\d*|\.\d+)/g;
	var ps, currentScreenIdx;

	/*
	 *	objects
	 */
	var defaultMissionKeys = {
		stn_optns_clockString: &#39;&#39;,
		stn_optns_curr_system: &#39;&#39;,
		stn_optns_buttons: {},
		// the rest are oxp dependent
		stn_optns_page: &#39;&#39;,
		stn_optns_page_num: 0,
		stn_optns_next_page_num: 0,
		stn_optns_page_count: 0,
		stn_optns_option: null,
		stn_optns_changes_count: 0,
		stn_optns_changed: {},
		// : , : , : , : , : , :
	};
///?replace all changesMade w/ missionKeys.stn_optns_changed
/// - only a single store of changes
/// - allows oxp to alter

	var infoTemplate = {
		option: null,			// text of option name
		optionStr: null,		// option display text; same as .option if rename (&#39;=&#39;) not used
		optionLen: 0,			// defaultFont measure of option name
		page: null,				// name of page option (currently) resides on
		type: null,				// one of text, toggle, number, decimal, vector, bitflags, choice
		selection: null,		// for types bitflags, choice
		numBits: null,			// for type bitflags
		allBits: null,			// for type bitflags
		// these next 3 may not be specified
		defawlt: null,			// default value
		min: null,				// range for types number, decimal, bitflags, choice &amp; vector
		max: null,				// range for types number, decimal, bitflags, choice &amp; vector
		isConditional: false,	// does option have a _condition in plist
		isSuppressed: false,	// current state if is conditional on other options
		condition: null,		// text of any _condition (if no substitutions)
		controls: null,			// list of options that depend on this ones value
		relyOnOptions: null,	// list of options this one relies on
		relyOnHostVars: null,	// list of hostVars this one relies on
		hasAssign: false,		// does option have a _assign in plist
		assign: null,			// text of any _assign (if no substitutions)
		hasExecute: false,		// does option have a _execute in plist
		execute: null,			// text of any _assign (if no substitutions)
		currently: null,		// current value of the option
	};

	///////////////////////////////////////////////////////////////////////////////
	// exposed functions //////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////

// : &#39; +  + &#39;
	function _getReminder4Oxp( prefix ) {
		if( !registeredOxps.hasOwnProperty( prefix ) ) {
			log( so.name, _notRegisteredMsg( _getReminder4Oxp, prefix ) );
		} else {										// return a copy
			return getObject( getRemindObj( prefix ) );
		}
	}

	function _notRegisteredMsg( caller, prefix ) {
		var msg = (typeof caller === &#39;function&#39; ? caller.name : caller);
		if( !prefix ) {
			msg += &#39;, missing or invalid prefix in function call: &#39; + prefix;
		} else {
			msg += &#39;, the host oxp &quot;&#39; + prefix
				+ &#39;&quot; must register before using this function&#39;;
		}
		return msg;
	}

	function _setAllowedCallback( prefix, newFunc ) {
		if( !registeredOxps.hasOwnProperty( prefix ) ) {
			log( so.name, _notRegisteredMsg( _setAllowedCallback, prefix ) );
		} else {
			registeredOxps[ prefix ].optionsAllowedCallback = newFunc;
			if( so.$optionsStarted &amp;&amp; prefix === keyPrefix ) {
				// set glocal if oxp&#39;s instance is running
				optionsAllowedCallback = newFunc;
			}
		}
	}

	function _getAllowedCallback( prefix ) {
		if( !registeredOxps.hasOwnProperty( prefix ) ) {
			log( so.name, _notRegisteredMsg( _getAllowedCallback, prefix ) );
		} else {
			return registeredOxps[ prefix ].optionsAllowedCallback;
		}
	}

	function _setCallPWSG( prefix, newBool ) {
		if( !registeredOxps.hasOwnProperty( prefix ) ) {
			log( so.name, _notRegisteredMsg( _setCallPWSG, prefix ) );
		} else {
			registeredOxps[ prefix ].callPWSG = newBool;
			if( so.$optionsStarted &amp;&amp; prefix === keyPrefix ) {
				// set glocal if oxp&#39;s instance is running
				callPWSG = newBool;
			}
		}
	}

	function _getCallPWSG( prefix ) {
		if( !registeredOxps.hasOwnProperty( prefix ) ) {
			log( so.name, _notRegisteredMsg( _getCallPWSG, prefix ) );
		} else {
			return registeredOxps[ prefix ].callPWSG;
		}
	}

	function _setNotifyCallback( prefix, newFunc ) {
		if( !registeredOxps.hasOwnProperty( prefix ) ) {
			log( so.name, _notRegisteredMsg( _setNotifyCallback, prefix ) );
		} else {
			registeredOxps[ prefix ].notifyCallback = newFunc;
			if( so.$optionsStarted &amp;&amp; prefix === keyPrefix ) {
				// set glocal if oxp&#39;s instance is running
				notifyCallback = newFunc;
			}
		}
	}

	function _getNotifyCallback( prefix ) {
		if( !registeredOxps.hasOwnProperty( prefix ) ) {
			log( so.name, _notRegisteredMsg( _getNotifyCallback, prefix ) );
		} else {
			return registeredOxps[ prefix ].notifyCallback;
		}
	}

	function _setSuppressSummary( prefix, newBool ) {
		if( !registeredOxps.hasOwnProperty( prefix ) ) {
			log( so.name, _notRegisteredMsg( _setSuppressSummary, prefix ) );
		} else {
			registeredOxps[ prefix ].suppressSummary = newBool;
			if( so.$optionsStarted &amp;&amp; prefix === keyPrefix ) {
				// set glocal if oxp&#39;s instance is running
				suppressSummary = newBool;
			}
		}
	}

	function _getSuppressSummary( prefix ) {
		if( !registeredOxps.hasOwnProperty( prefix ) ) {
			log( so.name, _notRegisteredMsg( _getSuppressSummary, prefix ) );
		} else {
			return registeredOxps[ prefix ].suppressSummary;
		}
	}

	// create a NEW set of missionKeys by combining newKeys
	// with defaultMissionKeys
	// - if you want to preserve existing key, use _updateMissionKeys
	function _setMissionKeys( prefix, newKeys ) {
		if( !registeredOxps.hasOwnProperty( prefix ) ) {
			log( so.name, _notRegisteredMsg( _setMissionKeys, prefix ) );
		} else {
			let reg = registeredOxps[ prefix ];
			freeObject( reg.missionKeys, true ); 		// purge the old set but not objects referenced
			let defKeys = getObject( defaultMissionKeys );// make a copy of defaultMissionKeys
			updateMissionKeys( prefix, defKeys, newKeys );// updates defKeys with newKeys
			reg.missionKeys = defKeys;
			if( so.$optionsStarted &amp;&amp; prefix === keyPrefix ) {
				// set glocal if oxp&#39;s instance is running
				missionKeys = defKeys;
			}
		}
	}

	// returns a COPY of missionKeys
	// any changes to it will have no effect until you send it back
	// using _setMissionKeys or _updateMissionKeys
	function _getMissionKeys( prefix ) {
		if( !registeredOxps.hasOwnProperty( prefix ) ) {
			log( so.name, _notRegisteredMsg( _getMissionKeys, prefix ) );
		} else {										// return a copy
			return getObject( registeredOxps[ prefix ].missionKeys );
		}
	}

	// add/updates the current missionKeys with the values in newKeys
	function _updateMissionKeys( prefix, newKeys ) {
		if( !registeredOxps.hasOwnProperty( prefix ) ) {
			log( so.name, _notRegisteredMsg( _updateMissionKeys, prefix ) );
		} else {
			updateMissionKeys( prefix, registeredOxps[ prefix ].missionKeys, newKeys );
			if( so.$optionsStarted &amp;&amp; prefix === keyPrefix ) {
				// set glocal if oxp&#39;s instance is running
				missionKeys = registeredOxps[ prefix ].missionKeys;
			}
		}
	}

	function updateMissionKeys( prefix, obj, update ) {	// also called by _registerHostOxp
		var that = updateMissionKeys;
		var defaults = (that.defaults = that.defaults || Object.keys( defaultMissionKeys ));

		var oxpsMissionKeys = registeredOxps[ prefix ].missionKeys;
		for( let key in update ) {
			if( update.hasOwnProperty( key ) ) {
				// update map preserving defaultMissionKeys
				if( defaults.indexOf( key ) &gt;= 0 &amp;&amp; update[ key ] !== oxpsMissionKeys[ key ] ) {
					log( so.name, &#39;updateMissionKeys, key &quot;&#39; + key
						+ &#39;&quot; belongs to station_options and is read-only; that update will be ignored&#39; );
				} else {
					obj[ key ] = update[ key ];
				}
			}
		}
	}


	///////////////////////////////////////////////////////////////////////////////
	// registration functions /////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////

	function _registerHostOxp( oxpRef, prefix, allowedFunc,
								doPWSG, notifyFunc, noReport, oxpKeys ) {

		function initMissionKeys( keys ) {
			var mKeys = getObject( defaultMissionKeys );// make a copy of defaultMissionKeys
			if( keys ) {
				for( let prop in keys ) {
					if( keys.hasOwnProperty( prop ) ) {
						mKeys[ prop ] = keys[ prop ];
					}
				}
			}
			return mKeys;
		}

		registerFailures.length = 0;
		_resetLocalVars();
		try{
			if( registeredOxps.hasOwnProperty( prefix ) ) {	  // already registered!
				// only happens (?) when reloading entire host script into debugger, update map
				log( so.name, &#39;_registerHostOxp, WARNING: missiontext prefix already registered: &#39; + prefix );
				registeredOxps[ prefix ].hostOxp = oxpRef;
				registeredOxps[ prefix ].optionsAllowedCallback = allowedFunc || null;
				registeredOxps[ prefix ].callPWSG = doPWSG === undefined ? false : doPWSG;
				registeredOxps[ prefix ].notifyCallback = notifyFunc || null;
				registeredOxps[ prefix ].suppressSummary = noReport === undefined ? false : noReport;
				registeredOxps[ prefix ].missionKeys = initMissionKeys( oxpKeys );
				return false;
			}
			var title, summary, category;				// options required for interface
			missionKeys = initMissionKeys( oxpKeys ); 	// needs to be set for expandText
			keyPrefix = prefix;
			title = expandText( prefix + &#39;interface_title&#39; );
			if( !title || title.length === 0 )
				registerFailures.push( prefix + &#39;interface_title&#39; );
			summary = expandText( prefix + &#39;interface_summary&#39; );
			if( !summary || summary.length === 0 )
				registerFailures.push( prefix + &#39;interface_summary&#39; );
			category = expandText( prefix + &#39;interface_category&#39; );
			if( !category || category.length === 0 )
				registerFailures.push( prefix + &#39;interface_category&#39; );
			if( registerFailures.length &gt; 0 ) {
				log( so.name, &#39;_registerHostOxp, ERROR registering &quot;&#39; + prefix
					+ &#39;&quot;, failed to expand: &#39; + registerFailures.join(&#39;, &#39;) );
				return false;
			}
			registeredOxps[ prefix ] = {
					hostOxp: oxpRef,
					optionsAllowedCallback: allowedFunc || null,
					callPWSG: doPWSG === undefined ? false : doPWSG,
					notifyCallback: notifyFunc || null,
					suppressSummary: noReport === undefined ? false : noReport,
					missionKeys: missionKeys,
					interface_title: title,
					interface_summary: summary,
					interface_category: category,
					callback: function _initOptions() { initOptions( prefix ) }
				};
			// calling to check for errors at registration, not first usage
			updatePageData( prefix, true );			// true =&gt; reportOnly
			let verdict = updateRegistry( prefix );
			_purgepools();
			return verdict;
		} catch( err ) {
			log( so.name, so._reportError( err, _registerHostOxp,
						[ oxpRef, prefix, allowedFunc,
						  doPWSG, notifyFunc, noReport, oxpKeys ] ) );
			throw err;
		}
	}

	function _resetLocalVars() {							// clear any data from previous user/session
		// values from _initStationOptions
		hostOxp = keyPrefix = optionsAllowedCallback = callPWSG = notifyCallback = suppressSummary = undefined;
		// values from missiontext
		hostVarPrefix = lowestValue = highestValue = maxPrecision = maxVectorLen = allow_reset = formatting = undefined;
		// derived values
		decodeExprn = decodeTerm = decodeAssign = decodeFnCall = undefined;
		// working objects
		clearObject( changesMade, true );				// true =&gt; keepObjects (ie. del prop only, not what it references) as sent to hostOxp
		if( missionKeys &amp;&amp; missionKeys.hasOwnProperty( &#39;stn_optns_changed&#39; ) ) {
			clearObject( missionKeys.stn_optns_changed );// clear previous changes
		}// do not clear missionKeys object as stored in registeredOxps
		clearObject( currentChoice );
		clearObject( decodedChoice );
		clearObject( expandKeys );
		clearObject( validOptions );
		clearObject( optionPages );
		clearObject( optionInfo );
		missionKeys = undefined;
		// working arrays
		allOptions.length = 0;
		pageLabels.length = 0;
		optionTabStops.length = 0;
		// local variables
		currentScreenIdx = undefined;
		ps = player &amp;&amp; player.ship;
	}

	function initOptions( prefix ) {
		if( !registeredOxps.hasOwnProperty( prefix ) ) {
			log( so.name, &#39;initOptions, missiontext prefix NOT registered: &#39; + prefix );
			return;
		}
		if( guiScreen != &quot;GUI_SCREEN_INTERFACES&quot;  ) {
			return;
		}
		_resetLocalVars();
		keyPrefix = prefix;
		// missionKeys must be initialized before any calls to expandText()
		missionKeys = registeredOxps[ prefix ].missionKeys;
		// initialize session
		so.$optionsStarted = true;
		so.$hudHidden = ps.hudHidden; 					// save HUD state
		ps.hudHidden = true;
		// from oolite JS ref: hudAllowsBigGui
		//	&quot;Whether the HUD allows a &quot;big GUI&quot; or not. Most useful for determining
		//	 whether mission screens will have 21 or 27 lines.
		//	 If hudHidden is true this will also be true, even if the HUD which is
		//	 hidden would not normally allow a big GUI.&quot;
		MAXSCREENLINES = ps.hudAllowsBigGui ? 27 : 21;
		currentChoice.option = null;
		scroller.reset();
		displayOptions();
	}

// : &#39; +  + &#39;
	var allOptions = [];
	function updatePageData( reportOnly ) {				// reportOnly used at registration to not return on errors
		hostOxp = registeredOxps[ keyPrefix ].hostOxp;
		hostVarPrefix = expandText( keyPrefix + &#39;hostVarPrefix&#39; );
		if( !hostVarPrefix || hostVarPrefix.length === 0 ) {
			registerFailures.push( keyPrefix + &#39;hostVarPrefix&#39; );
		} else {
			initREs( hostVarPrefix );
		}
		var optionPagesStr = expandText( keyPrefix + &#39;optionPages&#39; );
		if( !optionPagesStr || optionPagesStr.length === 0 ) {
			registerFailures.push( keyPrefix + &#39;optionPages&#39; );
		} else {
			let pages = optionPagesStr.match( matchListOfStr );
			if( pages === null ) {
				log(so.name, &#39;updatePageData, error parsing &quot;&#39; + keyPrefix + &#39;_optionPages&quot; key &#39;
					+ &#39;, expandText() returned &quot;&#39; + optionPagesStr + &#39;&quot;&#39; );
				if( !reportOnly )
					log(so.name, &#39;\tError is critical, aborting.&#39;);
				if( registerFailures.length )
					log(so.name, &#39;also failed to expand: &#39; + registerFailures.join(&#39;, &#39;) );
				if( !reportOnly ) {
					return false;
				}
			}
			// save page labels, as object property order is indeterminate
			pageLabels.length = 0;
			let pageCount = parsePages( pages );
			if( pageCount === 0 ) {
				log(so.name, &#39;updatePageData, for missiontext keyPrefix &quot;&#39; + keyPrefix
					+ &#39;&quot; error parsing pages: &quot;&#39; + pages + &#39;&quot;&#39; );
				if( !reportOnly )
					log(so.name, &#39;\tError is critical, aborting.&#39;);
				if( registerFailures.length )
					log(so.name, &#39;also failed to expand: &#39; + registerFailures.join(&#39;, &#39;) );
				if( !reportOnly ) {
					return false;
				}
			}
			// populate optionInfo even on registration (!reportOnly) for immediate
			// error detection ie. don&#39;t have to F4 and open page(s) to find any errors
			createOptionInfo( pages, allOptions );
		}
		return true;
	}

// : &#39; +  + &#39;
	function initREs( prefix ) {						// oxp specific re&#39;s
		// no lookbehinds in js
		var reQuoted = &quot;(?:&#39;([^&#39;\\\\]*(?:\\\\&#39;[^&#39;\\\\]*)*)&#39;)&quot;;
		// - allows escaped single quotes
		// - uses Friedl&#39;s: &quot;unrolling-the-loop&quot; technique
		//   ie. normal* (special normal*)* where special is an escaped single quote
		var reDecimal = &#39;([+-]?\\d*[.]\\d+|[+-]?\\d+[.]\\d*)&#39;;
		var reInteger = &#39;([+-]?\\d+)&#39;;
		var reVector = &#39;(\\[[^[]*\\])&#39;;
		var reOptionOrHost = &#39;[!\\s*]{0,}[&#39; + prefix + &#39;]?\\w+&#39;;
		var reOperators = &#39;([=!&lt;&gt;]+)&#39;;
		var exprnTerm = &#39;(&#39; + reQuoted + &#39;|&#39; + reVector + &#39;|&#39; + reDecimal + &#39;|&#39; + reInteger
						+ &#39;|&#39; + reOptionOrHost + &#39;)&#39;;
		decodeTerm = new RegExp( &#39;(\\s*)&#39; + exprnTerm, &#39;g&#39; );	// see createOptionInfo
		// (\s*)((?:&#39;([^&#39;\\]*(?:\\&#39;[^&#39;\\]*)*)&#39;)|(\[[^[]*\])|([+-]?\d*[.]\d+|[+-]?\d+[.]\d*)|([+-]?\d+)|[!\s*]{0,}[$]?\w+)
		/*	match indices
				[0] entire matched string
				[1] leading whitespace
				[2] the left term
				[3] unquoted version of [1] if quoted
				[4] a vector if [1] is one
				[5] a decimal if [1] is one
				[6] an integer if [1] is one
		*/
		decodeExprn = new RegExp( &#39;(?:[()\\s]*)&#39; + exprnTerm + &#39;(?:\\s*&#39; + reOperators + &#39;\\s*&#39;
									+ exprnTerm + &#39;)*(?:[()\\s]*)&#39;, &#39;g&#39; );
		// (?:[()\s]*)((?:&#39;([^&#39;\\]*(?:\\&#39;[^&#39;\\]*)*)&#39;)|(\[[^[]*\])|([+-]?\d*[.]\d+|[+-]?\d+[.]\d*)|([+-]?\d+)|[!\s*]{0,}[$]?\w+)(?:\s*([=!&lt;&gt;]+)\s*((?:&#39;([^&#39;\\]*(?:\\&#39;[^&#39;\\]*)*)&#39;)|(\[[^[]*\])|([+-]?\d*[.]\d+|[+-]?\d+[.]\d*)|([+-]?\d+)|[!\s*]{0,}[$]?\w+))*(?:[()\s]*)		// - expression can be a exprnTerm OR exprnTerm op exprnTerm
		/*	match indices
				[0] entire matched string
				[1] leading whitespace
				[2] the left term
				[3] unquoted version of [1] if quoted
				[4] a vector if [1] is one
				[5] a decimal if [1] is one
				[6] an integer if [1] is one
			NB: the rest can be undefined if there is no comparison operator
				[6] comparison operator
				[7] leading whitespace
				[8] the right term
				[9] unquoted version of [7] if quoted
			   [10] a vector if [7] is one
			   [11] a decimal if [7] is one
			   [12] an integer if [7] is one
		*/
		decodeAssign = new RegExp( &#39;\\s*([&#39; + prefix + &#39;]?\\w+)\\s*[=](?!=)\\s*([^;\\r\\n]+)(?:[;\\s]|$)*&#39;, &#39;g&#39; );
		// \s*([$]?\w+)\s*[=](?!=)\s*([^;\r\n]+)(?:[;\s]|$)*
		/*
				[0] entire matched string
				[1] assignment target (option or hostVar)
				[2] expression
		*/
		//												   NB: SO_PREFIX = &#39;$O_&#39;
		decodeFnCall = new RegExp( &#39;(\\s*)(?:(worldScripts[.]\\w+)[.](\\w+)|([$]O_\\w+)|((?:[&#39; + prefix
						+ &#39;]|[$_]+)\\w+))([(].*(?=[)][^)]*(?:;|$))[)])(\\s*)(?:[;\\s]|$)*&#39;, &#39;g&#39; );
		// (\s*)(?:(worldScripts[.]\w+)[.](\w+)|([$]O_\w+)|((?:[$]|[$_]+)\w+))([(].*(?=[)][^)]*(?:;|$))[)])(\s*)(?:[;\s]|$)*
		/*
				[0] entire matched string
				[1] leading whitespace
				[2] hostOxp name, eg. worldScripts.telescope
				[3] function name following [1]
				[4] function name of a station_options exposed function call
				[5] function name of an hostOxp function call, ie. starts with hostVarPrefix
				[6] function parameters
				[7] trailing whitespace
		*/
	}

	function parsePages( pages ) {
		var pageCount = 0;
		for( let idx = 0, len = pages.length; idx &lt; len; idx++ ) {
			let page = pages[ idx ];
			pageLabels.push( page );
			let optnStr = expandText( keyPrefix + page + &#39;_options&#39; );
			if( optnStr ) {
				pageCount++;
				let options = optnStr.match( matchListOfStr );
				if( options ) {
					parseOptionList( page, options );
				} else {
					log(so.name, &#39;parsePages, error parsing &quot;_options&quot; value: &#39; + optnStr
						+ &#39;\n  page = &#39; + page + &#39;, pageCount = &#39; + pageCount + &#39;, pageLabels = &#39; + pageLabels 
						+ &#39;\n  expandMissionText called w/ &quot;&#39; + (keyPrefix + page + &#39;_options&#39;) + &#39;&quot;&#39; );
				}
			} else {
				log(so.name, &#39;parsePages, missing &quot;_options&quot; key, page = &#39; + page
					+ &#39;, pageLabels = &#39; + pageLabels + &#39;, pageCount = &#39; + pageCount
					+ &#39;\n  expandMissionText called w/ &quot;&#39; + (keyPrefix + page + &#39;_options&#39;) + &#39;&quot;&#39; );
			}
		}
		return pageCount;
	}

	function parseOptionList( page, optionsList ) {
		var that = parseOptionList;
		var optionVars = (that.optionVars = that.optionVars || []);
		optionVars.length = 0;
		
		for( let idx = 0, len = optionsList.length; idx &lt; len; idx++ ) {
			let varName = parseOption( page, optionsList[ idx ] );
			if( varName ) 								// parseOption reports errors
				optionVars.push( varName );
		}
		if( !optionPages.hasOwnProperty( page ) ) {
			optionPages[ page ] = getArray();
		} else {
			optionPages[ page ].length = 0;
		}
		let dest = optionPages[ page ];
		dest.push.apply( dest, optionVars );
		// - this adds each element of &#39;optionVars&#39; to the &#39;dest&#39; array,
		//   vs. dest = dest.concat( optionVars );
		//   - concat returns a NEW array (more garbage)
		allOptions.push.apply( allOptions, optionVars );
	}

	function parseOption( page, option ) {
		var varName, optString;
		// remove any option strings (vs. variables) from page&#39;s &#39;_options&#39;
		if( option.indexOf( &#39;:&#39; ) &gt;= 0 ) {
			let names = option.split( &#39;:&#39; );
			if( names.length !== 2 ) {
				let msg =  &#39;parseOption, ERROR: invalid option renaming &quot;&#39; + option + &#39;&quot;&#39;;
				msg += &#39;\n    the correct format is variableName:optionName, &#39;;
				msg += &#39;\n    where optionName appears on option the pages&#39;;
				msg += &#39;\n    and worldScripts.myOxp[ hostVarPrefix + variableName ] &#39;;
				msg += &#39;\n    is assigned the value.&#39;;
				log( so.name, msg );
				return;
			}
			varName = names[ 0 ].trim();
			optString = names[ 1 ].trim();
		} else {
			optString = varName = option.trim();
		}
		if( expandText( keyPrefix + varName ) === null ) {
			log( so.name, &#39;parseOption, ERROR: missing expansion option &quot;&#39; 
				+  ( keyPrefix + varName )
				+ &#39;&quot;; should be in missiontext.plist or missionKeys&#39; );
			return;
		}
		makeInfo( page, optString, varName );
		return varName;
	}

	function makeInfo( page, optString, varName ) {
		try {
			if( expandText( keyPrefix + varName ) === null ) {
				log( so.name, &#39;makeInfo, ERROR: missing expansion option &quot;&#39; 
					+  ( keyPrefix + varName )
					+ &#39;&quot;; should be in missiontext.plist or missionKeys&#39; );
				return;
			}
			var result = getObject( infoTemplate );
			optionInfo[ varName ] = result;
			result.option = varName;
			result.optionStr = optString;
			result.optionLen = measureWord( optString );
			result.page = page;
			result.controls = getArray();
			result.relyOnOptions = getArray();
			result.relyOnHostVars = getArray();
			decodeOption( varName, result );
			result.currently = getOptionValue( varName );
		} catch( err ) {
			log( so.name, so._reportError( err, makeInfo, [page, optString, varName] ) );
			throw err;
		}
	}

	function createOptionInfo( pages, allOptions ) {

		function addToList( value, list ) {
			 if( list &amp;&amp; list.indexOf( value ) &lt; 0 ) {
				 list.push( value );
			 }
		}

		function addToValueList( option, value, info, isHostVar ) {
			if( isHostVar ) {
				addToList( value, info.relyOnHostVars );
			} else {
				addToList( value, info.relyOnOptions );
				addToList( option, optionInfo[ value ].controls );
				// - option that dictates whether other options are shown
			}
		}

		try{
			refreshSOKeys();
			var foundOne, value, matchStr, leadWS, term, unQuoted, aVector, aDecimal, anInt;
			// scan &#39;_condition&#39; for options &amp; hostVars
			for( let idx = 0, len = pages.length; idx &lt; len; idx++ ) {
				let ignore, nextTerm, page = pages[ idx ];
				let options = optionPages[ page ];
				for( let opt = 0, optLen = options.length; opt &lt; optLen; opt++ ) {
					let option = options[ opt ];
					let info = optionInfo[ option ];
					let condition = expandText( keyPrefix + option + &#39;_condition&#39; );
					if( condition === null )
						continue;
					info.isConditional = true;
					foundOne = false;
					decodeTerm.lastIndex = 0;			// reset re&#39;s .lastIndex as it doesn&#39;t reset on a new string!!!!
					while( true ) {
						nextTerm = decodeTerm.exec( condition );
/* debugging regex
if( nextTerm !== null ) {
	log(&#39;\n match found using \n&#39; + decodeTerm + &#39;\n  upon \n&#39; + condition + &#39;\nnextTerm:\n&#39; );
	let mNames = [ &#39;matchStr&#39;, &#39;leading&#39;, &#39;term&#39;, &#39;unQuoted&#39;, &#39;aVector&#39;, &#39;aDecimal&#39;, &#39;anInt&#39;,
				  &#39;operator&#39;, &#39;leading&#39;, &#39;rHandSide&#39;, &#39;rUnQuoted&#39;, &#39;rVector&#39;, &#39;rDecimal&#39;, &#39;rInteger&#39; ]
	for( let x = 0, len = nextTerm.length; x &lt; len; x++ ) {
		log(mNames[x] + &#39;\t\t&#39; + (x &lt; 10 ? &#39; &#39; + x : x) + &#39;: &#39; + nextTerm[x] );
	}
}
*/
						if( nextTerm === null ) {
							if( foundOne )
								break;
							throw( &#39;createOptionInfo, &quot;&#39; + option + &#39;&quot;, decodeTerm cannot decode condition \n\t&quot;&#39;
										+ condition + &#39;&quot;\n\tusing: \n\t&#39; + decodeTerm );
						}
						[ matchStr, leadWS, term, unQuoted, aVector, aDecimal, anInt ] = nextTerm;
						if( term.length &gt; 0 ) {
							[ value, ignore ] = splitExclamations( term );
						} else {
							throw( &#39;createOptionInfo, decodeTerm match produced empty capture: &#39; + nextTerm );
						}
						freeArray( nextTerm );
						let isHostVar = startsWith( value, hostVarPrefix ),
							isOption = allOptions.indexOf( value ) &gt;= 0;
						if( !isHostVar &amp;&amp; !isOption )  // ignore true, false, null, etc
							continue;
						foundOne = true;
						addToValueList( option, value, info, isHostVar );
					}
				}
			}
/// _showProps( obj, objName, newLine, show_deep, expand_arrays, show_type )
// log(&#39;createOptionInfo, exit&#39; + cd._showProps(optionInfo, &#39;optionInfo&#39;, 1,2,1));
		} catch( err ) {
			log( so.name, so._reportError(err, createOptionInfo, [pages, allOptions]));
			throw err;
		}
	}

// : &#39; +  + &#39;
	var registerFailures = [];
	function updateRegistry( prefix ) {					// called upon activation of Interface (F4) screen
		// had to split into 2 parts as refreshSOKeys() must precede this but follow updatePageData()
		registerFailures.length = 0;

		if( !registeredOxps.hasOwnProperty( prefix ) ) {
			log( so.name,
				&#39;updateRegistry, missiontext prefix NOT registered: &quot;&#39; + prefix  + &#39;&quot;&#39; );
			return false;
		}
		var host = registeredOxps[ prefix ];
		hostOxp = host.hostOxp;
		// these are alterable vis exposed functions, so registeredOxps is up to date
		optionsAllowedCallback = host.optionsAllowedCallback;
		callPWSG = host.callPWSG;
		notifyCallback = host.notifyCallback;
		suppressSummary = host.suppressSummary;
		// missionKeys set in initOptions

		// as all missiontext keys may be overridden, update related effects
		// (hostVarPrefix is in updatePageData())
		lowestValue = expandText( prefix + &#39;lowestValue&#39; );	// is optional, no failure msg
		if( !lowestValue || lowestValue.length === 0 ) {
			lowestValue = null;							// value when turned off or not present
		}
		highestValue = expandText( prefix + &#39;highestValue&#39; );	// is optional, no failure msg
		if( !highestValue || highestValue.length === 0 ) {
			highestValue = null;						// value when turned off or not present
		}
		maxPrecision = expandText( prefix + &#39;maxPrecision&#39; );
		if( !maxPrecision || maxPrecision.length === 0 ) {
			maxPrecision = 0;							// default value, no failure msg
		}
		maxVectorLen = expandText( prefix + &#39;maxVectorLen&#39; );
		if( !maxVectorLen || maxVectorLen.length === 0 ) {
			maxVectorLen = 0;							// default value, no failure msg
		}
		allow_reset = expandText( prefix + &#39;allow_reset_of_page&#39; );
		if( !allow_reset || allow_reset.length === 0 ) {
			allow_reset = false;						// default value, no failure msg
		} else {
			allow_reset = allow_reset === &#39;yes&#39; || allow_reset === &#39;true&#39; ? true : false;
		}
		formatting = expandText( prefix + &#39;formatting_of_page&#39; );
		if( !formatting || formatting.length === 0 ) {
			formatting = false;							// default value, no failure msg
		} else {
			formatting = formatting === &#39;yes&#39; || formatting === &#39;true&#39; ? true : false;
		}

		let tabStopsStr = expandText( prefix + &#39;optionTabStops&#39; );
		if( !tabStopsStr || tabStopsStr.length === 0 ) {
			registerFailures.push( prefix + &#39;optionTabStops&#39; );
		} else {
			optionTabStops.length = 0;
			if( !parseTabStops( tabStopsStr ) )
				registerFailures.push( prefix + &#39;optionTabStops&#39; );
		}

		let interfaceChanged = false;
		let title = checkOverride( prefix, &#39;interface_title&#39; );
		if( !title || title.length === 0 ) {
			registerFailures.push( prefix + &#39;interface_title&#39; );
		} else {
			interfaceChanged = interfaceChanged || title !== host.title;
			host.title = title;
		}
		let summary = checkOverride( prefix, &#39;interface_summary&#39; );
		if( !summary || summary.length === 0 ) {
			registerFailures.push( prefix + &#39;interface_summary&#39; );
		} else {
			interfaceChanged = interfaceChanged || summary !== host.summary;
			host.summary = summary;
		}
		let category = checkOverride( prefix, &#39;interface_category&#39; );
		if( !category || category.length === 0 ) {
			registerFailures.push( prefix + &#39;interface_category&#39; );
		} else {
			interfaceChanged = interfaceChanged || category !== host.category;
			host.category = category;
		}
		if( interfaceChanged ) {
			setOneInterface( prefix );
		}

		if( registerFailures.length ) {
			log( so.name, &#39;updateRegistry, failed to expand: &#39; + registerFailures.join(&#39;, &#39;) );
			return false;
		}
		return true;
	}

	var splitTabStops = /[^{]*[{]\s*([^}]*)\s*[}]\s*[,]?\s*/g;
	function parseTabStops( tabStops ) {
		var tabStopList = tabStops.split( splitTabStops );
		if( tabStopList ) {
			for( let idx = 0, len = tabStopList.length || 0; idx &lt; len; idx++ ) {
				let tabs = tabStopList[ idx ];
				if( !tabs || tabs.length === 0 )
					continue;
				let lst = tabs.match( matchNumbers );
				if( lst ) {
					let lastNum = 0, result = getArray();
					for( let lx = 0, len = lst.length; lx &lt; len; lx++ ) {
						let curr = parseFloat( lst[ lx ] );
						if( curr &lt; 0 || (lastNum &gt; 0 &amp;&amp; curr &lt;= lastNum) ) { // allow first to be zero
							let repl = lastNum + 0.1;
							log(so.name, &#39;parseTabStops, bad tab value &quot;&#39; + curr + &#39;&quot; &lt;= &quot;&#39;
								+ lastNum + &#39;&quot; (previous), using &quot;&#39; + repl );
							log(so.name, &#39;                (tabs must be increasing in value)&#39; );
							curr = repl;
						}
						result.push( curr );
						lastNum = curr;
					}
					optionTabStops.push( result );
				} else {
					log(so.name, &#39;parseTabStops, invalid numbers in &quot;_optionTabStops&quot; key&#39;
						+ &#39;, tabs = &#39; + tabs
						+ &#39;, expandMissionText called w/ &quot;&#39; + (keyPrefix + &#39;optionTabStops&#39;) + &#39;&quot;&#39; );
					return false;
				}
			}
		} else {
			log(so.name, &#39;parseTabStops, error parsing  &quot;_optionTabStops&quot; key&#39;
				+ &#39;, tabStops = &#39; + tabStops
				+ &#39;, expandMissionText called w/ &quot;&#39; + (keyPrefix + &#39;optionTabStops&#39;) + &#39;&quot;&#39; );
			return false;
		}
		return true;
	}

	function expandText( textKey, keys ) {
		var that = expandText;
		var merged = (that.merged = that.merged || {});	// working map assembled for each text expansion

		if( !textKey || textKey.length === 0 )
			return null;								// expandMissionText returns null if textKey not present

		var keyMap = missionKeys,
			result = null;								// expandMissionText returns null if textKey not present
		if( keys ) {									// create merger of default and oxp supplied keys
			clearObject( merged, true );				// true =&gt; keepObjects (ie. del prop only, not what it references)
			for( let prop in missionKeys ) {
				if( missionKeys.hasOwnProperty( prop ) ) {
					merged[ prop ] = missionKeys[ prop ];
				}
			}
			for( let prop in keys ) {
				if( keys.hasOwnProperty( prop ) ) {
					merged[ prop ] = keys[ prop ];
				}
			}
			keyMap = merged;
		}

		// missionKeys override; if the key is an empty string, it&#39;s treated
		// as if it was deleted
		var inMissionKeys = missionKeys !== undefined &amp;&amp; missionKeys.hasOwnProperty( textKey )
										&amp;&amp; missionKeys[ textKey ].length &gt; 0;
		if( inMissionKeys ) {
			/// need &#39; || {}&#39; else Oolite crashes
			result = expandDescription( missionKeys[ textKey ], keyMap || {} );
		} else {
			/// need &#39; || {}&#39; else Oolite crashes
			result = expandMissionText( textKey, keyMap || {} );
		}
		return result;
	}

	function checkOverride( prefix, prop ) {
		// values from missiontext can be overridden using missionKeys
		// while those passed at registration are altered via the exposed
		// functions (ie. the registeredOxps[ prefix ].prop value is always current)
		// - the two sets of values may overlap (eg. interface_title)
		var result = null, 
			host = registeredOxps[ prefix ],
			mKey = prefix + prop,
			check = expandText( mKey );					// respects missionKeys
		if( check !== null ) {
			result = check;
		} else if( host.hasOwnProperty( prop ) ) {
			result = host[ prop ];
		}
		if( missionKeys.hasOwnProperty( mKey ) &amp;&amp; check === null ) {
			let msg = &#39;checkOverride, missionKeys override &quot;&#39; + mKey + &#39;&quot;:\n\t&#39;;
			msg += missionKeys[ mKey ] + &#39;\n\texpansion failed&#39;;
			if( result ) {
				msg += &#39;, reverting to registered value &quot;&#39; + result + &#39;&quot;&#39;;
			} else {
				msg += &#39;, using default (if it exists) otherwise null&#39;;
			}
			log( so.name, msg );
		}
		return result;
	}

// : &#39; +  + &#39;
	function refreshSOKeys( soKeys ) {
		// called from createOptionInfo, initOptions, nextOptionsPage, processChoice, setChoice, setOptionValue
		var that = refreshSOKeys;
		var mkKeyProps = (that.mkKeyProps = that.mkKeyProps || []);
		mkKeyProps.length = 0;
		
		function refreshSOPageKeys( index ) {
			var numPages = pageLabels.length;
			missionKeys.stn_optns_page_count = numPages;
			if( numPages &gt; 0 &amp;&amp; index &gt;= 0 &amp;&amp; index &lt; numPages) {
				missionKeys.stn_optns_page = pageLabels[ index ];
				missionKeys.stn_optns_page_num = index + 1;
				missionKeys.stn_optns_next_page_num = (( index + 1 ) % ( numPages || 1 )) + 1;
			} else {
				missionKeys.stn_optns_page = &#39;&#39;;
				missionKeys.stn_optns_page_num = 0;
				missionKeys.stn_optns_next_page_num = 0;
			}
		}

		if( missionKeys === undefined ) {
			log(&#39;refreshSOKeys, ERROR: missionKeys === undefined&#39; );
			return;
		}
		missionKeys.stn_optns_clockString = clock.clockStringForTime( clock.adjustedSeconds );
		missionKeys.stn_optns_curr_system = system.name;
		// the rest are oxp dependent
		if( soKeys &amp;&amp; soKeys.hasOwnProperty( &#39;index&#39; ) ) {
			refreshSOPageKeys( soKeys.index );
		} else if( pageLabels.length &gt; 0 &amp;&amp; currentScreenIdx &lt; pageLabels.length ) {
			refreshSOPageKeys( currentScreenIdx );
		} else {
			refreshSOPageKeys( 0 );
		}
		// missionKeys.stn_optns_option = ??? - handled in processChoice
		missionKeys.stn_optns_changes_count = changesMade.hasOwnProperty( &#39;stnOptsPending&#39; )
												? changesMade.stnOptsPending : 0;
	}

	///////////////////////////////////////////////////////////////////////////////
	// formatting functions ///////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////

	function splitExclamations( term ) {
		var count = 0;
		if( term[ 0 ] === &#39;!&#39; ) {
			// count &amp; strip all leading exclamation marks
			let idx, len;
			for( idx = 0, len = term.length; idx &lt; len; idx++ ) {
				let it = term[ idx ];
				if( it === &#39;!&#39; ) {
					count++;
				} else if( it !== &#39; &#39; &amp;&amp; it !== &#39;\t&#39; ) {
					break;
				}
			}
			term = term.slice( idx );
		}
		return [ term, count ];
	}

	function startsWith( term, prefix ) { 				// String.startsWith not in our JS
		return term.slice( 0, prefix.length ) === prefix;
	}

	function endsWith( term, suffix ) { 				// String.endsWith not in our JS
		return term.slice( -suffix.length ) === suffix;
	}

	function setOneInterface( prefix ) {
		var that = setOneInterface;
		var interfaceDefn = (that.interfaceDefn = that.interfaceDefn || {});
		clearObject( interfaceDefn );

		if( !registeredOxps.hasOwnProperty( prefix ) ) {
			log( so.name, &#39;setOneInterface, missing for prefix &quot;&#39; + prefix + &#39;&quot;, aborting&#39; );
			return;
		}
		var host = registeredOxps[ prefix ];
		var checkPermission = host.optionsAllowedCallback;
		var allowed = checkPermission &amp;&amp; typeof checkPermission === &#39;function&#39;
					  ? checkPermission() : true;
		if( allowed ) {									// turn it on in F4 screen
			interfaceDefn.title = host.interface_title;
			interfaceDefn.summary = host.interface_summary;
			interfaceDefn.category = host.interface_category;
			interfaceDefn.callback = host.callback.bind( so );
			if( ps.dockedStation )						// is null when reloading via console &amp; not docked!
				ps.dockedStation.setInterface( prefix, interfaceDefn );
		} else {										// ensures it&#39;s off
			if( ps.dockedStation )
				ps.dockedStation.setInterface( prefix, null );
		}
	}

	function _setInterfaces() {							// called from equipmentAdded, equipmentAdded, shipDockedWithStation, etc.,
														//   to start up interface(s)
		ps = player &amp;&amp; player.ship;
		for( var prefix in registeredOxps ) {			// set/clear interface based on callback
			if( registeredOxps.hasOwnProperty( prefix ) ) {
				setOneInterface( prefix );
			} else {
				log( so.name, &#39;_setInterfaces, missing  for prefix &quot;&#39; + prefix + &#39;&quot;, skipping&#39; );
			}
		}
	}

	function nextOptionsPage() { 						// find next array of options using currentScreenIdx
		var that = nextOptionsPage;
		var soKeys = (that.soKeys = that.soKeys || {});
		clearObject( soKeys );

		var numPages = pageLabels.length;
		currentScreenIdx = ( currentScreenIdx + 1 ) % numPages;
		soKeys.index = currentScreenIdx;
		refreshSOKeys( soKeys );
		// check range in case pageLabels was changed
		return currentScreenIdx &gt;= 0 &amp;&amp; currentScreenIdx &lt; numPages
				? pageLabels[ currentScreenIdx ] : null;
	}

// : &#39; +  + &#39;
	function displayOptions( via ) { 					// optional &#39;via&#39; for choice that got us here
		var that = displayOptions;
		var screen = (that.screen = that.screen || {}); // re-used for runScreen; kept local to fn as static keys retained
		var summary, screenLines;

		// moved from initOptions to allow dynamic pages
		if( !updatePageData() )
			return;
		if( currentScreenIdx === undefined )			// got here via initOptions
			currentScreenIdx = 0;
		refreshSOKeys();	/// relies on pageLabels, which is set in updatePageData
		if( !updateRegistry( keyPrefix ) )
			return;

		var currentScreen = pageLabels[ currentScreenIdx ];
		if( !screen.hasOwnProperty( &#39;exitScreen&#39; ) ) { 	// 1st time through; this part is static
			screen.exitScreen = &#39;GUI_SCREEN_INTERFACES&#39;;
			screen.allowInterrupt = true;
			screen.textEntry = false;
		}
		screen.screenID = &#39;stn_optns_displayOptions_&#39; + keyPrefix + currentScreen + &#39;_page&#39;;
		screen.titleKey = keyPrefix + currentScreen + &#39;_title&#39;;
		summary = expandText( keyPrefix + currentScreen + &#39;_summary&#39; );
		if( !summary ) {
			log( so.name, so._reportError(&#39;missing or invalid &quot;&#39; + keyPrefix + currentScreen
				+ &#39;_summary&quot; in missiontext.plist&#39;));
			return
		}
		let lines = measureText( currentScreen + &#39;_summary&#39;, summary );
		if( formatting ) {
			formattedPage.length = 0;
			let textInfo = textIndices[ keyPrefix ][ currentScreen + &#39;_summary&#39; ];
			formatEols( summary, textInfo, 0, lines );
			screen.message = formattedPage.join( &#39;\n&#39; );
		} else {
			screen.message = summary;
		}
		screenLines = MAXSCREENLINES - lines;  			// # lines left after summary
		screen.allowInterrupt = changesMade.cag$stnOptsPending === 0;
		screen.choices = buildOptions( screenLines, screen, via );
		mission.runScreen( screen, processChoice.bind( so ) );
	}

	// buttons shared by options list and sub-pages
	// - the last button on sub-pages, &quot;Return to ...&quot;, is dynamic and always recycled
	var blankLine, scrollButton, scrollTopButton, nextPgButton,
		saveButton, abortButton, exitButton, saveEditButton, resetButton;

	function initButtons() {							// buttons for options list and sub-pages
		var alignment = expandText( &#39;stn_optns_button_alignment&#39; );
		var defaultColor = expandText( &#39;stn_optns_default_color&#39; );

		if( blankLine === undefined ) {
			blankLine = getChoice( &#39;&#39; );
		}
		if( scrollButton  === undefined ) {
			scrollButton = getChoice( expandText( &#39;stn_optns_scroll_down&#39; ) );
			missionKeys.stn_optns_buttons[ &#39;stn_optns_scroll_down&#39; ] = scrollButton;
		} else {
			scrollButton.text = expandText( &#39;stn_optns_scroll_down&#39; );
			scrollButton.color = expandText( &#39;stn_optns_scroll_down_button_color&#39; ) || defaultColor;
			scrollButton.alignment = alignment;
			scrollButton.unselectable = false;
		}
		if( scrollTopButton === undefined ) {
			scrollTopButton = getChoice( expandText( &#39;stn_optns_scroll_top&#39; ) );
			missionKeys.stn_optns_buttons[ &#39;stn_optns_scroll_top&#39; ] = scrollTopButton;
		} else {
			scrollTopButton.text = expandText( &#39;stn_optns_scroll_top&#39; );
			scrollTopButton.color = expandText( &#39;stn_optns_scroll_top_button_color&#39; ) || defaultColor;
			scrollTopButton.alignment = alignment;
			scrollTopButton.unselectable = false;
		}
		if( nextPgButton === undefined ) {
			nextPgButton = getChoice( expandText( &#39;stn_optns_list_next_page&#39; ) );
			missionKeys.stn_optns_buttons[ &#39;stn_optns_list_next_page&#39; ] = nextPgButton;
		} else {
			nextPgButton.text = expandText( &#39;stn_optns_list_next_page&#39; );
			nextPgButton.color = expandText( &#39;stn_optns_list_next_page_button_color&#39; ) || defaultColor;
			nextPgButton.alignment = alignment;
			nextPgButton.unselectable = false;
		}
		if( saveButton === undefined ) {
			saveButton = getChoice( expandText( &#39;stn_optns_list_save&#39; ) );
			missionKeys.stn_optns_buttons[ &#39;stn_optns_list_save&#39; ] = saveButton;
		} else {
			saveButton.text = expandText( &#39;stn_optns_list_save&#39; );
			saveButton.color = expandText( &#39;stn_optns_list_save_button_color&#39; ) || defaultColor;
			saveButton.alignment = alignment;
			saveButton.unselectable = false;
		}
		if( abortButton === undefined ) {
			abortButton = getChoice( expandText( &#39;stn_optns_list_abort&#39; ) );
			missionKeys.stn_optns_buttons[ &#39;stn_optns_list_abort&#39; ] = abortButton;
		} else {
			abortButton.text = expandText( &#39;stn_optns_list_abort&#39; );
			abortButton.color = expandText( &#39;stn_optns_list_abort_button_color&#39; ) || defaultColor;
			abortButton.alignment = alignment;
			abortButton.unselectable = false;
		}
		if( exitButton === undefined ) {
			exitButton = getChoice( expandText( &#39;stn_optns_list_exit&#39; ) );
			missionKeys.stn_optns_buttons[ &#39;stn_optns_list_exit&#39; ] = exitButton;
		} else {
			exitButton.text = expandText( &#39;stn_optns_list_exit&#39; );
			exitButton.color = expandText( &#39;stn_optns_list_exit_button_color&#39; ) || defaultColor;
			exitButton.alignment = alignment;
			exitButton.unselectable = false;
		}
		if( saveEditButton === undefined ) {
			saveEditButton = getChoice( expandText( &#39;stn_optns_option_save&#39; ) );
			missionKeys.stn_optns_buttons[ &#39;stn_optns_option_save&#39; ] = saveEditButton;
		} else {
			saveEditButton.text = expandText( &#39;stn_optns_option_save&#39; );
			saveEditButton.color = expandText( &#39;stn_optns_option_save_button_color&#39; ) || defaultColor;
			saveEditButton.alignment = alignment;
			saveEditButton.unselectable = false;
		}
		if( resetButton === undefined ) {
			resetButton = getChoice( expandText( &#39;stn_optns_option_reset&#39; ) );
			missionKeys.stn_optns_buttons[ &#39;stn_optns_option_reset&#39; ] = resetButton;
		} else {
			resetButton.text = expandText( &#39;stn_optns_option_reset&#39; );
			resetButton.color = expandText( &#39;stn_optns_option_reset_button_color&#39; ) || defaultColor;
			resetButton.alignment = alignment;
			resetButton.unselectable = false;
		}
	}

	function isCommonButton( key ) { 					// check for static buttons
		do {
			if( key === &#39;UU_blank&#39; )	break;			// blank line for spacing
			if( key === &#39;XX_reset&#39; )	break;			// &#39;Reset to factory default&#39;
			if( key === &#39;YY_save&#39; )		break;			// &#39;Apply changes and exit&#39;, color get toggled
			if( key === &#39;ZZ_abort&#39; )	break;			// top level only, &#39;Exit discarding changes&#39;
			if( key === &#39;ZZ_exit&#39; )		break;			// top level only, &#39;Exit (no changes)&#39;
			if( key === &#39;WW_next_pg&#39; )	break;			// top level only, &#39;Switch to next page&#39;
			if( key === &#39;ZZ_return&#39; )	return false;	// specific to sub-page, so always recycled
			// not testing &#39;VV_more&#39; (top level only) or &#39;ZZ_more&#39; (sub-page only) as require different handling
			return false;
		} while( false );
		return true;
	}

	function buildOptions( screenLines, screen, via ) {
		try {
			var that = buildOptions;
			var choices = (that.choices = that.choices || null); // re-used for runScreen; kept local to fn as static keys retained
			var optionRows = (that.optionRows = that.optionRows || {});
			var lastStart = that.lastStart || 0;		// index of starting option on page just displayed
			var lastEnd = that.lastEnd || 0;			// index of last option showing on page just displayed
			var lastValid = that.lastValid || 0;		// number of valid options on page just displayed
			var lastHost = that.lastHost || null;
			if( via === &#39;WW_next_pg&#39; || via === &#39;XX_reset&#39; || currentChoice.option === null ) {
				that.lastStart = that.lastEnd = that.lastValid = 0;
			}

			var currentScreen = pageLabels[ currentScreenIdx ],
				options = optionPages[ currentScreen ],
				start, end, tabs, option,
				lastValidKey, lastValidShowing = false,
				len = options.length, numValid = 0,
				lines = screenLines - 1;				// # lines for list (-1 for blank line before list)
			var haveChanges = changesMade.hasOwnProperty( &#39;cag$stnOptsPending&#39; );

			initButtons();
			if( !choices ) {							// first time, create static choices
				blankLine.unselectable = true;
				choices = that.choices = getObject();
				choices[ &#39;UU_blank&#39; ] = blankLine;
				choices[ &#39;YY_save&#39; ] = saveButton;
				choices[ &#39;ZZ_exit&#39; ] = exitButton;
				lines -= 3;
			} else {
				for( var x in choices ) {				// re-use objects
					if( choices.hasOwnProperty( x ) ) {
						if( isCommonButton( x ) ) {		// keep, are static
							lines--;
						} else if( x === &#39;VV_more&#39; ) {	// just delete the reference
							delete choices[ x ];
						} else {
							freeChoice( choices[ x ] );
							delete choices[ x ];
						}
					}
				}
			}

			if( !lastHost || lastHost !== keyPrefix ) { // being run by a different oxp
				let hasReset = choices.hasOwnProperty( &#39;XX_reset&#39; );
				if( allow_reset &amp;&amp; !hasReset ) {
					choices[ &#39;XX_reset&#39; ] = resetButton;
					lines--;
				} else if( !allow_reset &amp;&amp; hasReset ) {
					delete choices[ &#39;XX_reset&#39; ];
					lines++;
				}
				let hasNextPg = choices.hasOwnProperty( &#39;WW_next_pg&#39; );
				if( pageLabels.length &gt; 1 &amp;&amp; !hasNextPg ) {
					choices[ &#39;WW_next_pg&#39; ] = nextPgButton;
					lines--;
				} else if( pageLabels.length === 1 &amp;&amp; hasNextPg ) {
					delete choices[ &#39;WW_next_pg&#39; ];
					lines++;
				}
				that.lastHost = keyPrefix;				// so we only do this once, not every call
			}

			if( haveChanges ) { 						// changes have been made
				delete choices[ &#39;ZZ_exit&#39; ];
				choices[ &#39;ZZ_abort&#39; ] = abortButton;
				saveButton.color = expandText( &#39;stn_optns_default_color&#39; ) || &#39;yellowColor&#39;;
				saveButton.unselectable = false;
			} else {
				delete choices[ &#39;ZZ_abort&#39; ];
				choices[ &#39;ZZ_exit&#39; ] = exitButton;
				saveButton.color = expandText( &#39;stn_optns_notInUse_color&#39; ) || &#39;darkGrayColor&#39;;
				saveButton.unselectable = true;
			}

			tabs = currentScreenIdx &gt;= optionTabStops.length
					? null : optionTabStops[ currentScreenIdx ];
			// insert ALL valid options into &#39;validOptions&#39;
			lastValidKey = formatOptions( tabs );
			numValid = Object.keys( validOptions ).length;
			if( numValid &gt; lines ) {
				lines--;	 							// for &#39;more&#39; button
			}

			start = lastStart;							// guess page didn&#39;t shift
			end = lastEnd &gt; 0 ? lastEnd
							  : lastStart + lines - 1;	// -1 so last option starts next page
			let initChKey = via;
			if( via === &#39;WW_next_pg&#39; ) {				// first time on page
				scroller.reset( numValid );
				end = (numValid &lt; lines ? numValid : lines) - 1;// 0 indexed
				start = scroller.curr( numValid, lines, end );
			} else if( via === &#39;VV_more&#39; ) {			// scroll page
				start = scroller.next( numValid, lines );
				end = start + lines - 1;				// 0 indexed
			} else if( currentChoice.option === null ) {	// first page of opened F4 interface
				if( via === undefined ) {
					start = scroller.curr( numValid, lines, end );
				}
				initChKey = haveChanges ? &#39;YY_save&#39; : &#39;WW_next_pg&#39;;
			} else {									// back from editing option
				initChKey = currentChoice.option;
			}
			screen.initialChoicesKey = initChKey;

			let delta = lastValid &gt; 0 ? numValid - lastValid : 0;// ?did # options change
			if( numValid &lt;= lines ) {					// fits on one page
				end = numValid - 1;						// 0 indexed
				start = scroller.curr( numValid, lines, end );
			} else if( delta !== 0 ) {					// number of options has changed (conditionals)
				end = lastStart + (numValid &gt; lines ? lines : numValid) - 1;
				// set position so initChKey remains the same, if possible
				// ie. when sub-options collapse/expand
				if( delta &gt; 0 ) { 						// option expanded
					let row = optionRows[ initChKey ];	// option&#39;s place in displayed options
					if( row + delta &gt;= lines - 1 ) { 	// sub-options extend beyond end of page
						let valid = Object.keys( validOptions );
						let place = valid.indexOf( initChKey ); // option&#39;s place in all valid options
						end = place + delta;			// shift up to see all sub-options
					}
				} else if( delta &lt; 0 ) {				// option collapsed
					if( lastEnd + delta &gt; numValid - 1 ) {// not enough remaining options to fill to end of page
						end = numValid - 1 - delta;
					}
				}
				start = scroller.curr( numValid, lines, end );
			}
			that.lastStart = start;
			that.lastEnd = end;
			that.lastValid = numValid;

			clearObject( optionRows );
			let skip = 0, 								// # of VALID options skipped before starting
				count = 0;								// # of VALID options displayed
			for( let idx = 0; idx &lt; len; idx++ ) {		// set up option buttons
				option = options[ idx ];
				if( !validOptions.hasOwnProperty( option ) )
					continue;
				if( skip++ &lt; start )					// option has scrolled above top of page
					continue;
				lastValidShowing = option === lastValidKey;
				let prefix = count &lt; 10 ? &#39;0&#39; + count : count;
				let choiceKey = prefix + &#39;_&#39; + option;
				let nextOption = getChoice( validOptions[ option ] )
				// setup nextOption for display
				nextOption.alignment = &#39;LEFT&#39;;
				if( optionInfo[ option ].isSuppressed ) {
					// the only suppressed options that are added to validOptions are
					// controllers that aren&#39;t controlled (ie. top level in dependency)
					// and those options solely dependent on oxp vars, not options
					nextOption.color = expandText( &#39;stn_optns_notInUse_color&#39; ) || &#39;darkGrayColor&#39;;
				} else if( option === currentChoice.option ) {
					nextOption.color = expandText( &#39;stn_optns_lastUsed_color&#39; ) || &#39;greenColor&#39;;
				} else if( changesMade.hasOwnProperty( option ) ) {
					nextOption.color = expandText( &#39;stn_optns_optionChanged_color&#39; ) || &#39;cyanColor&#39;;
				}
				if( option === currentChoice.option ) {
					screen.initialChoicesKey = choiceKey;
				}
				optionRows[ option ] = count;
				choices[ choiceKey ] = nextOption;
				if( ++count &gt;= lines ) break;
			}
			if( numValid &gt; lines ) {					// add &#39;more&#39; button
				if( lastValidShowing ) {
					choices[ &#39;VV_more&#39; ] = scrollTopButton;
				} else {
					choices[ &#39;VV_more&#39; ] = scrollButton;
				}
				if( screen.initialChoicesKey === &#39;VV_more&#39; ) {
					choices[ &#39;VV_more&#39; ].color = expandText( &#39;stn_optns_lastUsed_color&#39; ) || &#39;greenColor&#39;;
				}
			}
			return choices;
		} catch( err ) {
			log( so.name, so._reportError( err, buildOptions, [screenLines, via] ) );
			throw err;
		}
	}

// : &#39; +  + &#39;
	function checkCondition( option ) {
		var that = checkCondition;
		var invalid = (that.invalid = that.invalid || [ false, 0 ]);
		var indents = (that.indents = that.indents || []);// .length only array for .join() for dependency markers
		indents.length = 0;

		var line = &#39;&#39;, inserted = 0;
		var conditionKey = keyPrefix + option + &#39;_condition&#39;;
		var info = optionInfo[ option ];
		var conditions = expandText( conditionKey );
		var subsShowing = expandText( &#39;stn_optns_subOptions_showing&#39; ),
			subsHidden = expandText( &#39;stn_optns_subOptions_hidden&#39; ),
			subsMarker = expandText( &#39;stn_optns_subOptions_marker&#39; );
		var showingLen = measureWord( subsShowing ), 
			hiddenLen = measureWord( subsHidden );
		info.condition = conditions;
		if( conditions ) {
			info.isSuppressed = !conditionMet( option, conditionKey, conditions );
			do {
				if( !info.isSuppressed ) break;
				// don&#39;t suppress top level controllers
				if( info.controls.length &gt; 0 &amp;&amp; info.relyOnOptions.length === 0
											 &amp;&amp; info.relyOnHostVars.length === 0)
					break;
				// or those that rely solely on hostVars
				if( info.relyOnHostVars.length !== 0 &amp;&amp; info.relyOnOptions.length === 0 )
					break;
				return invalid;
			} while( false );
		}
		var indentIt = null;
		if( info.controls.length &gt; 0 ) {				// prefix option to show whether it controls other options
			let currVal = getOptionValue( option );
			let controlStr = currVal ? subsShowing : subsHidden,
				controlLen = currVal ? showingLen : hiddenLen;
			line = controlStr;
			inserted += controlLen;
			indentIt = false;
		}
/* looks too busy -&gt; allow option entry but all buttons disabled
		if( info.relyOnHostVars.length &gt; 0 ) {
			// prepend option with &#39;$&#39; to indicate # hostVar dependencies
			indents.length = info.relyOnHostVars.length + 1;
			let hostVarStr = indents.join( &#39;$&#39; );
			line += hostVarStr;							// mark option as hostVar dependent
			inserted += strFontLen( hostVarStr );
			indentIt = indentIt !== false ? true : false;
		}
 */
		let reliesUpon = info.relyOnOptions;			// list, may be empty
		let indentStr = &#39;&#39;;
		if( reliesUpon.length &gt; 0 ) {
			// check all parent options are present
			let maxCtrlStrLen = 0;
			for( let idx = 0, len = reliesUpon.length; idx &lt; len; idx++ ) {
				let parent = reliesUpon[ idx ];
				if( !startsWith( parent, hostVarPrefix ) &amp;&amp; !optionInfo.hasOwnProperty( parent ) ) {
					log(so.name, &#39;checkCondition, ERROR, &quot;&#39; + option + &#39;&quot; relies on &quot;&#39;
						+ parent + &#39;&quot; which is missing!  conditions: &#39; + conditions );
					continue;
				}
				// set indent to size of parent&#39;s prefix
				let pHidden = optionInfo[ parent ].isSuppressed;
				let pCtrlStrLen = pHidden ? hiddenLen : showingLen;
				if( pCtrlStrLen &gt; maxCtrlStrLen ) {
					maxCtrlStrLen = pCtrlStrLen;
				}
			}
			// prepend option with colons to indicate # option dependencies
			indentStr = paddingText( &#39;&#39;, maxCtrlStrLen );
			indents.length = reliesUpon.length + 1;
			let optionStr = indents.join( subsMarker );
			line += optionStr;							// mark option as conditional
			inserted += strFontLen( optionStr );
			indentIt = indentIt !== false ? true : false;
		}
		line = (indentIt ? indentStr : &#39;&#39;) + line + info.optionStr;
		return [ line, inserted ];
	}

	function formatOptions( tabs ) {
		// check which options are valid; find max column shift
		var that = formatOptions;
		var valid = (that.valid = that.valid || []);
		var lines = (that.lines = that.lines || []);
		var shiftedTabs = (that.shiftedTabs = that.shiftedTabs || []);
		valid.length = 0;
		lines.length = 0;
		shiftedTabs.length = 0;

		var currentScreen = pageLabels[ currentScreenIdx ],
			options = optionPages[ currentScreen ];
		var idx, len, option, line, insert, maxInsert = 0;
		for( idx = 0, len = options.length; idx &lt; len; idx++ ) {// find all non-suppressed options
			option = options[ idx ];
			// returns start of line (option, special char?), length of any special char
			[ line, insert ] = checkCondition( option );
			if( line === false ) {						// option is suppressed
				continue;
			}
			if( insert &gt; maxInsert ) {
				maxInsert = insert;
			}
			valid.push( option );
			lines.push( line );
		}
		// shift tabs to account for inserted markers
		for( idx = 0, len = tabs.length; idx &lt; len; idx ++ ) {
			shiftedTabs[ idx ] = tabs[ idx ] + maxInsert;
		}
		clearObject( validOptions );
		for( idx = 0, len = valid.length; idx &lt; len; idx++ ) {// format valid options
			option = valid[ idx ];
			line = lines[ idx ];
			line += shiftedTabs &amp;&amp; shiftedTabs.length &gt; 0
					? paddingText( line, shiftedTabs[ 0 ] ) : &#39;&#39;;	// &#39;\t\t&#39;
			validOptions[ option ] = formatLine( option, line, shiftedTabs );
		}
		return valid[ valid.length - 1 ];				// last valid option
	}

// : &#39; +  + &#39;
	function formatLine( option, line, tabs ) {
		var value = getOptionValue( option );
		var type = typeof value;
		// space for middle column, ie. option&#39;s value
		var gap = tabs &amp;&amp; tabs.length &gt; 1
				? tabs[ 1 ] - tabs[ 0 ] : 0;

		// short description
		var brief = expandText( keyPrefix + option );
		if( brief &amp;&amp; brief.length &gt; 0 ) {
			let endSpec = brief.indexOf( &#39;)&#39; );
			if( endSpec &gt; 0 )
				brief = brief.slice( endSpec + 1 ).trim(); // skip past type, default &amp; range(?)
		}

		if( value === null ) {
		 	line += &#39;null&#39;;
		} else if( type === &#39;undefined&#39; ) {
			line += &#39;&#39;; 								// blank for page of only text
		} else if( type === &#39;string&#39; ) {
			line += value;
		} else if( type === &#39;boolean&#39; ) {
			line += expandText( ( value ? &#39;stn_optns_boolean_true&#39; : &#39;stn_optns_boolean_false&#39; ) );
		} else if( type === &#39;number&#39; ) {
			let num = floor( value ) === value			// an integer
					  ? value : value.toPrecision( maxPrecision &lt; 1 ? 1 : maxPrecision );
			let precision = maxPrecision - 1;
			while( gap &gt; 0 &amp;&amp; precision &gt;= 1 &amp;&amp; measureWord( &#39;&#39; + num ) &gt; gap ) { // overflows the gap
				num = value.toPrecision( precision );
				precision--;
			}
			line += num;
		} else if( Array.isArray( value ) || value instanceof Vector3D ) {
			line += formatArray( option, value, line, brief, tabs );
		} else {										// something else
			line += &#39;{object}&#39;;
			if( !changesMade.hasOwnProperty( option ) ) {// an array is only created when getOptionValue from host
				freeObject( value );					// else we&#39;re using the one in changesMade
			}
		}

		// assemble
		line += tabs &amp;&amp; tabs.length &gt; 1
				? paddingText( line, tabs[ 1 ] ) : &#39;\t&#39;;
		line += brief;
		while( strFontLen( line ) &gt; MAXSCREENWIDTH ) {	// truncate long lines on word boundary
			line = line.slice( 0, line.lastIndexOf( &#39; &#39; ) );
		}
		return line;
		// return getChoice( line );
	}

	function formatArray( option, value, line, brief, tabs ) {
		// return string representing the array/vector value of &#39;key&#39;
		// so it fits within tab stops
		var that = formatArray;
		var items = (that.items = that.items || []);
		items.length = 0;

		function getItems( precision ) {
			items.length = 0;
			for( let idx = 0; idx &lt; len; idx++ ) {
				let item = value[ idx ];
				if( item % 1 === 0 ) {					// remove .0&#39;s
					items.push( item );
				} else {
					// .toPrecision may return exponential notation
					let precise = item.toPrecision( precision );
					let pStr = precise.toString();
					let eIdx = pStr.indexOf( &#39;e&#39; );
					if( eIdx &gt;= 0 ) {
						let dot = pStr.indexOf( &#39;.&#39; );
						if( dot &lt; 0 ) {
							dot = eIdx;
						}
						precise = dot &gt;= precision ? item.toFixed( 0 )
								: item.toFixed( precision - dot );
					}
					items.push( precise );
				}
			}
		}

		var gap = tabs &amp;&amp; tabs.length &gt; 1
				? tabs[ 1 ] - tabs[ 0 ] : 0;
		var fmtStr, valueF, len = value.length,
			typeStr = Array.isArray( value ) ? &#39;{array}&#39; : &#39;{vector}&#39;,
			vectorLen = maxVectorLen, result = &#39;&#39;;
		var hairSpace = String.fromCharCode( 0x200a );

		getItems( vectorLen );
		if( gap &gt; 0 ) {
			if( !vectorLen || vectorLen &lt; 1 ) {
				// !vectorLen is zero when user turns it off: default is to round to integer
				// vectorLen = floor(maxPrecision / len + 0.5);  // round( maxPrecision / len )
				vectorLen = 1;	  						// argument to .toPrecision must be &gt;= 1
			}
			while( true ) { 							// try to squeeze value into gap
				fmtStr = items.join( &#39;, &#39; );
				valueF = measureWord( fmtStr );
				if( valueF &lt; gap ) 						// not &lt;= so there&#39;s a space to next column
					break;
				fmtStr = items.join( &#39;,&#39; + hairSpace );
				valueF = measureWord( fmtStr );
				if( valueF &lt; gap )  					// not &lt;= so there&#39;s a hairSpace to next column
					break;
				fmtStr = items.join( &#39;,&#39; );
				valueF = measureWord( fmtStr );
				if( valueF &lt;= gap ) 					// butts up against next column
					break;
				vectorLen--;
				if( vectorLen &lt; 1 )
					break;
				getItems( vectorLen );
			}
			result = valueF &gt; gap ? typeStr : fmtStr;
		} else {										// gap == 0 =&gt; no tabStops specified
			let lineF = measureWord( line ),
				briefF = measureWord( brief );
			fmtStr = items.join( &#39;, &#39; );
			valueF = measureWord( fmtStr );
			if( lineF + valueF + briefF &gt; MAXSCREENWIDTH ) {
				fmtStr = value.join( &#39;,&#39; + hairSpace );
				valueF = measureWord( fmtStr );
			}
			if( lineF + valueF + briefF &gt; MAXSCREENWIDTH ) {
				fmtStr = value.join( &#39;,&#39; );
				valueF = measureWord( fmtStr );
			}
			result = lineF + briefF + valueF &gt; MAXSCREENWIDTH ? typeStr : fmtStr;
		}
		if( !changesMade.hasOwnProperty( option ) ) {		// an array is only created when getOptionValue from host
			freeArray( value );							// else are using the one in changesMade
		}
		return result;
	}

	///////////////////////////////////////////////////////////////////////////////
	// evaluation functions ///////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////

// : &#39; +  + &#39;
	var classifiedTerm = {};
	function classifyTerm( term, option, context ) {
		var that = classifyTerm;
		var exclamations = (that.exclamations = that.exclamations || []);

		// check if &#39;term&#39; is an option or hostVar &amp; fetch its value
		// - return quoted strings as will be used in eval calls
		var count, value = term, type = null, opposite = false;
		if( term.length === 0 ) {
			term = value = &quot;&#39;&#39;&quot;;
			return [ term, value, type, opposite ];
		}
		[ term, count ] = splitExclamations( term );
		if( count &gt; 0 ) {
			exclamations.length = count + 1;
			opposite = exclamations.join( &#39;!&#39; );
		}
		if( startsWith( term, SO_PREFIX ) ) {
			type = so.hasOwnProperty( term ) &amp;&amp; typeof so[ term ] === &#39;function&#39;
					? &#39;soFunction&#39; : &#39;unknown&#39;;
		} else if( term === so.name ) {
			type = &#39;soFunction&#39;;
		} else if( term === &#39;worldScripts&#39; ) {
			type = &#39;oxpFunction&#39;;
		} else if( startsWith( term, hostVarPrefix ) ) {
			if( !hostOxp.hasOwnProperty( term ) ) {
				type = &#39;hostVariable&#39;
				log( so.name, &#39;classifyTerm, for &quot;&#39; + option
					+ &#39;&quot;, term &quot;&#39; + term + &#39;&quot; not found in: &#39;
					+ keyPrefix + &#39;, assuming it is a variable\n\t&#39; + context );
			} else if( typeof so[ term ] === &#39;function&#39; ) {
				type = &#39;hostFunction&#39;;
			} else {
				type = &#39;hostVariable&#39;;
				value = getOptionValue( stripPrefix( term ), true );	// true =&gt; get from hostOxp
				if( value === undefined ) {
					log( so.name, &#39;classifyTerm, for &quot;&#39; + option
						+ &#39;&quot;, &quot;&#39; + term + &#39;&quot; is undefined: &#39; + context );
				}
			}
		} else {
			let page;
			if( optionInfo.hasOwnProperty( term ) ) {
				page = optionInfo[ term ].page;
			}
			if( page ) {								// it&#39;s an option
				optionInfoToObj( term, classifiedTerm );
				type = classifiedTerm.type;
				if( classifiedTerm.error ) {
					type = &#39;unknown&#39;;					// checkValue will have logged error
				}
				value = getOptionValue( term );
				if( value === undefined ) {
					log( so.name, &#39;classifyTerm, for &quot;&#39; + option
						+ &#39;&quot;, option &quot;&#39; + term + &#39;&quot; is undefined: &#39; + context );
				} else {
					value = checkValue( value, classifiedTerm, option );
				}
			} else if( global.hasOwnProperty( term ) ) {
				type = typeof global[ term ] === &#39;function&#39; ? &#39;ooFunction&#39; : &#39;unknown&#39;;
			}
		}
		if( typeof value === &#39;string&#39; &amp;&amp; value.length === 0 ) {
			value = &quot;&#39;&#39;&quot;;
		}
		return [ term, value, type, opposite ];
	}

	var termSplitter = /\s*(?:[()]*)([=&lt;&gt;&amp;~^|&amp;?:]+|[!][=]{1,2})\s*/;	// exclude solo &#39;!&#39; as stays with term
	var matchCompareOp = /\s*([=!&lt;&gt;]+)\s*/;
	// NB: global flag &#39;g&#39; must not be used as it&#39;s for successive matches only
	// (.exec remember index from previous use; set re&#39;s .lastIndex=0 if must use /g)
	var indexingArray = /&#39;\s*([[][^\]]*[\]])\s*&#39;&#39;\s*([[][^\]]*[\]])\s*&#39;/g;

	function substituteValues( string, option, assignKey ) {
		var that = substituteValues;
		var delayed = (that.delayed = that.delayed || []);

		function valueFromString( term, unquoted, vector, decimal, integer ) {
			var value;
			if( integer ) 					value = parseInt( integer, 10 );
			else if( decimal )				value = parseFloat( decimal );
			else if( vector )				value = JSON.parse( vector );
			else if( term === &#39;null&#39; ) 		value = null;
			else if( term === &#39;undefined&#39; )	value = undefined;
			else if( term === &#39;true&#39; ) 		value = true;
			else if( term === &#39;false&#39; ) 	value = false;
			else if( unquoted ) {
				// return quoted strings as will be used in eval calls
				if( /\\&#39;/.test( term ) ) {				// remove escapes for escaped quotes;
					value = &#39;&quot;&#39; + unquoted.replace( /\\&#39;/g, &quot;&#39;&quot; ) + &#39;&quot;&#39;;
				} else {
					value = isSingleQuoted( term ) ? term : &quot;&#39;&quot; + stripQuotes( term ) + &quot;&#39;&quot;;
				}
			} else { 									// some other unquoted string (?option or hostVar)
				value = term;
			}
			return value;
		}

		function indexInList( list, item ) {
			var addQuotes = isSingleQuoted( item );
			for( let idx = 0, len = list.length; idx &lt; len; idx++ ) {
				let it = list[ idx ];
				if( item === (addQuotes ? &quot;&#39;&quot; + it + &quot;&#39;&quot;  : it) ) {
					return idx;
				}
			}
			return -1;
		}

		function valueToType( value, type, expression ) {

			function indexError( kind ) {
				return &#39;valueToType, &#39; + kind + &#39; (&#39; + coerced + &#39;) for value &quot;&#39; + value
								+ &#39;&quot; out of range for option &quot;&#39; + classifiedTerm.option
								+ &#39;&quot;, \n\tmust be in interval 0..&#39; + (choices.length - 1)
								+ &#39; for &#39; + kind + &#39; values: &#39; + choices
								+ &#39;\n\tsee &quot;&#39; + option + &#39;&quot;: &#39; + expression;
			}

			var choices, coerced = value;
			if( type === &#39;hostVariable&#39; ) {
				if( Array.isArray( value ) ) {
					coerced = valueToType( value, &#39;vector&#39;, expression );
				} else if( typeof value === &#39;string&#39; ) {
					coerced = valueFromString( value, stripQuotes( value ) )
				}
			} else if( type === &#39;choice&#39; &amp;&amp; typeof value === &#39;string&#39; ) {
				choices = classifiedTerm.selection;		// ASSUMES prior call to classifyTerm
				if( !choices || choices.length === 0 )
					throw( &#39;valueToType, cannot find choices for: &#39; + classifiedTerm.option
							+ &#39;; see &quot;&#39; + option + &#39;&quot;: &#39; + expression  );
				coerced = indexInList( choices, value );
				if( coerced &lt; 0 || coerced &gt;= choices.length ) {
					throw indexError( &#39;choice&#39; );
				}
			} else if( type === &#39;vector&#39; ) {			// validate term&#39;s elements
				let isArray = Array.isArray( value );
				if( !isArray || value.length === 0 ) {
					throw( &#39;valueToType, &#39; + (isArray ? &#39;empty&#39; : &#39;missing&#39;) + &#39; array  for &quot;&#39;
							+ classifiedTerm.option + &#39;&quot;; see &quot;&#39; + option + &#39;&quot;: &#39; + expression  );
				}
				for( let vi = 0, len = value.length; vi &lt; len; vi++ ) {
					let item = value[ vi ];
					let rangeChk = valueInRange( item, classifiedTerm );
					if( typeof rangeChk === &#39;string&#39; )
						// not between min &amp; max or if no range in spec., not between lowestValue &amp; highestValue
						throw( &#39;valueToType, invalid value ( &#39; + item + &#39; ) for &quot;&#39;
								+ classifiedTerm.option + &#39;&quot; : &#39; + rangeChk
								+ &#39;; see &quot;&#39; + option + &#39;&quot;: &#39; + expression  );
				}
				/* 	convert arrays to string for JS compare (JS has no inherent array comparison)
					(JSON.stringify&#39;d arrays have [], .toString does not)
					- no benefit using JSON as condition strings are first converted to
					  numbers, so insignificant differences won&#39;t matter (eg. -0, trailing zeros)
				*/
				// use single quotes to be consistent with strings which are always single quoted
				coerced = &quot;&#39;[&quot; + value.toString() + &quot;]&#39;&quot;;
			} else if( type === &#39;bitflags&#39; &amp;&amp; typeof value === &#39;string&#39; ) {
				choices = classifiedTerm.selection;		// ASSUMES prior call to classifyTerm
				if( !choices || choices.length === 0 )
					throw( &#39;valueToType, cannot find bitflag strings for: &#39; + classifiedTerm.option
							+ &#39;; see &quot;&#39; + option + &#39;&quot;: &#39; + expression  );
				coerced = indexInList( choices, value );
				if( coerced &lt; 0 || coerced &gt;= choices.length ) {
					throw indexError( &#39;bitflagStrs&#39; );
				}
			} else if( type === &#39;number&#39; || type === &#39;decimal&#39; || type === &#39;bitflags&#39; ) {
				let rangeChk = valueInRange( value, decodedChoice );
				if( typeof rangeChk === &#39;string&#39; )
					// not between min &amp; max or if no range in spec., not between lowestValue &amp; highestValue
					throw( &#39;valueToType, invalid value ( &#39; + value + &#39; ) for &quot;&#39;
							+ classifiedTerm.option + &#39;&quot;: &#39; + rangeChk
							+ &#39;; see &quot;&#39; + option + &#39;&quot;: &#39; + expression  );
			} else if( type === &#39;toggle&#39; ) {
				if( typeof value === &#39;string&#39; ) {
					let choices = classifiedTerm.selection;// ASSUMES prior call to classifyTerm
					if( !choices || choices.length === 0 )
						throw( &#39;valueToType, cannot find choices for: &#39; + classifiedTerm.option
							+ &#39;; see &quot;&#39; + option + &#39;&quot;: &#39; + expression  );
					let idx = indexInList( choices, value );
					coerced = idx === 0 ? false : true;
				}
			}											// no validation for &#39;text&#39;
			return coerced;
		}

		function optionValue( matchStr, leadWS, term, unQuoted, aVector, aDecimal, anInt, offset, origStr ) {
			var that = optionValue;
			var previous = (that.previous = that.previous ||
							{ &#39;term&#39;: null, &#39;value&#39;: null, &#39;unQuoted&#39;: null, &#39;type&#39;: null, &#39;operator&#39;: null });
			var numTerms = (that.numTerms = that.numTerms || -1);// -1 as numTerms++ for each, indices are 0-based

			var context = origStr.slice( offset );
			matchCompareOp.lastIndex = 0;				// reset re&#39;s .lastIndex as it doesn&#39;t reset on a new string!!!!
			var operator = matchCompareOp.exec( previous.operator );
			operator = operator ? operator[ 1 ] : null; // coerceValue only uses it for messages
			var [ term, value, type, opposite ] = classifyTerm( term, option, context );
			if( type === null ) {
				value = valueFromString( term, unQuoted, aVector, aDecimal, anInt );
				if( typeof value === &#39;string&#39; ) {
					if( matchCompareOp.test( previous.operator ) ) {
						value = valueToType( value, previous.type, context );
					} else if( assignKey ) {
						if( optionInfo.hasOwnProperty( assignKey ) ) {
							optionInfoToObj( term, classifiedTerm );
							value = valueToType( value, optionInfo[ assignKey ].type, context );
						}
					}
				} else if( Array.isArray( value ) ) {
					value = valueToType( value, &#39;vector&#39;, context );
				}
			} else if( type !== &#39;unknown&#39; &amp;&amp; !endsWith( type, &#39;Function&#39; ) ) {
				value = valueToType( value, type, context );
				if( type !== &#39;hostVariable&#39; ) {
					if( previous.type === null &amp;&amp; operator &amp;&amp; previous.unQuoted ) {
						// missed coercion as option trails string
						delayed.push( [ numTerms - 1, // -1 due to the operator&#39;s that.numTerms++;
										valueToType( previous.value, type, context ) ] );
					}
				}
			}
			that.numTerms++;
			that.previous.term = term;
			that.previous.value = value;
			that.previous.unQuoted = unQuoted;
			that.previous.type = type;
			termSplitter.lastIndex = 0;					// reset re&#39;s .lastIndex as it doesn&#39;t reset on a new string!!!!
			let trailing = termSplitter.exec( origStr.slice( offset + matchStr.length ) );
			if( trailing ) {							// operator after term, could be comparison or logical
				that.previous.operator = trailing[ 1 ];
				that.numTerms++;
			} else {
				that.previous.operator = null;
			}
			return leadWS + ( opposite ? opposite : &#39;&#39;) + value;
		}

		delayed.length = 0;
		optionValue.numTerms = -1;
		let result = string.replace( decodeTerm, optionValue );
		if( delayed.length ) {
			let splat = result.split( termSplitter );
			// .split can have empty strings, eg. when space between termSplitter char.s
			let terms = splat.filter( function( item ) { return item !==&#39;&#39;; } );
			for( let idx = 0, len = delayed.length; idx &lt; len; idx++ ) {
				let [ count, target ] = delayed[ idx ];
				terms[ count ] = target;
			}
			result = terms.join( &#39; &#39; );
		}
		// for an array index, remove doubled single quotes
		result = result.replace( indexingArray, &#39;$1$2&#39; );
		return result;
	}

// : &#39; +  + &#39;
	function conditionMet( option, conditionKey, conditions ) {
		try {

			decodeExprn.lastIndex = 0;					// reset re&#39;s .lastIndex as it doesn&#39;t reset on a new string!!!!
			var substituted = substituteValues( conditions, conditionKey );
if( startsWith( option, &#39;AutoScan&#39; ) ) {
	log(&#39;conditionMet, conditions: &#39; + conditions );
	log(&#39;             substituted: &#39; + substituted );
}
			try {
				// use strict protects the global namespace
				let result = eval( &quot;&#39;use strict&#39;; &quot; + substituted );
				return result;
			} catch( err ) {
				log( so.name, &#39;conditionMet caught &#39; + err + &#39; on:&#39;
					+ &#39;\n    eval( &gt;&gt;&#39; + substituted + &#39;&lt;&lt; );&#39;
					+ &#39;\n    where the argument was derived via substitution from:&#39;
					+ &#39;\n        &#39; + conditions
					+ &#39;\n    in &quot;&#39; + conditionKey + &#39;&quot;&#39; );
				return true; 							// don&#39;t let error suppress option
			}

		} catch( err ) {
			// FYI: can throw object, existing (or constructed in throw statement), eg. conditionalOption
			if( typeof err === &#39;string&#39; ) {				// one of mine
				if( err.length ) {						// zero length string =&gt; error already issued
					log( so.name, &#39;conditionMet, &#39; + err );
				}
				return true; 							// don&#39;t let error suppress option
			} else
				log( so.name, so._reportError( err, conditionMet, [ option, conditionKey, conditions ] ) );
				throw err;
		}
	}

// : &#39; +  + &#39;
	function doAssignments( option ) {
		var assignKey = keyPrefix + option + &#39;_assign&#39;;
		var expanded = expandText( assignKey );
		if( !expanded )
			return;
		try {
			var search, foundOne, result, index, lastIndex;
			decodeAssign.lastIndex = 0;					// reset re&#39;s .lastIndex as it doesn&#39;t reset on a new string!!!!
			var statement, substituted, expression,
				statements = expanded.split( /[;]/ );
			foundOne = false;
			index = lastIndex = 0;
			for( let idx = 0, len = statements.length; idx &lt; len; idx++ ) {
				expression = &#39;&#39;;
				statement = statements[ idx ];
				if( statement.length === 0 )
					continue;
				decodeAssign.lastIndex = 0;				// reset re&#39;s .lastIndex as it doesn&#39;t reset on a new string!!!!
				search = decodeAssign.exec( statement );
				if( search === null ) {					// not an assignment statement
					if( foundOne )
						break;
					throw( &#39;doAssignments, unable to parse _assign specifier for &quot;&#39;
						+ option + &#39;&quot; : &#39; + statement + &#39;\n\t_assign: &#39; + expanded );
				}
				index = search.index;
				let [ matchStr, target, assignment ] = search;
				if( index &gt; lastIndex ) {
					log( so.name, &#39;doAssignments, invalid assignment statement: &quot;&#39; + statement
						+ &#39;, nothing should precede the target : &quot;&#39; + target + &#39;&quot;&#39; );
					continue;
				}
				foundOne = true;
				let value, optType, isNot;
				[ target, value, optType, isNot ] = classifyTerm( target, assignKey, matchStr );
				substituted = substituteValues( assignment, assignKey, target );
				lastIndex = index;
				expression += &#39;worldScripts.&#39; + hostOxp.name + &#39;.&#39;
							+ (optType === &#39;hostVariable&#39; ? &#39;&#39; : hostVarPrefix)
							+ target + &#39; = &#39; + substituted;
				freeArray( search );

				try{
					result = eval( &quot;&#39;use strict&#39;; &quot; + expression );
					if( missionKeys.hasOwnProperty( target ) ) {
						missionKeys[ target ] = getOptionValue( target );
					}
				} catch( err ) {
					log( so.name, &#39;doAssignments caught &#39; + err + &#39; on:&#39;
						+ &#39;\n    eval( &#39; + expression + &#39; );&#39;
						+ &#39;\n    for &quot;&#39; + assignKey );
				}
				if( optType !== null ) {
					let option = stripPrefix( target );
					let startVal = getOptionValue( option, true );// true =&gt; from hostOxp
					if( changesMade.hasOwnProperty( option ) &amp;&amp; changesMade[ option ] !== startVal ) {
						log( so.name, &#39;doAssignments, WARNING: &#39; + assignKey + &#39; overwrites &quot;&#39; + option
							+ &#39;&quot; that player changed from: &#39; + startVal + &#39; to: &#39; + changesMade[ option ]
							+ &#39;; its valus is now: &#39; + result );
					}
					removeChangeMade( option ); 		// now rendered moot
				}
			}
		} catch( err ) {
			log( so.name, so._reportError( err, doAssignments, option ) );
			if( typeof err === &#39;string&#39; ) {
				log( so.name, err );
			} else {
				throw err;
			}
		}
	}

	function doExecutes( option ) {
		var executeKey = keyPrefix + option + &#39;_execute&#39;;
		var expanded = expandText( executeKey );
		if( !expanded )
			return;
		try {
			var search, foundOne, result, index, lastIndex;

			decodeFnCall.lastIndex = 0;					// reset re&#39;s .lastIndex as it doesn&#39;t reset on a new string!!!!
			var statement, substituted, expression,
				statements = expanded.split( /[;]/ );
			for( let idx = 0, len = statements.length; idx &lt; len; idx++ ) {
				statement = statements[ idx ];
				if( statement.length === 0 )
					continue;
				decodeAssign.lastIndex = 0;				// reset re&#39;s .lastIndex as it doesn&#39;t reset on a new string!!!!
				let assign = decodeAssign.test( statement );
				if( assign ) {
					log( so.name, &#39;doExecutes, assignment detected: &#39; + statement
						+ &#39;\n\tIgnoring as it will not work due to complete value substitution.  Move it into an &quot;_assign&quot; option&#39;);
					continue;
				}
				substituted = substituteValues( statement, executeKey );
				foundOne = false;
				expression = &#39;&#39;;
				index = lastIndex = 0;
				while( true ) {
					search = decodeFnCall.exec( substituted );
					if( search === null ) {					// no function calls
						if( foundOne )
							break;
						throw( &#39;doExecutes, unable to parse &quot;&#39;
							+ executeKey + &#39;&quot; : &#39;
							+ substituted.slice( lastIndex )
							+ &#39;\n\t_execute: &#39; + expanded );
					}
					index = search.index;
					let [ matchStr, leading, wsName, wsFn, soFn, oxpFn, args, trailing ] = search;
					foundOne = true;
					expression += substituted.slice( lastIndex, index );
					lastIndex = index;
					if( wsName &amp;&amp; wsFn ) {
						let script = eval( wsName );
						if( script !== undefined ) {	// oxp is present
							if( script.hasOwnProperty( wsFn )
									&amp;&amp; typeof script[ wsFn ] === &#39;function&#39; ) {
								expression += leading + wsName + &#39;.&#39;
											+ wsFn + args + trailing;
								index += matchStr.length;
							} else {
								log( so.name, &#39;doExecutes, unable to locate function &quot;&#39;
									+ wsFn + &#39;&quot;in &quot;&#39; + executeKey + &#39;&quot; : &#39;
									+ substituted.slice( index )
									+ &#39;\n\t_execute: &#39; + expanded );
							}
						} else {
							log( so.name, &#39;doExecutes, unable to locate worldScripts &quot;&#39;
								+ wsName + &#39;&quot;in &quot;&#39; + executeKey + &#39;&quot; : &#39;
								+ substituted.slice( index )
								+ &#39;\n\t_execute: &#39; + expanded );
						}
					} else if( soFn ) {
						if( so.hasOwnProperty( soFn )
								&amp;&amp; typeof so[ soFn ] === &#39;function&#39; ) {
							expression += leading + &#39;worldScripts.&#39; + so.name
										+ &#39;.&#39; + soFn + args + trailing;
							index += matchStr.length;
						} else {
							log( so.name, &#39;doExecutes, unable to locate &#39; + so.name + &#39; function &quot;&#39;
								+ soFn + &#39;&quot;in &quot;&#39; + executeKey + &#39;&quot; : &#39;
								+ substituted.slice( index )
								+ &#39;\n\t_execute: &#39; + expanded );
						}
					} else if( oxpFn ) {
						if( hostOxp.hasOwnProperty( oxpFn )
								&amp;&amp; typeof hostOxp[ oxpFn ] === &#39;function&#39; ) {
							expression += leading + &#39;worldScripts.&#39; + hostOxp.name
										+ &#39;.&#39; + oxpFn + args + trailing;
							index += matchStr.length;
						} else {
							log( so.name, &#39;doExecutes, unable to locate global function &quot;&#39;
								+ oxpFn + &#39;&quot;in &quot;&#39; + executeKey + &#39;&quot; : &#39;
								+ substituted.slice( index )
								+ &#39;\n\t_execute: &#39; + expanded );
						}
					} else {
						throw( &#39;doExecutes, unable to decode &quot;&#39; + executeKey + &#39;&quot;: &#39; + matchStr );
					}
				}

				try{
					result = eval( &quot;&#39;use strict&#39;; &quot; + expression ); // + &#39;;&#39;
				} catch( err ) {
					log( so.name, &#39;doExecutes caught &#39; + err + &#39; on:&#39;
						+ &#39;\n    eval( &#39; + expression + &#39; );&#39;
						+ &#39;\n    for &quot;&#39; + executeKey + &#39;&quot;, after substituting values in:&#39;
						+ &#39;\n        &#39; + expanded );
				}
				freeArray( search );
			}
		} catch( err ) {
			log( so.name, so._reportError( err, doExecutes, option ) );
			if( typeof err === &#39;string&#39; ) {
				log( so.name, err );
			} else {
				throw err;
			}
		}
	}
// : &#39; +  + &#39;

	///////////////////////////////////////////////////////////////////////////////
	// processing functions ///////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////

	function optionInfoToObj( option, obj ) {
		// clearObject( obj, true );				// true -&gt; keepObjects
		for( let prop in obj ) {				// reset to defaults (infoTemplate)
			if( obj.hasOwnProperty( prop ) ) {
				if( infoTemplate.hasOwnProperty( prop ) ) {
					obj[ prop ] = infoTemplate[ prop ];
				} else {
					delete obj[ prop ];
				}
			}
		}
		if( optionInfo.hasOwnProperty( option ) ) {		
			var info = optionInfo[ option ];
			for( let prop in info ) {
				if( info.hasOwnProperty( prop ) ) {
					obj[ prop ] = info[ prop ];
				}
			}
			obj.currently = getOptionValue( option );
		}
	}

	var keyFromChoice = /^(\d\d)_(\w+)/; 				// parse choice key: NN_&lt;variable name&gt;
	function processChoice( choice ) {					// for an optionPages selection
		try {
// log(&#39;processChoice, ===&gt; &#39; + cd._showProps(choice, &#39;choice&#39;,0,1));
			var currentScreen = pageLabels[ currentScreenIdx ];
			refreshSOKeys();
			missionKeys.stn_optns_option = null;
			clearObject( currentChoice ); 				// re-use object
			if( !choice || choice === &#39;ZZ_exit&#39; || choice === &#39;ZZ_abort&#39; ) {
				clearObject( changesMade, true );		// true =&gt; keepObjects (ie. del prop only, not what it references)
				clearObject( missionKeys.stn_optns_changed );
				_purgepools();
				return;
			} else if( choice === &#39;YY_save&#39; ) {			// button will be unselectable if no changes
				saveChoices();
				_purgepools();
				return;
			} else if( choice === &#39;XX_reset&#39; ) {
				confirmReset();
				return;
			} else if( choice === &#39;WW_next_pg&#39; ) {
				currentChoice.option = null;
				scroller.reset();
				currentScreen = nextOptionsPage();
				if( currentScreen !== null )
					displayOptions( choice );
				return;
			} else if( choice === &#39;VV_more&#39; || choice === &#39;ZZ_more&#39; ) {
				currentChoice.option = null;
				displayOptions( choice );
				return;
			}
			var changing = choice.match( keyFromChoice );
			if( changing === null ) {
				log( so.name, &#39;processChoice, ERROR: failed to decode &quot;&#39; + choice + &#39;&quot; using: &#39; + keyFromChoice );
				return;
			}
			var option = changing[ 2 ];					// get option from choice
			// var option = currentChoice.option = changing[ 2 ];// get option from choice
			freeArray( changing );
			var options = optionPages[ currentScreen ];
			if( options.indexOf( option ) &lt; 0 ) {
				log( so.name, &#39;processChoice, ERROR: cannot find option: &#39; + option + &#39; in &#39; + options );
			} else {
				optionInfoToObj( option, currentChoice );
				missionKeys.stn_optns_option = option;
				scroller.start();
				let type = currentChoice.type;
				if( type === &#39;toggle&#39; )		   chooseBoolean();
				else if( type === &#39;number&#39; )   chooseNumber();
				else if( type === &#39;vector&#39; )   chooseVector();
				else if( type === &#39;decimal&#39; )  chooseNumber(); // function handles both int &amp; float
				else if( type === &#39;bitflags&#39; ) chooseBits();
				else if( type === &#39;choice&#39; )   chooseChoice();
				else /* assume text */		   chooseText();
			}
		} catch( err ) {
			log( so.name, so._reportError( err, processChoice, choice, 1 ) );
			throw err;
		}
	}

	// parsing of the brief option specifier is done in stages, subsequent stages using the rest
	var decodeType = /\(\s*(text|toggle|number|decimal|vector|bitflags|choice)\s*(,?)\s*(.*?\))/;
		/*
			[1] the type
			[2] a comma, maybe
			[3] the rest, including closing parenthesis
		*/
	var decodeDefault = /\s*(null|true|false|\{.*?\}|&#39;([^&#39;\\]*(?:\\.[^&#39;\\]*)*)&#39;|[-+.\w]*)\s*(,?)\s*(.*?\))/;
		/*
			[1] default value
			[2] unquoted version of [1] if quoted
			[3] a comma, maybe
			[4] the rest, including closing parenthesis
		*/
	var decodeRange = /\s*(\{.*?\}|([-+.\w]*)\s*(:)\s*([-+.\w]*))\s*\)/;
		/*
					[1] selection enclosed in braces {} if [3] is not a colon
					[2] minimum if [3] is a colon
					[3] a colon, maybe
					[4] maximum if [3] is a colon
		*/

/// - decodeOption needs a &#39;do not check&#39; arg to suppress calls to checkValue, as only needs doing
///   when option is first decoded  *OR*
///   build a map of maps of decoded options (ie. cache) to use for rest of game &lt;- easier
	function decodeOption( option, destination ) {		// for option definitions
		var matchStr, unquoted, type, comma, rest, defawlt,
			descr = expandText( keyPrefix + option ),
			items = descr ? descr.match( decodeType ) : null;

		if( !items ) {
			let error = &#39;Error: for option &#39; + (keyPrefix + option)
						+ &#39;, failed to decode (bad type) &quot;&#39; + descr + &#39;&quot;&#39;;
			log( so.name, &#39;decodeOption, &#39; + error	);
			destination.error = error;
			return;
		}
		[matchStr, type, comma, rest] = items;
		destination.option = option;
		destination.type = type;
		// set selection if applicable (done here as any default is optional)
		if( type === &#39;bitflags&#39; ) {
			let flags = getBitFlagStrs( option ) || getArray();
			destination.selection = flags;
			let numBits = flags.length, allBits = 0;
			for( let x = 0; x &lt; numBits; x++ )
				allBits |= 1 &lt;&lt; x;
			destination.numBits = numBits;
			destination.allBits = allBits;
		} else if( type === &#39;toggle&#39; ) {
			destination.selection = getArray( expandText( &#39;stn_optns_boolean_false&#39; ),
												expandText( &#39;stn_optns_boolean_true&#39; ) );
		}
		if( !comma ) {									// no more, ie. no default, range
			if( type === &#39;text&#39; ) {						// no comma =&gt; text only page
				destination.type = &#39;display&#39;;
			} else if( type === &#39;bitflags&#39; || type === &#39;decimal&#39; || type === &#39;number&#39; ) {
				destination.defawlt = 0;				// allowed to skip both default &amp; range
				destination.min = destination.max = null;
			} else if( type === &#39;choice&#39; ) {
				destination.defawlt = 0;				// default to 1st in list if no default specified
			} else if( type === &#39;toggle&#39; ) {
				destination.defawlt = false;
			} else if( type === &#39;vector&#39; ) {
				destination.defawlt = getArray( 0, 0, 0 );
			} else {
				let error = &#39;Error: for option &#39; + (keyPrefix + option)
						+ &#39;, incomplete type spec. (expecting comma) &quot;&#39; + descr + &#39;&quot;&#39;;
				log( so.name, &#39;decodeOption, &#39; + error	);
			}
			return;
		}

		items = rest.match( decodeDefault );			// no error checking as always succeeds
		[matchStr, defawlt, unquoted, comma, rest] = items;
		defawlt = defawlt.replace( /\\&#39;/g, &quot;&#39;&quot; );		// unescaped imbedded quotes
		if( comma &amp;&amp; (type === &#39;text&#39; || type === &#39;toggle&#39;) ) {
			let error = &#39;Error: for option &#39; + (keyPrefix + option) + &#39;, &#39; + type
						+ &#39; cannot have a range &quot;&#39; + descr + &#39;&quot;&#39;;
			log( so.name, &#39;decodeOption, &#39; + error );
			destination.error = error;
			return;
		}
		destination.defawlt = defawlt = defawlt ? checkValue( defawlt, destination, option ) : null;
		destination.min = destination.max = null;
		if( !comma ) {
			return;	  									// no comma =&gt; no more to parse
		}

		items = rest.match( decodeRange );
		if( !items ) {
			let error = &#39;Error: for option &#39; + (keyPrefix + option)
						+ &#39;, missing range or too many commas in &quot;&#39;+ descr + &#39;&quot;&#39;;
			log( so.name, &#39;decodeOption, &#39; + error );
			destination.error = error;
			return;
		}
		comma = items[ 3 ];
		if( comma === &#39;:&#39; ) {							// we have a range
			getRange( option, items[ 2 ], items[ 4 ], destination );
		} else if( type === &#39;choice&#39; ) {
			destination.selection = parseArray( items[ 1 ], type, option );
			if( typeof defawlt === &#39;number&#39; &amp;&amp;
					(defawlt &lt; 0 || defawlt &gt;= destination.selection.length) ) {
				let error = &#39;Error: for option &#39; + (keyPrefix + option)
							+ &#39;, default index (&#39; + defawlt + &#39;) not in list &quot;&#39;
							+ descr + &#39;&quot;&#39;;
				log( so.name, &#39;decodeOption, &#39; + error );
				destination.error = error;
			} else if( typeof defawlt === &#39;string&#39; ) {
				let index = destination.selection.indexOf( defawlt );
				if( index &lt; 0 ) {
					let error = &#39;Error: for option &#39; + (keyPrefix + option)
								+ &#39;, default (&#39; + defawlt + &#39;) not in list &quot;&#39;
								+ descr + &#39;&quot;&#39;;
					log( so.name, &#39;decodeOption, &#39; + error );
					destination.error = error;
				} else {								// convert one of choices into an index
					destination.defawlt = index;
				}
			}
		} else {
			let error = &#39;Error: for option &#39; + (keyPrefix + option)
						+ &#39;, invalid type (&#39; + type + &#39;) for choice list &quot;&#39;
						+ descr + &#39;&quot;&#39;;
			log( so.name, &#39;decodeOption, &#39; + error );
			destination.error = error;
		}
	}

	function getBitFlagStrs( option ) {
		var flags = null,
			bitflagStrs = expandText( keyPrefix + option + &#39;_bitflagStrs&#39; );
		if( bitflagStrs === null ) {
			log( so.name, &#39;getBitFlagStrs, ERROR: missing or invalid _bitflagStrs key for &quot;&#39; + option + &#39;&quot;&#39; );
		} else {
			flags = bitflagStrs.match( matchListOfStr );
			if( !flags || flags.length === 0 ) {
				flags = null;
			}
		}
		return flags;
	}

	var parseNumber = /^\s*([+-]?[0-9]+)\s*$/;
	var parseDecimal = /^\s*([+-]?([0-9]+[.]?[0-9]*|[.][0-9]+))\s*$/;
	var quoteStripper = /&#39;([^&#39;\\]*(?:\\.[^&#39;\\]*)*)&#39;/;
	var dblQuoteStripper = /&quot;([^&quot;\\]*(?:\\.[^&quot;\\]*)*)&quot;/;
	var quoteTrimmer = /(^&#39;)|(&#39;$)/g;

	function checkValue( checking, result, option, orType ) {
		// used for both validating missiontext.plist &amp; user input
		//  !now also for validating _condition terms
		//	- errors go to log file, setChoice mk&#39;s its own msgs
		//	- &#39;orType&#39; overrides soType for recursive type checking (choice)
		var value, soType = orType || result.type,
			type = typeof checking;
// log(&#39;checkValue, option: &#39; + option + &#39;, checking: &#39; + checking + &#39;, soType: &#39; + soType + &#39;, type: &#39; + type );

		try {
			if( checking === undefined
				|| (Array.isArray(checking) &amp;&amp; checking.length === 0) ) {
				value = undefined;
			} else if( checking === &#39;null&#39; || checking === null ) {
				value = null;
			} else if( soType === &#39;choice&#39; ) {			// 1 level recursion for typing
				// must precede next block else may be treated as text (if checking is text)
				if( type === &#39;string&#39; ) {
					let match = checking.match( parseNumber );
					if( match === null ) {
						value = checkValue( checking, element, option, &#39;text&#39; );
					} else {
						value = checkValue( checking, element, option, &#39;number&#39; );
					}
				} else if( type === &#39;number&#39; ) {
					value = checking;
				} else {
					throw( expandText( &#39;stn_optns_bad_entry&#39; ) + &#39; for choice: &#39; + value + &#39;, typeof: &#39; + typeof value );
				}
			} else if( soType === &#39;text&#39; ) { /// || type === &#39;string&#39; - catches vectors
				if( checking[ 0 ] === &quot;&#39;&quot; ) { 			// quotes optional, verify they match
					let match = checking.match( quoteStripper );
					if( match === null ) {
						throw expandText( &#39;stn_optns_bad_quotes&#39; );
					}
					value = match[ 1 ];
				} else {
					value = checking;
				}
			} else if( soType === &#39;toggle&#39; || type === &#39;boolean&#39; )	{
				value = checking;
				if( typeof value === &#39;string&#39; ) {
					value = checking.replace( quoteTrimmer, &#39;&#39; ); 	// strip quotes (allow user leeway)
					value = value === &#39;true&#39;  ? true :
							value === &#39;false&#39; ? false : &#39;error&#39;;
					if( value === &#39;error&#39; ) {
						throw expandText( &#39;stn_optns_bad_bool&#39; );
					}
				}
			} else if( soType === &#39;bitflags&#39; ) {		// must precede number, as bitflag is a number!
				value = parseInt( checking, 10 );
				if( value !== value ) {
					throw expandText( &#39;stn_optns_bad_num&#39; );// test for NaN which is never equal to itself
				}
				if( value &lt; 0 &amp;&amp; value !== -1 ) {
					throw expandText( &#39;stn_optns_bad_bits&#39; );
				}
			} else if( soType === &#39;number&#39; || soType === &#39;decimal&#39; || type === &#39;number&#39; ) {
				if( typeof checking === &#39;string&#39; ) {
					let match = checking.match( soType === &#39;number&#39; ? parseNumber
																	: parseDecimal );
					if( match === null )
						throw expandText( &#39;stn_optns_parse_err&#39; );
					value = soType === &#39;number&#39; ? parseInt( match[ 1 ], 10 )
											    : parseFloat( match[ 1 ] );
				} else {
					value = checking;
				}
				if( value !== value ) {
					throw expandText( &#39;stn_optns_bad_num&#39; ); 					// test for NaN which is never equal to itself
				}
			} else if( soType === &#39;vector&#39; || Array.isArray( checking ) ) {
				if( soType === &#39;vector&#39; &amp;&amp; type === &#39;string&#39; ) {
					value = parseArray( checking, soType, option );
				} else {
					value = checking;
				}
				if( !value )
					throw expandText( &#39;stn_optns_bad_entry&#39; );
				let ball = &#39;&#39;;
				for( let idx = 0, len = value.length; idx &lt; len; idx++ ) {
					if( value[ idx ] !== value[ idx ] )	// test for NaN which is never equal to itself
						ball += (ball.length &gt; 0 ? &#39;, &#39; : &#39;&#39;) + expandText( &#39;stn_optns_bad_array&#39; ) + idx;
				}
				if( ball.length &gt; 0 ) {
					freeArray( value );
					throw ball;
				}
			} else {
				throw( expandText( &#39;stn_optns_bad_type&#39; ) + &#39; &#39; + soType );
			}
		} catch( err ) {
			if( err instanceof Error ) { 				// not thrown by me
				log( so.name, so._reportError( err, checkValue, [checking, result, orType], 1 ) );
				throw err;
			}
			let error = &#39;Error: &#39; + (err ? err : expandText( &#39;stn_optns_bad_type&#39; ) + &#39; &#39; + soType)
								  + &#39; for &#39; + (keyPrefix + option) + &#39;, checking: &#39; + checking;
			result.error = error;
			log( so.name, &#39;checkValue, &#39; + error	 );
			return soType;								// returning type indicates to caller an error occured
		}
		if( result.error ) {
			result.error = &#39;&#39;;
		}
// log(&#39;checkValue, exit, returning value: &#39; + value + &#39;, typeof value: &#39; + (Array.isArray(value) ? &#39;array&#39; : typeof value) );
		return value;
	}

	var replaceBraces = /^\s*\{\s*|\s*\}\s*$/g;
	var choiceSplitter = /\s*,\s*/;
	var element = {};									// tmp obj for results of checkValue

	function parseArray( str, type, option ) {
		if( !str || str.length === 0 )
			return null;
		var stripped = str.replace( replaceBraces, &#39;&#39; );
		if( !stripped )
			return null;
		var array, result;
		if( type === &#39;choice&#39; ) {
			array = stripped.split( choiceSplitter );
		} else {
			array = stripped.match( matchNumbers );
		}
		if( !array || array.length === 0 ) {
			return null;
		}
		result = getArray();
		if( type === &#39;choice&#39; ) {
			element.type = type;
			for( let idx = 0, len = array.length; idx &lt; len; idx++ ) {
				let value = checkValue( array[ idx ], element, option );
				if( element.error ) {
					log( so.name, &#39;Error parsing choice = &#39; + array[ idx ] );
					freeArray( result );
					return null;
				} else { 								// value could be zero
					result.push( value );
				}
			}
		} else {
			for( let idx = 0, len = array.length; idx &lt; len; idx++ ) {
				result.push( parseFloat( array[ idx ] ) );
			}
		}
		return result;
	}

	function getRange( option, min, max, result ) {
		var	 type = result.type;

		if( !min &amp;&amp; !max ) { 							// are &#39;&#39; if regex found nothing
			result.min = result.max = null;
			return;
		}
		let isNumber = type === &#39;number&#39; || type === &#39;bitflags&#39;;
		result.min = min = !min || min.length === 0 ? lowestValue :	// lowestValue is null when turned off
						   isNumber ? parseInt( min, 10 ) : parseFloat( min );
		result.max = max = !max || max.length === 0 ? highestValue :// highestValue is null when turned off
						   isNumber ? parseInt( max, 10 ) : parseFloat( max );
		if( type === &#39;bitflags&#39; ) { 					// check range is valid
			if( min &lt; 0 || max &lt; 0 ) {
				log( so.name, &#39;getRange, Error: found negative bitflag, using &#39;
					+ (min &lt; 0 ? &#39;zero for min, &#39; : &#39;&#39;)
					+ (max &lt; 0 ? -max + &#39; for max, &#39; :&#39;&#39;)
					+ &#39; for &#39; + (keyPrefix + option) + &#39;, range: &#39; + min + &#39;:&#39; + max );
				if( min &lt; 0 ) {
					result.min = min = 0;
				}
				if( max &lt; 0 ) {
					result.max = max = -max;
				}
			}
			if( max !== null ) {
				let numBits = result.numBits = max.toString( 2 ).length;
				let boundary = pow( 2, numBits ) - 1; // 2^N - 1
				if( max !== boundary ) {
					result.max = max = boundary;
					log( so.name, &#39;getRange, Error: incorrect bitflag boundary, using max = &#39;
									 + max + &#39;, for &#39; + (keyPrefix+ option) + &#39;, range: &#39; + min + &#39;:&#39; + max );
				}
			}
		}
	}

	function formatRange( withTabs ) {
		var min = currentChoice.min,
			max = currentChoice.max;
		return min === null &amp;&amp; max === null ? null :
				(min !== null ? min : &#39;&#39;) + (withTabs ? &#39;\t\t&#39; :&#39;&#39;) + &#39;:&#39;
										  + (withTabs ? &#39;\t\t&#39; :&#39;&#39;) + (max !== null ? max : &#39;&#39;);
	}

	function mkChoicePage( rtnobj, screen, choices, btn_count, initialChoice, errmsg ) {
		var that = mkChoicePage;
		var depends = (that.depends = that.depends || []);
		depends.length = 0;

		var option = currentChoice.option,
			type = currentChoice.type,
			dstr, defawlt = currentChoice.defawlt,
			cstr, currently = currentChoice.currently,
			range = formatRange( true ),
			isSuppressed = optionInfo[ option ].isSuppressed;

		if( type === &#39;vector&#39; ) {
			cstr = currently &amp;&amp; currently.join( &#39;,\t\t&#39; );
			dstr =	 defawlt &amp;&amp;	  defawlt.join( &#39;,\t\t&#39; );
		} else if( type === &#39;toggle&#39; ) {
			cstr = currently === true ? expandText( &#39;stn_optns_boolean_true&#39; )
										: currently === false ? expandText( &#39;stn_optns_boolean_false&#39; ) : currently;
			dstr =	 defawlt === true ? expandText( &#39;stn_optns_boolean_true&#39; )
										: defawlt === false ? expandText( &#39;stn_optns_boolean_false&#39; ) : defawlt;
		} else if( type === &#39;choice&#39; ) {
			let selection = currentChoice.selection;
			cstr = typeof currently === &#39;number&#39; ? selection[ currently ] : currently;
			dstr = typeof defawlt	=== &#39;number&#39; ? selection[ defawlt ]	  : defawlt;
		} else {
			cstr = currently;
			dstr = defawlt;
		}
		let src = expandText( keyPrefix + option + &#39;_long&#39; );
		let textEntry = !isSuppressed &amp;&amp; type !== &#39;toggle&#39; &amp;&amp; type !== &#39;bitflags&#39; &amp;&amp; type !== &#39;choice&#39;;
		if( textEntry ) {
			if( defawlt !== undefined ) src += &#39;\n\n&#39; + expandText( &#39;stn_optns_enter_plus&#39; );
			src += &#39;\n\n&#39; + expandText( &#39;stn_optns_enter_abort&#39; );
			if( type === &#39;text&#39; ) src += &#39;\n\n&#39; + expandText( &#39;stn_optns_enter_empty_str&#39; );
		}
		let status = &#39;\n\n&#39; + expandText( &#39;stn_optns_setting_str&#39; ) + &#39;: &#39; + cstr
					 + (range ? &#39;\t\t\t\t&#39; + expandText( &#39;stn_optns_range_str&#39; ) + &#39;:\t\t&#39; + range : &#39;&#39;)
					 + (defawlt === undefined ? &#39;&#39; : &#39;\t\t\t\t&#39; + expandText( &#39;stn_optns_default_long&#39; ) + &#39;:\t\t&#39;
													 + (defawlt === null ? &#39;null&#39; : dstr));
		if( measurePhrase( status ) &gt; MAXSCREENWIDTH ) { // break up into separate lines
			status = &#39;\n\n&#39; + expandText( &#39;stn_optns_setting_str&#39; ) + &#39;: &#39; + cstr
					 + (range ? &#39;\n&#39; + expandText( &#39;stn_optns_range_str&#39; ) + &#39;:\t\t&#39; + range : &#39;&#39;)
					 + (defawlt === undefined ? &#39;&#39; : &#39;\n&#39; + expandText( &#39;stn_optns_default_str&#39; ) + &#39;:\t\t&#39;
													 + (defawlt === null ? &#39;null&#39; : dstr));
		}

		let controlStr = &#39;&#39;, dependStr = &#39;&#39;, info = optionInfo[ option ];
		if( info.controls.length &gt; 0 ) {
			controlStr = &#39;This option restricts &#39; + info.controls.join( &#39;, &#39; ) + &#39;.&#39;;
		}
		if( info.relyOnOptions.length &gt; 0 ) {
			depends.push.apply( depends, info.relyOnOptions );
			// - like extend in Python, this adds each element
			//   of &#39;relyOnOptions&#39; array to the &#39;depends&#39; array, vs
			//   depends = depends.concat( info.relyOnOptions );
			//   - this returns a NEW array (more garbage)
		}
		if( info.relyOnHostVars.length &gt; 0 ) {
			depends.push.apply( depends, info.relyOnHostVars );
		}
		if( depends.length ) {
			dependStr += &#39;This option depends on &#39; + depends.join( &#39;, &#39; ) + &#39;.&#39;;
		}
		if( controlStr.length || dependStr.length ) {
			controlStr = &#39;\n\n(&#39; + controlStr + (controlStr ? &#39;  &#39;: &#39;&#39;);
			controlStr += dependStr + &#39;)&#39;;
		}

		src += status + controlStr + (errmsg ? &#39;\n\n&#39; + errmsg : &#39;&#39;);
		scrollText( rtnobj, src, option,				// input screens have 1 button; either &#39;more&#39; button or input line
					btn_count + 1,						// + 1 for button below
					!!errmsg );							// errmsg makes endOfPage true, keeping user @ bottom of page
		screen.message = rtnobj.message;
		let rtn_key = rtnobj.choice_key;
		choices[ rtn_key ] = rtnobj.choice_value;		// choices are ignored when textEntry is true
		screen.textEntry = textEntry &amp;&amp; rtn_key !== &#39;ZZ_more&#39;;

		if( isSuppressed ) {
			// top level/externally dependent options will still be listed
			// - make all but the exit button unselectable
			screen.initialChoicesKey = rtn_key;
			for( let choice in choices ) {
				if( choices.hasOwnProperty( choice ) ) {
					if( choice !== rtn_key ) {
						choices[ choice ].color = expandText( &#39;stn_optns_notInUse_color&#39; ) || &#39;darkGrayColor&#39;;
						choices[ choice ].unselectable = true;
					}
				}
			}
		} else {
			screen.initialChoicesKey = initialChoice || rtn_key;
		}
	}
// : &#39; +  + &#39;

	// object for return values of scrollText, used by all the _choose* fns via mkChoicePage()
	var rtnobj = {};

	function resetOptionChoices( choices ) {
		initButtons();									// update button text for oxp override
		var defaultColor = expandText( &#39;stn_optns_default_color&#39; ) || &#39;yellowColor&#39;;
		for( var x in choices ) {						// re-use choices object
			if( choices.hasOwnProperty( x ) ) {
				choices[ x ].unselectable = false;
				choices[ x ].color = defaultColor;
				if( isCommonButton( x ) ) {				// are common buttons, always present
					continue;
				}
				if( x !== &#39;ZZ_more&#39; ) {					// is set after scrollText
					freeChoice( choices[ x ] );
				}
				delete choices[ x ];
			}
		}
	}

	function chooseText( errmsg ) {
		var that = chooseText;
		var choices = (that.choices = that.choices || {});	// re-used for runScreen; kept local to fn as static keys retained
		var screen = (that.screen = that.screen || {});		//	 &quot;
		var option = currentChoice.option,
			type = currentChoice.type;

		if( !screen.hasOwnProperty( &#39;exitScreen&#39; ) ) {	// first time, create static part
			screen.exitScreen = &#39;GUI_SCREEN_INTERFACES&#39;;
			screen.choices = choices;
		} else {
			resetOptionChoices( choices );
		}
		screen.screenID = &#39;stn_optns_chooseText_&#39; + keyPrefix + option;
		if( type === &#39;display&#39; ) {
			let title = expandText( keyPrefix + option );
			screen.title = title.slice( title.indexOf( &#39;)&#39; ) + 1 ).trim(); // skip over option type parameters
			let src = expandText( keyPrefix + option + &#39;_long&#39; );
			scrollText( rtnobj, src, option, 1 );			// 1 for either &#39;more&#39; or return button
			let choice_key = rtnobj.choice_key;
			choices[ choice_key ] = rtnobj.choice_value;
			screen.message = rtnobj.message;
			screen.initialChoicesKey = choice_key;
			screen.textEntry = false;
			screen.allowInterrupt = changesMade.cag$stnOptsPending === 0;
		} else {
			expandKeys.stn_optns_option_key = option;
			screen.title = expandText( &#39;stn_optns_choose_text&#39;, expandKeys );
			mkChoicePage( rtnobj, screen, choices, 1, null, errmsg ); // initialChoice is null
			screen.allowInterrupt = false;
		}
		mission.runScreen( screen, setChoice.bind( so ) );
	}

	function chooseBoolean() {
		var that = chooseBoolean;
		var choices = (that.choices = that.choices || {});	// re-used for runScreen; kept local to fn as static keys retained
		var screen = (that.screen = that.screen || {});		//	 &quot;
		var option = currentChoice.option,
			lastUsedColor = expandText( &#39;stn_optns_lastUsed_color&#39; ) || &#39;greenColor&#39;;

		if( !screen.hasOwnProperty( &#39;exitScreen&#39; ) ) { 	// first time, create static stuff
			screen.exitScreen = &#39;GUI_SCREEN_INTERFACES&#39;;
			screen.allowInterrupt = false;
			screen.textEntry = false;
			screen.choices = choices;
		} else {
			resetOptionChoices( choices );
		}
		screen.screenID = &#39;stn_optns_chooseBoolean_&#39; + keyPrefix + option;
		// expand everytime to allow oxp override
		choices[ &#39;AA_True&#39; ]  = getChoice( expandText( &#39;stn_optns_boolean_true&#39; ) );
		choices[ &#39;BB_False&#39; ] = getChoice( expandText( &#39;stn_optns_boolean_false&#39; ) );
		if( currentChoice.currently === true ) {
			choices[ &#39;AA_True&#39; ].color = lastUsedColor;
		} else if( currentChoice.currently === false ) {
			choices[ &#39;BB_False&#39; ].color = lastUsedColor;
		}
		expandKeys.stn_optns_option_key = option;
		screen.title = expandText( &#39;stn_optns_choose_boolean&#39;, expandKeys );
		mkChoicePage( rtnobj, screen, choices, 2, null ); // initialChoice is null
		mission.runScreen( screen, setChoice.bind( so ) );
	}

	function chooseNumber( errmsg ) {
		var that = chooseNumber;
		var choices = (that.choices = that.choices || {});	// re-used for runScreen; kept local to fn as static keys retained
		var screen = (that.screen = that.screen || {});		//	 &quot;
		var option = currentChoice.option,
			range = formatRange();

		if( !screen.hasOwnProperty( &#39;exitScreen&#39; ) ) { 	// 1st time through; this part is static
			screen.exitScreen = &#39;GUI_SCREEN_INTERFACES&#39;;
			screen.allowInterrupt = false;
			screen.choices = choices;
		} else {
			resetOptionChoices( choices );
		}
		screen.screenID = &#39;stn_optns_chooseNumber_&#39; + keyPrefix + option;
		expandKeys.stn_optns_option_key = option;
		expandKeys.stn_optns_number_range = range ? range : &#39;&#39;;
		screen.title = expandText( (range !== null ? &#39;stn_optns_choose_number_range&#39;
												   : &#39;stn_optns_choose_number&#39;), expandKeys );
		mkChoicePage( rtnobj, screen, choices, 1, null, errmsg );	// initialChoice is null
		mission.runScreen( screen, setChoice.bind( so ) );
	}

	function chooseVector( errmsg ) {
		var that = chooseVector;
		var choices = (that.choices = that.choices || {});	// re-used for runScreen; kept local to fn as static keys retained
		var screen = (that.screen = that.screen || {});		//	 &quot;
		var option = currentChoice.option;

		if( !screen.hasOwnProperty( &#39;exitScreen&#39; ) ) { 	// 1st time through; this part is static
			screen.exitScreen = &#39;GUI_SCREEN_INTERFACES&#39;;
			screen.allowInterrupt = false;
			screen.choices = choices;
		} else {
			resetOptionChoices( choices );
		}
		screen.screenID = &#39;stn_optns_chooseVector_&#39; + keyPrefix + option;
		expandKeys.stn_optns_option_key = option;
		screen.title = expandText( &#39;stn_optns_choose_vector&#39;, expandKeys );
		mkChoicePage( rtnobj, screen, choices, 1, null, errmsg );	// initialChoice is null
		mission.runScreen( screen, setChoice.bind( so ) );
	}

	function chooseBits( value, current, statusMsg ) {
		var that = chooseBits;
		var choices = (that.choices = that.choices || {});	// re-used for runScreen; kept local to fn as static keys retained
		var screen = (that.screen = that.screen || {});		//	 &quot;
		var option = currentChoice.option,
			defawlt = currentChoice.defawlt,
			min = currentChoice.min,
			max = currentChoice.max,
			buttons, hasDefault = defawlt !== undefined,
			currently = value === undefined ? currentChoice.currently : value;
		var notInUseColor = expandText( &#39;stn_optns_notInUse_color&#39; ) || &#39;darkGrayColor&#39;,
			invalidColor = expandText( &#39;stn_optns_invalid_color&#39; ) || &#39;redColor&#39;,
			lastUsedColor = expandText( &#39;stn_optns_lastUsed_color&#39; ) || &#39;greenColor&#39;;
		var clearAll = expandText( &#39;stn_optns_bitflag_clear_all&#39; ),
			setAll = expandText( &#39;stn_optns_bitflag_set_all&#39; );

		if( !screen.hasOwnProperty( &#39;exitScreen&#39; ) ) {	// first time, create static part
			screen.exitScreen = &#39;GUI_SCREEN_INTERFACES&#39;;
			screen.allowInterrupt = false;
			screen.textEntry = false;
			screen.choices = choices;
		} else {
			resetOptionChoices( choices );
		}
		expandKeys.stn_optns_option_key = option;
		var flags = currentChoice.selection;
		var initialChoice = null;
		if( !flags ) {									// author forgot bitflagStrs (error already reported)
			screen.title = expandText( &#39;stn_optns_choose_number&#39;, expandKeys );
			mkChoicePage( rtnobj, screen, choices, (hasDefault ? 4 : 3), initialChoice, statusMsg );
			mission.runScreen( screen, setChoice.bind( so ) );
			return;
		}
		var idx, len = flags.length,
			allBits = currentChoice.allBits,
			numBits = currentChoice.numBits;
		choices[ &#39;WB_clear_all&#39; ] = getChoice( clearAll );
		if( currently === 0 ) {
			choices[ &#39;WB_clear_all&#39; ].color = notInUseColor;
			choices[ &#39;WB_clear_all&#39; ].unselectable = true;
		}
		choices[ &#39;WA_set_all&#39; ] = getChoice( setAll );
		if( currently === allBits ) {
			choices[ &#39;WA_set_all&#39; ].color = notInUseColor;
			choices[ &#39;WA_set_all&#39; ].unselectable = true;
		}
		screen.screenID = &#39;stn_optns_chooseBits_&#39; + keyPrefix + option;

		let changed = false;
		if( value !== undefined ) {
			let curr_val = getOptionValue( option );
			changed = !equalValue( value, curr_val );
			curr_val = freeValue( curr_val );
		}
		buttons = setCommonButtons( option, changed, hasDefault, choices, true );
		screen.title = expandText( &#39;stn_optns_choose_bitflags&#39;, expandKeys );

		if( numBits === undefined )	{					// needed for &#39;set all flags&#39; cmd
			currentChoice.numBits = numBits = len;		// - may be overridden by range
		}
		if( defawlt === -1 ) {
			currentChoice.defawlt = allBits;
		}
		if( min === null ) {							// no min in range if supplied
			currentChoice.min = min = 0;
		}
		if( max === null ) {							// no max in range if supplied
			currentChoice.max = max = allBits;
		}
		var clearFlag = expandText( &#39;stn_optns_bitflag_clear&#39; ),
			setFlag = expandText( &#39;stn_optns_bitflag_set&#39; );
		for( idx = 0; idx &lt; len; idx++ ) {
			let flag = 1 &lt;&lt; idx;
			let choice = getChoice( flags[ idx ] + &#39;: &#39;
									 + (currently &amp; flag ? setFlag : clearFlag) );
			let unselectable = flag &lt; min || flag &gt; max;
			if( unselectable ) {
				choice.color = invalidColor;
			} else if( currently &amp; flag ) {
				choice.color = lastUsedColor;
			} else {
				choice.color = notInUseColor;
			}
			choice.unselectable = unselectable;
			let choice_key = (idx &lt; 10 ? &#39;0&#39; + idx : idx) + &#39;_&#39; + currently + &#39;_&#39; + flag;
			choices[ choice_key ] = choice;
			if( idx &lt; numBits &amp;&amp; current === flag ) {
				initialChoice = choice_key;
			}
		}
		if( typeof current === &#39;string&#39; &amp;&amp; current.indexOf( &#39;_&#39; ) &gt;= 0 ) { // choice was not an individual bit flag
			initialChoice = current === &#39;WA_set_all&#39; ? &#39;WB_clear_all&#39; :
							current === &#39;WB_clear_all&#39; ? &#39;WA_set_all&#39; : current;
		}
		mkChoicePage( rtnobj, screen, choices, --idx + (hasDefault ? 4 : 3),  // idx + 3 or 4 buttons
						initialChoice, statusMsg );
		mission.runScreen( screen, setChoice.bind( so ) );
	}

	function setCommonButtons( key, needsSave, hasDefault, choices, inclBlank ) {
		// for buttons common to chooseBits &amp; chooseChoice
		var buttons = 0;
		choices[ &#39;YY_save&#39; ] = saveEditButton;
		if( needsSave ) {
			saveEditButton.color = expandText( &#39;stn_optns_default_color&#39; ) || &#39;yellowColor&#39;;
			saveEditButton.unselectable = false;
		} else {
			saveEditButton.color = expandText( &#39;stn_optns_notInUse_color&#39; ) || &#39;darkGrayColor&#39;;
			saveEditButton.unselectable = true;
		}
		buttons++;
		if( hasDefault ) {								// add reset to default button
			choices[ &#39;XX_reset&#39; ] = resetButton;
			buttons++;
		} else {
			delete choices[ &#39;XX_reset&#39; ];
		}
		if( inclBlank ) {
			choices[ &#39;UU_blank&#39; ] = blankLine;
			buttons++;
		} else {
			delete choices[ &#39;UU_blank&#39; ];
		}
		return buttons; // mkChoicePage will add 1 for the return/more button it adds
	}

	function chooseChoice( value, item, listNum, statusMsg ) {
		var that = chooseChoice;
		var choices = (that.choices = that.choices || {});	// re-used for runScreen; kept local to fn as static keys retained
		var screen = (that.screen = that.screen || {});		//	 &quot;
		// args are all undefined when first enter page
		var option = currentChoice.option,
			defawlt = currentChoice.defawlt,
			curr_btn = listNum === undefined ? currentChoice.currently : parseInt( listNum, 10 ),
			buttons, hasDefault = defawlt !== undefined,
			currently = value === undefined ? currentChoice.selection[ currentChoice.currently ] : value,
			lastUsedColor = expandText( &#39;stn_optns_lastUsed_color&#39; ) || &#39;greenColor&#39;;

		if( !screen.hasOwnProperty( &#39;exitScreen&#39; ) ) {	// first time, create static part
			screen.exitScreen = &#39;GUI_SCREEN_INTERFACES&#39;;
			screen.allowInterrupt = false;
			screen.textEntry = false;
			screen.choices = choices;
		} else {
			resetOptionChoices( choices );
		}
		screen.screenID = &#39;stn_optns_chooseChoice_&#39; + keyPrefix + option;

		let changed = false;
		if( value !== undefined ) {						// process user&#39;s selection
			let curr_val = getOptionValue( option );
			let index = currentChoice.selection.indexOf( value );
			changed = !equalValue( index, curr_val );
			curr_val = freeValue( curr_val );
		}

		buttons = setCommonButtons( option, changed, hasDefault, choices, true ); // true adds blank line after choices
		expandKeys.stn_optns_option_key = option;
		screen.title = expandText( &#39;stn_optns_choose_choice&#39;, expandKeys );
		let items = currentChoice.selection,
			idx, len = items.length;
		let initialChoice = null;
		for( idx = 0; idx &lt; len; idx++ ) {
			let selection = items[ idx ];
			let choice = getChoice( typeof selection === &#39;string&#39; &amp;&amp; selection.length === 0 ? &quot;&#39;&#39;&quot; :
									selection === null ? &#39;null&#39; : selection );
			let choice_key = (idx &lt; 10 ? &#39;0&#39; + idx : idx) + &#39;_&#39; + currently + &#39;_&#39; + selection + &#39;_&#39; + idx;
			choices[ choice_key ] = choice;
			if( idx === curr_btn ) {
				choice.color = lastUsedColor;
			}
			if( listNum !== undefined &amp;&amp; idx === curr_btn ) {
				initialChoice = choice_key;
			}
		}
		if( item === &#39;XX_reset&#39; || item === &#39;YY_save&#39; ) { // choice was not an item
			initialChoice = item;
		}
		mkChoicePage( rtnobj, screen, choices, len + buttons, initialChoice, statusMsg );
		mission.runScreen( screen, setChoice.bind( so ) );
	}

	function setChoice( choice ) {						// for selection made in an option&#39;s specific page
		var that = setChoice;
		var vector = (that.vector = that.vector || []);
		var errmsg = (that.errmsg = that.errmsg || &#39;&#39;);
		vector.length = 0;

		try {
			var currValue = that.currValue;
			var parse, value = null,
				option = currentChoice.option,
				type = currentChoice.type,
				defawlt = currentChoice.defawlt,
				currently = currentChoice.currently,
				isSuppressed = optionInfo[ option ].isSuppressed;

// log(&#39;setChoice, ===&gt; &#39; + cd._showProps(choice, &#39;choice&#39;,0,1));
			refreshSOKeys();
			switch( true ) {
				case choice === &#39;ZZ_more&#39;:
						 if( type === &#39;text&#39; || type === &#39;display&#39; )   chooseText( errmsg );
					else if( type === &#39;toggle&#39; )					   chooseBoolean();
					else if( type === &#39;number&#39; || type === &#39;decimal&#39; ) chooseNumber( errmsg );
					else if( type === &#39;vector&#39; )					   chooseVector( errmsg );
					else if( type === &#39;bitflags&#39; )					   chooseBits();
					else if( type === &#39;choice&#39; )					   chooseChoice();
					else
						log( so.name, &#39;setChoice, unknown type = &#39; + type );
					return;

				case isSuppressed:
					break;

				case choice === &#39;null&#39;:
					setOptionValue( option, null );
					break;

				case !choice || choice.length === 0:
					that.errmsg = errmsg = &#39;&#39;;
					scroller.stop();
					displayOptions( &#39;ZZ_abort&#39; );
					return;

				case choice === &#39;+&#39;:
				case type === &#39;text&#39;:
					if( choice === &#39;+&#39; &amp;&amp; defawlt !== undefined ) {
						resetOptionValue( option );
						break;
					}
					that.errmsg = errmsg = &#39;&#39;;
					if( choice === &quot;&#39;&#39;&quot; ) {
						setOptionValue( option, &#39;&#39; );
						break;
					}
					if( choice.indexOf( &quot;&#39;&quot; ) &gt;= 0 ) { 	// ensure they match
						let quotes = choice.match( quoteStripper );
						if( quotes === null ) {
							that.errmsg = errmsg = expandText( &#39;stn_optns_bad_match_quote&#39; ) + &quot; &#39;&quot;;
							chooseText( errmsg );
							return;
						}
					}
					if( choice.indexOf( &#39;&quot;&#39; ) &gt;= 0 ) { 	// ensure they match
						let quotes = choice.match( dblQuoteStripper );
						if( quotes === null ) {
							that.errmsg = errmsg = expandText( &#39;stn_optns_bad_match_quote&#39; ) + &#39; &quot;&#39;;
							chooseText( errmsg );
							return;
						}
					}
					setOptionValue( option, choice );
					break;

				case type === &#39;display&#39;:
					scroller.stop();
					displayOptions( &#39;ZZ_return&#39; );
					return;

				case type === &#39;toggle&#39;:
					if( choice === &#39;AA_True&#39; &amp;&amp; currently !== true ) {
						setOptionValue( option, true );
					} else if( choice === &#39;BB_False&#39; &amp;&amp; currently !== false ) {
						setOptionValue( option, false );
					}
					break;

				case type === &#39;number&#39; || type === &#39;decimal&#39;:
					that.errmsg = errmsg = &#39;&#39;;
					value = checkValue( choice, currentChoice, option );
					if( currentChoice.error ) {
						let reason;
						if( currentChoice.error.indexOf( expandText( &#39;stn_optns_parse_err&#39; ) ) &gt;= 0 ) {
							if( choice.match( parseDecimal ) ) {
								reason = expandText( &#39;stn_optns_decimal_not_number&#39; );
							} else {
								reason = expandText( &#39;stn_optns_bad_type&#39; ) + &#39; &#39; + type;
							}
						}
						that.errmsg = errmsg = expandText( &#39;stn_optns_bad_entry&#39; ) 
									+ &#39; &quot;&#39;  + choice + &#39;&quot;, &#39; + reason;
						chooseNumber( errmsg );
						return;
					}
					value = valueInRange( value, currentChoice );
					if( typeof value === &#39;string&#39; )	 {
						that.errmsg = errmsg = value;
						chooseNumber( errmsg );
						return;
					}
					setOptionValue( option, value );
					break;

				case type === &#39;vector&#39;:
					that.errmsg = errmsg = &#39;&#39;;
					value = checkValue( choice, currentChoice, option );
					if( currentChoice.error ) {
						freeArray( value );
						that.errmsg = errmsg = expandText( &#39;stn_optns_bad_entry&#39; ) + &#39; &quot;&#39; + choice 
									+ &#39;&quot;, &#39; + expandText( &#39;stn_optns_bad_type&#39; ) + &#39; &#39; + type;
						chooseVector( errmsg );
						return;
					}
					for( let idx = 0, len = value.length; idx &lt; len; idx++ ) {
						let test = valueInRange( value[ idx ], currentChoice );
						if( typeof test === &#39;string&#39; ) {
							errmsg += (errmsg.length &gt; 0 ? &#39;\n&#39; : &#39;&#39;) + test;
						} else {
							vector.push( test );
						}
					}
					freeArray( value );
					if( errmsg.length &gt; 0 ) {
						that.errmsg = errmsg;
						chooseVector( errmsg );
						return;
					}
					setOptionValue( option, getArray( vector ) );
					break;

				case type === &#39;bitflags&#39;:
					parse = choice.split( &#39;_&#39; ); 		// choices encoded as index_value_flag
					let bits = parseInt( parse[ 1 ], 10 ),
						flag = parseInt( parse[ 2 ], 10 ),
						min = currentChoice.min,
						max = currentChoice.max;
					freeArray( parse );
					if( choice === &#39;WA_set_all&#39;
							|| choice === &#39;WB_clear_all&#39; ) { // can&#39;t use -1; only set known bits
						flag = choice;
						if( currValue === undefined ) {
							currValue = getOptionValue( option );
						}
						let startBit = min ? min.toString(2).length - 1 : 0;
						let stopBit	 = max ? max.toString(2).length
										   : currentChoice.numBits.toString(2).length;
						for( let idx = startBit; idx &lt; stopBit; idx++ ) {
							let bit = 1 &lt;&lt; idx;
							currValue = choice === &#39;WA_set_all&#39; ? currValue | bit
																: currValue &amp; ~bit;
						}
					} else if( choice === &#39;YY_save&#39; ) {
						setOptionValue( option, currValue );
						delete that.currValue;			// reset for next option&#39;s use
						break;
					} else if( choice === &#39;XX_reset&#39; ) {
						flag = choice;
						currValue = defawlt;
					} else if( choice === &#39;ZZ_return&#39; ) {
						delete that.currValue;			// reset for next option&#39;s use
						break;
					} else {
						currValue = bits ^ flag;
					}
					that.currValue = currValue;
					chooseBits( currValue, flag, expandText( &#39;stn_optns_curr_flags&#39; ) + &#39;: &#39; + currValue );
					return;

				case type === &#39;choice&#39;:
					// choices encoded as index_value_item_btn# (value can have spaces!)
					parse = choice.split( &#39;_&#39; );
					let item = parse[ 2 ],
						num = parse[ 3 ];
					freeArray( parse );
					if( choice === &#39;YY_save&#39; ) {
						// &#39;number&#39; =&gt; assumed to be index into choices
						if( typeof currValue === &#39;number&#39; ) {
							setOptionValue( option, currValue );
						} else {
							setOptionValue( option, currentChoice.selection.indexOf( currValue ) );
						}
						delete that.currValue;			// reset for next option&#39;s use
						break;
					} else if( choice === &#39;ZZ_return&#39; ) {
						delete that.currValue;			// reset for next option&#39;s use
						break;
					} else if( choice === &#39;XX_reset&#39; ) {
						item = choice;
						if( typeof defawlt === &#39;number&#39; ) { // defawlt can be either index or one of the choices
							currValue = defawlt;
						} else {
							currValue = currentChoice.selection.indexOf( defawlt );
						}
					} else {
						currValue = item;
						// as choices can be defined as list of string or list of number,
						// use currentChoice.selection to coerce value
						if( typeof currentChoice.selection[0] === &#39;number&#39; ) {
							// value always arrives as string, as it&#39;s encoded in button name
							currValue = currValue.indexOf(&#39;.&#39;) == -1
										? parseInt( currValue, 10 ) : parseFloat( currValue );
						}
					}
					that.currValue = (typeof currValue === &#39;string&#39;
									  &amp;&amp; currValue.length === 0 ? &quot;&#39;&#39;&quot; : currValue);
					chooseChoice( currValue, item, num,
								  expandText( &#39;stn_optns_curr_choice&#39; ) + &#39;: &#39; +
									(typeof currValue === &#39;number&#39; ? currentChoice.selection[ currValue ]
																   : currValue) );
					return;
			}
			that.errmsg = errmsg = &#39;&#39;;
			scroller.stop();
			displayOptions();
		} catch( err ) {
			log( so.name, so._reportError( err, setChoice, choice ) );
			throw err;
		}
	}

	function valueInRange( value, choiceObj ) {
		var min = choiceObj.min,
			max = choiceObj.max;

		var error = &#39;range&#39;;
		do {
			if( min !== null &amp;&amp; value &lt; min )
				break;
			if( max !== null &amp;&amp; value &gt; max )
				break;
			error = &#39;lowest&#39;;
			if( min === null &amp;&amp; lowestValue !== null &amp;&amp; value &lt; lowestValue )
				break;
			error = &#39;highest&#39;;
			if( min === null &amp;&amp; highestValue !== null &amp;&amp; value &gt; highestValue )
				break;
			return value;
		} while( false );
		let msg = expandText( &#39;stn_optns_bad_range_prefix&#39; ) + &#39; &quot;&#39; + value + &#39;&quot; &#39;;
		if( error === &#39;range&#39; ) {
			msg += expandText( &#39;stn_optns_bad_range_suffix&#39; ) + &#39; &#39; + (min || &#39;&#39;) + &#39; : &#39; + (max || &#39;&#39;);
		} else if( error === &#39;lowest&#39; ) {
			msg += expandText( &#39;stn_optns_bad_range_lowest&#39; ) + &#39; &#39; + lowestValue;
		} else if( error === &#39;highest&#39; ) {
			msg += expandText( &#39;stn_optns_bad_range_highest&#39; ) + &#39; &#39; + highestValue;
		}
		return msg;
	}

	///////////////////////////////////////////////////////////////////////////////
	// option &amp; page scrolling ////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////

// : &#39; +  + &#39;
	var pageTemplate = { &#39;start&#39;: -1,  &#39;count&#39;: -1, &#39;lastShown&#39;: false };

	function Scroller() {
		this.pageInfo = [];
	}
	Scroller.prototype.start = function() {
		this.pageInfo.push( getObject( pageTemplate ) );
// this._report(&#39;start&#39;);
	}
	Scroller.prototype.stop = function() {
		freeObject( this.pageInfo.pop() );
// this._report(&#39;stop&#39;);
	}
	Scroller.prototype.reset = function( count ) {
		for( let idx = 0, len = this.pageInfo.length; idx &lt; len; idx++ ) {
			freeObject( this.pageInfo[ idx ] );
		}
		this.pageInfo.length = 0;
		this.pageInfo.push( getObject( pageTemplate ) );
		if( count !== undefined )
			this.pageInfo[ 0 ].count = count;			// preserve # options as it&#39;s dynamic
// this._report(&#39;reset&#39;);
	}
	Scroller.prototype._restart = function( count ) {
		var level = this.pageInfo.length - 1;
		this.pageInfo[ level ].start = 0;
		this.pageInfo[ level ].count = count;			// preserve # options as it&#39;s dynamic
		this.pageInfo[ level ].lastShown = false;
// this._report(&#39;_restart&#39;);
		return 0;										// convenience return
	}
	Scroller.prototype._bottomJustify = function( lines, count ) {
		var level = this.pageInfo.length - 1;
		var start = count &lt;= lines ? 0 : count - lines;
		this.pageInfo[ level ].start = start &lt; 0 ? 0 : start;
		this.pageInfo[ level ].count = count;			// preserve # options as it&#39;s dynamic
		this.pageInfo[ level ].lastShown = true;
// this._report(&#39;_bottomJustify&#39;);
		return start;									// convenience return
	}
	Scroller.prototype.curr = function( count, lines, see ) {
		var level = this.pageInfo.length - 1;
		var start = this.pageInfo[ level ].start;
		if( start &lt; 0 ) {								// 1st time through
			return this._restart( count );
		}
		if( start &gt;= count ) {							// page shrunk
			return this._bottomJustify( lines, count );
		}
		// set start so see is visible
		var new_start = start;
		if( see &lt; start ) {								// make see the first line
			new_start = see;
		} else if( start + lines &lt;= see ) {				// make see the final line
			new_start = see - lines + 1;
		}
		if( new_start &lt; 0 ) {
			new_start = 0;
// this._report(&#39;curr&#39;);
		} else if( new_start + lines &gt;= count ) {		// mixing 0-based indices and 1-based amounts
// this._report(&#39;curr&#39;);
			return this._bottomJustify( lines, count );
		}
		this.pageInfo[ level ].start = new_start;
		this.pageInfo[ level ].count = count;
		this.pageInfo[ level ].lastShown = new_start + lines &gt; count - 1;
// this._report(&#39;curr&#39;);
		return new_start;
	}
	Scroller.prototype.incr = function() {
		var level = this.pageInfo.length - 1;
		var start = this.pageInfo[ level ].start;
		this.pageInfo[ level ].start = start + 1;
// this._report(&#39;incr&#39;);
	}
	Scroller.prototype.decr = function() {
		var level = this.pageInfo.length - 1;
		var start = this.pageInfo[ level ].start;
		this.pageInfo[ level ].start = start &gt; 0 ? start - 1 : 0;
// this._report(&#39;decr&#39;);
	}
	Scroller.prototype.next = function( count, lines, endOfPage ) {
		var level = this.pageInfo.length - 1;
		var start = this.pageInfo[ level ].start;
		var new_start;
		if( start &lt; 0 || count &lt;= lines ) {				// 1st time on page OR fits w/o scrolling
			new_start = 0;
		} else if( endOfPage ) {					 	// stay at bottom
			return this._bottomJustify( lines, count );
		} else if( this.pageInfo[ level ].lastShown ) {	// displayed bottom, return to top
			return this._restart( count );
		} else {										// count &gt; lines, must scroll
			new_start = start + lines;					// next page
			if( new_start + lines &gt;= count ) {			// mixing 0-based indices and 1-based amounts
				return this._bottomJustify( lines, count );
			}
		}
		this.pageInfo[ level ].start = new_start;
		this.pageInfo[ level ].count = count;
		this.pageInfo[ level ].lastShown = new_start + lines &gt; count - 1;
// this._report(&#39;next&#39;);
		return new_start;
	}
	Scroller.prototype._report = function( caller ) {
		var stack = this.pageInfo.length;
		log(&#39;    .&#39; + mission.screenID + &#39;, &#39; + caller + &#39;, stack has &#39; + stack );
		if( stack === 1 	|| true) {
			// _showProps( obj, objName, newLine, show_deep, expand_arrays, show_type )
			log( cd._showProps(this.pageInfo, &#39;stack&#39;, 1,2,1) );
		}
	}
	Scroller.prototype.constructor = Scroller;
	var scroller = new Scroller();

	function scrollText( rtnobj, src, option, buttons, endOfPage ) {
		var that = scrollText;
		var pg_srclen = (that.pg_srclen = that.pg_srclen || {});  // cache srclen to detect if it changes

		var lastPage, startLine = 0,
			srclen = src.length,
			choice_key, choice_value;					// for buttons &amp; blank line
		let cacheKey = keyPrefix + option;
		if( !pg_srclen.hasOwnProperty( cacheKey )		// haven&#39;t measured
				|| pg_srclen[ cacheKey ] !== srclen ) {	// or srclen changed, remeasure
			measureText( option, src );
			pg_srclen[ cacheKey ] = srclen;
		}
		var textInfo = textIndices[ keyPrefix ][ option ];
		var totalLines = textInfo.length;
		var lines = MAXSCREENLINES - buttons - 1;		// -1 for blank line above button
		startLine = scroller.next( totalLines, lines - 1, endOfPage );// -1 to repeat last line of previous page
		lastPage = endOfPage || ( totalLines - startLine &lt;= lines );
		let topIsBlank = true;
		do {											// don&#39;t start page with a blank line
			if( !textInfo || startLine &gt;= textInfo.length )
				break;
			let sol = textInfo[ startLine ][ 0 ],
				eol = textInfo[ startLine ][ 1 ];
			for( let ti = sol; ti &lt; eol; ti++ ) {
				let chr = src[ ti ];
				if( chr !== &#39; &#39; &amp;&amp; chr !== &#39;\t&#39; ) {
					topIsBlank = false;
					break;
				}
			}
			if( topIsBlank ) {
				// scroll backwards so last line of previous page starts this page
				if( totalLines - startLine &gt; lines ) {
					startLine--;
					scroller.decr();
				} else { // except when it&#39;s the last page (else loop forever!)
					startLine++;
					scroller.incr();
				}
			}
		} while( topIsBlank &amp;&amp; startLine &lt; totalLines );

		if( formatting ) {
			formattedPage.length = 0;
			formatEols( src, textInfo, startLine, lines );
			rtnobj.message = formattedPage.join( &#39;\n&#39; );
		} else {
			let start = textInfo[ startLine ][ 0 ];
			let lastln = startLine + lines - 1;
			lastln = lastln &gt; totalLines - 1 ? totalLines - 1 : lastln;
			let end = textInfo[ lastln ][ 1 ];
			rtnobj.message = src.slice( start, end );
		}
		if( startLine + lines &lt; totalLines ) {			// more to show after this page
			choice_key = &#39;ZZ_more&#39;;
			choice_value = scrollButton;
		} else { // it&#39;s less than a full page or we&#39;re at the bottom
			choice_key = &#39;ZZ_return&#39;;
			expandKeys.stn_optns_continue_key = expandText( keyPrefix + pageLabels[ currentScreenIdx ] + &#39;_title&#39; );
			choice_value = getChoice( expandText( &#39;stn_optns_option_continue&#39;, expandKeys ) );
		}
		rtnobj.choice_key = choice_key;
		rtnobj.choice_value = choice_value;
		return totalLines;
	}

	function measureWord( word ) {
		var that = measureWord;
		var cache = (that.cache = that.cache || {});

		if( !cache.hasOwnProperty( word ) ) {
			cache[ word ] = strFontLen( word );
		}
		return cache[ word ];
	}

	function measurePhrase( str, start, end ) { 		// measure all char.s but &#39;\n&#39;s
														// called by measureText &amp; mkChoicePage (for status line)
		var that = measurePhrase;
		var phrase = (that.phrase = that.phrase || []);
		phrase.length = 0;

		if( start &gt;= end )
			return 0;
		var dst = 0, src = start || 0, len = str.length;
		if( !end || end &gt; len ) {
			end = len;
		}
		while( src &lt; end ) {
			let chr = str[ src ];
			if( chr !== &#39;\n&#39; )
				phrase[ dst++ ] = chr;
			src++;
		}
		// for arrays, defaultFont.measureString assumes spaces between each element
		return strFontLen( phrase ) - (phrase.length - 1) * SpaceLen;
	}

	var textIndices = {}; 		// cache ends of each line so only measure once
	var formattedPage = [];
	var wordSplitter = /[ \t\n]+/;

	function measureText( option, str ) { 				// measure str from start, store index of line ends
		// the way the core source reads, if a &#39;\n&#39; is encountered before a line is forced to wrap,
		// all its spaces are preserved.  But if it&#39;s long enough that it must be formatted, it gets
		// tokenized (so all runs of space char.s are replaced with a single space char), up to the point
		// where the remainder won&#39;t wrap, after which spaces are again preserved.
		// see addLongText in GuiDisplayGen.m
		var that = measureText;
		var CRs = (that.CRs = that.CRs || []);
		CRs.length = 0;

		var lines = 0, eolCache, index,
			strlen = str.length;
		if( !textIndices.hasOwnProperty( keyPrefix ) ) {// create entry for oxp
			textIndices[ keyPrefix ] = getObject();
		}
		let oxpCache = textIndices[ keyPrefix ];
		if( !oxpCache.hasOwnProperty( option ) ) {		// create entry for this block of text
			oxpCache[ option ] = getArray();
		} else {										// we&#39;re re-measuring, toss previous entry
			oxpCache[ option ].length = 0;
		}
		eolCache = oxpCache[ option ];
		for( index = 0; index &lt; strlen; index++ ) {		// find all newline chars
			let idx = str.indexOf( &#39;\n&#39;, index );
			if( idx &lt; 0 ) break;
			CRs.push( idx );
			index = idx;
		}
		if( index &lt; strlen ) {							// append newline if necessary
			CRs.push( strlen );
		}
		index = 0;
		var end, chr, format, lineF, wordF, currCR,
			tokenizing, lastCR = 0;
		for( var ci = 0, len = CRs.length; ci &lt; len; ci++ ) {
			tokenizing = false;
			end = currCR = CRs[ ci ];
			chr = str[ end ];
			while( end &gt; lastCR &amp;&amp; (chr === &#39; &#39; || chr === &#39;\t&#39; || chr === &#39;\n&#39;) ) {
				end--;									// strip trailing spaces
				chr = str[ end ];
			}
			if( end !== CRs[ ci ] ) {
				end++;									// always point at char after last
			}
			lineF = measurePhrase( str, index, end );
			format = floor(lineF / MAXSCREENWIDTH) &gt; 0;	// # line needing formatting
			tokenizing = format;
			let wi = 0, words = str.slice( index, end ).split( wordSplitter ),
				wlen = words.length;
			while( index &lt;= end ) {						// &lt;= vs &lt; so we preserve imbedded \n char&#39;s
				if( !format ) {							// output as is
					eolCache.push( [index, currCR, lineF, (tokenizing ? null : false)] );
					lines++;
					index = currCR + 1;					// +1 to start of next line; currCR is a &#39;\n&#39; char
					break;
				} else {								// tokenized output until one line full
					lineF = 0; wordF = 0;
					let startIndex = index, fullLine = null;
					for( ; wi &lt; wlen; wi++ ) {
						let word = words[ wi ];
						wordF = measureWord( word );
						if( wordF &gt; MAXSCREENWIDTH ) {	// it happens, I did it my own self!
							let wdIdx = str.indexOf( word ),
								wdlen = word.length;
							if( lineF &gt; 0 ) {
								eolCache.push( [startIndex, wdIdx, lineF, null] );
								lines++;
								lineF = 0;
							}
							eolCache.push( [wdIdx, wdIdx + wdlen, wordF, false] );
							wdIdx += wdlen;
							eolCache.push( [wdIdx, wdIdx, 0, &#39;stub&#39;] );
							lines += 2;					// core just outputs it and it&#39;ll create a blank line
							startIndex = wdIdx;
							continue;
						}
						if( lineF + SpaceLen + wordF &gt; MAXSCREENWIDTH ) { // word won&#39;t fit
							fullLine = true;
							break;
						}
						if( lineF === 0 ) {
							lineF = wordF;
						} else {
							lineF += SpaceLen + wordF;
						}
						if( wi &lt; wlen - 1 ) {
							index = str.indexOf( words[ wi + 1 ], index + word.length );
						} else {						// no more words
							index = currCR + 1;			// skip the return, break from while loop
						}
					} // end for line
					eolCache.push( [startIndex, index - 1, lineF, fullLine] );
					lineF = measurePhrase( str, index, end );
				} // endif !format
				lines++;
				format = floor(lineF / MAXSCREENWIDTH) &gt; 0;
			} // end while( index &lt;= end ), ie. an input line
			lastCR = currCR;
		} // end for loop over all CRs

		return lines;
	}

	function removeDups( list1, list2 ) {				// remove dups so each member is unique; list2 bows to list1
		if( !list1 )
			return;
		var list = list2 || list1;
		var lstlen = list.length;
		while( lstlen-- ) {
			let item = list[ lstlen ];
			let idx = list1.indexOf( item );
			if( (!list2 &amp;&amp; idx !== lstlen)
					|| (list2 &amp;&amp; idx &gt;= 0) ) {			// splice creates garbage, so remove it manually
				let started = list.length;
				for( let li = lstlen; li &lt; started; li++ ) {
					list[ li ] = list [ li + 1 ];
				}
				list.length = started - 1;
			}
		}
	}

	function compareNumbers( a, b ) { return a - b; }	// sort function

	const TRAILERS = &quot;,.;:})?!&quot;;
	function formatEols( str, strLines, start, lines ) {
		var that = formatEols;
		var fmtLn = (that.fmtLn = that.fmtLn || []);
		var primeBreaks = (that.primeBreaks = that.primeBreaks || []);	// indices of prime spaces for expansion
		var pettyBreaks = (that.pettyBreaks = that.pettyBreaks || []);	// indices of lesser spaces
		var lnNum = 0,	strLinesLen = strLines.length,
//			  strlen = str.length,	//cagfmt
			currLine = start,
			cutoff = start + lines &lt; strLinesLen ? start + lines : strLinesLen;

//log( so.name, &#39;formatEols, currLine = &#39; + currLine + &#39;, cutoff = &#39; + cutoff + &#39;, strLinesLen = &#39; + strLinesLen //cagfmt
//	  + &#39;, lines = &#39; + lines + &#39;, SpaceLen = &#39; + SpaceLen.toFixed(3) ); //cagfmt
//let debug = false, cag = &#39;&#39;; //cagfmt

		var sol, eol, lineF, tokenized, fullStretch, lastChI, wdStart;
		while( lnNum &lt; lines &amp;&amp; currLine &lt; cutoff &amp;&amp; currLine &lt; strLinesLen ) {
			primeBreaks.length = 0;
			pettyBreaks.length = 0;

			// each item in strLines has:
			//	index of 1st char, index of eol char, font length from 1st to eol char, and
			//	whether it was tokenized: false vs true, null, where null indicats a non-tokenized
			//	line generated by line breaks (not str input), the difference being that false
			//	leaves any leading whitespace while null strips it
			[sol, eol, lineF, tokenized] = strLines[ currLine ];
			if( tokenized === &#39;stub&#39; ) {						// it&#39;s a stub for a wordF &gt; MAXSCREENWIDTH
				currLine++;										//	 to account for blank line generated when core
				continue;										//	 outputs an overlong text line
			}

//debug = str.slice( sol, eol ).indexOf( &#39;2013.03.31.&#39; ) &gt;= 0; //cagfmt
////debug = debug || str.slice( sol, eol ).indexOf( &#39;(OXP Performance&#39; ) &gt;= 0; //cagfmt
//cag = &#39;&#39;; //cagfmt

//cag += &#39;sol = &#39; + sol + &#39;, eol = &#39; + eol + &#39;, lineF = &#39; + lineF.toFixed(3) + &#39;, tokenized = &#39; + tokenized + &#39;\n&#39;; //cagfmt
//cag += &#39;&quot;&#39; + str.slice(sol,eol).replace(/\n/g, &#39;cR&#39;).replace(/\t/g, &#39;tB&#39;) + &#39;&quot;\n&#39;; //cagfmt
			let spaces = 0, doubleSpc = 0,
				slack = floor((MAXSCREENWIDTH - lineF) / SpaceLen);// in spaces
//cag += &#39;initial slack = &#39; + slack; //cagfmt

			fullStretch = tokenized === true ? true :
						  tokenized === null ? lineF &gt; MAXSCREENWIDTH * 0.8 : false;
			if( tokenized === null &amp;&amp; !fullStretch ) {			// last line in a paragraph
				slack = floor(slack * lineF / MAXSCREENWIDTH);	// don&#39;t over-stretch short lines
			}
			lastChI = eol - 1;									// eol always points at &#39; &#39;, &#39;\n&#39; or = strllen
			wdStart = -1;

//if( eol &lt; strlen &amp;&amp; str[eol] !== &#39;\n&#39; &amp;&amp; str[eol] !== &#39; &#39; )  //cagfmt
//	  cag += &#39;\neol is OFF, point @ &quot;&#39; + str[eol] + &#39;&quot;, eol = &#39; + eol  //cagfmt
//		  + &#39;...&#39; + str.slice(eol-20, eol).replace(/\n/g, &#39;cR&#39;) //cagfmt
//		  + &#39;|&#39; + str[eol] + &#39;|&#39; //cagfmt
//		  + str.slice(eol+1, eol+20).replace(/\n/g, &#39;cR&#39;) + &#39;...&#39; //cagfmt
//		  ; //cagfmt

			while( str[ lastChI ] === &#39; &#39; || str[ lastChI ] === &#39;\t&#39; ) {
				lastChI--;			// index of last non-space char
			}
//cag += &#39;, lastChI = &#39; + lastChI + &#39;, slack: &#39; + slack + &#39;\n&#39;; //cagfmt
			fmtLn.length = 0;
			for( let si = sol, fl = 0; si &lt;= lastChI; si++ ) {	// copy a line
				let chr = str[ si ];
				if( chr === &#39; &#39; || chr === &#39;\t&#39; ) {
					if( tokenized !== false &amp;&amp; fl === 0 )		// gobble leading whitespace
						continue;
					if( wdStart &gt; 0 &amp;&amp; fl - wdStart &lt; 3 ) {		// short word, cannot be 1st one
						pettyBreaks.unshift( wdStart - 1 );		// space before word
						pettyBreaks.push( fl );					//	 unshift as prefer space before if can&#39;t have both
					}
					wdStart = -1;
					spaces++;									// count breaks for doubling up on spaces
					if( tokenized !== false ) {
						fmtLn[ fl++ ] = &#39; &#39;;
						while( si + 1 &lt; lastChI ) {
							let nchr = str[ si + 1 ];
							if( nchr !== &#39; &#39; &amp;&amp; nchr !== &#39;\t&#39; )
								break;
							si++;								// discard extra whitespace if tokenized
						}
						continue;
					}
				}
				if( wdStart &lt; 0 ) {
					wdStart = fl;
				}
				fmtLn[ fl ] = chr;
				if( tokenized === false ) {						// leave line untouched
					fl++;
					continue;
				}
				let prev = si &gt; sol ? str[ si - 1 ] : null;
				let next = si &lt; lastChI ? str[ si + 1 ] : null;
				if( si + 1 &lt; lastChI &amp;&amp; TRAILERS.indexOf( chr ) &gt;= 0 ) { // + 1 to avoid eol
					if( next === &#39; &#39; || next === &#39;\t&#39; )
						primeBreaks.unshift( fl + 1 );			// trailing punctuation
				}
				if( si - 1 &gt; sol &amp;&amp; (chr === &#39;(&#39; || chr === &#39;{&#39; )) { // - 1 to avoid sol
					if( prev === &#39; &#39; || prev === &#39;\t&#39;  )
						primeBreaks.push( fl - 1 );				// leading punctuation
				}
				if( chr === &quot;&#39;&quot; ) {
					if( next === &#39; &#39; || next === &#39;\t&#39;  ) {		// closing quote
						if( si + 1 &lt; lastChI ) pettyBreaks.push( fl + 1 );
					} else if( prev === &#39; &#39; || prev === &#39;\t&#39; ) {// opening quote
						if( si - 1 &gt; sol ) pettyBreaks.unshift( fl - 1 );
					}	//	else it&#39;s an apostrophe, do nothing
				}
				if( chr === &#39;\\&#39; &amp;&amp; next === &#39;&quot;&#39; ) {	// escaped quotes (? any others) %%
					let next2 = si + 1 &lt; lastChI ? str[ si + 2 ] : null;
					if( next2 === &#39; &#39; || next2 === &#39;\t&#39;	 ) {	// closing quote
						if( si + 2 &lt; lastChI ) pettyBreaks.push( fl + 2 );
					} else if( prev === &#39; &#39; || prev === &#39;\t&#39; ) {// opening quote
						if( si - 1 &gt; sol ) pettyBreaks.unshift( fl - 1 );
					}
				}
				if( chr === &#39;%&#39; &amp;&amp; si + 1 &lt;= lastChI ) {		 // oolite plist support &#39;%&#39; escaping for brackets []
					let nextChr = str[ si + 1 ];
					if( nextChr === &#39;]&#39; ) pettyBreaks.push( fl + 1 );
					if( nextChr === &#39;[&#39; ) pettyBreaks.unshift( fl - 1 );
				}
				fl++;
			}

//cag += &#39;\nprimeBreaks: &#39; + primeBreaks.length + &#39;\n&#39;; //cagfmt
//let cagsln = fmtLn.join(&#39;&#39;); //cagfmt
//for( let idx = 0, len = primeBreaks.length; idx &lt; len; idx++ ) { //cagfmt
//	  let prime = primeBreaks[idx]; //cagfmt
//	  cag += &#39;, &#39; + prime + &#39;: &quot;&#39; + cagsln.slice(prime, prime + 10).replace(/\n/g, &#39;cR&#39;) + &#39;&quot;&#39;; //cagfmt
// } //cagfmt
//cag += &#39;\npettyBreaks: &#39; + pettyBreaks.length + &#39;\n&#39;; //cagfmt

//for( let idx = 0, len = pettyBreaks.length; idx &lt; len; idx++ ) { //cagfmt
//	  let petty = pettyBreaks[idx]; //cagfmt
//	  cag += &#39;, &#39; + petty + &#39;: &quot;&#39; + cagsln.slice(petty, petty + 10).replace(/\n/g, &#39;cR&#39;) + &#39;&quot;&#39;; //cagfmt
// } //cagfmt
//cag += &#39;\n&#39;; //cagfmt

			if( tokenized !== false ) {
				removeDups( primeBreaks );
				removeDups( pettyBreaks );
				removeDups( primeBreaks, pettyBreaks );
// _showProps( obj, objName, newLine, show_deep, expand_arrays, show_type )
//cag += cd._showProps( primeBreaks, &#39;primeBreaks.dups&#39;, 1, 1, 1 ) + &#39; len: &#39; + primeBreaks.length + &#39;\n&#39;; //cagfmt
//cag += cd._showProps( pettyBreaks, &#39;pettyBreaks.dups&#39;, 1, 1, 1 ) + &#39; len: &#39; + pettyBreaks.length + &#39;\n&#39;; //cagfmt

				let len = primeBreaks.length;						// primeBreaks get 1st priority
				if( len &gt; 0 ) {
					if( slack &gt;= len ) {							// enough room for all
						slack -= len;
					} else {
						primeBreaks.length = slack;
						slack = 0;
					}
				}
				len = pettyBreaks.length;							// pettyBreaks get 2nd priority
				if( len &gt; 0 ) {
					if( slack &gt;= len ) {							// enough room for all
						slack -= len;
					} else {
						pettyBreaks.length = slack;
						slack = 0;
					}
				}
				len = pettyBreaks.length;
				while( len-- ) {									// concat arrays
					let brk = pettyBreaks.pop();
					if( primeBreaks.indexOf( brk ) &lt; 0 ) {			// no dup, else steal from doubleSpc
						primeBreaks.push( brk );
					}
				}
				primeBreaks.sort( compareNumbers );

//cag += cd._showProps( primeBreaks, &#39;primeBreaks.concat.sort&#39;, 1, 1, 1 )  //cagfmt
//	  + &#39; len: &#39; + primeBreaks.length + &#39;\n&#39;; //cagfmt

				if( slack &gt; 0 ) {									// use remaining slack to double up spaces
					doubleSpc = slack &lt;= spaces || fullStretch		// use all slack
								? slack : spaces;					//	 or double as many as slack allows
//cag +=  &#39;fullStretch = &#39; + fullStretch + &#39;, doubleSpc = &#39; + doubleSpc + &#39;, slack = &#39; + slack + &#39;, spaces = &#39; + spaces + &#39;\n&#39;; //cagfmt
				}
			}

//let tmpF = strFontLen( fmtLn.join(&#39;&#39;) ); //cagfmt
//if( tmpF &gt; MAXSCREENWIDTH ) //cagfmt
//	  cag += &#39;\n,\t* fmtLn * over MAXSCREENWIDTH, tmpF = &#39; + tmpF.toFixed(3) + &#39;: &quot;&#39; + fmtLn.join(&#39;&#39;) + &#39;&quot;&#39;;	 //cagfmt

			let primeBrk = primeBreaks.shift(),
				line = &#39;&#39;;

/// //////////////////////////////////////////////
//cag += &#39; (&#39; + spaces + &#39; spaces), slack -&gt; &#39; + slack + &#39;\n&#39;; //cagfmt
//if( primeBrk ) { //cagfmt
//	  cag += &#39;primeBrk = &#39; + primeBrk + &#39;: &quot;&#39; + cagsln.slice(primeBrk, primeBrk + 10).replace(/\n/g, &#39;cR&#39;); //cagfmt
//	  for( let idx = 0, len = primeBreaks.length; idx &lt; len; idx++ ) { //cagfmt
//		  let lead = primeBreaks[idx]; //cagfmt
//		  cag += &#39;&quot;, &#39; + lead + &#39;: &quot;&#39; + cagsln.slice(lead, lead + 10).replace(/\n/g, &#39;cR&#39;); //cagfmt
//	  } //cagfmt
//	  cag += &#39;&quot;&#39;; //cagfmt
// } //cagfmt
//cag += &#39;\ndoubleSpc = &#39; + doubleSpc + (fullStretch ? &#39;, fullStretch = &#39; + fullStretch : &#39;&#39;) + &#39;\n&#39;; //cagfmt
//cag += &#39;\n&#39;; //cagfmt
//if( debug ) log( so.name, cag ); //cagfmt
//cag = &#39;&#39;; //cagfmt
/// //////////////////////////////////////////////

			for( let si = 0, flLen = fmtLn.length; si &lt; flLen; si++ ) { // assemble new line
				let chr = fmtLn[ si ];

//if( chr === &#39; &#39; || chr === &#39;\t&#39; ) //cagfmt
//	  cag += &#39;si = &#39; + (si&lt;10?&#39; &#39;:&#39;&#39;) + si + &#39;,	 chr = &quot;&#39; + cagsln.slice(si, si + 10).replace(/\n/g, &#39;cR&#39;) + &#39;&quot;&#39;; //cagfmt

				if( chr === &#39; &#39; || chr === &#39;\t&#39; ) {
					if( primeBrk &amp;&amp; primeBrk === si ) {
						if( lineF + SpaceLen &gt; MAXSCREENWIDTH )
							break;	// safety valve
						line += &#39; &#39;;
						lineF += SpaceLen;
						primeBrk = primeBreaks.shift();
//cag +=  &#39;, primeBrk = &#39; + (primeBrk ||&#39;&#39;); //cagfmt
//cag += &#39;, lineF = &#39; + lineF.toFixed(3); //cagfmt
					}
					if( fullStretch &amp;&amp; doubleSpc &gt; 0 ) {
						let extras = floor(doubleSpc/spaces + 0.5);
						doubleSpc -= extras;
						spaces--;
//cag += &#39;, adding extras = &#39; + extras + &#39;, doubleSpc = &#39; + doubleSpc + &#39;&quot;&#39;;   //cagfmt
						while( extras-- ) {
							if( lineF + SpaceLen &gt; MAXSCREENWIDTH )
								break;// safety valve
							line += &#39; &#39;;
							lineF += SpaceLen;
						}
//cag += &#39;, lineF = &#39; + lineF.toFixed(3); //cagfmt
					} else if( doubleSpc &gt; 0 ) {
						if( lineF + SpaceLen &gt; MAXSCREENWIDTH )
							break;	// safety valve
						line += &#39; &#39;;
						lineF += SpaceLen;
						doubleSpc--;
//cag += &#39;, doubleSpc = &#39; + doubleSpc; //cagfmt
//cag += &#39;, lineF = &#39; + lineF.toFixed(3); //cagfmt
					}
				}
				line += fmtLn[ si ];
//if( chr === &#39; &#39; || chr === &#39;\t&#39; ) cag += &#39;\n&#39;; //cagfmt
			}
			formattedPage.push( line );
			currLine++;
			lnNum++;

//tmpF = strFontLen( line ); //cagfmt
//cag += &#39;\n.\t&quot;&#39; + line.replace(/\n/g, &#39;cR&#39;) + &#39;&quot;	 &#39; + tmpF.toFixed(3) + &#39;\n&#39;; //cagfmt
//cag += &#39;.\t 0....5....1....5....2....5....3....5....4....5....$....5....6....5....7....5....8....5....9....5....0\n&#39;; //cagfmt
//cag += &#39;.\t&quot;&#39; + fmtLn.join(&#39;&#39;).replace(/\n/g, &#39;cR&#39;) + &#39;&quot;\n\n&#39;; //cagfmt
//if( tmpF &gt; MAXSCREENWIDTH ) //cagfmt
//	  cag +=  &#39;line over MAXSCREENWIDTH, tmpF = &#39; + tmpF.toFixed(3) + &#39;: &quot;&#39; + line + &#39;&quot;\n\n&#39;;	  //cagfmt
//if( debug ) log( so.name, cag ); //cagfmt

		}
		return currLine &lt; strLinesLen - 1; // is there more, ie. do we scroll
	}

	///////////////////////////////////////////////////////////////////////////////
	// functions for oxp variables ////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////

// : &#39; +  + &#39;
	function stripPrefix( term ) {
		if( startsWith( term, hostVarPrefix ) ) {
			return term.slice( hostVarPrefix.length );
		}
		return term;
	}

	function isSingleQuoted( term ) {
		return startsWith( term, &quot;&#39;&quot; ) &amp;&amp; endsWith( term, &quot;&#39;&quot; );
	}

	function stripQuotes( term ) {
		if( isSingleQuoted( term ) ) {
			return term.slice( 1, term.length - 2 );
		} else if( startsWith( term, &#39;&quot;&#39; ) &amp;&amp; endsWith( term, &#39;&quot;&#39; ) ) {
///should never happen
			log( &#39;stripQuotes, * * *  how did term become double quoted: &#39; + term );
			term = term.slice( 1, term.length - 2 );
			return term.replace( &#39;&quot;&#39;, &quot;&#39;&quot; );
		}
		return term;
	}

	function confirmReset() {
		var that = confirmReset;
		var choices = (that.choices = that.choices || {&#39;01_yes&#39;: &#39;Yes&#39;, &#39;02_no&#39;: &#39;No&#39;});
		var screen = (that.screen = that.screen || {});

		if( !screen.hasOwnProperty( &#39;exitScreen&#39; ) ) { // static
			screen.exitScreen = &#39;GUI_SCREEN_INTERFACES&#39;;
			screen.screenID = &#39;stn_optns_confirmReset_&#39; + keyPrefix;
			screen.allowInterrupt = false;
			screen.textEntry = false;
			screen.choices = choices;
			screen.initialChoicesKey = &#39;02_no&#39;;
		}

		var currentScreen = pageLabels[ currentScreenIdx ],
			page_key = keyPrefix + currentScreen + &#39;_title&#39;;
		expandKeys.stn_optns_reset_page = expandText( page_key );
		screen.title = expandText( &#39;stn_optns_reset_title&#39;, expandKeys );
		screen.message = expandText( &#39;stn_optns_reset_summary&#39;, expandKeys );
		mission.runScreen( screen, performReset.bind( so ) );
	}

	function performReset( choice ) {
		try {
			if( choice === &#39;01_yes&#39; ) {
				let currentScreen = pageLabels[ currentScreenIdx ],
					options = optionPages[ currentScreen ];
				for( let idx = 0, len = options.length; idx &lt; len; idx++ ) {
					resetOptionValue( options[ idx ] );
				}
			}
			displayOptions( &#39;XX_reset&#39; );
		} catch( err ) {
			log( so.name, so._reportError( err, performReset, choice ) );
			throw err;
		}
	}

	function equalValue( a, b ) {
		if( Array.isArray( a ) ) {
			if( !Array.isArray( b ) )
				return false;
			if( a.length !== b.length )
				return false;
			for( let idx = 0, len = a.length; idx &lt; len; idx++ ) {
				if( a[ idx ] !== b[ idx ] )
					return false;
			}
			return true;
		}
		if( typeof a === &#39;object&#39; ) {
			if( typeof b !== &#39;object&#39; ) return false;
			let asprops = Object.getOwnPropertyNames( a );
			let bsprops = Object.getOwnPropertyNames( b );
			if( asprops.length !== bsprops.length ) return false;
			for( let idx = 0, len = asprops.length; idx &lt; len; idx++ ) {
				if( asprops.indexOf( bsprops[ idx ] ) &lt; 0 )
					return false;
			}
			asprops = freeArray( asprops );
			bsprops = freeArray( bsprops );
			for( let x in a ) {
				if( a.hasOwnProperty( x ) &amp;&amp; b.hasOwnProperty( x )
						&amp;&amp; a[ x ] === b[ x ] ) {
					continue;
				} else {
					return false;
				}
			}
			return true;
		}
		return a === b;
	}

	function getHostValue( option ) {
		if( !hostOxp.hasOwnProperty( hostVarPrefix + option ) )
			return; // undefined
		return hostOxp[ hostVarPrefix + option ];
	}

	function setHostVar( option, value ) {
		hostOxp[ hostVarPrefix + option ] = copyValue( value );
	}
	
	function getOptionValue( option, fromHost ) {				// fromHost =&gt; try getting value from host first
		if( !fromHost ) {
			if( changesMade.hasOwnProperty( option ) ) {
				return copyValue( changesMade[ option ] );
			}
		}
		let hostVar = getHostValue( option );			// change not pending, return curr. value
		return copyValue( hostVar );
	}
	
	function setOptionValue( option, value ) {
		
		function setCurrently( option, value ) {
			freeValue( info.currently )
			info.currently = copyValue( value );
		}
		
		var that = setOptionValue;
		var soKeys = (that.soKeys = that.soKeys || {});
		clearObject( soKeys );

		var info = optionInfo[ option ];
		var hostVal = getHostValue( option ), 
			newVal = changesMade[ option ];
		if( changesMade.hasOwnProperty( option ) ) {	// already been changed
			if( equalValue( value, newVal ) ) {			// same as existing change, nothing to do
				return;
			} else if( equalValue( value, hostVal ) ) {	// changed back to original value
				setCurrently( option, value );
				removeChangeMade( option );
				doAssignments( option );
				doExecutes( option );
				return;
			}
		} else if( equalValue( value, hostVal ) ) {		// entered original value
			return;
		}
		setCurrently( option, value )

		if( changesMade.hasOwnProperty( &#39;cag$stnOptsPending&#39; ) ) {
			changesMade[ &#39;cag$stnOptsPending&#39; ] += 1;
		} else {
			changesMade[ &#39;cag$stnOptsPending&#39; ] = 1;
		}
		missionKeys.stn_optns_changes_count = changesMade[ &#39;cag$stnOptsPending&#39; ];
		if( missionKeys.stn_optns_changed.hasOwnProperty( option ) ) {
			freeValue( missionKeys.stn_optns_changed[ option ] );
		}
		if( Array.isArray( value ) ) {					// don&#39;t reference originals, use copy
			changesMade[ option ] = getArray( value );
			missionKeys.stn_optns_changed[ option ] = getArray( value );
			if( missionKeys.hasOwnProperty( option ) ) {
				missionKeys[ option ] = getArray( value );
			}
		} else if( typeof value === &#39;object&#39; ) {
			changesMade[ option ] = getObject( value );
			missionKeys.stn_optns_changed[ option ] = getObject( value );
			if( missionKeys.hasOwnProperty( option ) ) {
				missionKeys[ option ] = getObject( value );
			}
		} else {
			changesMade[ option ] = value;
			missionKeys.stn_optns_changed[ option ] = value;
			if( missionKeys.hasOwnProperty( option ) ) {
				missionKeys[ option ] = value;
			}
		}
		doAssignments( option );
		doExecutes( option );
	}

	function resetOptionValue( option ) {
		var info = optionInfo[ option ];
		if( info.type === &#39;display&#39; )
			return;										// has no variable associated with option
		if( info.option &amp;&amp; info.defawlt !== undefined ) {
			setOptionValue( option, info.defawlt );
		}
	}
	
	function removeChangeMade( option ) {
		var that = removeChangeMade;
		var soKeys = (that.soKeys = that.soKeys || {});
		clearObject( soKeys );

		if( changesMade.hasOwnProperty( option ) ) {
			freeValue( changesMade[ option ] );
			delete changesMade[ option ];
			if( changesMade[ &#39;cag$stnOptsPending&#39; ] &lt;= 1 ) {
				delete changesMade[ &#39;cag$stnOptsPending&#39; ];
				missionKeys.stn_optns_changes_count = 0;
			} else {
				changesMade[ &#39;cag$stnOptsPending&#39; ] -= 1;
				missionKeys.stn_optns_changes_count -= 1;
			}
		}
		if( missionKeys.stn_optns_changed.hasOwnProperty( option ) ) {
			freeValue( missionKeys.stn_optns_changed[ option ] );
			delete missionKeys.stn_optns_changed[ option ];
		}
	}

// : &#39; +  + &#39;
	var optionsChanged = [];
	var pagesChanged = [];
	var changesDetail = [];

	function saveChoices() {							// commit changes to host oxp
		optionsChanged.length = 0;						// re-use arrays
		pagesChanged.length = 0;
		changesDetail.length = 0;
		var rpt = &#39;none&#39;, longestF = 0;
		var rmdr = getRemindObj();
		if( changesMade.hasOwnProperty( &#39;cag$stnOptsPending&#39; ) ) {
			for( let option in changesMade ) {
				if( changesMade.hasOwnProperty( option ) ) {
					if( option === &#39;cag$stnOptsPending&#39; )
						continue;
					// if( !hostOxp.hasOwnProperty( hostVarPrefix + option ) ) continue;
					// - no, this can be used to init non-existent properties
					let hostVal = getOptionValue( option, true );
					let newVal = changesMade[ option ];
					setHostVar( option, newVal )
					if( typeof newVal === &#39;object&#39; ) {
						// remove only reference so object will persist in hostOxp
						// - later call to clearObject() would free any arrays/objects
						delete changesMade[ option ];
					}
					if( rmdr.reportSummary ) {
						let lenF = measureWord( option );
						if( lenF &gt; longestF ) {
							longestF = lenF;
						}
						changesDetail.push( [option, hostVal, newVal] );
					} else {
						freeValue( hostVal );
					}
					optionsChanged.push( option ); 		// save variable name
					let page;
					if( optionInfo.hasOwnProperty( option ) ) {
						page = optionInfo[ option ].page;
					} else {
						page = &#39;unknown!&#39;;
					}
					if( pagesChanged.indexOf( page ) &lt; 0 )
						pagesChanged.push( page );		// one of two arrays sent via notifyCallback 
				}
			}
		}
		if( notifyCallback )							// inform hostOxp what&#39;s been altered
			notifyCallback( optionsChanged, pagesChanged );
		if( callPWSG )									// write to missionVariables; user still req&#39;d to save game
			hostOxp.playerWillSaveGame();
		if( rmdr.reportSummary ) {
			rpt = &#39;&#39;;
			longestF += SpaceLen * 4;					// add small indent for list (don&#39;t touch window&#39;s edge)
			let spacing = paddingText( &#39;&#39;, SpaceLen * 2 ),
				spacingLen = SpaceLen * 2;				// spacing between column of options &amp; values
			for( let ci = 0, clen = changesDetail.length; ci &lt; clen; ci++ ) {
				let [option, hostVal, newVal] = changesDetail[ ci ];
				let heading = paddingText( option, longestF ) + option + COLON + spacing;
				let prev = rptChange( option, hostVal ),
					curr = rptChange( option, newVal ),
					info = optionInfo[ option ];
				if( info.type === &#39;bitflags&#39; &amp;&amp; prev === &#39;&#39; &amp;&amp; curr === &#39;&#39; ) {
					// rptChange will return the value if it cannot find the bitflagStrs
					rpt += rptBitFlags( heading, longestF + measureWord( COLON ) + spacingLen );
							// these add space between option &amp; flags
				} else {
					rpt += wrapRight( heading + prev + ARROW + curr, -1, longestF, longestF );
				}
				freeValue( hostVal );
			}
			reportSavegame( rpt );
		} else if( rmdr.remindAutosave ) {
			reportSavegame( &#39;no_summary&#39; );
		} else {
			clearObject( changesMade, true );			// true =&gt; keepObjects (ie. del prop only, not what it references)
		}
	}

	///////////////////////////////////////////////////////////////////////////////
	// functions for summary page /////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////

	var fromCol = [], toCol = [];						// for formatting bit flag summary

	function wrapRight( str, strLen, indent, shortenFirst ) {
		shortenFirst = shortenFirst || 0;
		if( !strLen || strLen &lt;= 0 ) {					// caller doesn&#39;t have length on hand
			strLen = measureWord( str );
		}
		var pad = indent &lt;= shortenFirst ? 0 : indent - shortenFirst;
		if( indent - shortenFirst + strLen &lt; MAXSCREENWIDTH ) {	// fits on one line
			return (pad ? paddingText( &#39;&#39;, pad ) : &#39;&#39;) + str + &#39;\n&#39;;
		}
		var line = &#39;&#39;, total = 0, wrapped = &#39;&#39;, words = str.split( COMMA );
		while( words.length &gt; 0 ) {
			let nextWord = words.shift();
			let nextWordLen = measureWord( nextWord );
			let commaLen = measureWord( COMMA );
			if( total === 0 || total + commaLen + nextWordLen &gt; MAXSCREENWIDTH ) {
				// first line (may have a shortener) OR line is full
				if( total &gt; 0 ) {
					wrapped += line + &#39;\n&#39;;
					line = &#39;&#39;;
					pad = indent;
					total = 0;
				}
				if( pad + nextWordLen &gt; MAXSCREENWIDTH ) {// don&#39;t go past edge
					pad = MAXSCREENWIDTH - nextWordLen;
				}
				line += (pad &gt; 0 ? paddingText( &#39;&#39;, pad ) : &#39;&#39;) + nextWord;
				total += pad + nextWordLen;
			} else {
				line += COMMA + nextWord;
				total += commaLen + nextWordLen;
			}
		}
		if( line ) 
			wrapped += line + &#39;\n&#39;;
		return wrapped;
	}

	function rptBitFlags( label, labelLen ) {
		/*
			OptionName: old_flag, second_flag -&gt; new_flag, new_second

			OR, if option &amp; from fit

			OptionName: old_flag, second_flag
					   -&gt; new_flag, new_second
		*/
		var fromFmt = &#39;&#39;, fromLen = 0, toFmt = &#39;&#39;, toLen = 0;
		var commaLen = measureWord( COMMA ),
			arrowLen = measureWord( ARROW );
		if( fromCol.length ) {
			// not measuring final formatted set because measureWord caches
			for( let ci = 0, len = fromCol.length; ci &lt; len; ci++ ) {
				fromFmt += fromCol[ ci ];
				fromLen += measureWord( fromCol[ ci ] );
				if( len &gt; 1 &amp;&amp; ci &lt; len - 1 ) {
					fromFmt += COMMA;
					fromLen += commaLen;
				}
			}
		} else {
			fromFmt = &#39;&lt;none&gt;&#39;;
			fromLen = measureWord( fromFmt );
		}
		if( toCol.length ) {
			for( let ci = 0, len = toCol.length; ci &lt; len; ci++ ) {
				toFmt += toCol[ ci ];
				toLen += measureWord( toCol[ ci ] );
				if( len &gt; 1 &amp;&amp; ci &lt; len - 1 ) {
					toFmt += COMMA;
					toLen += commaLen;
				}
			}
		} else {
			toFmt = &#39;&lt;none&gt;&#39;;
			toLen = measureWord( toFmt );
		}

		var rpt;
		if( labelLen + fromLen + arrowLen + toLen &lt;= MAXSCREENWIDTH ) {
			// option and both sets of flags fit in one line
			rpt = label + fromFmt + ARROW + toFmt + &#39;\n&#39;;
		} else {
			rpt = wrapRight( label + fromFmt, labelLen + fromLen, labelLen, labelLen );
			let indentLen = SpaceLen * 2; 				// shift &#39;to&#39; flags so not inline w/ &#39;from&#39;
			rpt += wrapRight( ARROW + toFmt, arrowLen + toLen, indentLen + labelLen, arrowLen );
		}
		fromCol.length = 0;								// reset for next rpt
		toCol.length = 0;
		return rpt;
	}

	function noParens( str ) {
		let spacePending = false, inParen = false, parsed = &#39;&#39;;
		for(let x = 0, len = str.length; x &lt; len; x++) {
			let ch = str[ x ];
			if( ch === &#39;(&#39; ) {
				inParen = true;
			} else if( ch === &#39;)&#39; ) {
				inParen = false;
				spacePending = true;
			} else if( ch === &#39; &#39; ) {
				spacePending = true;
			} else if( !inParen ) {
				if( !spacePending ) {
					parsed += ch;
				} else if( PUNCTUATION.indexOf( ch ) &gt;= 0 ) {
					parsed += ch;
					spacePending = false;
				} else if( ch !== &#39; &#39; ){
					parsed += &#39; &#39; + ch;
					spacePending = false;
				}
			}
		}
		return parsed;
	}

	function rptChange( option, value ) {
		var info = optionInfo[ option ];
		var rpt = &#39;&#39;, type = info.type;
		if( type === &#39;text&#39; ) {
			rpt = &quot;&#39;&quot; + value + &quot;&#39;&quot;;
		} else if( type === &#39;toggle&#39; ) {
			rpt = expandText( ( value ? &#39;stn_optns_boolean_true&#39; : &#39;stn_optns_boolean_false&#39; ) );
		} else if( type === &#39;vector&#39; ) {
			rpt = &quot;[ &quot; + value.join( &#39;, &#39; ) + &quot; ]&quot; ;
		} else if( type === &#39;choice&#39; ) {
			rpt = info.selection[ value ];
		} else if( type === &#39;bitflags&#39; ) {
			let flags = info.selection;
			if( !flags ) {
				rpt = value;
			} else {
				let column = fromCol.length === 0 ? fromCol : toCol;
				if( flags &amp;&amp; flags.length &gt; 0 ) {
					for( let ci = 0, len = flags.length; ci &lt; len; ci++ ) {
						let flag = 1 &lt;&lt; ci;
						if( value &amp; flag ) {
							// flag is set, prep columns for rptBitFlags
							column.push( noParens( flags[ ci ] ) );
						}
					}
				}
			}
		} else {
			rpt = value;
		}
		return rpt;
	}

	var NAG_COUNT = 3;
	var remindScreenMsg = &#39;&#39;;

	function reportSavegame( rpt, choice ) {
		var that = reportSavegame;
		var choices = (that.choices = that.choices || {});
		var notChoices = (that.notChoices = that.notChoices || {});
		var screen = (that.screen = that.screen || {});
		var remind = (that.remind = that.remind || {});

		if( !screen.hasOwnProperty( &#39;exitScreen&#39; ) ) {	// first time ever, create statics
			screen.exitScreen = &#39;GUI_SCREEN_INTERFACES&#39;;
			screen.screenID = &#39;stn_optns_reportSavegame_&#39; + keyPrefix;
			screen.allowInterrupt = false;
			screen.textEntry = false;
			choices[ &#39;01_OK&#39; ] = getChoice( expandText( &#39;stn_optns_remind_savegame_acknowledge&#39; ) );
			choices[ &#39;02_NONAG&#39; ] = getChoice( expandText( &#39;stn_optns_remind_savegame_quit_nagging&#39; ) );
			choices[ &#39;03_NORPT&#39; ] = getChoice( expandText( &#39;stn_optns_remind_savegame_quit_reporting&#39; ) );
			screen.initialChoicesKey = &#39;01_OK&#39;;
			screen.choices = choices;
		}
		var rmdr = getRemindObj();
		let defaultColor = expandText( &#39;stn_optns_default_color&#39; ) || &#39;yellowColor&#39;;
		var returnToTop = false;
		if( rpt ) {										// first time through this summary page
			remind.reportSummary = rmdr.reportSummary;	// preserve state
			remind.remindAutosave = rmdr.remindAutosave;
			remind.autosaveStopRemind = rmdr.autosaveStopRemind;
			if( choices.hasOwnProperty( &#39;ZZ_more&#39; ) ) {	// don&#39;t know if it&#39;ll be needed
				delete choices[ &#39;ZZ_more&#39; ];			// don&#39;t freeChoice as it&#39;s a global button
			}
			for( let x in notChoices ) {				// restore dynamic buttons
				if( notChoices.hasOwnProperty( x ) ) {	// move into choices
					choices[ x ] = notChoices[ x ];
					delete notChoices[ x ];
				}
			}
			for( let x in choices ) {					// restore button color
				if( choices.hasOwnProperty( x ) ) {
					if( x === &#39;02_NONAG&#39; ) {
						choices[ x ].color = defaultColor;
						if( !rmdr.remindAutosave ) {	// store it for future use
							notChoices[ x ] = choices[ x ];
							delete choices[ x ];
						}
					} else if( x === &#39;03_NORPT&#39; ) {		// summary button remains as an &#39;undo&#39; until nagging is done
						if( rmdr.reportSummary ) {
							choices[ x ].text = expandText( &#39;stn_optns_remind_savegame_quit_reporting&#39; );
						} else {
							choices[ x ].text = expandText( &#39;stn_optns_remind_savegame_start_reporting&#39; );
							choices[ x ].color = expandText( &#39;stn_optns_notInUse_color&#39; ) || &#39;darkGrayColor&#39;;
						}
					} else {
						choices[ x ].color = defaultColor;
					}
				}
			}
		} else {										// process reply
			if( choice === &#39;ZZ_more&#39; ) {				// preserve static more button
				if( choices[ choice ] === scrollTopButton ) {
					returnToTop = true;
				}
				choices[ choice ] = scrollButton;
			} else if( choice === &#39;02_NONAG&#39; ) {
				let prev = remind.autosaveStopRemind,
					curr = rmdr.autosaveStopRemind;
				if( prev === false || (prev === NAG_COUNT - 1 &amp;&amp; curr &gt;= NAG_COUNT) ) {
					// disabled by hostOxp using suppressSummary OR player exceeding NAG_COUNT
					rmdr.remindAutosave = false;		// disable the nagging
					notChoices[ choice ] = choices[ choice ];// move into notChoices
					delete choices[ choice ];
				} else {								// choice remains as a toggle
					if( abs(curr - prev) &gt; 1 ) {		// only one decrement per summary page; 2nd one undoes 1st
						rmdr.autosaveStopRemind = prev;
					}
					if( abs(curr - prev) % 2 &gt; 0 ) {
						choices[ choice ].color = expandText( &#39;stn_optns_optionChanged_color&#39; ) || &#39;cyanColor&#39;;
					}
				}
			} else if( choice === &#39;03_NORPT&#39; ) {		// choice remains as a toggle
				let prev = remind.reportSummary,
					curr = rmdr.reportSummary;
				if( prev &amp;&amp; curr ) {					// was toggled back on
					choices[ choice ].color = defaultColor;
				} else if( prev &amp;&amp; !curr ) {			// was toggled off
					choices[ choice ].color = expandText( &#39;stn_optns_optionChanged_color&#39; ) || &#39;cyanColor&#39;;
				} else if( !prev &amp;&amp; curr ) {			// was restarted
					choices[ choice ].color = expandText( &#39;stn_optns_optionChanged_color&#39; ) || &#39;cyanColor&#39;;
				} else { // !prev &amp;&amp; !curr				// restart was undone
					choices[ choice ].color = expandText( &#39;stn_optns_notInUse_color&#39; ) || &#39;darkGrayColor&#39;;
				}
			}
		}
		var willReport = remind.reportSummary &amp;&amp; rpt !== &#39;no_summary&#39; &amp;&amp; rpt !== &#39;none&#39;,
			willRemind = remind.remindAutosave;			// rpt is null when we return to process buttons
		if( willReport ) {
			screen.title = expandText( &#39;stn_optns_remind_summary_title&#39; );
		} else if( willRemind ) {
			screen.title = expandText( &#39;stn_optns_remind_savegame_title&#39; );
		} else {										// nothing to do
			clearObject( changesMade, true );			// true =&gt; keepObjects (ie. del prop only, not what it references)
			return;
		}
		if( rpt ) {										// first time through this summary page
			let count = changesMade[ &#39;cag$stnOptsPending&#39; ];
			remindScreenMsg = willReport ? expandText( &#39;stn_optns_remind_list_header&#39; ) + rpt : &#39;&#39;;
			expandKeys.stn_optns_changes_count = count;
			expandKeys.stn_optns_changes_plurality = expandText( ( count &gt; 1 ? &#39;stn_optns_remind_is_plural&#39;
																				  : &#39;stn_optns_remind_is_single&#39; ) );
			expandKeys.stn_optns_changes_verb = expandText( ( count &gt; 1 ? &#39;stn_optns_remind_plural_verb&#39;
																			 : &#39;stn_optns_remind_single_verb&#39; ) );
			expandKeys.stn_optns_changes_pronoun = expandText( ( count &gt; 1 ? &#39;stn_optns_remind_plural_pronoun&#39;
																				: &#39;stn_optns_remind_single_pronoun&#39; ) );
			if( willRemind &amp;&amp; willReport ) {
				remindScreenMsg += expandText( &#39;stn_optns_remind_savegame_summary_autosave&#39;, expandKeys );
			} else if( willReport ) {
				remindScreenMsg += expandText( &#39;stn_optns_remind_savegame_summary&#39;, expandKeys );
			} else {	// willRemind, as the !willReport &amp;&amp; !willRemind case returns above
				remindScreenMsg += expandText( &#39;stn_optns_remind_savegame_autosave&#39;
														+ remind.autosaveStopRemind, expandKeys );
			}
			scroller.start();
		} // else we&#39;re scrolling or toggling buttons
		if( returnToTop ) {
			scroller.reset();
		}
		scrollText( rtnobj, remindScreenMsg, &#39;reportSavegame&#39;,
					Object.keys( choices ).length + 1 ); // +1 for blank line
		let choice_key = rtnobj.choice_key;
		choices[ choice_key ] = rtnobj.choice_value;
		if( choice_key === &#39;ZZ_more&#39; &amp;&amp; !choices.hasOwnProperty( &#39;ZZ_more&#39; ) ) {
			choices[ &#39;ZZ_more&#39; ] = scrollButton;
		} else if( choice_key === &#39;ZZ_return&#39; &amp;&amp; choices.hasOwnProperty( &#39;ZZ_more&#39; ) ) {
			// repurpose for returning to top of list
			choices[ &#39;ZZ_more&#39; ] = scrollTopButton;
		}
		screen.initialChoicesKey = choice_key === &#39;ZZ_more&#39; ? choice_key : &#39;01_OK&#39;;
		screen.message = rtnobj.message;
		mission.runScreen( screen, remindAcknowledged.bind( so ) );
	}

	function getRemindObj( prefix ) {					// may be called &#39;locally&#39; (prefix is undefined) or for a
														// specific hostOxp (prefix is its keyPrefix) - see _getReminder4Oxp
		var rmdr = so.$Remind2Savegame;
		var forOxp = prefix || keyPrefix;
		if( !rmdr || !rmdr.hasOwnProperty( forOxp ) ) {	// may have replies to other hostOxp&#39;s
			let oldStyle = null;
			if( !rmdr ) {
				// re-check missionVariables in case $Remind2Savegame was clobbered by different hostOxp
				rmdr = JSON.parse( missionVariables.$StationOptionsRemind2Savegame );
				if( rmdr === null || typeof rmdr === &#39;number&#39; ) {	// not present OR old format
					if( typeof rmdr === &#39;number&#39; ) {
						oldStyle = rmdr;
					}
					rmdr = getObject();
				}
				so.$Remind2Savegame = rmdr;
			}
			rmdr[ forOxp ] = getObject();				// init
			rmdr[ forOxp ].reportSummary = true;
			rmdr[ forOxp ].remindAutosave = true;
			rmdr[ forOxp ].autosaveStopRemind = oldStyle === null ? 0 : oldStyle; // could be zero
			rmdr[ forOxp ].suppressSummary = false;
		}
		let curr = rmdr[ forOxp ];
		if( !prefix ) {									// called &#39;locally&#39;, otherwise suppressSummary is undefined
														//   or for a (possibly) different oxp
			// check here (vs init) to be dynamic (detect when player changes, allow hostOxp freedom to act)
			if( curr.suppressSummary !== suppressSummary ) {
				curr.reportSummary = !suppressSummary || suppressSummary !== &#39;summary&#39;;
				curr.remindAutosave = (!suppressSummary || suppressSummary !== &#39;autosave&#39;)
										&amp;&amp; curr.autosaveStopRemind &lt; NAG_COUNT;
				curr.suppressSummary = suppressSummary;
			}
		}
		if( gameSettings.autosave )
			curr.remindAutosave = false;
		return curr;
	}

	function remindAcknowledged( choice ) {
		try {
			if( choice === &#39;02_NONAG&#39; ) {
				getRemindObj().autosaveStopRemind++;
				reportSavegame( null, &#39;02_NONAG&#39; );
			} else if( choice === &#39;03_NORPT&#39; ) {
				let rmdr = getRemindObj();
				rmdr.reportSummary = !rmdr.reportSummary;
				reportSavegame( null, &#39;03_NORPT&#39; );
			} else if( choice === &#39;ZZ_more&#39; ) {
				reportSavegame( null, &#39;ZZ_more&#39; );
			} else if( choice === &#39;ZZ_return&#39; ) {
				scroller.stop();
				clearObject( changesMade, true );		// true =&gt; keepObjects (ie. del prop only, not what it references)
				displayOptions( &#39;WW_next_pg&#39; );
			} else { // choice === &#39;01_OK&#39;
				remindScreenMsg = &#39;&#39;;
				clearObject( changesMade, true );		// true =&gt; keepObjects (ie. del prop only, not what it references)
			}
		} catch( err ) {
			log( so.name, so._reportError( err, remindAcknowledged, choice ) );
			throw err;
		}
	}

	///////////////////////////////////////////////////////////////////////////////
	// utility functions //////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////

	function freeValue( value ) {
		if( Array.isArray( value ) ) {
			freeArray( value );
		} else if( typeof value === &#39;object&#39; ) {
			freeObject( value );
		}
		return null;									// convenience return
	}

	function copyValue( value )  {
		if( value === null ) {							// null is an object!
			return value;
		} else if( Array.isArray( value ) ) {
			return getArray( value );					// don&#39;t ref originals, use copy
		} else if( typeof value === &#39;object&#39; ) {
			return getObject( value );					// don&#39;t ref originals, use copy
		}
		return value;
	}

	var object_pool = [];

	function clearObject( obj, keepObjects ) {
		for( var x in obj ) { // re-use object
			if( obj.hasOwnProperty( x ) ) {
				if( !keepObjects ) {
					freeValue( obj[ x ] );
				}
				// not setting to null as hasOwnProperty is frequently relied upon
				delete obj[ x ];
			}
		}
		return null;									// convenience return
	}

	function freeObject( obj, keepObjects ) {
		if( !obj || typeof obj !== &#39;object&#39; )
			return;
		clearObject( obj, keepObjects );				// scrub old data
		object_pool.push( obj );						// toss into recycle bin
		return null;									// convenience return
	}

	function getObject( elements ) {
		var obj = object_pool.length &gt; 0 ? object_pool.pop() : {};
		if( elements &amp;&amp; typeof elements === &#39;object&#39; ) {
			for( var x in elements ) {
				if( elements.hasOwnProperty( x ) ) {
					obj[ x ] = elements[ x ];
				}
			}
		}
		return obj;
	}

	var array_pool = [];

	function freeArray( array ) {
		if( !array || !Array.isArray( array ) ) 
			return;
		for( var idx = 0, len = array.length; idx &lt; len; idx++ ) {
			freeValue( array[ idx ] );
		}
		array.length = 0;								// scrub old data
		array_pool.push( array );						// toss into recycle bin
		return null;									// convenience return
	}

// : &#39; +  + &#39;
	function getArray( elements ) {
		var array = array_pool.length &gt; 0 ? array_pool.pop() : [];

		// as we&#39;re in strict mode, we cannot access &#39;caller&#39;, &#39;callee&#39;, and &#39;arguments&#39; properties
		// but we can make a copy? whatever

		var args = Array.prototype.slice.call( arguments );
		var aCount = args.length;
		if( aCount &gt; 1 ) {
			while( aCount-- ) {
				array[ aCount ] = args[ aCount ];
			}
		} else if( elements &amp;&amp; Array.isArray( elements ) ) {
			let x = elements.length;
			while( x-- ) {
				array[ x ] = elements[ x ];
			}
		}
		return array;
	}

	var choice_pool = [];

	function getChoice( text ) {
		var choice = choice_pool.length &gt; 0 ? choice_pool.pop() : {};
		choice.text = text;
		choice.color = expandText( &#39;stn_optns_default_color&#39; ) ||&#39;yellowColor&#39;;
		choice.alignment = &#39;CENTER&#39;;
		choice.unselectable = false;
		return choice;
	}

	function freeChoice( choice ) {
		if( !choice || typeof choice !== &#39;object&#39; )
			return;
		clearObject( choice );
		choice_pool.push( choice );
	}

	function poolReport( msg ) {
		log(&#39;poolReport, &#39; + msg );
		log(&#39;poolReport, choice_pool: &#39; + choice_pool.length + &#39;, array_pool: &#39; + array_pool.length
			+ &#39;, object_pool: &#39; + object_pool.length );
	}

	function _purgepools( report ) {					// called upon page change &amp; exit, free up any abandoned changes &amp; all memory pools
		if( report ) {
			poolReport( (typeof report === &#39;string&#39; ? report : &#39;_purgepools&#39;) );
		}
		choice_pool.length = 0;							// empty pools for garbage collection
		array_pool.length = 0;
		object_pool.length = 0;
	}

/* 
	function chrCount( ch, str ) {						// return number of &#39;ch&#39; characters in &#39;str&#39;
		// fastest of 5, no garbage, 2x faster than as a String.prototype
		for( var count = -1, index = -2; index !== -1;
			count++, index = str.indexOf( ch, index + 1 ) );
		return count;
	}
 */
 
/*
	this is duplicated from my revised version of _paddingText in
	 ..\Resouces\Scripts\oolite-contracts-helpers.js
	- remove (and update ref&#39;s) when/if it&#39;s incorporated into the core
*/
	function paddingText( currentText, desiredLength ) {
		var that = paddingText;
		var strFontLen = (that.strFontLen = that.strFontLen || defaultFont.measureString);
		var hairSpace = (that.hairSpace = that.hairSpace || String.fromCharCode( 0x200a ));
		// 1/8 width space; while there are also 1/4 &amp; 1/2 width unicode chars, MacOS only supports this one!
		var hairSpaceLength = (that.hairSpaceLength = that.hairSpaceLength || strFontLen( hairSpace ));
		var spaceLength	= (that.spaceLength	= that.spaceLength || strFontLen( &#39; &#39; ));
		var padding = (that.padding = that.padding || []);

		if( desiredLength &lt;= 0 ) return &#39;&#39;;
		var num, padString = &#39;&#39;;
		var currentLength = strFontLen( currentText );
		var lengthNeeded = desiredLength - currentLength;
		if( lengthNeeded &lt;= 0 ) return &#39;&#39;;

		num = floor( lengthNeeded / spaceLength ) + 1;
		if( num &gt; 1 ) {
			padding.length = num;
			padString += padding.join( &#39; &#39; );
		}
		lengthNeeded -= num &lt;= 0 ? 0 : ( num - 1 ) * spaceLength;

		num = floor( lengthNeeded / hairSpaceLength ) + 1;
		if( num &gt; 1 ) {
			padding.length = num;
			padString += padding.join( hairSpace );
		}

		return padString;
	}

	return {  _setInterfaces: _setInterfaces,
			_registerHostOxp: _registerHostOxp,
				 _purgepools: _purgepools,
			_getReminder4Oxp: _getReminder4Oxp,

		 _getAllowedCallback: _getAllowedCallback,
				_getCallPWSG: _getCallPWSG,
		  _getNotifyCallback: _getNotifyCallback,
		 _getSuppressSummary: _getSuppressSummary,
			 _getMissionKeys: _getMissionKeys,

		 _setAllowedCallback: _setAllowedCallback,
				_setCallPWSG: _setCallPWSG,
		  _setNotifyCallback: _setNotifyCallback,
		 _setSuppressSummary: _setSuppressSummary,
			 _setMissionKeys: _setMissionKeys,

		  _updateMissionKeys: _updateMissionKeys,
		     _resetLocalVars: _resetLocalVars,
		   };

// };				// end of closure
}.bind(this); // get [native code] in debugger rather than entire function




}).call(this);
// }).call(worldScripts.station_options);


/*		(function() { //  run BEFORE reloading entire script
	var so = worldScripts.station_options;
	for( let x in so ) {
		if( so.hasOwnProperty( x ) )
			delete so[ x ];
	}

})()	// */


/*		(function() { //  run AFTER reloading entire script
	var so = worldScripts.station_options;
	so.startUp();

	var ws = worldScripts.telescope;
	so._initStationOptions( ws, &#39;telescope_&#39;, ws._stnOptionsAllowed, true, ws._reloadFromStn );

	so._setStationInterfaceEntries();

})()	// */




</pre></td>
                </tr>
            </table>
        </a>
    </body>
</html>
