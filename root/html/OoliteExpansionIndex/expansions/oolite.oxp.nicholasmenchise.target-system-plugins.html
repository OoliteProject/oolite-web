<html>
    <head>
        <title>Expansion Target System Plugins</title>
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <table border="0" width="100%">
            <tr>
                <td>Back to <a href='../index.html'>Index</a></td>
                <td align="right"><small>Page generated: Oct 11, 2023, 3:16:49 PM</small></td>
            </tr>
        </table>

        <h1>Expansion Target System Plugins</h1>

        <h2>Content</h2>
        <ul>
          <li><a href="#warnings">Warnings</a></li>
          <li><a href="#manifest">Manifest</a></li>
          <li><a href="#documentation">Documentation</a></li>
          <li><a href="#equipment">6 Equipment</a></li>
          <li><a href="#ships">0 Ships</a></li>
          <li><a href="#models">0 Models</a></li>
          <li><a href="#scripts">6 Scripts</a></li>
        </ul>

          <a name="warnings">
            <h2>Warnings</h2>
            <ol>
                <li>Information URL mismatch between OXP Manifest and Expansion Manager string length at character position 0</li>
            </ol>
          </a>

        <a name="manifest">
        <h2>Manifest</h2>
            <table border="1">
                <tr>
                    <th></th>
                    <th>from Expansion Manager's OXP list</th>
                    <th>from Expansion Manifest</th>
                </tr>
                <tr>
                    <td>Description</td>
                    <td>A collection of equipment items that expand the functionality of the player ship&#39;s target system: Short Range Snapshot, Target Memory Interface and Target Banking Module.</td>
                    <td>A collection of equipment items that expand the functionality of the player ship&#39;s target system: Short Range Snapshot, Target Memory Interface and Target Banking Module.</td>
                </tr>
                <tr>
                    <td>Identifier</td>
                    <td>oolite.oxp.nicholasmenchise.target-system-plugins</td>
                    <td>oolite.oxp.nicholasmenchise.target-system-plugins</td>
                </tr>
                <tr>
                    <td>Title</td>
                    <td>Target System Plugins</td>
                    <td>Target System Plugins</td>
                </tr>
                <tr>
                    <td>Category</td>
                    <td>Equipment</td>
                    <td>Equipment</td>
                </tr>
                <tr>
                    <td>Author</td>
                    <td>Nicholas Menchise</td>
                    <td>Nicholas Menchise</td>
                </tr>
                <tr>
                    <td>Version</td>
                    <td>0.81</td>
                    <td>0.81</td>
                </tr>
                <tr>
                    <td>Tags</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Required Oolite Version</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Maximum Oolite Version</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Required Expansions</td>
                    <td>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>Optional Expansions</td>
                    <td>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>Conflict Expansions</td>
                    <td>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>Information URL</td>
                    <td><a target="_blank" href=""></a></td>
                    <td><a target="_blank" href="">n/a</a></td>
                </tr>
                <tr>
                    <td>Download URL</td>
                    <td><a target="_blank" href="https://wiki.alioth.net/img_auth.php/9/96/Target-System-Plugins_0.81.oxz">https://wiki.alioth.net/img_auth.php/9/96/Target-System-Plugins_0.81.oxz</a></td>
                    <td><a target="_blank" href="">n/a</a></td>
                </tr>
                <tr>
                    <td>License</td>
                    <td>CC BY-NC-SA 4.0</td>
                    <td>CC BY-NC-SA 4.0</td>
                </tr>
                <tr>
                    <td>File Size</td>
                    <td>n/a</td>
                </tr>
                <tr>
                    <td>Upload date</td>
                    <td>1610873378</td>
                </tr>
            </table>
                </a>

        <a name="documentation">
        <h2>Documentation</h2>
        <p>Also read <a href='http://wiki.alioth.net/index.php/Target%20System%20Plugins'>http://wiki.alioth.net/index.php/Target%20System%20Plugins</a></p>
        <h3>readme.txt</h3>
        <pre>Oolite Expansion Pack
Target System Plugins
Copyright 2019 Nicholas Menchise

License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)
available at https://creativecommons.org/licenses/by-nc-sa/4.0/


Introduction

    This expansion introduces three equipment items that add more features to the
player ship&#39;s targeting system. These items are intended to be compatible with any
target selector the player prefers.


Dependencies

    All of these items require some core game equipment before they will work. This
equipment must be functioning at all times. In other words, if the dependencies are
damaged or missing, then the plugins will fail and they will let you know about it.


The Equipment

    The Short Range Snapshot (SRS) counts the targets within the player ship&#39;s scanner
range, divides them into seven categories and displays the tallies in its MFD. Additional
tallies are appended when applicable.
Requires the Scanner Targeting Enhancement. Tech Level 12. Cost: 300 Cr.

    The Target Memory Interface (TMI) displays a list of up to eight of the most recently
targeted objects sorted by distance from the player ship in its MFD. It can also indicate
the category of each target if the SRS is installed.
Requires the Target System Memory Expansion. Tech Level 9. Cost: 200 Cr.

    The Target Banking Module (TBM) is primeable equipment that utilises the SRS target
categories as memory banking modes. The player can select a category on the SRS MFD
with the mode button, then press the activate button to assign up to 8 targets at once
to the memory bank through the TMI.
Requires the SRS and the TMI. Tech Level 12. Cost: 500 Cr.


Cascade Weapon Alert

    All MFDs of functioning plugins will alert the player if a cascade weapon like the
Quirium Cascade Mine is within the player ship&#39;s scanner range.


SRS Categories

    Hostile: all targets that are hostile toward the player ship
    Outlaw: offenders and fugitives, including Thargoids
    Neutral: traders, hunters, etc.
    State: police and military
    Cargo: cargo containers, escape capsules, metal fragments, derelicts, etc.
    Rock: asteroids, boulders, splinters, rock hermits
    Other: almost everything else (excludes wreckage and wormholes)


SRS Additional Tallies

    The SRS will append some tallies for more specific targets on the same line as
the relevant category, if applicable. For example, if there are 10 rocks and 4 of them
are splinters, then the SRS will display the following:

Rock: 10 ... 4 splinters.

    The categories with additional tallies are as follows:
        Outlaw: Thargoid
        Cargo: Escape Capsule
        Rock: Splinter


TMI Category Symbols

    The TMI MFD can indicate the category of each target if the SRS is functioning. This
information is displayed symbolically to save space for target names.

    There are eight symbols:
        !H!    Hostile
        !O.    Outlaw
        Nt-    Neutral
        St/    State
        -C-    Cargo
        -R-    Rock
        .o?    Other
        ???    Unknown


SRS and TMI Tips

    The plugins will display some helpful information about themselves on their MFDs
when no targets are listed.


Development History

    It all started when I discovered the Target System Upgrade expansion by Andrey
Belov (also known as &quot;timer&quot;). I noticed that the equipment&#39;s hostile/outlaw mode
was not selecting Thargoid ships that were attacking other ships. I had some prior
experience with Javascript, so I decided to modify one of the functions a bit. It started
selecting the Thargoids and I was satisfied for a little while, but then I wanted to add
more target modes and information on the equipment&#39;s MFD. One thing led to
another and I ended up creating what is now known as the Short Range Snapshot.

    The feature formerly known as the TSU Snapshot was almost ready to be part of
a new release, which could have been the first update to the TSU in five years.
However, the more I used and enjoyed the enhanced TSU, the more features I wanted.
I also wanted to release an expansion that did not favour one piece of targeting
equipment over another. I wanted compatibility with the Fast Target Selector at the
very least.

    I also became aware of some performance issues I had created by integrating
an MFD that tallied five target modes at once with filtering code that was designed
for one mode at a time. I had already replaced Andrey&#39;s MFD code and rewrote
the primeable equipment event handlers, but now I was facing the challenge of
modifying the code that actually made the targeting work, which I barely
understood at the time. I still can&#39;t figure out how the sort by distance function
works. Fortunately, I learned from the Oolite Javascript Reference for the System
class that sorting by distance was built into some of its methods.

    New ideas were occuring to me as I learned more about how to script Oolite
expansions. The idea for the Target Memory Interface was the turning point. I
decided to make a new expansion from scratch that I would call Target System
Plugins. The goal was to add features to the player ship&#39;s targeting system that
could be used with the player&#39;s preferred target selector in addition to the
memory banking feature of the TMI.

    I knew I had made the right decision after I discovered the wonders of the
descriptions property list, which wasn&#39;t used in the TSU. It was the first part of
the new expansion that I worked on, even before porting my Snapshot code. The
TSP equipment was going to use a lot of strings, to put it mildly, which made
descriptions.plist the best place for me to figure out the design of the frontend. For
example, it was during my work on that property list that I realised I needed to
have abbreviation symbols for the target modes in the TMI MFD, so that there
would be enough room in the MFD to make it a useful frontend for the target
memory bank. All of this happened before I wrote a single line of code for the
TMI.

    The next step was writing my own code that actually made the targeting work.
My experience with modifying and testing the TSU&#39;s filter parameters (i.e. what
to include and exclude in each target mode) would prove useful, but I wasn&#39;t
confident until I did some more research into the filteredEntities method of the
System class, the same method that Andrey used to get the targets from scanner
range. I finally understood how that method was filtering the entities, which
enabled me to write my own functions with similar functionality (pun not intended).
This was the key to avoiding the performance issues from my previous work, as
my entire expansion, even with three different pieces of equipment working
simultaneously, would only need to call the filteredEntities method once per
second. My own filtering code would do the rest.

    I spent the next couple of weeks developing the expansion when another idea
occurred to me. The first TMI design had two overall features: an MFD that
served as a front end for the Target System Memory Expansion (TSME); and
primeable equipment that would assign an entire category of targets from the
SRS to target memory. I wondered if I was over-engineering the TMI, which was
dependent on the SRS as well as the TSME (if either of them broke, then the TMI
wouldn&#39;t work). The SRS also had its own dependency (the Scanner Targeting
Enhancement), which meant that the TMI would fail if any of three other equipment
items were broken or missing and the player would lose access to both features.

    I decided to spin off the second feature into its own equipment item: the
Target Banking Module. The TMI would only be dependent on the TSME as it was
the front end for that equipment. The TBM would be dependent on the TMI and
SRS, so only the most advanced feature would have the highest dependency
stack (four equipment items in total). I was fortunate that the redesign only
required a few changes to the code that I already wrote.

    I finished the scripts on the 1st of February, 2019. The development history
up to this point spanned approximately one month. Testing and debugging was
about to begin.

    I knew that writing everything before testing any of the functions was not a
good idea, but my hubris got the better of me at the time. My lack of experience
with the descriptions property list and string expansion did not help matters. I
had not written the string expansion calls properly, because I had not read the
reference material thoroughly. A lot of corrections were needed before my scripts
would load at startup.

    I had started working on another expansion pack for Oolite by this time, the
Primeable Equipment MFD, because I wanted to make something less ambitious
and time-consuming while testing this one. That was when the idea for the Hostile
Awareness MFD occurred to me, but I would need to research the Vector3D class
and learn about vectors in general before I could even begin working on that
feature. My first project had become even more ambitious and time-consuming. I
knew that my second project would be my first public release.

    I was mistaken when I thought that the existing scripts were finished at the
beginning of February, to put it mildly. The bugs in the TMI made it useless as
a frontend for the TSME. One of the bugs took about a week to fix and I had to
study the relevant parts of the core game&#39;s source code several times to figure
out a solution. I was lucky that the syntax of Objective C was similar enough to
Javascript that I could read it.

    Unfortunately, it became apparent that the solution was not going to be
enough. The Javascript engine does not provide enough access to event handlers
like key presses to maintain the accuracy of the TMI list. It would not work as a
complete TSME frontend. I decided to redesign the TMI to have less scope in
a way that would be even more useful to the player.

    The third incarnation of the TMI is an MFD that displays up to 8 targets at once
sorted by distance from the player ship. This new design made my previous idea
for the Hostile Awareness MFD redundant, since the TMI combined with the SRS
can provide similar information, albeit without vector indicators. I decided to
remove the Hostile Awareness MFD from my planned feature set.

    This just leaves more testing and one more feature that would apply to all of
my MFDs: a cascade weapon alert. This idea occurred to me after discovering the
Q-Bomb Detector expansion by Diziet Sma. I liked the general idea behind it, but
I disagreed with charging 5000 credits for an alarm.

</pre>
        </a>

        <a name="equipment">          
        <h2>Equipment</h2>
            <table>
                <tr>
                    <th>Name</th>
                    <th>Visible</th>
                    <th>Cost [deci-credits]</th>
                    <th>Tech-Level</th>
                </tr>
                <tr>
                    <td><a href="../equipment/EQ_TSP_SHORT_RANGE_SNAPSHOT.html">Short Range Snapshot</a></td>
                    <td>yes</td>
                    <td align="right">3000</td>
                    <td align="center">12+</td>
                </tr>
                <tr>
                    <td><a href="../equipment/EQ_TSP_SHORT_RANGE_SNAPSHOT_REMOVAL.html">Sell Short Range Snapshot</a></td>
                    <td>yes</td>
                    <td align="right">150</td>
                    <td align="center">12+</td>
                </tr>
                <tr>
                    <td><a href="../equipment/EQ_TSP_TARGET_BANKING_MODULE.html">Target Banking Module</a></td>
                    <td>yes</td>
                    <td align="right">5000</td>
                    <td align="center">12+</td>
                </tr>
                <tr>
                    <td><a href="../equipment/EQ_TSP_TARGET_BANKING_MODULE_REMOVAL.html">Sell Target Banking Module</a></td>
                    <td>yes</td>
                    <td align="right">250</td>
                    <td align="center">12+</td>
                </tr>
                <tr>
                    <td><a href="../equipment/EQ_TSP_TARGET_MEMORY_INTERFACE.html">Target Memory Interface</a></td>
                    <td>yes</td>
                    <td align="right">2000</td>
                    <td align="center">9+</td>
                </tr>
                <tr>
                    <td><a href="../equipment/EQ_TSP_TARGET_MEMORY_INTERFACE_REMOVAL.html">Sell Target Memory Interface</a></td>
                    <td>yes</td>
                    <td align="right">100</td>
                    <td align="center">12+</td>
                </tr>
            </table>
        </a>

        <a name="ships">    
        <h2>Ships</h2>
            This expansion declares no ships. This may be related to warnings.
        </a>

        <a name="models">    
        <h2>Models</h2>
            This expansion declares no models. This may be related to warnings.
        </a>

        <a name="scripts">    
        <h2>Scripts</h2>
            <table>
                <tr>
                    <th>Path</th>
                </tr>
                <tr>
                    <td valign="top">Scripts/target-system-plugins_conditions.js</td>
                    <td><pre>&quot;use strict&quot;;

this.name           = &quot;TargetSystemPlugins_Conditions&quot;;
this.author         = &quot;Nicholas Menchise&quot;;
this.copyright      = &quot;(C) 2019 Nicholas Menchise&quot;;
this.licence        = &quot;CC BY-NC-SA 4.0&quot;;

//
// This condition script includes the instructions for disallowing the
// removal option for TSP equipment if the Sell Equipment expansion
// by Commander McLane is not installed.
//


this.allowAwardEquipment = function(eqKey, ship, context) {
    if (!worldScripts[&quot;sell_equipment&quot;]) return false;
    return true;
}
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/target-system-plugins_fs.js</td>
                    <td><pre>&quot;use strict&quot;;

this.name           = &quot;TargetSystemPlugins_FilterSort&quot;;
this.author         = &quot;Nicholas Menchise&quot;;
this.copyright      = &quot;(C) 2019 Nicholas Menchise&quot;;
this.licence        = &quot;CC BY-NC-SA 4.0&quot;;

//
// This world script includes the instructions for filtering entities within
// scanner range and sorting them into groups for the equipment.
//


// Total targets within scanner range
this.$targetsTotal = [];

// Hostile targets within scanner range
this.$targetsHostile = [];

// Outlaw targets within scanner range
this.$targetsOutlaw = [];

// Neutral targets within scanner range
this.$targetsNeutral = [];

// State targets within scanner range
this.$targetsState = [];

// Cargo targets within scanner range
this.$targetsCargo = [];

// Rock targets within scanner range
this.$targetsRock = [];

// Other targets within scanner range
this.$targetsOther = [];

// Memory bank of Entities for the TMI MFD.
this.$targetsMemoryData = [];

// Target category symbol strings. There should be a symbol for each Entity.
this.$targetsMemorySigns = [];

// Memory bank index positions of valid Entities within player ship scanner range, sorted by distance.
this.$targetsMemoryInRange = [];


//
// Sets the array of total targets within scanner range.
//
// This function is called by _updateTallies function in world script TargetSystemPlugins_ShortRangeSnapshot.
//
// The predicate for the filteredEntities method of System class excludes
// RRS autopilot screens for better compatibility with the Rescue Stations expansion.
//
this._getTargetsTotal = function() {
    this.$targetsTotal = system.filteredEntities(
        this,
        function(e) {
            if (
                e.isShip &amp;&amp; !e.isCloaked &amp;&amp; e.displayName !== &quot;Wreckage&quot; &amp;&amp; e.dataKey !== &quot;rrs_autopilot_screen&quot;
            ) return e;
        },
        player.ship, player.ship.scannerRange
    );
}


//
// Sets the arrays of targets in seven categories.
//
// This function is called by _updateTallies function in world script TargetSystemPlugins_ShortRangeSnapshot.
//
this._getTargetsSorted = function() {

    // Hostile mode
    this.$targetsHostile = this._getTargetsFiltered(
        function(e) {
            if (e.hasHostileTarget &amp;&amp; e.target === player.ship) {
                return true;
            }
                else {
                    return false;
                }
        }
    );

    // Outlaw mode
    this.$targetsOutlaw = this._getTargetsFiltered(
        function(e) {
            if (e.scanClass === &quot;CLASS_THARGOID&quot; || e.scanClass === &quot;CLASS_NEUTRAL&quot; &amp;&amp; e.bounty !== 0) {
                return true;
            }
                else {
                    return false;
                }
        }
    );

    // Neutral mode, includes additional parameters for better compatibility with the Escort Contracts expansion
    this.$targetsNeutral = this._getTargetsFiltered(
        function(e) {
            if (e.beaconLabel === &quot;Escort Mother&quot; || e.scanClass === &quot;CLASS_NEUTRAL&quot; &amp;&amp; e.bounty === 0) {
                return true;
            }
                else {
                    return false;
                }
        }
    );

    // State mode
    this.$targetsState = this._getTargetsFiltered(
        function(e) {
            if (e.scanClass === &quot;CLASS_POLICE&quot; || e.scanClass === &quot;CLASS_MILITARY&quot;) {
                return true;
            }
                else {
                    return false;
                }
        }
    );

    // Cargo mode, includes additional parameters for better compatibility with the Ore Processor expansion
    this.$targetsCargo = this._getTargetsFiltered(
        function(e) {
            if (e.scanClass === &quot;CLASS_CARGO&quot; &amp;&amp; e.displayName !== &quot;Splinter&quot;) {
                return true;
            }
                else {
                    return false;
                }
        }
    );

    // Rock mode, includes additional parameters for better compatibility with Ore Processor and Escort Contracts expansions
    this.$targetsRock = this._getTargetsFiltered(
        function(e) {
            if (e.displayName === &quot;Splinter&quot; || e.scanClass === &quot;CLASS_ROCK&quot; &amp;&amp; e.beaconLabel !== &quot;Escort Mother&quot;) {
                return true;
            }
                else {
                    return false;
                }
        }
    );

    // Other mode
    this.$targetsOther = this._getTargetsFiltered(
        function(e) {
            if (
                e.scanClass !== &quot;CLASS_THARGOID&quot; &amp;&amp; e.scanClass !== &quot;CLASS_NEUTRAL&quot; &amp;&amp; e.scanClass !== &quot;CLASS_POLICE&quot; &amp;&amp;
                e.scanClass !== &quot;CLASS_MILITARY&quot; &amp;&amp; e.scanClass !== &quot;CLASS_CARGO&quot; &amp;&amp; e.scanClass !== &quot;CLASS_ROCK&quot;
            ) {
                return true;
            }
                else {
                    return false;
                }
        }
    );

}


//
// Returns an array of Entities that matches a target category.
//
// This function is called by _getTargetsSorted function.
//
// filterThisWay argument is a function with one argument variable and one condition that returns a boolean.
// The condition includes the filter parameters. It should return true within the if statement and false within the else statement.
//
this._getTargetsFiltered = function(filterThisWay) {
    var giveTheseTargets = [];

    for (var n = 0; n &lt; this.$targetsTotal.length; n++) {
        var tryThisOne = filterThisWay(this.$targetsTotal[n]);
        if (tryThisOne) var x = giveTheseTargets.push(this.$targetsTotal[n]);
    }

    return giveTheseTargets;
}


//
// Returns the number of Entities in a target category that matches a parameter.
//
// This function is called by _updateTallies function in world script TargetSystemPlugins_ShortRangeSnapshot.
//
// This should only be called on the condition that there are any targets in the relevant category.
//
// whichTally argument is a string that specifies the targets to be counted.
// There are three valid strings for this argument:
// &quot;thargoid&quot; for Thargoid ships
// &quot;escape&quot; for escape capsules
// &quot;splinter&quot; for rock splinters.
//
// Returns a negative integer if the string is invalid or the array to be searched is empty.
//
this._getTally = function(whichTally) {
    var tallyResult = -1;
    var checkList = [];

    // Determines the target array to be searched.
    if (whichTally === &quot;thargoid&quot;) checkList = this.$targetsOutlaw;
    if (whichTally === &quot;escape&quot;) checkList = this.$targetsCargo;
    if (whichTally === &quot;splinter&quot;) checkList = this.$targetsRock;

    if (checkList.length &lt; 1) return tallyResult;
    tallyResult = 0;

    // Determines the filter function to be applied to the target array.
    var countThese = function(){};
    if (whichTally === &quot;thargoid&quot;)
        countThese = function(e) {
            if (e.scanClass === &quot;CLASS_THARGOID&quot;) {
                return true;
            }
                else {
                    return false;
                }
        };
    if (whichTally === &quot;escape&quot;)
        countThese = function(e) {
            if (e.hasRole(&quot;escape-capsule&quot;)) {
                return true;
            }
                else {
                    return false;
                }
        };
    if (whichTally === &quot;splinter&quot;)
        countThese = function(e) {
            if (e.displayName === &quot;Splinter&quot;) {
                return true;
            }
                else {
                    return false;
                }
        };

    // Searches the target array and increments the tally when the correct entries are found.
    for (var n = 0; n &lt; checkList.length; n++) {
        var tryThisOne = countThese(checkList[n]);
        if (tryThisOne) tallyResult++;
    }

    return tallyResult;
}


//
// Tests an Entity to determine if it goes into the target memory bank and does so if it passes.
//
// This function is called by shipTargetAcquired event handler in world script TargetSystemPlugins_SharedHandlers.
//
// testThis argument is the Entity to be tested.
//
this._tmiBankThisOrNot = function(testThis) {

    // Checks if the Entity is already in the memory bank to avoid duplication.
    var matchFound = this._tmiCheckForMatch(testThis, this.$targetsMemoryData);

    // Clears invalid entries and keeps the memory bank array length to 8 or less.
    this._tmiCleanUp();
    if (!matchFound &amp;&amp; this.$targetsMemoryData.length == 8) var removeD = this.$targetsMemoryData.shift();
    if (!matchFound &amp;&amp; this.$targetsMemorySigns.length == 8) var removeS = this.$targetsMemorySigns.shift();

    if (!matchFound) {
        // Adds target information to the end of the arrays.
        var x = this.$targetsMemoryData.push(testThis);
        var srsWorking = worldScripts[expandDescription(&quot;[tsplugins_script_srs]&quot;)]._statusCheck();
        var signOfThis = &quot;&quot;;
        if (srsWorking) signOfThis = this._tmiSignThis(testThis);
        if (!srsWorking) signOfThis = expandDescription(&quot;[tsplugins_sign_missed]&quot;);    // symbol for unknown
        x = this.$targetsMemorySigns.push(signOfThis);
    }
        else {
            // Transfers the target information from its current position in the arrays to the end of the arrays.
            var whereIsThis = this.$targetsMemoryData.indexOf(testThis);
            var transferD = this.$targetsMemoryData[whereIsThis];
            var transferS = this.$targetsMemorySigns[whereIsThis];
            removeD = this.$targetsMemoryData.splice(whereIsThis, 1);
            removeS = this.$targetsMemorySigns.splice(whereIsThis, 1);
            var y = this.$targetsMemoryData.push(transferD);
            y = this.$targetsMemorySigns.push(transferS);
        }

}


//
// Tests the target memory bank for invalid entries and removes them, if so.
//
// This function is called by _tmiBankThisOrNot function.
//
this._tmiCleanUp = function() {
    for (var n = 0; n &lt; this.$targetsMemoryData.length; n++) {
        if (!this.$targetsMemoryData[n].isInSpace) {
            var removeD = this.$targetsMemoryData.splice(n, 1);
            var removeS = this.$targetsMemorySigns.splice(n, 1);
            n--;
        } else {}
    }
}


//
// Sets an array of index positions of $targetsMemoryData entries within the player ship&#39;s scanner range, sorted
// by distance from the player ship. The array is assigned to $targetsMemoryInRange.
// Also moves targets in memory to the front of their arrays if they&#39;re out of scanner range, which puts them first
// in line for removal by _tmiBankThisOrNot function when trimming the length.
//
// This function is called by _timedUpdate function in world script TargetSystemPlugins_TargetMemoryInterface.
// It is also called by shipTargetAcquired event handler in world script TargetSystemPlugins_SharedHandlers.
// It is also called by activated event handler in equipment script TargetSystemPlugins_TargetBankingModule.
//
this._tmiGroupInRange = function() {

    // Gets the index positions of targets within scanner range and their distances from player ship.
    var youScanThem = [];
    var youMeasureThem = [];
    var youAreHere = player.ship.position;
    var outThere = player.ship.scannerRange;
    for (var n = 0; n &lt; this.$targetsMemoryData.length; n++) {
        var checkThisOne = this.$targetsMemoryData[n];
        if (!checkThisOne.isInSpace || checkThisOne.isCloaked) {
        }
            else if (youAreHere.distanceTo(checkThisOne) &lt; outThere) {
                var foundThisOne = youAreHere.distanceTo(checkThisOne);
                var x = youScanThem.push(n);
                x = youMeasureThem.push(foundThisOne);
            }
                else {
                    // Transfers the target information from its current position in the arrays to the start of the arrays.
                    var transferD = this.$targetsMemoryData[n];
                    var transferS = this.$targetsMemorySigns[n];
                    var removeD = this.$targetsMemoryData.splice(n, 1);
                    var removeS = this.$targetsMemorySigns.splice(n, 1);
                    x = this.$targetsMemoryData.unshift(transferD);
                    x = this.$targetsMemorySigns.unshift(transferS);
                }
    }

    // Sorts the entries by distance from player ship.
    var youSortThem = [];
    var howMany = youScanThem.length;
    for (var n = 0; n &lt; howMany; n++) {
        var closestRange = outThere;
        var closestOne = -1;
        for (var p = 0; p &lt; youMeasureThem.length; p++) {
            if (youMeasureThem[p] &lt; closestRange) closestRange = youMeasureThem[p];
            if (youMeasureThem[p] == closestRange) closestOne = p;
        }
        var y = youSortThem.push(youScanThem[closestOne]);
        var removeN = youScanThem.splice(closestOne, 1);
        var removeM = youMeasureThem.splice(closestOne, 1);
    }

    this.$targetsMemoryInRange = youSortThem;
}


//
// Initialises the TMI arrays.
//
// This function is called by startUp, shipWillDockWithStation, shipWillEnterWitchspace, equipmentDamaged and
// equipmentRemoved event handlers in world script TargetSystemPlugins_SharedHandlers.
//
this._tmiReset = function() {
    this.$targetsMemoryData = [];
    this.$targetsMemorySigns = [];
    this.$targetsMemoryInRange = [];
}


//
// Tests the Entities in the target memory bank to determine if their TMI category symbols are current and changes
// them, if necessary.
//
// This function is called by _timedUpdate function in world script TargetSystemPlugins_TargetMemoryInterface.
//
// This should only be called if the SRS equipment is functional.
//
this._tmiSignUpdate = function() {
    var signRecorded = &quot;&quot;;    // stores the TMI category symbol that&#39;s in the memory bank
    var signScanned = &quot;&quot;;    // stores the TMI category symbol that&#39;s in the latest snapshot, if target is found

    for (var n = 0; n &lt; this.$targetsMemorySigns.length; n++) {
        signRecorded = this.$targetsMemorySigns[n];
        if (!this.$targetsMemoryData[n].isInSpace || this.$targetsMemoryData[n].isCloaked) {
            signScanned = expandDescription(&quot;[tsplugins_sign_missed]&quot;);
        }
            else {
                signScanned = this._tmiSignThis(this.$targetsMemoryData[n]);
            }
        if (signRecorded !== signScanned) this.$targetsMemorySigns[n] = signScanned;
    }
}


//
// Tests an Entity to determine its target category and returns its TMI symbol string.
//
// This function is called by _tmiBankThisOrNot and _tmiSignUpdate functions.
//
// This should only be called if the SRS equipment is functional.
//
// whatsThat argument is the Entity to be tested.
//
this._tmiSignThis = function(whatsThat) {
    var signNotFound = expandDescription(&quot;[tsplugins_sign_missed]&quot;);    // symbol for unknown

    // Compares the Entity to the Entities in seven arrays until match found or searched all
    var matchFound = false;
    var checkThese = [
        this.$targetsHostile, this.$targetsOutlaw,
        this.$targetsNeutral, this.$targetsState,
        this.$targetsCargo, this.$targetsRock,
        this.$targetsOther
    ];
    var signWithThis = [
        expandDescription(&quot;[tsplugins_sign_mode0]&quot;), expandDescription(&quot;[tsplugins_sign_mode1]&quot;),
        expandDescription(&quot;[tsplugins_sign_mode2]&quot;), expandDescription(&quot;[tsplugins_sign_mode3]&quot;),
        expandDescription(&quot;[tsplugins_sign_mode4]&quot;), expandDescription(&quot;[tsplugins_sign_mode5]&quot;),
        expandDescription(&quot;[tsplugins_sign_mode6]&quot;)
    ];
    for (var n = 0; n &lt; checkThese.length; n++) {
        matchFound = this._tmiCheckForMatch(whatsThat, checkThese[n]);
        if (matchFound) return signWithThis[n];
    }

    return signNotFound;
}


//
// Returns a boolean that indicates if an Entity matches an entry in an array of Entities.
//
// This function is called by _tmiBankThisOrNot and _tmiSignThis functions.
//
// checkThis argument is the Entity to be tested.
// againstThis argument is the array of Entities.
//
this._tmiCheckForMatch = function(checkThis, againstThis) {

    for (var n = 0; n &lt; againstThis.length; n++) {
        if (checkThis === againstThis[n]) return true;
    }

    return false;
}

</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/target-system-plugins_sh.js</td>
                    <td><pre>&quot;use strict&quot;;

this.name           = &quot;TargetSystemPlugins_SharedHandlers&quot;;
this.author         = &quot;Nicholas Menchise&quot;;
this.copyright      = &quot;(C) 2019 Nicholas Menchise&quot;;
this.licence        = &quot;CC BY-NC-SA 4.0&quot;;

//
// This world script includes the miscellaneous instructions that are shared
// by the equipment. For example, the code that updates the MFDs. It also
// includes the event handlers.
//



// Whether or not the TBM primeable equipment is processing an activate event. Prevents TMI MFD overload when true.
this.$tbmActive = false;

// Stores the ready status of the TBM primeable equipment.
this.$tbmReady = false;

// Stores the current target mode of the TBM primeable equipment.
this.$tbmTargetMode = 7;    // set to Total mode by default, because it&#39;s always displayed on SRS MFD when equipment is activated.

// Calls the function that updates the cascade alert every quarter of a second.
this.$cascadeUpdate = new Timer(this, function() { this._cascadeWeaponAlert(); }, 0, 0.25);

// Stores the SoundSource for the cascade weapon alert. Property set by cascadeWeaponDetected event handler.
this.$cascadeUpdateSound = new SoundSource;

// Whether or not the cascade alert danger text is on the MFD during an alert. It&#39;s intended to flash with each timer interval.
this.$cascadeDangerText = true;

// Stores an array of cascade weapon Entities detected by player ship.
this.$cascadeDangerObject = [];


//
// Sets MFD text, if MFDs are available.
//
// This function is called by _statusUpdate and _setMfdString functions in world script TargetSystemPlugins_ShortRangeSnapshot.
// It is also called by the same functions in world script TargetSystemPlugins_TargetMemoryInterface. It is also called by some
// event handlers below. It is also called by _cascadeWeaponMfd function below.
//
// mfdKey argument stores the string that determines where the text will be displayed.
// mfdString argument stores the text to be displayed. It can also set the MFD to blank if the value is null.
//
this._setMfd = function(mfdKey, mfdString) {
    if (player.ship.multiFunctionDisplays &gt; 0) player.ship.setMultiFunctionText(mfdKey, mfdString);
}


//
// Takes over all functioning TSP MFDs to display an alert when a cascade weapon is within the player ship scanner range.
//
// This function is called by $cascadeUpdate timer.
//
this._cascadeWeaponAlert = function() {
    var tspSRS = worldScripts[expandDescription(&quot;[tsplugins_script_srs]&quot;)];
    var tspTMI = worldScripts[expandDescription(&quot;[tsplugins_script_tmi]&quot;)];

    // Stops the SRS and TMI timers, if they are running.
    if (tspSRS.$readyUpdate.isRunning) tspSRS.$readyUpdate.stop();
    if (tspTMI.$readyUpdate.isRunning) tspTMI.$readyUpdate.stop();

    // Checks if cascade weapon is still within scanner range and acts accordingly.
    var srsWorking = tspSRS._statusCheck();
    var tmiWorking = tspTMI._statusCheck();
    var youAreHere = player.ship.position;
    var outThere = player.ship.scannerRange;
    if (this.$cascadeDangerObject.length &lt; 1) {
        // Stops the cascade timer and restarts the MFDs, if the equipment is functional.
        this.$cascadeUpdate.stop();
        this.$cascadeDangerText = true;
        if (srsWorking) tspSRS._statusUpdate(true, 3);
        if (tmiWorking) tspTMI._statusUpdate(true, 3);
    }
        else if (!this.$cascadeDangerObject[0].isValid || youAreHere.distanceTo(this.$cascadeDangerObject[0]) &gt; outThere) {
            // Removes the cascade weapon entry from the array.
            var removeCascade = this.$cascadeDangerObject.shift();
        }
            else {
                // Calls the function that sets the string for the MFDs and updates them, if TSP MFDs are available.
                if (srsWorking || tmiWorking) this._cascadeWeaponMfd(srsWorking, tmiWorking, youAreHere);
            }

}


//
// Sets the string for cascade weapon alert, passes the update to the MFDs of functional TSP equipment and plays warning sound.
//
// This function is called by _cascadeWeaponAlert function.
//
// sayThisSRS argument is a boolean that indicates whether or not the SRS is functioning.
// sayThisTMI argument is a boolean that indicates whether or not the TMI is functioning.
// youAreHere argument is the vector position of the player ship.
//
this._cascadeWeaponMfd = function(sayThisSRS, sayThisTMI, youAreHere) {

    // Sets the string for the danger text lines and switches the boolean for the next update.
    var dangerLines = &quot;&quot;;
    if (this.$cascadeDangerText) {
        dangerLines = expandDescription(&quot;[tsplugins_cascade_danger_text]&quot;);
        this.$cascadeDangerText = false;
    }
        else {
            this.$cascadeDangerText = true;
        }

    // Gets the distance between the player ship and the weapon in kilometres.
    var rawDistance = youAreHere.distanceTo(this.$cascadeDangerObject[0]);
    rawDistance /= 1000;
    var fineDistance = &quot;&quot; + rawDistance;
    fineDistance = fineDistance.substring(0, 4);

    // Sets the string for the MFD update.
    var sayThis1 = dangerLines + &quot;\n&quot; + &quot;\n&quot; + &quot;\n&quot;;
    var sayThis2 = expandDescription(&quot;[tsplugins_cascade_word1]&quot;) + &quot;\n&quot; + &quot;\n&quot;;
    var sayThis3 = expandDescription(&quot;[tsplugins_cascade_word2]&quot;) + &quot;\n&quot; + &quot;\n&quot;;
    var sayThis4 = &quot;                        &quot; + fineDistance + &quot;km&quot; + &quot;\n&quot; + &quot;\n&quot;;
    var sayThis5 = dangerLines;
    var sayThisMfd = sayThis1 + sayThis2 + sayThis3 + sayThis4 + sayThis5;

    // Assigns the string to the functional TSP MFDs and plays the warning sound.
    if (sayThisSRS) this._setMfd(worldScripts[expandDescription(&quot;[tsplugins_script_srs]&quot;)].$mfdKey, sayThisMfd);
    if (sayThisTMI) this._setMfd(worldScripts[expandDescription(&quot;[tsplugins_script_tmi]&quot;)].$mfdKey, sayThisMfd);
    this.$cascadeUpdateSound.play();

}


//
//
// Event handlers. See Oolite Javascript Reference pages on Elite Wiki for more details.
//
//


this.startUp = function() {

    // Puts equipment keys in the global array of the sell_equipment world script, if available.
    // The sell_equipment world script is found in the Sell Equipment expansion pack by Commander McLane.
    if (worldScripts[&quot;sell_equipment&quot;])
        var x = worldScripts[&quot;sell_equipment&quot;].equipment_key.push(
            expandDescription(&quot;[tsplugins_eqkey_srs]&quot;), expandDescription(&quot;[tsplugins_eqkey_tmi]&quot;),
            expandDescription(&quot;[tsplugins_eqkey_tbm]&quot;)
        );

    var tspSRS = worldScripts[expandDescription(&quot;[tsplugins_script_srs]&quot;)];
    var tspTMI = worldScripts[expandDescription(&quot;[tsplugins_script_tmi]&quot;)];

    // Checks if the equipment is on the player ship and sets the availability status
    if (
        player.ship.equipmentStatus(expandDescription(&quot;[tsplugins_eqkey_srs]&quot;)) === &quot;EQUIPMENT_OK&quot; ||
        player.ship.equipmentStatus(expandDescription(&quot;[tsplugins_eqkey_srs]&quot;)) === &quot;EQUIPMENT_DAMAGED&quot;
    ) tspSRS.$onShip = true;
    if (
        player.ship.equipmentStatus(expandDescription(&quot;[tsplugins_eqkey_tmi]&quot;)) === &quot;EQUIPMENT_OK&quot; ||
        player.ship.equipmentStatus(expandDescription(&quot;[tsplugins_eqkey_tmi]&quot;)) === &quot;EQUIPMENT_DAMAGED&quot;
    ) tspTMI.$onShip = true;

    // Stops the timers that update the MFDs.
    if (tspSRS.$readyUpdate.isRunning) tspSRS.$readyUpdate.stop();
    if (tspTMI.$readyUpdate.isRunning) tspTMI.$readyUpdate.stop();
    if (this.$cascadeUpdate.isRunning) this.$cascadeUpdate.stop();

    // Initialises the TMI memory bank arrays.
    worldScripts[expandDescription(&quot;[tsplugins_script_fs]&quot;)]._tmiReset();

}


this.shipWillDockWithStation = function(station) {
    var tspSRS = worldScripts[expandDescription(&quot;[tsplugins_script_srs]&quot;)];
    var tspTMI = worldScripts[expandDescription(&quot;[tsplugins_script_tmi]&quot;)];

    // Deactivates the equipment and informs the player on the equipment MFDs, if functional.
    var srsWorking = tspSRS._statusCheck();
    var tmiWorking = tspTMI._statusCheck();
    if (srsWorking) {
        tspSRS.$ready = false;
        tspSRS.$readyUpdate.stop();
        this._setMfd(tspSRS.$mfdKey, expandDescription(&quot;[tsplugins_title_srs] [tsplugins_mfd_status_off]&quot;));
    }
        else {
        }
    if (tmiWorking) {
        tspTMI.$ready = false;
        tspTMI.$readyUpdate.stop();
        worldScripts[expandDescription(&quot;[tsplugins_script_fs]&quot;)]._tmiReset();
        this._setMfd(tspTMI.$mfdKey, expandDescription(&quot;[tsplugins_title_tmi] [tsplugins_mfd_status_off]&quot;));
    }
        else {
        }
    this.$tbmReady = false;
    this.$tbmTargetMode = 7;

}


this.shipLaunchedFromStation = function(station) {
    var tspSRS = worldScripts[expandDescription(&quot;[tsplugins_script_srs]&quot;)];
    var tspTMI = worldScripts[expandDescription(&quot;[tsplugins_script_tmi]&quot;)];

    // Activates the equipment and informs the player on the equipment MFDs, if functional.
    var srsWorking = tspSRS._statusCheck();
    var tmiWorking = tspTMI._statusCheck();
    if (srsWorking) tspSRS._statusUpdate(true, 3);
    if (tmiWorking) tspTMI._statusUpdate(true, 3);
    if (player.ship.equipmentStatus(expandDescription(&quot;[tsplugins_eqkey_tbm]&quot;)) === &quot;EQUIPMENT_OK&quot;) this.$tbmReady = true;

}


this.shipWillEnterWitchspace = function(cause, destination) {
    var tspSRS = worldScripts[expandDescription(&quot;[tsplugins_script_srs]&quot;)];
    var tspTMI = worldScripts[expandDescription(&quot;[tsplugins_script_tmi]&quot;)];

    // Deactivates the equipment temporarily and informs the player on the equipment MFDs, if functional.
    var srsWorking = tspSRS._statusCheck();
    var tmiWorking = tspTMI._statusCheck();
    if (srsWorking) tspSRS._statusUpdate(false, 3);
    if (tmiWorking) {
        tspTMI._statusUpdate(false, 3);
        worldScripts[expandDescription(&quot;[tsplugins_script_fs]&quot;)]._tmiReset();
    }
        else {
        }
    this.$tbmReady = false;

}


this.shipExitedWitchspace = function() {
    var tspSRS = worldScripts[expandDescription(&quot;[tsplugins_script_srs]&quot;)];
    var tspTMI = worldScripts[expandDescription(&quot;[tsplugins_script_tmi]&quot;)];

    // Restores the equipment and informs the player on the equipment MFDs, if functional.
    var srsWorking = tspSRS._statusCheck();
    var tmiWorking = tspTMI._statusCheck();
    if (srsWorking) tspSRS._statusUpdate(true, 3);
    if (tmiWorking) tspTMI._statusUpdate(true, 3);
    if (player.ship.equipmentStatus(expandDescription(&quot;[tsplugins_eqkey_tbm]&quot;)) === &quot;EQUIPMENT_OK&quot;) this.$tbmReady = true;

}


this.equipmentAdded = function(equipmentKey) {

    // Sets the availability status to true for added equipment.
    if (equipmentKey === expandDescription(&quot;[tsplugins_eqkey_srs]&quot;)) worldScripts[expandDescription(&quot;[tsplugins_script_srs]&quot;)].$onShip = true;
    if (equipmentKey === expandDescription(&quot;[tsplugins_eqkey_tmi]&quot;)) worldScripts[expandDescription(&quot;[tsplugins_script_tmi]&quot;)].$onShip = true;

    if (equipmentKey === expandDescription(&quot;[tsplugins_eqkey_tbm]&quot;)) this.$tbmReady = true;    // just in case it&#39;s added in-flight

}


this.equipmentDamaged = function(equipment) {

    // Informs the player that the equipment is damaged on the equipment MFDs.
    if (equipment === expandDescription(&quot;[tsplugins_eqkey_srs]&quot;) || equipment === &quot;EQ_SCANNER_SHOW_MISSILE_TARGET&quot;)
        var srsWillFail = worldScripts[expandDescription(&quot;[tsplugins_script_srs]&quot;)]._statusCheck();
    if (equipment === expandDescription(&quot;[tsplugins_eqkey_tmi]&quot;) || equipment === &quot;EQ_TARGET_MEMORY&quot;) {
        var tmiWillFail = worldScripts[expandDescription(&quot;[tsplugins_script_tmi]&quot;)]._statusCheck();
        worldScripts[expandDescription(&quot;[tsplugins_script_fs]&quot;)]._tmiReset();
    }
        else {
        }
    if (equipment === expandDescription(&quot;[tsplugins_eqkey_tbm]&quot;)) this.$tbmReady = false;

}


this.equipmentRemoved = function(equipmentKey) {
    var tspSRS = worldScripts[expandDescription(&quot;[tsplugins_script_srs]&quot;)];
    var tspTMI = worldScripts[expandDescription(&quot;[tsplugins_script_tmi]&quot;)];

    // Sets the availability status to false and switches off MFDs for removed equipment.
    if (equipmentKey === expandDescription(&quot;[tsplugins_eqkey_srs]&quot;)) {
        tspSRS.$onShip = false;
        this._setMfd(tspSRS.$mfdKey, null);
    }
        else {
        }
    if (equipmentKey === expandDescription(&quot;[tsplugins_eqkey_tmi]&quot;)) {
        tspTMI.$onShip = false;
        this._setMfd(tspTMI.$mfdKey, null);
        worldScripts[expandDescription(&quot;[tsplugins_script_fs]&quot;)]._tmiReset();
    }
        else {
        }

    if (equipmentKey === expandDescription(&quot;[tsplugins_eqkey_tbm]&quot;)) this.$tbmReady = false;    // just in case it&#39;s removed in-flight

}


this.equipmentRepaired = function(equipment) {
    // This code is for in-flight repairs only, which is possible with some expansion packs.

    // Informs the player if the equipment is restored on the equipment MFDs.
    if (equipment === expandDescription(&quot;[tsplugins_eqkey_srs]&quot;) || equipment === &quot;EQ_SCANNER_SHOW_MISSILE_TARGET&quot;) {
        var srsWillWork = false;
        var tspSRS = worldScripts[expandDescription(&quot;[tsplugins_script_srs]&quot;)];
        if (!player.ship.docked) srsWillWork = tspSRS._statusCheck();
        if (srsWillWork) tspSRS._statusUpdate(true, 3);
    }
        else {
        }
    if (equipment === expandDescription(&quot;[tsplugins_eqkey_tmi]&quot;) || equipment === &quot;EQ_TARGET_MEMORY&quot;) {
        var tmiWillWork = false;
        var tspTMI = worldScripts[expandDescription(&quot;[tsplugins_script_tmi]&quot;)];
        if (!player.ship.docked) tmiWillWork = tspTMI._statusCheck();
        if (tmiWillWork) tspTMI._statusUpdate(true, 3);
    }
        else {
        }

    if (equipment === expandDescription(&quot;[tsplugins_eqkey_tbm]&quot;) &amp;&amp; !player.ship.docked) this.$tbmReady = true;

}


this.playerChangedPrimedEquipment = function(equipmentKey) {
    // Sets TBM to Total mode, because it&#39;s a reliable way to indicate that the TBM can access the SRS MFD.
    if (equipmentKey === expandDescription(&quot;[tsplugins_eqkey_tbm]&quot;)) {
        this.$tbmTargetMode = 7;
        worldScripts[expandDescription(&quot;[tsplugins_script_srs]&quot;)]._setMfdString();
    }
}


this.cascadeWeaponDetected = function(weapon) {
    // Initiates cascade weapon alert.
    var putThatHere = this.$cascadeDangerObject.push(weapon);
    this.$cascadeUpdateSound.sound = &quot;warning.ogg&quot;;
    if (!this.$cascadeUpdate.isRunning) this.$cascadeUpdate.start();
}


this.shipTargetAcquired = function(target) {
    // Passes new target to the TMI, if functional.
    // Wormholes are not passed to the TMI because the Target System Memory Expansion ignores them.
    // The functions to update the TMI MFD are called by the TBM when it&#39;s active, hence the condition at the end,
    // which prevents excessive updates to the MFD.
    //
    var tspTMI = worldScripts[expandDescription(&quot;[tsplugins_script_tmi]&quot;)];
    var tspFS = worldScripts[expandDescription(&quot;[tsplugins_script_fs]&quot;)];
    var tmiWorking = tspTMI._statusCheck();
    if (tmiWorking &amp;&amp; !target.isWormhole) tspFS._tmiBankThisOrNot(target);
    if (tmiWorking &amp;&amp; !this.$tbmActive) {
        tspFS._tmiGroupInRange();
        tspTMI._setMfdString();
    }
        else {
        }
}

</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/target-system-plugins_srs.js</td>
                    <td><pre>&quot;use strict&quot;;

this.name           = &quot;TargetSystemPlugins_ShortRangeSnapshot&quot;;
this.author         = &quot;Nicholas Menchise&quot;;
this.copyright      = &quot;(C) 2019 Nicholas Menchise&quot;;
this.licence        = &quot;CC BY-NC-SA 4.0&quot;;

//
// This world script includes the instructions for the SRS MFD strings and checking the equipment status.
//


// Whether or not the equipment is on the player ship
this.$onShip = false;

// Whether or not the equipment is functioning
this.$ready = false;

// Whether or not MFD updates should be suspended to prevent tip strings from changing every second
this.$mfdSuspend = false;

// Calls the function that updates the equipment MFD every second, if the equipment is functioning
this.$readyUpdate = new Timer(this, function() { this._timedUpdate(); }, 0, 1);

// Stores the MFD key for the equipment
this.$mfdKey = &quot;tsplugins_srs&quot;;

// Stores the equipment&#39;s target tallies from the last timed update
//
// This is stored as a global variable so that the target mode selection can be updated independently on the MFD.
// The tallies should be stored in the following order:
// Hostile, Outlaw, Neutral, State, Cargo, Rock, Other, Total, Thargoids, Escape Capsules, Splinters.
//
this.$tallies = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];


//
// Checks the status of the equipment and its dependencies. Returns a boolean.
//
// This function is called by _timedUpdate function. It is also called by _statusCheck function in equipment
// script TargetSystemPlugins_TargetBankingModule. It is also called by event handlers in world script
// TargetSystemPlugins_SharedHandlers. It is also called by _cascadeWeaponAlert function in world script
// TargetSystemPlugins_SharedHandlers.
//
// A negative status (false) will trigger a function call that results in a status update.
// An integer is calculated and passed in the same function call to provide more specific
// information in the status update.
//
this._statusCheck = function() {
    var dependsValue = 0;
    var dependsResult = false;

    if (player.ship.equipmentStatus(expandDescription(&quot;[tsplugins_eqkey_srs]&quot;)) === &quot;EQUIPMENT_OK&quot;) dependsValue = 2;
    if (player.ship.equipmentStatus(&quot;EQ_SCANNER_SHOW_MISSILE_TARGET&quot;) === &quot;EQUIPMENT_OK&quot;) dependsValue++;

    if (dependsValue == 3) dependsResult = true;
    if (this.$ready &amp;&amp; dependsValue &lt; 3) this._statusUpdate(false, dependsValue);

    return dependsResult;
}


//
// Updates the status of the equipment and informs the player when it&#39;s activated, disabled or damaged.
//
// This function is called by _statusCheck function. It is also called by event handlers in the world
// script TargetSystemPlugins_SharedHandlers.
//
// isWorking argument stores a boolean that indicates if the equipment is enabled.
//
// whatHappened argument stores an integer that indicates the cause of the status change.
// A value of 3 means that the equipment is fine, but something else may be stopping it, e.g. witchspace tunnel.
// A value of 2 means that the dependency check has failed.
// A value less than 2 means that the equipment is damaged.
//
this._statusUpdate = function(isWorking, whatHappened) {

    // Changes the ready status and stops the timer, if necessary. Stops the function if equipment is off the ship.
    if (this.$ready !== isWorking) this.$ready = isWorking;
    if (!isWorking &amp;&amp; this.$readyUpdate.isRunning) this.$readyUpdate.stop();
    if (!this.$onShip) return;

    // Sets the string for the status update to the MFD.
    var theseLines = &quot;&quot;;    // stores the MFD update string.
    if (isWorking) theseLines = expandDescription(&quot;[tsplugins_ready_srs]&quot;);
    if (!isWorking &amp;&amp; whatHappened == 3) theseLines = expandDescription(&quot;[tsplugins_title_srs][tsplugins_mfd_status_witchspace]&quot;);
    if (!isWorking &amp;&amp; whatHappened == 2) theseLines = expandDescription(&quot;[tsplugins_disabled1_srs]&quot;);
    if (!isWorking &amp;&amp; whatHappened &lt; 2) theseLines = expandDescription(&quot;[tsplugins_broken_srs]&quot;);

    // Calls the MFD setting function.
    worldScripts[expandDescription(&quot;[tsplugins_script_sh]&quot;)]._setMfd(this.$mfdKey, theseLines);

    // Resumes the timer that calls regular updates to the MFD, if the equipment has become functional.
    // The two second delay ensures that the player can see the status update when the equipment is activated.
    //
    if (isWorking &amp;&amp; !this.$readyUpdate.isRunning) {
        this.$readyUpdate.nextTime = clock.absoluteSeconds + 2;
        this.$readyUpdate.start();
        this.$mfdSuspend = false;    // fixed a bug where the MFD could get stuck on startup instead of displaying tip
    }
        else {
        }
}


//
// Updates the equipment MFD at regular intervals, if the equipment is functional.
//
// This function is called by $readyUpdate timer.
//
this._timedUpdate = function() {
    var isWorking = this._statusCheck();
    if (!isWorking) return;
    this._updateTallies();
    if (this.$tallies[7] &gt; 0) this.$mfdSuspend = false;
    if (!this.$mfdSuspend) this._setMfdString();
}


//
// Calculates and sets the integers in the tallies array.
//
// This function is called by _timedUpdate function.
//
this._updateTallies = function() {

    // Sets the entries for additional tallies to zero to prevent outdated values from showing up.
    for (var n = 8; n &lt; this.$tallies.length; n++) this.$tallies[n] = 0;

    // Updates the target data within the player ship&#39;s scanner range.
    var tspFS = worldScripts[expandDescription(&quot;[tsplugins_script_fs]&quot;)];
    tspFS._getTargetsTotal();
    tspFS._getTargetsSorted();

    // Sets the tallies for the target modes.
    this.$tallies[0] = tspFS.$targetsHostile.length;
    this.$tallies[1] = tspFS.$targetsOutlaw.length;
    this.$tallies[2] = tspFS.$targetsNeutral.length;
    this.$tallies[3] = tspFS.$targetsState.length;
    this.$tallies[4] = tspFS.$targetsCargo.length;
    this.$tallies[5] = tspFS.$targetsRock.length;
    this.$tallies[6] = tspFS.$targetsOther.length;
    this.$tallies[7] = tspFS.$targetsTotal.length;

    // Sets additional tallies, if applicable.
    if (this.$tallies[1] &gt; 0) this.$tallies[8] = tspFS._getTally(&quot;thargoid&quot;);
    if (this.$tallies[4] &gt; 0) this.$tallies[9] = tspFS._getTally(&quot;escape&quot;);
    if (this.$tallies[5] &gt; 0) this.$tallies[10] = tspFS._getTally(&quot;splinter&quot;);

}


//
// Sets the string that will be sent to the equipment MFD and calls the MFD update.
//
// This function is called by _timedUpdate function. It is also called by event handlers in equipment
// script TargetSystemPlugins_TargetBankingModule. It is also called by playerChangedPrimedEquipment
// event handler in world script TargetSystemPlugins_SharedHandlers.
//
this._setMfdString = function() {
    var sayThisMfd = &quot;&quot;;
    var tspSH = worldScripts[expandDescription(&quot;[tsplugins_script_sh]&quot;)];

    // Sets the snapshot string when targets are found.
    if (this.$tallies[7] &gt; 0) {

        // Sets the first line, which includes the title and timestamp. The second line is blank.
        var snapshotTime = &quot;&quot;;
        if (clock.isAdjusting) snapshotTime = &quot;Ad:ju:st&quot;;
        if (!clock.isAdjusting) snapshotTime = clock.clockStringForTime(clock.adjustedSeconds).substring(8);
        var lineOne = expandDescription(&quot;[tsplugins_title_srs]&quot;);
        lineOne += &quot;        &quot; + snapshotTime + &quot;\n&quot; + &quot;\n&quot;;

        // Sets the target mode selection column.
        var modeColumn = [];
        for (var n = 0; n &lt; 8; n++) modeColumn[n] = expandDescription(&quot;[tsplugins_mfd_unselected]&quot;);
        var tmiWorking = worldScripts[expandDescription(&quot;[tsplugins_script_tmi]&quot;)]._statusCheck();
        if (
            tmiWorking &amp;&amp; tspSH.$tbmReady &amp;&amp; this.$tallies[tspSH.$tbmTargetMode] &gt; 0 &amp;&amp;
            player.ship.primedEquipment === expandDescription(&quot;[tsplugins_eqkey_tbm]&quot;)
        ) modeColumn[tspSH.$tbmTargetMode] = expandDescription(&quot;[tsplugins_mfd_selected]&quot;);

        // Sets the target tally lines and puts them next to the target mode selection column.
        var tallyText = this._getTallyList();
        var linesEight = &quot;&quot;;
        for (var n = 0; n &lt; modeColumn.length; n++) {
            linesEight = linesEight + modeColumn[n] + tallyText[n];
            if (n &lt; 7) linesEight += &quot;\n&quot;;
        }

        sayThisMfd = lineOne + linesEight;
    }
        else {
            // Sets the SRS Tip string when no targets are found.
            sayThisMfd = expandDescription(&quot;[tsplugins_mfd_tip_srs]&quot;);
            this.$mfdSuspend = true;
        }

    // Calls the MFD setting function.
    tspSH._setMfd(this.$mfdKey, sayThisMfd);
}


//
// Returns an array of strings for the target tally text.
//
// This function is called by _setMfdString function.
//
this._getTallyList = function() {
    var tallyList = [&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;];
    var tallyLabels = [
        expandDescription(&quot;[tsplugins_title_mode0]&quot;), expandDescription(&quot;[tsplugins_title_mode1]&quot;),
        expandDescription(&quot;[tsplugins_title_mode2]&quot;), expandDescription(&quot;[tsplugins_title_mode3]&quot;),
        expandDescription(&quot;[tsplugins_title_mode4]&quot;), expandDescription(&quot;[tsplugins_title_mode5]&quot;),
        expandDescription(&quot;[tsplugins_title_mode6]&quot;), expandDescription(&quot;[tsplugins_title_mode7]&quot;)
    ];

    // Sets the left column of the tally text. Tallies with no targets are not displayed.
    for (var n = 0; n &lt; tallyList.length; n++) {
        if (this.$tallies[n] &gt; 0) tallyList[n] = tallyLabels[n] + &quot;: &quot; + this.$tallies[n];
    }

    // Appends additional tallies, if applicable.
    if (this.$tallies[8] &gt; 0) tallyList[1] += expandDescription(&quot;[tsplugins_mfd_gap]&quot;) + this.$tallies[8] + &quot; Thargoid ship&quot;;
    if (this.$tallies[8] &gt; 1) tallyList[1] += &quot;s&quot;;
    if (this.$tallies[9] &gt; 0) tallyList[4] += expandDescription(&quot;[tsplugins_mfd_gap]&quot;) + this.$tallies[9] + &quot; escape pod&quot;;
    if (this.$tallies[9] &gt; 1) tallyList[4] += &quot;s&quot;;
    if (this.$tallies[10] &gt; 0) tallyList[5] += expandDescription(&quot;[tsplugins_mfd_gap]&quot;) + this.$tallies[10] + &quot; splinter&quot;;
    if (this.$tallies[10] &gt; 1) tallyList[5] += &quot;s&quot;;

    return tallyList;
}

</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/target-system-plugins_tbm.js</td>
                    <td><pre>&quot;use strict&quot;;

this.name           = &quot;TargetSystemPlugins_TargetBankingModule&quot;;
this.author         = &quot;Nicholas Menchise&quot;;
this.copyright      = &quot;(C) 2019 Nicholas Menchise&quot;;
this.licence        = &quot;CC BY-NC-SA 4.0&quot;;

//
// This equipment script includes the instructions for the TBM&#39;s &quot;mode&quot; and
// &quot;activated&quot; event handlers and their support functions, e.g. the status check.
//



// Stores an integer that symbolises the state of the equipment, which enables the HUD
// console messages to provide more specific explanations when the controls are disabled.
//
// There are four valid integer values. The values are set by _statusCheck function.
// Zero means that a dependency was unavailable on the last two status checks.
// One means that dependencies are available, but the equipment is temporarily disabled by a witchspace tunnel.
// Two means that a dependency was unavailable on the last status check.
// Three means that all equipment is fine, but the controls could still be disabled if there are no targets in SRS.
//
this.$statusInfo = 0;


//
// Checks the status of the equipment and its dependencies. Returns a boolean.
//
// This function is called by the .mode and .activated event handlers.
//
// An integer is calculated and set to the status info variable. See the variable comments for details.
//
// The equipment&#39;s ready status variable in world script TargetSystemPlugins_SharedHandlers is set to false if a
// dependency is unavailable.
//
this._statusCheck = function() {
    var dependsValue = 0;
    var dependsResult = false;
    var tspSRS = worldScripts[expandDescription(&quot;[tsplugins_script_srs]&quot;)];
    var tspSH = worldScripts[expandDescription(&quot;[tsplugins_script_sh]&quot;)];
    var srsWorking = tspSRS._statusCheck();
    var tmiWorking = worldScripts[expandDescription(&quot;[tsplugins_script_tmi]&quot;)]._statusCheck();
    var tbmWorking = tspSH.$tbmReady;

    // The condition below refers to the tbmReady variable instead of the equipmentStatus method of PlayerShip object,
    // because it applies to situations where the equipment is temporarily disabled. The equipment script does nothing
    // if the equipment is damaged, because it&#39;s not primeable.
    //
    if (tbmWorking) dependsValue = 2;
    if (srsWorking &amp;&amp; tmiWorking) dependsValue++;

    if (dependsValue == 3) dependsResult = true;
    if (tbmWorking &amp;&amp; dependsValue &lt; 3) tspSH.$tbmReady = false;

    // Disables the equipment controls if no targets are in SRS arrays.
    // The tbmReady variable is not changed, because it&#39;s unnecessary.
    //
    if (tspSRS.$tallies[7] &lt; 1) dependsResult = false;

    this.$statusInfo = dependsValue;
    return dependsResult;
}


//
// Informs the player that the equipment is disabled and why. The message is sent to the HUD console.
//
// This function is called by the .mode and .activated event handlers.
//
// This should only be called after a status check returns a negative value.
//
this._statusMessage = function() {
    var sendThis = expandDescription(&quot;[tsplugins_console_tbm_disabled_alert] &quot;);
    if (this.$statusInfo == 1) sendThis += expandDescription(&quot;[tsplugins_console_tbm_disabled_why1]&quot;);
    if (this.$statusInfo == 2 || this.$statusInfo == 0) sendThis += expandDescription(&quot;[tsplugins_console_tbm_disabled_why2]&quot;);
    if (this.$statusInfo == 3) sendThis += expandDescription(&quot;[tsplugins_console_tbm_disabled_why3]&quot;);
    player.consoleMessage(sendThis);
}


//
// Returns the correct array of Entities for target banking.
//
// This function is called by .activated event handler.
//
// targetMode argument is the equipment&#39;s current target mode.
//
this._bankTheseTargets = function(targetMode) {
    var theseTargets = [];
    var tspFS = worldScripts[expandDescription(&quot;[tsplugins_script_fs]&quot;)];
    if (targetMode == 0) theseTargets = tspFS.$targetsHostile;
    if (targetMode == 1) theseTargets = tspFS.$targetsOutlaw;
    if (targetMode == 2) theseTargets = tspFS.$targetsNeutral;
    if (targetMode == 3) theseTargets = tspFS.$targetsState;
    if (targetMode == 4) theseTargets = tspFS.$targetsCargo;
    if (targetMode == 5) theseTargets = tspFS.$targetsRock;
    if (targetMode == 6) theseTargets = tspFS.$targetsOther;
    if (targetMode == 7) theseTargets = tspFS.$targetsTotal;
    return theseTargets;
}


//
// Event handlers. Specified on Elite wiki page Oolite Javascript Reference: Equipment scripts.
//


this.mode = function() {

    // Checks if the equipment is working.
    var tbmWorking = this._statusCheck();

    if (tbmWorking) {

        // Finds and sets the next valid target mode.
        var tspSH = worldScripts[expandDescription(&quot;[tsplugins_script_sh]&quot;)];
        var tspSRS = worldScripts[expandDescription(&quot;[tsplugins_script_srs]&quot;)];
        tspSH.$tbmTargetMode++;
        if (tspSH.$tbmTargetMode &gt; 7) tspSH.$tbmTargetMode = 0;
        for (var n = tspSH.$tbmTargetMode; n &lt; 8; n++) {
            if (tspSRS.$tallies[n] &gt; 0) break;
            tspSH.$tbmTargetMode++;
        }

        // Updates the SRS MFD with the next valid target mode.
        tspSRS._setMfdString();

    }
        else {
            // Informs the player that the equipment is not working.
            this._statusMessage();
        }

}


this.activated = function() {

    var tspSH = worldScripts[expandDescription(&quot;[tsplugins_script_sh]&quot;)];
    var tspSRS = worldScripts[expandDescription(&quot;[tsplugins_script_srs]&quot;)];

    // Checks if the equipment is working.
    var tbmWorking = this._statusCheck();

    if (!tbmWorking) {
        // Informs the player that the equipment is not working.
        this._statusMessage();
    }
        else if (tspSRS.$tallies[tspSH.$tbmTargetMode] &lt; 1) {
            // Informs the player that there are no targets in the selected mode and switches to Total mode.
            player.consoleMessage(expandDescription(&quot;[tsplugins_console_tbm_none_mode]&quot;));
            tspSH.$tbmTargetMode = 7;
            tspSRS._setMfdString();
        }
            else {

                // Assigns targets in a valid mode to player ship.
                // The maximum number of targets is 8, because that&#39;s the limit of the TMI MFD.
                // The loop works backwards so that the last new target is the nearest one to the player ship.
                // The loop checks if the target is still around in case something happened to it after the last SRS update.
                // The loop avoids passing targets already in TMI memory, because doing so would be a waste of cycles.
                // The tbmActive state prevents the shipTargetAcquired event handler from updating the TMI MFD.
                //
                tspSH.$tbmActive = true;
                var tspFS = worldScripts[expandDescription(&quot;[tsplugins_script_fs]&quot;)];
                var howMany = tspSRS.$tallies[tspSH.$tbmTargetMode];
                if (howMany &gt; 8) howMany = 8;
                var whichTargets = this._bankTheseTargets(tspSH.$tbmTargetMode);
                for (var n = 1; n &lt;= howMany; n++) {
                    var thisTarget = whichTargets[howMany - n];
                    var matchFound = tspFS._tmiCheckForMatch(thisTarget, tspFS.$targetsMemoryData);
                    if (thisTarget.isInSpace &amp;&amp; !matchFound) player.ship.target = thisTarget;
                }

                // Updates the TMI MFD.
                tspFS._tmiGroupInRange();
                worldScripts[expandDescription(&quot;[tsplugins_script_tmi]&quot;)]._setMfdString();
                tspSH.$tbmActive = false;

            }

}

</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/target-system-plugins_tmi.js</td>
                    <td><pre>&quot;use strict&quot;;

this.name           = &quot;TargetSystemPlugins_TargetMemoryInterface&quot;;
this.author         = &quot;Nicholas Menchise&quot;;
this.copyright      = &quot;(C) 2019 Nicholas Menchise&quot;;
this.licence        = &quot;CC BY-NC-SA 4.0&quot;;

//
// This world script includes the instructions for the TMI MFD strings and checking the equipment status.
//


// Whether or not the equipment is on the player ship
this.$onShip = false;

// Whether or not the equipment is functioning
this.$ready = false;

// Whether or not MFD updates should be suspended to prevent tip strings from changing every second
this.$mfdSuspend = false;

// Calls the function that updates the equipment MFD at regular intervals, if the equipment is functioning
this.$readyUpdate = new Timer(this, function() { this._timedUpdate(); }, 0, 1);

// Stores the MFD key for the equipment
this.$mfdKey = &quot;tsplugins_tmi&quot;;


//
// Checks the status of the equipment and its dependencies. Returns a boolean.
//
// This function is called by _timedUpdate function. It is also called by _setMfdString function in
// world script TargetSystemPlugins_ShortRangeSnapshot. It is also called by _statusCheck function
// in equipment script Target SystemPlugins_TargetBankingModule. It is also called by event handlers
// in world script TargetSystemPlugins_SharedHandlers. It is also called by _cascadeWeaponAlert function
// in world script TargetSystemPlugins_SharedHandlers.
//
// A negative status (false) will trigger a function call that results in a status update.
// An integer is calculated and passed in the same function call to provide more specific
// information in the status update.
//
this._statusCheck = function() {
    var dependsValue = 0;
    var dependsResult = false;

    if (player.ship.equipmentStatus(expandDescription(&quot;[tsplugins_eqkey_tmi]&quot;)) === &quot;EQUIPMENT_OK&quot;) dependsValue = 2;
    if (player.ship.equipmentStatus(&quot;EQ_TARGET_MEMORY&quot;) === &quot;EQUIPMENT_OK&quot;) dependsValue++;

    if (dependsValue == 3) dependsResult = true;
    if (this.$ready &amp;&amp; dependsValue &lt; 3) this._statusUpdate(false, dependsValue);

    return dependsResult;
}


//
// Updates the status of the equipment and informs the player when it&#39;s activated, disabled or damaged.
//
// This function is called by _statusCheck function. It is also called by event handlers in the world
// script TargetSystemPlugins_SharedHandlers.
//
// isWorking argument stores a boolean that indicates if the equipment is enabled.
//
// whatHappened argument stores an integer that indicates the cause of the status change.
// A value of 3 means that the equipment is fine, but something else may be stopping it, e.g. witchspace tunnel.
// A value of 2 means that the dependency check has failed.
// A value less than 2 means that the equipment is damaged.
//
this._statusUpdate = function(isWorking, whatHappened) {

    // Changes the ready status and stops the timer, if necessary. Stops the function if equipment is off the ship.
    if (this.$ready !== isWorking) this.$ready = isWorking;
    if (!isWorking &amp;&amp; this.$readyUpdate.isRunning) this.$readyUpdate.stop();
    if (!this.$onShip) return;

    // Sets the string for the status update to the MFD.
    var theseLines = &quot;&quot;;    // stores the MFD update string.
    if (isWorking) theseLines = expandDescription(&quot;[tsplugins_ready_tmi]&quot;);
    if (!isWorking &amp;&amp; whatHappened == 3) theseLines = expandDescription(&quot;[tsplugins_title_tmi][tsplugins_mfd_status_witchspace]&quot;);
    if (!isWorking &amp;&amp; whatHappened == 2) theseLines = expandDescription(&quot;[tsplugins_disabled1_tmi]&quot;);
    if (!isWorking &amp;&amp; whatHappened &lt; 2) theseLines = expandDescription(&quot;[tsplugins_broken_tmi]&quot;);

    // Calls the MFD setting function.
    worldScripts[expandDescription(&quot;[tsplugins_script_sh]&quot;)]._setMfd(this.$mfdKey, theseLines);

    // Resumes the timer that calls regular updates to the MFD, if the equipment has become functional.
    // The two second delay ensures that the player can see the status update when the equipment is activated.
    //
    if (isWorking &amp;&amp; !this.$readyUpdate.isRunning) {
        this.$readyUpdate.nextTime = clock.absoluteSeconds + 2;
        this.$readyUpdate.start();
        this.$mfdSuspend = false;    // fixed a bug where the MFD was stuck on startup instead of displaying tip
    }
        else {
        }
}


//
// Updates the equipment MFD at regular intervals, if the equipment is functional and targets are within scanner range.
//
// This function is called by $readyUpdate timer.
//
this._timedUpdate = function() {
    var isWorking = this._statusCheck();
    if (!isWorking) return;
    var tspFS = worldScripts[expandDescription(&quot;[tsplugins_script_fs]&quot;)];
    tspFS._tmiGroupInRange();
    if (tspFS.$targetsMemoryInRange.length &gt; 0) this.$mfdSuspend = false;
    var srsWorking = worldScripts[expandDescription(&quot;[tsplugins_script_srs]&quot;)]._statusCheck();
    if (srsWorking) tspFS._tmiSignUpdate();
    if (!this.$mfdSuspend) this._setMfdString();
}


//
// Sets the string that will be sent to the equipment MFD and calls the MFD update.
//
// This function is called by _timedUpdate function.
// It is also called by shipTargetAcquired event handler in world script TargetSystemPlugins_SharedHandlers.
// It is also called by .activated event handler in equipment script TargetSystemPlugins_TargetBankingModule.
//
// This should only be called shortly after _tmiGroupInRange function in world script
// TargetSystemPlugins_FilterSort is called, if not immediately afterwards.
//
this._setMfdString = function() {
    var sayThisMfd = &quot;&quot;;
    var srsWorking = worldScripts[expandDescription(&quot;[tsplugins_script_srs]&quot;)]._statusCheck();
    var tspFS = worldScripts[expandDescription(&quot;[tsplugins_script_fs]&quot;)];
    var targetsIndex = tspFS.$targetsMemoryInRange;

    if (targetsIndex.length &gt; 0) {
    // Sets the target list string when targets are found.

        // Sets the first line, which includes the title and number of targets in memory that are within scanner range.
        // The second line is blank.
        //
        var lineOne = expandDescription(&quot;[tsplugins_title_tmi]&quot;) + &quot;                &quot; + targetsIndex.length + &quot;\n&quot; + &quot;\n&quot;;

        // Gets the columns for the remaining lines.
        var selectColumn = this._getSelectionColumn(tspFS.$targetsMemoryData, targetsIndex);
        var symbolColumn = this._getCategoryColumn(tspFS.$targetsMemorySigns, targetsIndex, srsWorking);
        var namesColumn = this._getTargetNamesColumn(tspFS.$targetsMemoryData, targetsIndex);

        // Sets up the columns.
        var linesEight = &quot;&quot;;
        for (var n = 0; n &lt; 8; n++) {
            linesEight = linesEight + selectColumn[n] + symbolColumn[n] + &quot;  &quot; + namesColumn[n];
            if (n &lt; 7) linesEight += &quot;\n&quot;;
        }

        sayThisMfd = lineOne + linesEight;
    }
        else if (srsWorking) {
            // Sets the TMI Guide string when no targets are found. The type of string depends on the SRS status.
            sayThisMfd = expandDescription(&quot;[tsplugins_mfd_tip1_tmi]&quot;);
            this.$mfdSuspend = true;
        }
            else {
                sayThisMfd = expandDescription(&quot;[tsplugins_mfd_tip2_tmi]&quot;);
                this.$mfdSuspend = true;
            }

    // Calls the MFD setting function.
    worldScripts[expandDescription(&quot;[tsplugins_script_sh]&quot;)]._setMfd(this.$mfdKey, sayThisMfd);
}


//
// Returns an array of strings that define the target selection column of the TMI MFD.
//
// This function is called by _setMfdString function.
//
// targetsInHistory argument is an array of objects selected with the player ship&#39;s targeting system recently.
// targetsInRange argument is an array of index positions of objects in targetsInHistory that are within the
// player ship&#39;s scanner range.
//
this._getSelectionColumn = function(targetsInHistory, targetsInRange) {
    var thisColumn = [];
    for (var n = 0; n &lt; 8; n++) thisColumn[n] = expandDescription(&quot;[tsplugins_mfd_unselected]&quot;);
    for (var n = 0; n &lt; targetsInRange.length; n++) {
        var thisOne = targetsInRange[n];
        if (targetsInHistory[thisOne] === player.ship.target)
            thisColumn[n] = expandDescription(&quot;[tsplugins_mfd_selected]&quot;);
    }
    return thisColumn;
}


//
// Returns an array of strings that define the target category column of the TMI MFD.
//
// This function is called by _setMfdString function.
//
// symbolsInHistory argument is an array of target category symbols corresponding to objects selected
// with the player ship&#39;s targeting system recently.
// targetsInRange argument is an array of index positions of symbolsInHistory corresponding to objects
// that are within the player ship&#39;s scanner range.
// snapshotAvailable argument is a boolean that indicates whether or not the SRS is functioning.
//
this._getCategoryColumn = function(symbolsInHistory, targetsInRange, snapshotAvailable) {
    var thisColumn = [];
    for (var n = 0; n &lt; 8; n++) thisColumn[n] = expandDescription(&quot;[tsplugins_sign_blank]&quot;);
    for (var n = 0; n &lt; targetsInRange.length; n++) {
        if (!snapshotAvailable) break;
        var thisOne = targetsInRange[n];
        thisColumn[n] = symbolsInHistory[thisOne];
    }
    return thisColumn;
}


//
// Returns an array of strings that define the target names column of the TMI MFD.
//
// This function is called by _setMfdString function.
//
// targetsInHistory argument is an array of objects selected with the player ship&#39;s targeting system recently.
// targetsInRange argument is an array of index positions of objects in targetsInHistory that are within the
// player ship&#39;s scanner range.
//
this._getTargetNamesColumn = function(targetsInHistory, targetsInRange) {
    var thisColumn = [];
    for (var n = 0; n &lt; 8; n++) thisColumn[n] = &quot;&quot;;
    for (var n = 0; n &lt; targetsInRange.length; n++) {
        var thisOne = targetsInRange[n];
        var nameThisOne = targetsInHistory[thisOne].displayName;
        if (nameThisOne.length &gt; 31) nameThisOne = nameThisOne.substring(0, 29) + &quot;...&quot;;
        thisColumn[n] = nameThisOne;
    }
    return thisColumn;
}

</pre></td>
                </tr>
            </table>
        </a>
    </body>
</html>
