<html>
    <head>
        <title>Expansion Bulletin Board System</title>
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <table border="0" width="100%">
            <tr>
                <td>Back to <a href='../index.html'>Index</a></td>
                <td align="right"><small>Page generated: Oct 11, 2023, 3:16:49 PM</small></td>
            </tr>
        </table>

        <h1>Expansion Bulletin Board System</h1>

        <h2>Content</h2>
        <ul>
          <li><a href="#warnings">Warnings</a></li>
          <li><a href="#manifest">Manifest</a></li>
          <li><a href="#documentation">Documentation</a></li>
          <li><a href="#equipment">0 Equipment</a></li>
          <li><a href="#ships">0 Ships</a></li>
          <li><a href="#models">0 Models</a></li>
          <li><a href="#scripts">1 Scripts</a></li>
        </ul>

          <a name="warnings">
            <h2>Warnings</h2>
            <ol>
                <li>Information URL mismatch between OXP Manifest and Expansion Manager string length at character position 0</li>
            </ol>
          </a>

        <a name="manifest">
        <h2>Manifest</h2>
            <table border="1">
                <tr>
                    <th></th>
                    <th>from Expansion Manager's OXP list</th>
                    <th>from Expansion Manifest</th>
                </tr>
                <tr>
                    <td>Description</td>
                    <td>Adds an interface screen for local or event-driven mission opportunities.</td>
                    <td>Adds an interface screen for local or event-driven mission opportunities.</td>
                </tr>
                <tr>
                    <td>Identifier</td>
                    <td>oolite.oxp.phkb.BulletinBoardSystem</td>
                    <td>oolite.oxp.phkb.BulletinBoardSystem</td>
                </tr>
                <tr>
                    <td>Title</td>
                    <td>Bulletin Board System</td>
                    <td>Bulletin Board System</td>
                </tr>
                <tr>
                    <td>Category</td>
                    <td>Miscellaneous</td>
                    <td>Miscellaneous</td>
                </tr>
                <tr>
                    <td>Author</td>
                    <td>phkb</td>
                    <td>phkb</td>
                </tr>
                <tr>
                    <td>Version</td>
                    <td>2.2</td>
                    <td>2.2</td>
                </tr>
                <tr>
                    <td>Tags</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Required Oolite Version</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Maximum Oolite Version</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Required Expansions</td>
                    <td>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>Optional Expansions</td>
                    <td>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>Conflict Expansions</td>
                    <td>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>Information URL</td>
                    <td><a target="_blank" href=""></a></td>
                    <td><a target="_blank" href="">n/a</a></td>
                </tr>
                <tr>
                    <td>Download URL</td>
                    <td><a target="_blank" href="https://wiki.alioth.net/img_auth.php/9/90/BulletinBoardSystem.oxz">https://wiki.alioth.net/img_auth.php/9/90/BulletinBoardSystem.oxz</a></td>
                    <td><a target="_blank" href="">n/a</a></td>
                </tr>
                <tr>
                    <td>License</td>
                    <td>CC-BY-NC-SA 4.0</td>
                    <td>CC-BY-NC-SA 4.0</td>
                </tr>
                <tr>
                    <td>File Size</td>
                    <td>n/a</td>
                </tr>
                <tr>
                    <td>Upload date</td>
                    <td>1656887470</td>
                </tr>
            </table>
                </a>

        <a name="documentation">
        <h2>Documentation</h2>
        <p>Also read <a href='http://wiki.alioth.net/index.php/Bulletin%20Board%20System'>http://wiki.alioth.net/index.php/Bulletin%20Board%20System</a></p>
        <h3>readme.txt</h3>
        <pre>Bulletin Board System
By Nick Rogers

Overview
========
This OXP adds a bulletin board to most stations in Oolite, from which missions (added by other OXP&#39;s) can be viewed and accepted. This OXP doesn&#39;t include any missions itself - it is a framework that other OXP&#39;s can utilise to make the process of adding missions easier.

Player Usage
============
The Bulletin Board is accessed through the Interfaces screen (F4), and it&#39;s normally found under the &quot;Contracts&quot; section. If there are no missions available, and you don&#39;t have any active missions, the interface won&#39;t be listed. When there are missions available, or you have active missions, the number of these will be displayed on the interface entry. eg &quot;GalCop bulletin board (4 available, 2 active)&quot;.

When the interface is opened, any active missions will be grouped at the top of the list. Active missions are marked with a &quot;•&quot; and also have a value in the &quot;%&quot; (percentage completed) column. All other entries in the list are available missions.

If the destination system of a mission is directly on your currently plotted course on the F6 system map, the mission will be coloured green. If the destination is within 7ly of any system on your currently plotted course, the mission will be colours dark green. Using the Library Config OXP (see http://wiki.alioth.net/index.php/Library), the use of colour can be changed to instead use markers, where a † beside the destination system name means &quot;on current course&quot;, and a ‡ means &quot;near current course&quot;. 

When a mission is selected from the list, details of the mission will be displayed. These details include:
    Description              The short description of this mission.
    Details                  Full details of the mission parameters.
    Destination system       Where the mission needs to be completed at.
    Mission expires in       How much time you have to complete the mission.
    Payment on completion    How much you will be paid when the mission is completed.
    Penalty                  How much you will be charged if you fail to complete the mission. This value will be scaled by how much of the mission you completed.

If you have accepted a mission you will also see:    
    Percent complete         How much of the mission has been completed so far.

At the bottom of the screen will be the following options:
    Accept mission           This will signal that you are starting this mission.
    Show destination         This will display a chart (either a short range or long range, depending on the distance to the destination), allowing the player to 
                             see where the destination is.

Once you have accepted a mission, you will see the following options:
    Terminate mission        This will signal that you are giving up on this mission. If the mission has a penalty, it will be applied now. The mission will be removed from the list.
    Complete mission         This will only be available once the percent complete reaches 100%. This option will give you your payment and remove the mission from the list.

Active missions are shown on the F5F5 Manifest screen, under the &quot;Bulletin Board Missions&quot; heading. Depending on the mission, you will likely see how much of the mission you have yet to complete, and how much time is remaining before the mission expires.

Some missions will automatically complete as soon as you reach 100%, some will complete the next time you dock. It&#39;s important to check back on the Bulletin Board to see if you need to &quot;Complete&quot; the mission yourself.

Technical Details
=================
The purpose of the Bulletin Board system is to create a simple yet flexible interface which OXP authors can use to offer custom missions to the player. Missions added to the list are intended to be only available in the current system. Active missions are stored by the system and saved in the save game file, but the list of available missions will be cleared out with each hyperspace jump. 

To add a new mission to the Bulletin Board, you need to run the &quot;$addBBMission&quot; function and pass an object with the following parameters:

   ---------------------------------------------------------------------------------------------------------------------------
    var bb = worldScripts.BulletinBoardSystem;
    if (bb) {
        var myID = bb.$addBBMission({
                description:&quot;My first mission&quot;,
                source:7,
                destination:129,
                stationKey:&quot;galcop&quot;,
                details:&quot;This is my first sample mission available on the Bulletin board.&quot;,
                manifestText:&quot;My mission is active!&quot;,
                statusText:&quot;A special text description to include on the briefing screen.&quot;,
                expiry:clock.seconds + 86400,
                payment:1000,
                penalty:100,
                deposit:0,
                allowPartialComplete:false,
                allowTerminate:true,
                accepted:false,
                percentComplete:0,
                completionType:&quot;AT_SOURCE&quot;,
                stopTimeAtComplete:false,
                markerShape:&quot;MARKER_PLUS&quot;,
                markerColor:&quot;cyanColor&quot;,
                markerScale:1.0,
                model:&quot;police&quot;,
                spinModel:true,
                disablePercentDisplay:true,
                playAcceptedSound:true,
                noEmails:true,
                customDisplayItems:&quot;&quot;,
                initiateCallback:&quot;$myMissionInitiate&quot;,
                completedCallback:&quot;$myMissionComplete&quot;,
                confirmCompleteCallback:&quot;$myMissionConfirmComplete&quot;,
                terminateCallback:&quot;$myMissionTerminate&quot;,
                failedCallback:&quot;$myMissionFailed&quot;,
                manifestCallback:&quot;$myMissionUpdateManifest&quot;,
                availableCallback:&quot;$myMissionAvailableCheck&quot;,
                worldScript:&quot;MyFirstMission&quot;
        });
    }
   ---------------------------------------------------------------------------------------------------------------------------

In detail these parameters are:
    ID                          (optional) You can specify your own ID number, rather than let the BB system create one. 
                                    If the ID you specify is already in use an error will be generated.
    description                 (required) This is the description of the mission shown in the Bulletin board list
    source                      (optional) The system ID of the source of this mission. If not included it will default to the 
                                    current system&#39;s ID.
    destination                 (required) This is the system ID of the destination system where the mission will be carried out. 
                                    This can be the current system, if the mission is local.
                                    Setting destination to -1 equals Interstellar space.
                                    Setting destination to 256 means there is no fixed destination.
    stationKey                  (optional) The stationKey helps to limit which stations the mission will be offered in. 
                                    See the section below title &quot;Station Keys&quot; for more details. 
                                    If omitted this will default to &quot;&quot; (blank), meaning this mission will be available from all 
                                    stations in this system
    details                     This is the full details of the mission parameters.
    manifestText                (optional) This is the text to display on the F5F5 manifest screen when the mission has been 
                                    accepted. See also &quot;manifestCallback&quot; below.
    statusText                  (optional) This is the text to display on the mission briefing screen when the mission is active. 
                                    If not set, the &quot;manifestText&quot; property will be used instead.
    expiry                      (required) The time is clock seconds when the mission must be completed by. If set to -1 this
                                    means the item has no expiry time.
    payment                     (optional) The number of credits the player will be given when they complete the mission.
    penalty                     (optional) The number of credits the player will be charged if they fail to complete the mission, 
                                    scaled by the percentage completed.
    deposit                     (optional) The number of credits the player will need to pay up-front to accept the mission. 
                                    This amount will be refunded when the mission is completed.
    allowPartialComplete        (optional) True/false value that indicates whether the player can complete the mission with less 
                                    than the full percentage. 
                                    Payment and deposit will be scaled by the percentage completed. Penalties will also apply, 
                                    again scaled by the percentage completed.
                                    For example, if the payment is 100 cr and the penalty 10 cr, and the player completes 70% of 
                                    the mission, if they hand it in they would receive 70 cr (70% of 100), and the penalty would 
                                    be 3 cr (30% of 10), meaning their total payment would be 73 cr.
                                    Default is false.
    allowTerminate              (optional) True/false value indicating whether the &quot;Terminate mission&quot; will be available to the 
                                    player after accepting the mission. The default is true.
    accepted                    (optional) True/false value indicating whether this mission will be added to the list as already 
                                    accepted by the player. Under normal circumstances this item can be left out. However, if 
                                    you want to link missions together, so completing one mission automatically starts a second 
                                    mission, you may want to add the mission to the list as &quot;accepted:true&quot; so the player 
                                    doesn&#39;t have to go to the Bulletin Board and manually accept the second mission.
                                    The default is false.
    percentComplete             (optional) A decimal value between 0 and 1. Allows you to create missions that already have some 
                                    part completed.
    completionType              (optional) A text value indicating what should happen when the player completes the mission 
                                    (ie the percentComplete value reached 1, or 100%). Can be one of these:
                                    AT_SOURCE                Player must return to the source system/station, open the mission 
                                                                and select &quot;Complete mission&quot;.
                                    AT_STATIONKEY            Player can return to any system, dock at any station with the same 
                                                                stationKey, open the mission and select &quot;Complete mission&quot;.
                                    ANYWHERE                 Player can return to any system, dock at any station, open the 
                                                                mission and select &quot;Complete mission&quot;.
                                    IMMEDIATE                Player is rewarded immediately when the mission is flagged as 100% 
                                                                complete - player won&#39;t need to dock anywhere.
                                    WHEN_DOCKED_SOURCE       Player is automatically rewarded as soon as they next dock at the 
                                                                source system/station. Notice will appear in arrival report.
                                    WHEN_DOCKED_STATIONKEY   Player is automatically rewarded as soon as they next dock at any 
                                                                station, any system, but with the same station key. Notice will 
                                                                appear in arrival report.
                                    WHEN_DOCKED_ANYWHERE     Player is automatically rewarded as soon as they next dock at any 
                                                                station, any system. Notice will appear in arrival report.
                                    The default is &quot;AT_SOURCE&quot;.
    stopTimeAtComplete          (optional) True/false flag to indicate that the clock will stop when the mission is flagged 
                                    100% complete. 
                                    Default false. This means that, for a completionType of &quot;AT_SOURCE&quot; the player has to 
                                    return to the original station within the allowed time in order to complete the mission. 
                                    If this flag is set to true, once the player completes the mission at the destination, 
                                    they are free to take as much time as they like to return to the original station and 
                                    hand in their mission.
                                    This flag will be ignored if the completionType is set to &quot;IMMEDIATE&quot;.
    arrivalReportText           (optional) When the completionType is set to &quot;WHEN_DOCKED_*&quot; this text will be displayed on the 
                                    arrival report when the player completes the mission.
                                    If omitted, will default to &quot;&#39;&lt;description&gt;&#39; mission complete. You have been awarded &lt;payment&gt;.&quot;
    model                       (optional) Role of a ship to use as the background on the mission details screen.
    modelPersonality            (optional) The entityPersonality assigned to the ship model.
    spinModel                   (optional) True/false value indicating whether the ship model will rotate or not. 
                                    The default is true.
    background                  (optional) guiTextureSpecifier (name of a picture used as background)
    overlay                     (optional) guiTextureSpecifier (name of a picture used as overlay)
                                    Will default to the bulletin board graphic when not set.
    mapOverlay                  (optional) guiTextureSpecifier (name of a picture used as overlay) for the map screen.
                                    Will default to the &quot;overlay&quot; setting (if set), otherwise will use the bulletin board graphic.
    forceLongRangeChart         (optional) True/false value which, when true, indicates that the map display for this mission 
                                    should always be a long range chart. When false, map zoom will be chosen based on the distance
                                    between the source and destination systems.
                                    The default is false.
    markerShape                 (optional) Allows the shape of the galactic chart marker to be overridden. 
                                    Default is &quot;MARKER_PLUS&quot;. Possible values are:
                                    NONE             No galactic chart marker will be added.
                                    MARKER_X         Uses an &quot;X&quot; to mark the system.
                                    MARKER_PLUS      Uses a &quot;+&quot; to mark the system.
                                    MARKER_SQUARE    Uses a square shape to mark the system.
                                    MARKER_DIAMOND   Uses a diamond shape to mark the system.
    markerColor                 (optional) Allows the color of the galactic chart marker to be overridden. 
                                    Default is &quot;redColor&quot;.
    markerScale                 (optional) Allows the scale setting of the galactic chart marker to be overridden. 
                                    Value between 0.5 and 2.0. Default is 1.0.
    additionalMarkers           (optional) Array of marker dictionaries definition any extra systems that should be marked on
                                    the system map for this mission.
                                    Each item can have:
                                    system          system ID to mark (required)
                                    markerShape     one of the standard marker shapes (default MARKER_PLUS)
                                    markerColor     color of the marker (default redColor)
                                    markerScale     scale of the marker (default 1.0)
    disablePercentDisplay       (optional) Controls the display of the &quot;Percent complete&quot; value on this mission details page. 
                                    Default is false.
                                    When set to true, only the mission manifest text will be shown on the mission details page.
    playAcceptedSound           (optional) Controls whether the [contract-accepted] sound will be player upon contract acceptance. 
                                    Default is true.
    noEmails                    (optional) If the Email System is installed, but you don&#39;t want this item to send confirmation 
                                    emails, set this flag to true.
    customDisplayItems          (optional) Allows a mission to specify additional, non-standard items on the details page.
                                    When used, should be set to an array of dictionary items, having &quot;heading&quot; and &quot;value&quot; 
                                    properties in each dictionary object.
                                    eg [{heading:&quot;Special Instructions:&quot;, value:&quot;Be very, very qwiet...&quot;}]
    customMenuItems             (optional) Provides a way for a third party to add custom menu entries to a BB item. 
                                    When used, should be set to an array of dictionary items, having the following elements:
                                    text            (required) Text to display in the menu item
                                    worldScript     (required) Name of the worldScript which contains the callback function
                                    callback        (required) Name of the callback function 
                                                        (the mission ID will be passed as a parameter)
                                    condition       (optional) Name of a callback function that will return either a blank string,
                                                        meaning the menu item is available, or a string containing the reason why
                                                        the menu item is unavailable.
                                                        (the mission ID will be passed as a parameter)
                                    activeOnly      (optional) Boolean value indicating the menu item is only visible when the
                                                        mission is active. Default is true.
                                    autoRemove      (optional) Boolean value that indicates the menu should be removed from 
                                                        the BB item as soon as the player selects it. Default is false.
    initiateCallback            (optional) The function name to call back when the mission is accepted by the player.
    completedCallback           (optional) The function name to call back when the mission is completed by the player, 
                                    based on the completionType setting.
    confirmCompleteCallback     (optional) A function name to call to confirm the mission has been completed. Useful if there 
                                    are secondary steps that must have been completed by the player.
                                    For instance, you might want to check that the player has a particular amount of a certain 
                                    commodity in their hold.
                                    Expects a string return value of blank (meaning mission is completed) or [string explaining 
                                    why mission cannot be completed] (meaning the mission is not complete).
    terminateCallback           (optional) The function name to call back when the mission is terminated/cancelled by the player.
    failedCallback              (optional) The function name to call back when the player fails to complete the mission in the 
                                    alloted time. Called during the &quot;shipWillDockWithStation&quot; event.
    manifestCallback            (optional) The function name to call back when the manifest entry for the mission requires updating.
                                    Note: If both the manifestText and manifestCallback are blank, no information will be
                                    displayed for this mission if it becomes active.
    availableCallback           (optional) The function to call to check if the mission is actually available. The mission ID will 
                                    be passed as a parameter. Function should return a string value of either a blank (&quot;&quot;), to 
                                    indicate the mission is available, or a short description of the reason why the mission is
                                    unavailable (eg &quot;Insufficient cargo space&quot;).
    bonusCalculationCallback    (optional) The function to call to calculate and return any bonus payment when the player 
                                    successfully completes a mission. Will only be called if the mission is 100% completed 
                                    inside the allotted time. If set, must return a number &gt;= 0. Will be called after the 
                                    completedCallback function, if set.
    worldScript                 (required) The name of the worldScript where these functions reside.
    postStatusMessages          (optional) Array of dictionary objects defining a message to be displayed to the player when 
                                    they accept, complete or terminate a mission.
                                    status             (required) Defines which status the message will follow. Possible values:
                                                           initiated, completed, terminated
                                    text               (required) The text of the message to be displayed
                                    return             (optional) Where to return the player to after the mission page is displayed
                                                           item     Returns player to the mission details page (N/A for completed/terminated)
                                                           list     Returns player to the mission listing
                                                           exit     Returns player to the F4 Interfaces screen
                                    background         (optional) guiTextureSpecifer to use for the background of the message
                                    overlay            (optional) guiTextureSpecifer to use for the overlay of the message
                                    model              (optional) ship model to use on the message.
                                    modelPersonality   (optional) The entityPersonality assigned to the ship model.
                                    spinModel          (optional) True/false value indicating whether the ship model will rotate or not. 
                                                           The default is true.
                                    If any of the optional parameters are left out, the equivalent parameter from the BB item will be used.
    data                        (optional) Any data that might be useful to store with the mission for later access.

This call will return a unique ID (integer) value (either created by the BB system or passed from the caller) that can be stored and used to reference this mission in other bulletin board functions.

Once a mission has been added, it is up to the calling script to work out and track the criteria required to complete a mission. The BB system will handle the display of information, and will pay or charge the player if they complete or fail the mission. But the rules which govern the mission criteria are controlled solely by the calling routine. It is up to the calling routine to track the mission and tell the BB system when updates are required.

With that in mind, the following functions will be of use to the calling party:

   ---------------------------------------------------------------------------------------------------------------------------
   $updateBBMissionPercentage(bbID, percentage);
   ---------------------------------------------------------------------------------------------------------------------------
   This function will update the percentage completed value for a given mission ID (as provided by the $addBBMission function).
   
   When this function is called, it will also initiate the &quot;manifestCallback&quot; routine, giving the OXP an opportunity to update the manifest entry.
   
   If the percentage is 1 (ie. 100%), and the completionType is &quot;IMMEDIATE&quot;, the &quot;completedCallback&quot; routine will be called and the mission will be removed from the list. Otherwise, the mission will be completed at another event (eg when docking, or when the player selects &quot;Complete Mission&quot; on the mission details screen.)
   
   ---------------------------------------------------------------------------------------------------------------------------
   $updateBBManifestText(bbID, newtext);
   ---------------------------------------------------------------------------------------------------------------------------
   This function will update the manifest text entry for a given mission ID. This function should generally be called from the &quot;manifestCallback&quot; routine.

   ---------------------------------------------------------------------------------------------------------------------------
   $updateBBStatusText(bbID, newtext);
   ---------------------------------------------------------------------------------------------------------------------------
   This function will update the status text on the mission briefing screen for a given mission ID. This function should generally be called from the &quot;manifestCallback&quot; routine. If no status text is supplied, the &quot;manifestText&quot; property will be used instead.

   ---------------------------------------------------------------------------------------------------------------------------
   $shuffleBBList()
   ---------------------------------------------------------------------------------------------------------------------------
   A function to randomise the order of bulletin board items. This can be handy if you add missions to the list in a sequence, but you don&#39;t want that sequence to be visible to the player by having all the same types of missions grouped together.
   
   ---------------------------------------------------------------------------------------------------------------------------
   $percentCompleted(bbID)
   ---------------------------------------------------------------------------------------------------------------------------
   Returns the current percentage complete value for a particular mission ID.

   ---------------------------------------------------------------------------------------------------------------------------
   $removeBBMission(bbID)
   ---------------------------------------------------------------------------------------------------------------------------
   Removes a particular mission ID from the list. This method skips any mission constraints and completed/failed events and just removed the record. This can be useful when chaining missions together, if the previous mission needs to be removed completely, without performing any of the callbacks.

   ---------------------------------------------------------------------------------------------------------------------------
   $getItem(bbID)
   ---------------------------------------------------------------------------------------------------------------------------
   Returns a bulletin board mission object for the given mission ID.

   ---------------------------------------------------------------------------------------------------------------------------
   $getIndex(bbID)
   ---------------------------------------------------------------------------------------------------------------------------
   Returns the index value of the given mission ID in the internal data array. This can be useful if you would like to update mission parameters directly (eg. changing the &quot;stopTimeAtComplete&quot; flag).
   Note: Because index values are subject to change without notices (particularly between saves) the value returned from this function should be used and then discarded. Do not try to save the index value in some method and use it later - you may be updating a completely different mission!

   ---------------------------------------------------------------------------------------------------------------------------
   $removeCustomMenuItem(bbID, index)
   ---------------------------------------------------------------------------------------------------------------------------
   Removes the custom menu item from the passed mission ID at the index point.

   ---------------------------------------------------------------------------------------------------------------------------
   $registerBBEvent(wsName, fnName, eventName)
   ---------------------------------------------------------------------------------------------------------------------------
   Registers a worldScript/function to be called when a particular BB system event takes place. 
       wsName                         Name of worldscript where function can be found.
       fnName                         Name of the function to call.
       eventName                      Name of the event to attach to.
   At the moment, the possible events are:
       missionAdded                   Occurs when a mission is added to the BB.
       open                           Occurs when the BB is opened.
       close                          Occurs when the BB is closed using the &quot;Close&quot; option.
       exit                           Occurs when the BB is closed by the player selecting another Fn command.
       launchExit                     Occurs when the BB is closed by the player launching their ship. The station launched from will be passed as a parameter.
       preListDisplay                 Occurs just before the BB mission list is displayed
       postListDisplay                Occurs just after the BB mission list is displayed
       preItemDisplay                 Occurs just before a mission detail page is displayed. The mission ID will be passed as a parameter.
       postItemDisplay                Occurs just after a mission detail page is displayed. The mission ID will be passed as a parameter.
       preItemChartDisplay            Occurs just before the chart view of a mission is displayed. The mission ID will be passed as a parameter.
       postItemChartDisplay           Occurs just after the chart view of a mission is displayed. The mission ID will be passed as a parameter.
       shipWillDockWithStation_start  Occurs at the beginning of the shipWillDockWithStation world event.
       shipWillDockWithStation_end    Occurs at the end of the shipWillWillDockWithStation world event.

   ---------------------------------------------------------------------------------------------------------------------------
   $unregisterBBEvent(wsName, fnName, eventName)
   ---------------------------------------------------------------------------------------------------------------------------
   Removes a callback from the registration list.
       wsName                     Name of worldscript where function can be found.
       fnName                     Name of the function to call.
       eventName                  Name of the event to detach from.

   ---------------------------------------------------------------------------------------------------------------------------
   $setBackgroundDefault(guiTextureSpecifer)
   ---------------------------------------------------------------------------------------------------------------------------
   Sets the default background to use on the BB.

   ---------------------------------------------------------------------------------------------------------------------------
   $resetBackgroundDefault()
   ---------------------------------------------------------------------------------------------------------------------------
   Resets the default background back to the original default.

   ---------------------------------------------------------------------------------------------------------------------------
   $setOverlayDefault(guiTextureSpecifier)
   ---------------------------------------------------------------------------------------------------------------------------
   Sets the default overlay to use on the BB.

   ---------------------------------------------------------------------------------------------------------------------------
   $resetOverlayDefault()
   ---------------------------------------------------------------------------------------------------------------------------
   Resets the default overlay back to the original default.

Station Keys
------------
To limit the stations at which a mission will be available from, a station key is required. When the &quot;stationKey&quot; is not provided to the &quot;$addBBMission&quot; function, the mission will be available at all stations in the source system.

Each station can have multiple station keys, depending on the worldScript, but if no specific station key is added, the default station key will be the stations &quot;allegiance&quot; property. So, a station with an allegiance of &quot;galcop&quot; will have a default station key of &quot;galcop&quot;. Therefore, if you want to limit your mission to only be available at GalCop-aligned stations, you would include &quot;galcop&quot; in the &quot;stationKey&quot; when adding the mission to the bulletin board. If you want to include your mission at both &quot;galcop&quot; and &quot;chaotic&quot; stations, you would use a comma separator and make your mission stationKey &quot;galcop,chaotic&quot;.

But what if allegiance is insufficient to identify the specific station you want to add your mission to? In these cases, you need to give your target station a special stationKey of its own. At some point after the system has been populated, (for instance, during the systemWillPopulate or systemWillRepopulate events), find the station you want to give your special key to and perform the following function:

    var bb = worldScripts.BulletinBoardSystem;
    var stns = system.stations;
    
    // loop through all the available stations
    for (var i = 0; i &lt; stns.length; i++) {
        // if this station is the one I&#39;m looking for....you&#39;ll need to provide some logic for identifying your station
        if (stns[i].~~~something~~~) {
            // add the station key for this worldScript
            bb.$addStationKey(this.name, stns[i], &quot;myStationKey&quot;);

            // first parameter is &quot;worldScriptName&quot;. Normally this would be &quot;this.name&quot;.
            // second parameter is &quot;station&quot;. This is a reference to the station.
            // third parameter is &quot;stationKey&quot;. This is the station key that will be added to the list of keys for this worldScript and station combination.
        }
    }

Once the station has been given this custom key for your worldScript, you can use that key when adding missions. The custom key will override whatever default key the station may have had previously. A station can have multiple keys for your worldScript.

For example, let&#39;s say I wanted to create a mission that was only available at the main station of the system. However, with OXP&#39;s like &quot;Stations For Extra Planets&quot; installed, I can&#39;t just rely on the station.allegiance. What I need to do is this:

    this.systemWillPopulate = function() {
        if (system.mainStation) {
            var bb = worldScript.BulletinBoardSystem;
            bb.$addStationKey(this.name, system.mainStation, &quot;mainStation&quot;);
        }
    }

Now I can apply the &quot;mainStation&quot; station key to any bulletin board missions I add, and they will now only be visible at the main station in the system.

Removing the Bulletin Board from a Station
------------------------------------------
You may decide that you don&#39;t want to have the bulletin board at a particular station. This can be achieved in one of two ways:

1. In the shipdata.plist file for the station, include the following item in the &quot;script_info&quot; section:

    &quot;script_info&quot; = {
        &quot;bb_hide&quot; = 1;
    };

2. At some point after the system has been populated, find the station you want to hide the bulletin board on and add &quot;bb_hide&quot; value to the &quot;script&quot; property by doing the following:

    var stns = system.stations;
    for (var i = 0; i &lt; stns.length; i++) {
        // if this station is the one I&#39;m looking for....you&#39;ll need to provide some logic for identifying your station
        if (stns[i].~~~something~~~) {
            stns[i].script.bb_hide = 1;
        }
    }
    
Adding main menu items
======================
There may be times when you want a special menu item to appear on the main control listing page of the BB system, not just on the mission details page itself. To do this you can use the $addMainMenuItem and $removeMainMenuItem functions.

To add a menu item use the $addMainMenuItem function:

   ---------------------------------------------------------------------------------------------------------------------------
    var bb = worldScripts.BulletinBoardSystem;
    if (bb) {
        bb.$addMainMenuItem({
            text: &quot;Special function text&quot;,
            color:&quot;greenColor&quot;,
            unselectable: false,
            autoRemove: true,
            worldScript:&quot;myWorldScriptName&quot;,
            menuCallback:&quot;myFunctionName&quot;
        });
    }
   ---------------------------------------------------------------------------------------------------------------------------

In detail these parameters are:
	text                    Text to display on the menu
	color                   Color of the item. Will default to this._menuColor (orangeColor)
	unselectable            Flag to control whether the item should be unselectable. Defaults to false.
                                If true, color will be set to this._disabledColor (darkGreyColor).
	autoRemove              Flag to indicate the item should be removed from the menu when selected by the player.
                                Defaults to false.
	worldScript             WorldScript name for the callback function.
	menuCallback            Function to call when the user selects the item.

To manually remove a menu item (ie if the &quot;autoRemove&quot; option is set to false), use the $removeMainMenuItem function:

   ---------------------------------------------------------------------------------------------------------------------------
    var bb = worldScripts.BulletinBoardSystem;
    if (bb) {
        bb.$removeMainMenuItem(&quot;myWorldScriptName&quot;, &quot;myFunctionName&quot;);
    }
   ---------------------------------------------------------------------------------------------------------------------------

   This function accepts two parameters:
   worldScriptName          The name of the worldScript registered on the item.
   functionCallbackName     The name of the menu function callback on the item.

Example Mission Script
======================
The following is a very brief example demonstrating the methods of adding a mission to the bulletin board, and setting up the callbacks. This is a subset of a larger project, but should suffice in providing code examples of the techniques outlined above. This has also been included as an OXP in the &quot;Resources&quot; folder of the BB OXP package. Move the &quot;AsteroidHunter.OXP&quot; into your &quot;AddOns&quot; folder to see this OXP in action.

    &quot;use strict&quot;;
    this.name        = &quot;AsteroidHunter&quot;;
    this.author      = &quot;phkb&quot;;
    this.copyright   = &quot;2017 phkb&quot;;
    this.description = &quot;Adds a simple asteroid hunt mission to the Bulletin Board&quot;;
    this.licence     = &quot;CC BY-NC-SA 4.0&quot;;

    this._bb = null;				// link to Bulletin Board worldScript

    //-------------------------------------------------------------------------------------------------------------
    this.startUp = function() {
        // establish a link to the bulletin board worldscript
        this._bb = worldScripts.BulletinBoardSystem;
    }

    //-------------------------------------------------------------------------------------------------------------
    this.startUpComplete = function() {
        this.$addLocalMissions()
    }

    //-------------------------------------------------------------------------------------------------------------
    this.shipWillExitWitchspace = function() {
        // adds new missions to the list
        this.$addLocalMissions();
    }

    //-------------------------------------------------------------------------------------------------------------
    this.shipKilledOther = function(whom, damageType) {
        // mission type 1 - asteroid hunt - monitor when the player shoots an asteroid
        if (whom.hasRole(&quot;asteroid&quot;)) {
            var item = null;
            // cycle through the bulletin board list
            if (this._bb._data.length &gt; 0) {
                for (var i = 0; i &lt; this._bb._data.length; i++) {
                    item = this._bb._data[i];
                    // is this an accepted mission, and the target destination is the same as the current system...
                    if (item.accepted === true &amp;&amp; item.destination === system.ID) {
                        // ..and there is some data on the item, and the data has a property of &quot;type&quot; and the type is 1 (asteroid hunt) 
                        // and the number of destroyed asteroids is less than the target quantity
                        if (item.hasOwnProperty(&quot;data&quot;) &amp;&amp; item.data.hasOwnProperty(&quot;type&quot;) &amp;&amp; item.data[&quot;type&quot;] == 1 &amp;&amp; item.data.quantity &lt; item.data.targetQuantity) {
                            // ...then update the quantity
                            item.data.quantity += 1;
                            // signal the bulletin board that we&#39;ve had a change in the mission completion percentage
                            this._bb.$updateBBMissionPercentage(item.missionID, (item.data.quantity / item.data.targetQuantity));

                            // notify the player that we just did something that affected a mission
                            player.consoleMessage(&quot;Mission goal updated&quot;);
                        }
                    }
                }
            }
        }
    }

    //-------------------------------------------------------------------------------------------------------------
    // handles the manifest entry callback from the bulletin board
    this.$updateManifestEntry = function(missID) {
        var item = this._bb.$getItem(missID);
        if (item.data.quantity == item.data.targetQuantity) {
            this._bb.$updateBBManifestText(missID, 
                expandDescription(&quot;Mission to destroy asteroids complete. Return to the main station in [system] to claim payment.&quot;, 
                    {system:System.systemNameForID(item.source)})
            );
        } else {
            // otherwise, just update the description with what is currently expected
            this._bb.$updateBBManifestText(
                missID,
                expandDescription(&quot;Destroy [quantity] asteroids in [destination] within [expiry].&quot;, 
                    {quantity:(item.data.targetQuantity - item.data.quantity), 
                    destination:system.name, 
                    expiry:this._bb.$getTimeRemaining(item.expiry)})
            );
        }
    }

    //-------------------------------------------------------------------------------------------------------------
    // adds the asteroid hunt mission to the bulletin board
    this.$addLocalMissions = function() {
        // if we haven&#39;t got any missions in the available list, try to add one now
        // first, count up the number already in player
        var chk = 0;
        if (this._bb._data.length &gt; 0) {
            for (var i = 0; i &lt; this._bb._data.length; i++) {
                if (this._bb._data[i].destination === system.ID &amp;&amp;
                    this._bb._data[i].hasOwnProperty(&quot;data&quot;) &amp;&amp; 
                    this._bb._data[i].data.hasOwnProperty(&quot;type&quot;) &amp;&amp; 
                    this._bb._data[i].data[&quot;type&quot;] == 1) 
                    chk += 1;
            }
        }
        // if there&#39;s one there already, exit now
        if (chk &gt; 0) return;

        // pick a random number of asteroid that need to be destroyed
        var qty = parseInt((Math.random() * 10) + 10);
        // calculate the payment
        var amt = qty * 10;
        // calculate the expiry time
        var expire = clock.adjustedSeconds + 21600; // 6 hours to complete.
        // add the mission to the bulletin board, and make a note of the id
        var id = this._bb.$addBBMission({
            source:system.ID,
            destination:system.ID,
            stationKey:&quot;galcop&quot;,
            description:&quot;Clean up the spaceways&quot;,
            details:expandDescription(&quot;Commanders are needed to help clean up the spacelanes by removing [quantity] asteroids in this system.&quot;, {quantity:qty}),
            payment:amt,
            expiry:expire,
            penalty:0,
            model:&quot;asteroid&quot;,
            modelPersonality:parseInt(Math.random() * 32767),
            manifestCallback:&quot;$updateManifestEntry&quot;,
            worldScript:this.name,
            data:{type:1, targetQuantity:qty, quantity:0}
        });
    }

Licence
=======
This work is licensed under the Creative Commons Attribution-Noncommercial-Share Alike 4.0 Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/

Bulletin board image by icons8.com from http://www.iconsplace.com/black-icons/copy-icon with licence Creative Commons Attribution-NoDerivs 3.0 Unported

Version History
===============
2.2
- Fixed issue that could lead to missions having the same ID.

2.1
- The email ID of the last email sent relating to a BB item is now accessible through the &quot;lastEmailID&quot; property. Requires Email System v1.7.8.

2.0 
- Fixed issue were text was covering the map when the Advanced Navigation Array wasn&#39;t installed.

1.9
- Tweaks to the calculation for determining if an unaccepted mission is expired.

1.8
- Fixed issue where the calculation to determine whether an unaccepted mission should be considered expired was being a little too broad.
- Bug fixes.
- Code refactoring.

1.7
- Calls to &#39;confirmCompletedCallback&#39; now performed each time mission screen is opened when a &quot;Complete mission&quot; menu item is displayed.

1.6
- Added &quot;additionalMarkers&quot;, an array of marker dictionaries, which enables a single mission to have multiple markers on the system chart.
- Added &quot;forceLongRangeChart&quot;, a boolean value (default false), which will force the map screen to always show the long range chart, rather than a short range or custom chart.
- Fixed issue with &quot;playAcceptedSound&quot; not defaulting to true correctly.
- Fixed issue where some available items may not be shown on the main mission list if there are any active missions.

1.5.1
- Fixed issue calculating route time if there is no route to destination.

1.5
- Added option to highlight missions whose target system is on or near to your current course. Highlight can be via color or markers, switchable via Library.
- Code refactoring.
- Added mission description and payment amount to the map screen.
- Added &quot;Next contract&quot; menu item to mission details page.
- Included option (switchable via Library Config) of adding &quot;Next contract&quot; to map screen.

1.4
- Makes use of new short range chart and custom chart options available in Oolite 1.87.
- Better method of determining when missions are expired and then removing them from the BB list.
- Added a flag to Library Config that will allow the internal ID of a mission to be added to the mission details page, which can be useful for debugging.
- Now plays the &quot;[contract-accepted]&quot; sound when any contract is accepted.
- Added new flag to the &quot;$addBBMission&quot; object: &quot;playAcceptedSound&quot;, a boolean value allowing the contract to control whether the &quot;[contract-accepted]&quot; sound will be played.

1.3
- When setting a course to a target system, F7 screen will now display the new destination.

1.2
- Added expiry time in hours to the mission details screen.
- When 1 day is remaining, it will now read &quot;1 day&quot; rather than &quot;1 days&quot; (same for hours, minutes and seconds).

1.1
- Better handling of scenario where player doesn&#39;t have the Advanced Navigational Array installed.

1.0
- Added option to force the Bulletin Board interface screen to always be shown, even if no contracts are available.
- Fixed bug where missions that do not have a specific system destination (ie 256) were always displaying a &quot;Close to expiry&quot; warning.
- Turned on decimal place display on all credit value output.
- Bug fixes.

0.29
- Added additional text to mission briefings for missions close to expiry, to better explain the fact.
- Added a cleanup function to remove marked systems that have become orphaned from their mission.

0.28
- Sorted available missions by payment amount. Accepted missions will still be sorted by when they were accepted.

0.27
- Added &quot;shipWillDockWithStation_start&quot; and &quot;shipWillDockWithStation_end&quot; events, triggers at the start and then at the end of the shipWillDockWithStation, to allow mission OXP&#39;s to know in which order things will be processed, which is particularly important for BB items flagged as &quot;WHEN_DOCKED_SOURCE&quot;, &quot;WHEN_DOCKED_STATIONKEY&quot;, and &quot;WHEN_DOCKED_ANYWHERE&quot;.
- Method of using of &quot;formatCredits&quot; function is now consistent.

0.26
- Added the &quot;condition&quot; property to custom menu items, to allow for the item to be disabled in certain conditions.
- Added the &quot;activeOnly&quot; property to custom menu items, to allow the item to be hidden if the mission isn&#39;t active.

0.25
- At some point I&#39;d managed to delete the &quot;confirmCompleteCallback&quot; property when adding a new mission to the board. Fixed.

0.24
- Fixed issue with missions where completion type is AT_SOURCE, where the &quot;Complete mission&quot; menu item was not being displayed.

0.23
- Improved handling of missions with intergalactic source or destination systems.
- Fixed issue with Xenon Redux UI sometimes losing its background images on the BB.

0.22
- Added facility to add menu items to the main BB contract listing page.
- A BB item can now have the destination set to -1 (Interstellar space), or 256 (no fixed destination).
- Setting the payment of a BB item to zero will now hide the &quot;Payment&quot; line on the mission details page.
- &quot;payment&quot; is no longer a required element.
- Fixed more JS errors when terminating a contract.

0.21
- Expanded number of contracts shown on main listing to 21.
- Added &quot;bonusCalculationCallback&quot; to allow bonus payments to be calculated and given to the player when a mission is successfully completed.
- Fixed JS error when terminating a contract.
- Fixed reference error when attempting to retrieve a postStatusMessage for a completed mission.
- Added validations for postStatusMessages when adding a mission to the board.

0.20
- Fixed issue with new sorting methods conflicting with old indexing system for selected item.

0.19
- Added postStatusMessages property for individual missions to allow a mission screen to be shown to the player after status changes.
- When missions are accepted they will appear in the accepted list and manifest screen in the same order as they were accepted in.
- &quot;initiateCallback&quot; and &quot;completedCallback&quot; are no longer required elements.
- Corrections and adjustments to the &quot;AsteroidHunter&quot; sample script.
- Code cleanup and refactoring.

0.18
- Adjusted precedence of colors for items in the mission list. If a mission is both unavailable and close to expiry, unavailability will be selected for the item color.
- Added new events: &quot;open&quot; (fires when BB is opened), &quot;close&quot; (fires when BB is closed from the menu), &quot;exit&quot; (fires when BB is exited without specifically selecting &#39;Close&#39;), &quot;launchExit&quot; (fires when BB is exited by the player launching their ship).
- Added &quot;data&quot; element to BB item, so that relevant data can be stored with the mission, for later retrieval. This data is not displayed to the player.
- Adding a mission with the expiry parameter set to -1 will result in a mission with an unlimited expiry.
- Fixed issue where explicitly setting &quot;allowTerminate:true&quot; was not being correctly set.
- Page reset when returning from the map display to the briefing screen.
- Added the &quot;mapOverlay&quot; option to allow a specific image to be applied to the map screen for a mission.
- Added &quot;setOverlayDefault&quot; and &quot;resetOverlayDefault&quot; functions to control the default overlay used on the BB.
- Added &quot;setBackgroundDefault&quot; and &quot;resetBackgroundDefault&quot; functions to control the default background used on the BB.
- Overlay setting for item now applies on confirmation screen and mission incomplete screen.
- Adjusted procedure for applying overlays to screen, making better use of defaults.
- &quot;terminateCallback&quot; is no longer a required element.
- Simplified the sample script &quot;AsteroidHunter&quot;.

0.17
- Added number of jumps to destination to the various mission screens.
- Origination system and destination system details will now wrap inside the column correctly.
- Cleanup of chart route mode handling.

0.16
- Attempt to fix the event callback function generating error when calling functions.

0.15
- Added &quot;remoteDepositProcess&quot; property, to control whether deduction of the deposit amount should be handled by the BB or by some external process.
- Changed colour of unavailable items in the main list to be a slightly darker shade of gray.
- Added a &quot;Net payment&quot; line to missions that have a deposit.
- Unavailable items will now be put at the bottom of the mission list.
- Removed the backgroundHeight and overlayHeight properties. The background and overlay properties are now defined as guiTextureSpecifier, which can include these other elements as part of a dictionary.

0.14
- The &quot;availableCallback&quot; function was not being called on the short or long range chart screens.
- Added an event registration and execution system, so OXP&#39;s can know when various interface events have taken place.
- Days now included in mission time remaining on the mission detail screen.
- Fixed issue where &quot;Set course for&quot; options were not being displayed on map screens.
- Fixed issue where numeric custom display item values were causing an error.
- Fixed issue where an error would occur if a mission does not have a manifestText entry as well as no manifestCallback.
- Fixed issue where adding multiple station keys to the same station were not adding data correctly.
- The stationKeys array was not being reset after a jump.
- Corrected errors in documentation.
- Bug fixes.
- Code refactoring.

0.13
- Added an &quot;availableCallback&quot; function, to allow for cases where a mission can be added to the BB, but conditions prevent the player from being able to accept it (eg insufficient cargo space).
- If a mission has a deposit amount as part of the terms of acceptance, this value will be deducted from the payment amount on the first page of the bulletin board display. Brings it into line with the cargo contracts screen.
- Fixed bug with displaying custom items on a mission detail page.

0.12
- Moved restoring data process to startUp function.

0.11
- Added custom menu items that can be used with callbacks to allow custom functions to be called on each mission.
- Changed methodology for creating mission ID&#39;s to eliminate the possibility of ever having two missions with the same ID.
- Changed short range chart selection range to 7.5ly, rather than 15ly.
- Fixed another minor bug with the players destination getting reset unexpectedly when viewing mission destinations.
- Missions added with &quot;autoAccept&quot; turned on will now get their destination marker put on the system map, and (if the Email System is installed) will have confirmation emails sent.
- Fixed Javascript reference error when terminating a mission.
- Better handling of interstellar space conditions.
- Added the &quot;noEmails&quot; option, to stop a mission from sending confirmation emails.
- Added ability for calling routines to specify their own ID for reference, overriding the default.
- Changed the console message that is displayed when a mission is manually terminated by the player.
- Chart markers were not being removed from the chart after missions were completed.
- Fixed issue with HUD not becoming visible again when launching while viewing the Bulletin Board.
- Setting a blank value (&quot;&quot;) for a mission station key should have allowed the mission to be found and completed at any station in the source system.
- Swapped &quot;Expiry&quot; and &quot;Payment&quot; columns in the main list to align better with other contract screens (parcels, cargo, passengers).

0.10
- &quot;terminateCallback&quot; was not being called when a mission was terminated by the player. &quot;failedCallback&quot; was being called instead.
- Fixed Javascript bug in &quot;failedCallback&quot; routine.

0.9
- Added optional &quot;deposit&quot; property to mission items, which will be deducted from the player&#39;s account when accepting the mission.
- Added travel time (in hours) to the destination system info and source system info.
- &quot;Set course&quot; option now takes player&#39;s full course into consideration when working out whether the option should be displayed, rather than just the final destination.
- Fixed issue where player destination was getting reset when a chart screen is exited by pressing a function key, rather than via the &quot;Exit&quot; command.

0.8
- Fixed issue with AT_SOURCE missions that allow for partial completion, where they could be partially completed at non-source stations.
- Active but expired missions that are shown on the main BB list will now just show as &quot;Expired&quot;.
- Added &quot;customDisplayItems&quot;, so missions can add their own heading/value information items to the mission details page.
- &quot;Set course for&quot; menu items won&#39;t be shown if player already has that system set as their destination.
- Changed &quot;==&quot; comparisons to &quot;===&quot; for performance improvements.

0.7
- Accepting a mission now doesn&#39;t close the mission briefing screen.
- Added a &quot;stopTimeAtComplete&quot; boolean value to enable missions to be setup so that, as soon as the mission is flagged 100% complete, the expiry time countdown will stop. This means that the player can take as much time as they want to return to the system and hand in their completed mission. The default for this value is false.
- Added a &quot;allowPartialComplete&quot; boolean value so that a mission can be handed in early, with a reduction in the payment based on the percentage completed. If penalties also apply it will reduced by the percentage completed.
- Added a &quot;statusText&quot; text value that will be displayed on the mission briefing screen as the &quot;Current status&quot; instead of the manifestText value.
- Added the &quot;$updateBBStatusText&quot; function to enable the status text to be updated.
- Added the originating system to the mission details page.
- Added the destination system to the main mission list.
- Moved &quot;Percentage Complete&quot; column to be the last column on the main mission list screen.
- Changed the &quot;Expires&quot; column to only show hours (or minutes if the time remaining is less than 100 minutes) on the main mission list screen.
- Fixed issue with &quot;allowTerminate&quot; not defaulting correctly.
- Changed how stationKeys are added, making it possible for a station to have multiple keys, as well as allowing for multiple worldScripts to have different station keys for the same station.
- Fixed issue where exiting a multi-page mission briefing and re-opening it was not resetting the current page back to 1.
- Fixed issue where boolean values of true or false (that is not a text string with &quot;true&quot; or &quot;false&quot; in it) were not being recognised correctly when adding a mission.
- Changed the way the number of active missions is counted. Now any active mission is listed, not just the non-expired missions.
- When viewing a completed Bulletin Board mission and the player is not in the originating system, the option to &quot;Set course for [originating system]&quot; will now be available.
- Corrected logic for determining when a property has been passed in an object when adding new missions.
- Changed completion types &quot;AT_STATION&quot; and &quot;WHEN_DOCKED_STATION&quot; to be &quot;AT_STATIONKEY&quot; and &quot;WHEN_DOCKED_STATIONKEY&quot; to better describe their purpose.
- Added a debug flag to turn on/off log messages.
- If the Email System is installed, accepting, terminating, completing and failing missions will now generate a confirmation email.
- Added a comma between &quot;# available&quot; and &quot;# active&quot; on the interface screen.

0.6
- Added an additional check when creating a new mission. Expiry time must be in the future.
- Fixed bug with &quot;markerShape&quot; setting not being correctly set up.
- Active missions that have expired are now coloured red in the bulletin board list.
- Included manifest text on mission briefing page when mission is completed but not yet handed in. Also included expiry time, which is still relevant for completed-yet-not-handed-in missions.
- Forced manifest entries to be updated each time the manifest screen is viewed in order to keep &quot;Expires in&quot; field up to date.
- Added &quot;%&quot; to percentage completed text on mission screen.
- Added a &quot;disablePercentDisplay&quot; boolean value to enable a mission to turn off the display of the &quot;Percent complete&quot; value. This would leave just the manifest text as the method of showing mission status.
- Completed missions that are about to be handed in will no longer show as being close to expiry.
- Better handling missions complete when docking where the confirmCompleteCallback function returns a value.
- Fixed bug when attempting to show the long range chart.
- Fixed bug with mission variable declaration in $failedMission routine.
- Code refactoring.

0.5
- Fixed remainder of missing &quot;clock&quot; references.

0.4
- Turned off some debug messages.
- Fixed missing &quot;clock&quot; reference when updating mission percentage.

0.3
- Fixed Javascript reference error when displaying mission details.
- Fixed issue where setting course for the destination system wasn&#39;t actually setting the course.
- Bulletin Board was not resetting itself correctly between views.
- Fixed issue where the space between accepted and available missions was not appearing if there were only 1 of each type in the list.
- Added a confirmation screen to the terminate mission process.
- Added a &quot;Set course for&quot; option to the mission briefing page.
- Added the &quot;confirmCompleteCallback&quot; callback function, so that secondary steps can be confirmed before a mission can be accepted as complete. This would be useful if there is a possibility that something might have changed between completing the required steps of a mission, and getting to a dock to enter the &quot;Complete Mission&quot; response (eg loosing or selling cargo).

0.2
- Missions whose expiry time has already passed are now excluded from the list of available missions.
- Missions whose expiry time is extremely tight are now highlighted on the list of available missions and in the mission details as well.
- clock.adjustedSeconds now used to calculate remaining time to complete mission.
- Spelling corrections.

0.1
- Initial release
</pre>
        </a>

        <a name="equipment">          
        <h2>Equipment</h2>
            This expansion declares no equipment. This may be related to warnings.
        </a>

        <a name="ships">    
        <h2>Ships</h2>
            This expansion declares no ships. This may be related to warnings.
        </a>

        <a name="models">    
        <h2>Models</h2>
            This expansion declares no models. This may be related to warnings.
        </a>

        <a name="scripts">    
        <h2>Scripts</h2>
            <table>
                <tr>
                    <th>Path</th>
                </tr>
                <tr>
                    <td valign="top">Scripts/bb_system.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name = &quot;BulletinBoardSystem&quot;;
this.author = &quot;phkb&quot;;
this.copyright = &quot;2017 phkb&quot;;
this.description = &quot;Interface screen for localised or event-driven mission opportunities.&quot;;
this.licence = &quot;CC BY-NC-SA 4.0&quot;;

// CHECK: add a unaccepted mission for another system (ie not the current) - will it show up on the BB?

this._bbOpen = false; // flag to indicate the bulletin board has been opened
this._bbExiting = 0; // int to track what sort of exit from the board is taking place (1 = direct function key, 2 = from close menu)
this._maxpage = 0; // total number of pages of inbox to display
this._curpage = 0; // the current page of the inbox being displayed
this._msRows = 21; // rows to display on the mission screen
this._msCols = 32; // columns to display on the mission screen
this._displayType = 0; // controls the view.
this._displayPage = 0; // which page of the mission item are we showing
this._itemList = [];
this._routeMode = &quot;&quot;; // current route mode for long range chart (if ANA is installed)
this._itemColor = &quot;yellowColor&quot;;
this._menuColor = &quot;orangeColor&quot;;
this._exitColor = &quot;yellowColor&quot;;
this._disabledColor = &quot;darkGrayColor&quot;;
this._unavailableColor = &quot;grayColor&quot;;
this._warningColor = &quot;redColor&quot;;
this._onPathColor = &quot;greenColor&quot;; // colour for available items that are directly on your current course
this._nearPathColor = &quot;0 0.6 0 1&quot;; // colour for available items that are near to your current course
this._shuffleTries = 1; // how many times to shuffle the BB to make it as unsorted as possible.
this._updateRequired = false; // flag set after a new mission is added to the bb to indicate the interface entry needs to be updated
this._stationKeys = []; // array of worldscripts/stationkeys for the currently docked station
this._markers = [&quot;NONE&quot;, &quot;MARKER_X&quot;, &quot;MARKER_PLUS&quot;, &quot;MARKER_SQUARE&quot;, &quot;MARKER_DIAMOND&quot;];
this._completionTypes = [&quot;AT_SOURCE&quot;, &quot;AT_STATIONKEY&quot;, &quot;ANYWHERE&quot;, &quot;IMMEDIATE&quot;, &quot;WHEN_DOCKED_SOURCE&quot;, &quot;WHEN_DOCKED_STATIONKEY&quot;, &quot;WHEN_DOCKED_ANYWHERE&quot;];
this._lastChoice = [&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;]; // stores the last choice on each of the mission screens
this._notCompleteText = &quot;&quot;; // text returned from the confirmCompleteCallback function
this._bbAdminName = {}; // names to attach to confirmation emails (when Email System is installed)
this._suspendedDestination = -1;
this._tempMarkers = -1;
this._nextID = 100;
this._eventRegister = {};
this._overlayDefault = {
	name: &quot;bb-overlay.png&quot;,
	height: 546
};
this._overlay = this._overlayDefault;
this._backgroundDefault = &quot;&quot;;
this._background = this._backgroundDefault;
this._holdItem = {};
this._mainMenuItems = []; // array of menu items to appear of the first page of the BB
this._alwaysShowBB = false;
this._showID = false; // flag which determines whether the ID number is shown on mission details page
this._nextContractOnMap = false;
this._nearPathRange = 7; // range (in LY) to consider a system to be &quot;near&quot;
this._useMarkers = 0; // how to use near system markers on BB list: 
// 0 = no markers, just colours, 1 = markers only, no colours, 2 = markers and colours, 4 = turn off feature
this._oldVersion = 1.4;
this._zoomDist = [{
		dist: 45,
		zoom: 3.5
	},
	{
		dist: 40,
		zoom: 3.2
	},
	{
		dist: 35,
		zoom: 2.9
	},
	{
		dist: 30,
		zoom: 2.5
	},
	{
		dist: 25,
		zoom: 2.2
	},
	{
		dist: 20,
		zoom: 1.7
	},
	{
		dist: 15,
		zoom: 1.4
	},
	{
		dist: 7,
		zoom: 1.0
	},
];

// configuration settings for use in Lib_Config
this._bbConfig = {
	Name: this.name,
	Alias: &quot;Bulletin Board System&quot;,
	Display: &quot;Display Options&quot;,
	Alive: &quot;_bbConfig&quot;,
	Bool: {
		B0: {
			Name: &quot;_showID&quot;,
			Def: false,
			Desc: &quot;Show mission ID&quot;
		},
		B1: {
			Name: &quot;_nextContractOnMap&quot;,
			Def: false,
			Desc: &quot;&#39;Next Contract&#39; on map&quot;
		},
		Info: &quot;0 - Displays the internal mission ID on details page.\n1 - Shows the &#39;Next contract&#39; option on all map screens.&quot;
	},
	SInt: {
		S0: {
			Name: &quot;_nearPathRange&quot;,
			Def: 7,
			Min: 1,
			Max: 15,
			Desc: &quot;Range of near path&quot;
		},
		S1: {
			Name: &quot;_useMarkers&quot;,
			Def: 0,
			Min: 0,
			Max: 3,
			Desc: &quot;Near system markers&quot;
		},
		Info: &quot;0 - Sets the range (in LY) defining a system as being near current path.\n1 - 0=No markers, 1=Markers Only, 2=Markers &amp; Colors, 3=Turn off feature&quot;
	}
};
this._trueValues = [&quot;yes&quot;, &quot;1&quot;, 1, &quot;true&quot;, true];

/* array Specifications
	text                    Text to display on the menu
	color                   Color of the item. Will default to this._menuColor (orangeColor)
	unselectable            Flag to control whether the item should be unselectable. 
							If true, color will be set to this._disabledColor (darkGreyColor)
	autoRemove              Flag to indicate the item should be removed from the menu when selected by the player.
	worldScript             WorldScript name for the callback function.
	menuCallback            Function to call when the user selects the item.
*/

this._data = []; // array of available and accepted missions
/* Array Specifications
	data array
	ID						Numerical id of the mission
	stationKey				text key used for limiting new mission access to particular stations
							will default to blank (all stations) if not provided. can include multiple items, 
							comma-separated (eg &quot;galcop,chaotic&quot;)
	description				one line description of the mission (used on the main BB list)
	source					system where mission is available
	sourceName				name of the source system (auto-generated from the source value)
	sourceGalaxy			galaxy number where source system resides (will default to current galaxy)
	destination				system where mission must be completed: 0-255 for planets, -1 for interstellar, 
							256 for no destination
	destinationName			name of the destination system (auto-generated from the destination value)
	destinationGalaxy		galaxy number where the source system resides (will default to the current galaxy)
	galaxy					galaxy number where mission was created
	details					expanded description of the mission
	manifestText			text to display on the manifest screen
	statusText				text to include on the mission briefing screen when the mission is active.
							Will default to manifestText when not supplied
	expiry					the time the mission must be completed by. -1 means unlimited time.
	accepted				boolean flag indicating the mission has been accepted by the player. default false.
	percentComplete			how much of the mission has been completed by the player
	payment					how much the player will be paid on completion of the mission
	penalty					how much the player will be penalised for not completing the mission
	deposit					(optional) how much the player needs to pay as a deposit for taking the mission.
							This amount will be refunded if the mission is completed successfully.
							Amount will be adjusted based on the percentage completed of the mission.
	allowPartialComplete	boolean flag that indicates whether the player can complete the mission with less than 
							the full percentage. 
							Payment will be scaled by the percentage completed. Penalties will also apply, again scaled 
							by the percentage completed.
							For example, if the payment is 100 cr and the penalty 10 cr, and the player completes 
							70% of the mission, if they hand it in they would receive 70 cr (70% of 100), and the 
							penalty would be 3 cr (30% of 10), meaning their total payment would be 67 cr.
							Default is false.
	model					role of a ship to use as the background on the mission details screen.
	modelPersonality		the entityPersonality assigned to the ship model.
	spinModel				True/false value indicating whether the ship model will rotate or not. The default to true.
	background				guiTextureSpecifier (name of a picture used as background)
	overlay					guiTextureSpecifier (name of a picture used as an overlay). Will default to the bulletin board 
							graphic when not set.
	mapOverlay              guiTextureSpecifier for map screen (name of a picture used as background). 
							Will default to the overlay setting (if provided) when not set, otherwise the bulletin board 
							graphic.
	forceLongRangeChart		boolean flag indicating whether the map screen for this mission will be forced to use 
							the long range chart. Default false, meaning the map will calculate the best zoom level 
							required based on the source and destination systems.
	markerShape				the shape of the destination system marker to use on the galactic chart (default &quot;MARKER_PLUS&quot;).
							Use &quot;NONE&quot; to leave off marking the chart.
	markerColor				the color of the marker on the galactic chart (default &quot;redColor&quot;)
	markerScale				the scale of the marker on the galactic chart (default 1.0)
	additionalMarkers		array of dictionary items, defining extra markers that will be placed on the system map
							system			system ID where marker will be places
							markerShape		shape of the system marker (default &quot;MARKER_PLUS&quot;)
							markerColor		color of the marker (default &quot;redColor&quot;)
							markerScale		scale of the marker (default 1.0);
	allowTerminate			boolean flag to indicate whether the &quot;Terminate mission&quot; option will be available after 
							accepting the mission. (default true)
	completionType			what happens when mission is completed: &quot;AT_SOURCE&quot;, &quot;AT_STATIONKEY&quot;, &quot;ANYWHERE&quot;, 
							&quot;IMMEDIATE&quot;, &quot;WHEN_DOCKED_SOURCE&quot;, &quot;WHEN_DOCKED_STATIONKEY&quot;, &quot;WHEN_DOCKED_ANYWHERE&quot;
							AT_SOURCE: player must return to the source system, dock at any station with the same 
								stationKey, open the mission and select &quot;Complete mission&quot;
							AT_STATIONKEY: player can return to any system, dock at any station with the same 
								stationKey, open the mission and select &quot;Complete mission&quot;
							ANYWHERE: player can return to any system, dock at any station, open the mission and 
								select &quot;Complete mission&quot;
							IMMEDIATE: player is rewarded immediately when the mission is flagged as 100% complete - 
								player won&#39;t need to dock anywhere
							WHEN_DOCKED_SOURCE: player is automatically rewarded as soon as they next dock at the source 
								station
							WHEN_DOCKED_STATIONKEY: player is automatically rewarded as soon as they next dock at any 
								station with the same station key
							WHEN_DOCKED_ANYWHERE: player is automatically rewarded as soon as they next dock at any station
							(default &quot;AT_SOURCE&quot;)
	stopTimeAtComplete		boolean flag to indicate that the clock will stop when the mission is flagged 100% complete. 
							Default false. This means that, for a completionType of &quot;AT_SOURCE&quot; the player has to return to 
							the original station within the allowed time in order to complete the mission. If this flag is 
							set to true, once the player completes the mission at the destination, they are free to take as 
							much time as they like to return to the original station and hand in their mission.
	disablePercentDisplay	boolean flag that allows the &quot;Percent complete&quot; item to be hidden on the mission details page. 
							Default false.
	noEmails				boolean flag that stops the transmission of confirmation emails 
							(if the Email System is installed)
	statusValue				value to display instead of the percentComplete value.
	arrivalReportText		text to display on the arrival report after the player completes mission and completionType 
							set to &quot;WHEN_DOCKED_*&quot;
	customDisplayItems		array of dictionary objects containing header/value key pairs to be displayed on the mission 
							screen as separate items.
	customMenuItems			array of dictionary objects containing additional items to be shown in the menu
								text		text to display on the menu
								worldScript	worldscript of the callback
								callback	function name of the callback object
								condition	function name of a callback object that will return either a blank, 
											meaning menu item is available, or some text, giving the reason why the item 
											is unavailable
								activeOnly	boolean indicating whether the menu item will only be visible when the 
											mission is active. default true.
								autoRemove	boolean indicating whether the menu item will be removed when selected
	remoteDepositProcess	boolean flag to indicate whether deduction of any deposit amount should be processed by the 
							BB or remotely.
							Default is false, meaning the deposit will be deducted by the BB.
	initiateCallback		function name to callback when contract is accepted
	confirmCompleteCallback function name to callback to check if a contract can be completed.
	completedCallback		function name to callback when the player flags the mission as completed
	terminateCallback		function name to callback when the player gives up on the mission
	failedCallback			function name to callback when the player fails a mission (called when the player docks)
	manifestCallback		function name to callback when the text on the manifest screen needs updating
	availableCallback		function name to callback when checking if this contract is available to the player
							function should return either a blank string to indicate contract is available,
							or a string with the reason why the contract is unavailable
							if no callback is set, it is assumed contract is always available
	worldScript				name of worldscript containing the callback functions
	postStatusMessages		array of dictionary objects used to display text to the user after initiated, completed, or 
							terminated.
							Will only be shown for completionTypes AT_SOURCE, AT_STATIONKEY, and ANYWHERE.
							For any other completionType it is assumed the originating script will display additional info 
							the player, or the &quot;arrivalReportText&quot; will be used.
                                status        Can be either initiated, completed, or terminated 
								return        What to display after player pressed enter. 
													&quot;item&quot; to display the mission details, 
													&quot;list&quot; to display the mission list
													&quot;exit&quot; to exit the BB completely
                                text          Text to be displayed
                                background    Background image to be used on the display
                                model         Model to be shown on the display
                                overlay       Overlay to be shown on the display
	data					object containing reference data for calling WS.
*/

//-------------------------------------------------------------------------------------------------------------
this.startUp = function () {
	// load up player data
	if (missionVariables.BBData) {
		this._data = JSON.parse(missionVariables.BBData);
		delete missionVariables.BBData;
		this.$updateData();
	}
}

//-------------------------------------------------------------------------------------------------------------
this.startUpComplete = function () {

	// register our settings, if Lib_Config is present
	if (worldScripts.Lib_Config) worldScripts.Lib_Config._registerSet(this._bbConfig);

	this.$addAcceptedDate();

	if (missionVariables.BBNextID) this._nextID = missionVariables.BBNextID;
	// add a mission screen exception to Xenon UI
	if (worldScripts.XenonUI) {
		var wx = worldScripts.XenonUI;
		wx.$addMissionScreenException(&quot;oolite-bbsystem-shortrangechart-map&quot;);
		wx.$addMissionScreenException(&quot;oolite-bbsystem-longrangechart-map&quot;);
	}
	// add a mission screen exception to Xenon Redux UI
	if (worldScripts.XenonReduxUI) {
		var wxr = worldScripts.XenonReduxUI;
		wxr.$addMissionScreenException(&quot;oolite-bbsystem-shortrangechart-map&quot;);
		wxr.$addMissionScreenException(&quot;oolite-bbsystem-longrangechart-map&quot;);
	}
	if (worldScripts.DisplayCurrentCourse) {
		var dcc = worldScripts.DisplayCurrentCourse;
		dcc._screenIDList.push(&quot;oolite-bbsystem-shortrangechart-map&quot;);
		dcc._screenIDList.push(&quot;oolite-bbsystem-longrangechart-map&quot;);
	}

	this._suspendedDestination = -1;
	this._tempMarkers = -1;
	this._hudHidden = false;

	if (missionVariables.BBUseMarkers) this._useMarkers = parseInt(missionVariables.BBUseMarkers);
	if (missionVariables.BBNearPathRange) this._nearPathRange = parseInt(missionVariables.BBNearPathRange);
	if (missionVariables.BBOldVersion) this._oldVersion = parseFloat(missionVariables.BBOldVersion);
	if (missionVariables.BBNextContractOnMap) this._nextContractOnMap = this._trueValues.indexOf(missionVariables.BBNextContractOnMap) &gt;= 0 ? true : false;

	if (player.ship.docked) this.$initInterface(player.ship.dockedStation);

	// dud data cleanup
	//for (var i = 1; i &lt; 10; i++) {
	//	for (var j = 0; j &lt;= 255; j++) {
	//		mission.unmarkSystem({system:j, name:&quot;GalCopBB_Missions&quot; + &quot;_&quot; + i});		
	//	}
	// }
	this.$refreshManifest();
	this.$dataCleanup();
}

//-------------------------------------------------------------------------------------------------------------
this.shipWillDockWithStation = function (station) {
	this.$triggerBBEvent(&quot;shipWillDockWithStation_start&quot;, station);
	this.$checkForCompleteOnDock(station);
	this.$initInterface(station);
	this.$triggerBBEvent(&quot;shipWillDockWithStation_end&quot;, station);
}

//-------------------------------------------------------------------------------------------------------------
this.playerWillSaveGame = function () {
	missionVariables.BBOldVersion = this._oldVersion;
	missionVariables.BBNextID = this._nextID;
	if (this._data.length &gt; 0) {
		missionVariables.BBData = JSON.stringify(this._data);
	} else {
		delete missionVariables.BBData;
	}
	missionVariables.BBNearPathRange = this._nearPathRange;
	missionVariables.BBUseMarkers = this._useMarkers;
	missionVariables.BBNextContractOnMap = this._nextContractOnMap;
}

//-------------------------------------------------------------------------------------------------------------
this.guiScreenWillChange = function (to, from) {
	// force the manifest entries to update
	// this keeps the &quot;number of hours remaining&quot; value up to date.
	if (to === &quot;GUI_SCREEN_MANIFEST&quot;) {
		for (var i = 0; i &lt; this._data.length; i++) {
			if (this._data[i].accepted === true) {
				if (this._data[i].manifestCallback != &quot;&quot;) {
					worldScripts[this._data[i].worldScript][this._data[i].manifestCallback](this._data[i].ID);
				}
			}
		}
	}
}

//-------------------------------------------------------------------------------------------------------------
this.guiScreenChanged = function (to, from) {
	var p = player.ship;
	if (from === &quot;GUI_SCREEN_MISSION&quot; &amp;&amp; this._bbOpen) {
		this._bbOpen = false;
		if (this._hudHidden === false &amp;&amp; p.hudHidden === true) p.hudHidden = this._hudHidden;
		if (this._suspendedDestination &gt;= 0) p.targetSystem = this._suspendedDestination;
		this._suspendedDestination = -1;
		if (this._tempMarkers &gt;= 0) this.$removeChartMarker(this._tempMarkers);
		this._tempMarkers = -1;
	}
	if (guiScreen === &quot;GUI_SCREEN_INTERFACES&quot; || this._updateRequired === true) {
		// update the interfaces screen
		this._updateRequired = false;
		if (p.dockedStation != null) {
			if (p.docked) this.$initInterface(p.dockedStation);
		}
	}
}

//-------------------------------------------------------------------------------------------------------------
this.missionScreenOpportunity = function () {
	if (this._bbExiting === 1) {
		this._bbExiting = 0;
		this.$triggerBBEvent(&quot;exit&quot;);
	}
	this._bbExiting = 0;
}

//-------------------------------------------------------------------------------------------------------------
this.shipLaunchedFromStation = function (station) {
	if (this._bbExiting === 1) {
		this._bbExiting = 0;
		this.$triggerBBEvent(&quot;launchExit&quot;, station);
	}
	this._bbExiting = 0;
}

//-------------------------------------------------------------------------------------------------------------
this.shipWillEnterWitchspace = function (cause, destination) {
	// clear out any unaccepted missions whenever we do a witchspace jump
	for (var i = this._data.length - 1; i &gt;= 0; i--) {
		if (this._data[i].source === system.ID &amp;&amp; this._data[i].accepted === false) this.$removeBBMission(this._data[i].ID);
	}
	// reset the BB admin name dictionary so new names will be generated for this system
	this._bbAdminName = {};
	// reset the station keys
	this._stationKeys = [];
}

//-------------------------------------------------------------------------------------------------------------
// adds a mission to the BB.
this.$addBBMission = function $addBBMission(bbObj) {

	var truetypes = [&quot;yes&quot;, &quot;1&quot;, &quot;true&quot;, true, 1, -1];
	var falsetypes = [&quot;no&quot;, &quot;0&quot;, &quot;false&quot;, false, 0];

	var src = system.ID;
	if (bbObj.hasOwnProperty(&quot;source&quot;)) {
		if (parseInt(bbObj.source) &gt; 255 || parseInt(bbObj.source) &lt; 0) {
			throw &quot;Invalid BB mission settings: &#39;source&#39; system ID (&quot; + bbObj.source + &quot;) must be between 0 and 255.&quot;;
		}
		src = bbObj.source;
	}
	if (bbObj.hasOwnProperty(&quot;destination&quot;) === false || parseInt(bbObj.destination) &gt; 256 || parseInt(bbObj.destination) &lt; -1) {
		throw &quot;Invalid BB mission settings: &#39;destination&#39; system ID (&quot; + bbObj.destination + &quot;) must be supplied and between -1 and 256.&quot;;
	}
	if (bbObj.hasOwnProperty(&quot;description&quot;) === false || bbObj.description === &quot;&quot;) {
		throw &quot;Invalid BB mission settings: &#39;description&#39; must be supplied.&quot;;
	}
	if (bbObj.hasOwnProperty(&quot;details&quot;) === false || bbObj.details === &quot;&quot;) {
		throw &quot;Invalid BB mission settings: &#39;details&#39; must be supplied.&quot;;
	}
	if (bbObj.hasOwnProperty(&quot;payment&quot;) === true &amp;&amp; bbObj.payment &lt; 0) {
		throw &quot;Invalid BB mission settings: &#39;payment&#39; must be greater than or equal to 0.&quot;;
	}
	if (bbObj.hasOwnProperty(&quot;expiry&quot;) === false || bbObj.expiry === 0) {
		throw &quot;Invalid BB mission settings: &#39;expiry&#39; must be supplied.&quot;;
	}
	if (bbObj.expiry &gt; 0 &amp;&amp; bbObj.expiry &lt; clock.adjustedSeconds) {
		throw &quot;Invalid BB mission settings: &#39;expiry&#39; must be in the future.&quot;;
	}
	if (bbObj.hasOwnProperty(&quot;worldScript&quot;) === false || bbObj.worldScript === &quot;&quot;) {
		throw &quot;Invalid BB mission settings: &#39;worldScript&#39; must be supplied.&quot;;
	}

	// work out some defaults, and if they&#39;ve been overridden
	// completionType
	var completeType = &quot;AT_SOURCE&quot;;
	if (bbObj.hasOwnProperty(&quot;completionType&quot;) &amp;&amp; bbObj.completionType != &quot;&quot;) {
		if (this._completionTypes.indexOf(bbObj.completionType) &gt;= 0) {
			completeType = bbObj.completionType;
		} else {
			throw &quot;Invalid BB mission settings: unrecognised &#39;completionType&#39; setting (&quot; + bbObj.completionType + &quot;). Must be one of &quot; + this._completionTypes;
		}
	}

	var stopTime = false;
	if (bbObj.hasOwnProperty(&quot;stopTimeAtComplete&quot;) &amp;&amp; truetypes.indexOf(bbObj.stopTimeAtComplete) &gt;= 0) {
		stopTime = true;
	}

	// markerShape
	var markShape = &quot;MARKER_PLUS&quot;;
	if (bbObj.hasOwnProperty(&quot;markerShape&quot;) &amp;&amp; bbObj.markerShape != &quot;&quot;) {
		if (this._markers.indexOf(bbObj.markerShape) &gt;= 0) {
			markShape = bbObj.markerShape;
		} else {
			throw &quot;Invalid BB mission settings: unrecognised &#39;markerShape&#39; setting (&quot; + bbObj.markerShape + &quot;). Must be one of &quot; + this._markers;
		}
	}

	// validate any postStatusMessages
	if (bbObj.hasOwnProperty(&quot;postStatusMessages&quot;)) {
		var statusTypes = [&quot;initiated&quot;, &quot;completed&quot;, &quot;terminated&quot;];
		var list = bbObj.postStatusMessages;
		if (list &amp;&amp; list.length &gt; 0) {
			for (var i = 0; i &lt; list.length; i++) {
				if (list[i].hasOwnProperty(&quot;status&quot;) === false) {
					throw &quot;Invalid BB mission settings: postStatusMessages does not include &#39;status&#39; property.&quot;;
				}
				if (statusTypes.indexOf(list[i].status) === -1) {
					throw &quot;Invalid BB mission settings: postStatusMessages &#39;status&#39; value (&quot; + list[i].status + &quot;) not recognised. Must be one of &quot; + statusTypes;
				}
				if (list[i].hasOwnProperty(&quot;text&quot;) === false) {
					throw &quot;Invalid BB mission settings: postStatusMessages does not include &#39;text&#39; property.&quot;;
				}
				if (list[i].text === &quot;&quot;) {
					throw &quot;Invalid BB mission settings: postStatusMessages &#39;text&#39; value is blank&quot;;
				}
			}
		}
	}

	var addMarkers = [];
	if (bbObj.hasOwnProperty(&quot;additionalMarkers&quot;) === true) {
		// make sure each additional marker is valid
		if (Array.isArray(bbObj.additionalMarkers) === true) {
			for (var i = 0; i &lt; bbObj.additionalMarkers.length; i++) {
				var item = bbObj.additionalMarkers[i];
				if (item.hasOwnProperty(&quot;system&quot;) === true) {
					var def = {};
					def[&quot;system&quot;] = item.system;
					if (item.hasOwnProperty(&quot;markerShape&quot;) === true) {
						if (this._markers.indexOf(item.markerShape) &gt;= 0) {
							def[&quot;markerShape&quot;] = item.markerShape;
						} else {
							throw &quot;Invalid BB mission settings: unrecognised &#39;markerShape&#39; setting (&quot; + item.markerShape + &quot;). Must be one of &quot; + this._markers;
						}
					} else {
						def[&quot;markerShape&quot;] = &quot;MARKER_PLUS&quot;;
					}
					if (item.hasOwnProperty(&quot;markerColor&quot;) === true) {
						def[&quot;markerColor&quot;] = item.markerColor;
					} else {
						def[&quot;markerColor&quot;] = &quot;redColor&quot;;
					}
					if (item.hasOwnProperty(&quot;MARKER_SCALE&quot;) === true) {
						def[&quot;markerScale&quot;] = item.markerScale;
					} else {
						def[&quot;markerScale&quot;] = 1.0;
					}
					addMarkers.push(def);
				}
			}
		}
	}

	var id = 0;
	if (bbObj.hasOwnProperty(&quot;ID&quot;) &amp;&amp; isNaN(bbObj.ID) === false &amp;&amp; parseInt(bbObj.ID) &gt; 0) {
		id = parseInt(bbObj.ID);
		for (var i = 0; i &lt; this._data.length; i++) {
			if (this._data[i].ID === id) {
				throw &quot;Invalid BB mission settings: ID &quot; + id + &quot; is already in use!&quot;;
			}
		}
	} else {
		id = this.$nextID();
	}

	this._data.push({
		ID: id,
		stationKey: (bbObj.stationKey &amp;&amp; bbObj.stationKey != &quot;&quot; ? bbObj.stationKey : &quot;&quot;),
		source: src,
		sourceName: System.systemNameForID(src),
		sourceGalaxy: galaxyNumber,
		destination: bbObj.destination,
		destinationName: this.$systemNameForID(bbObj.destination),
		destinationGalaxy: galaxyNumber,
		description: bbObj.description,
		details: bbObj.details,
		manifestText: (bbObj.hasOwnProperty(&quot;manifestText&quot;) ? bbObj.manifestText : &quot;&quot;),
		originalManifestText: (bbObj.hasOwnProperty(&quot;manifestText&quot;) ? bbObj.manifestText : &quot;&quot;),
		statusText: (bbObj.hasOwnProperty(&quot;statusText&quot;) ? bbObj.statusText : &quot;&quot;),
		payment: (bbObj.hasOwnProperty(&quot;payment&quot;) ? bbObj.payment : 0),
		penalty: (bbObj.hasOwnProperty(&quot;penalty&quot;) &amp;&amp; bbObj.penalty &gt; 0 ? bbObj.penalty : 0),
		deposit: (bbObj.hasOwnProperty(&quot;deposit&quot;) &amp;&amp; parseInt(bbObj.deposit) &gt; 0 ? parseInt(bbObj.deposit) : 0),
		allowPartialComplete: (bbObj.hasOwnProperty(&quot;allowPartialComplete&quot;) &amp;&amp; truetypes.indexOf(bbObj.allowPartialComplete) &gt;= 0 ? true : false),
		expiry: bbObj.expiry,
		playAcceptedSound: (!bbObj.hasOwnProperty(&quot;playAcceptedSound&quot;) || truetypes.indexOf(bbObj.playAcceptedSound) &gt;= 0 ? true : false),
		accepted: (bbObj.hasOwnProperty(&quot;accepted&quot;) &amp;&amp; truetypes.indexOf(bbObj.accepted) &gt;= 0 ? true : false),
		allowTerminate: (bbObj.hasOwnProperty(&quot;allowTerminate&quot;) &amp;&amp; falsetypes.indexOf(bbObj.allowTerminate) &gt;= 0 ? false : true),
		percentComplete: (bbObj.hasOwnProperty(&quot;percentComplete&quot;) &amp;&amp; bbObj.percentComplete &gt; 0 ? bbObj.percentComplete : 0.0),
		completionType: completeType,
		stopTimeAtComplete: stopTime,
		completionTime: (bbObj.hasOwnProperty(&quot;completionTime&quot;) &amp;&amp; bbObj.completionTime &gt; 0 ? bbObj.completionTime : 0),
		arrivalReportText: (bbObj.hasOwnProperty(&quot;arrivalReportText&quot;) ? bbObj.arrivalReportText : &quot;&quot;),
		model: (bbObj.hasOwnProperty(&quot;model&quot;) ? bbObj.model : &quot;&quot;),
		modelPersonality: (bbObj.hasOwnProperty(&quot;modelPersonality&quot;) &amp;&amp; parseInt(bbObj.modelPersonality) &gt; 0 ? bbObj.modelPersonality : 0),
		spinModel: (bbObj.hasOwnProperty(&quot;spinModel&quot;) &amp;&amp; falsetypes(bbObj.spinModel) ? false : true),
		background: (bbObj.hasOwnProperty(&quot;background&quot;) ? bbObj.background : &quot;&quot;),
		overlay: (bbObj.hasOwnProperty(&quot;overlay&quot;) ? bbObj.overlay : &quot;&quot;),
		mapOverlay: (bbObj.hasOwnProperty(&quot;mapOverlay&quot;) ? bbObj.mapOverlay : (bbObj.hasOwnProperty(&quot;overlay&quot;) ? bbObj.overlay : &quot;&quot;)),
		forceLongRangeChart: (bbObj.hasOwnProperty(&quot;forceLongRangeChart&quot;) &amp;&amp; truetypes.indexOf(bbObj.forceLongRangeChart) &gt;= 0 ? true : false),
		markerShape: markShape,
		markerColor: (bbObj.hasOwnProperty(&quot;markerColor&quot;) ? bbObj.markerColor : &quot;redColor&quot;),
		markerScale: (bbObj.hasOwnProperty(&quot;markerScale&quot;) &amp;&amp; bbObj.markerScale &gt;= 0.5 &amp;&amp; bbObj.markerScale &lt;= 2.0 ? bbObj.markerScale : 1.0),
		additionalMarkers: addMarkers,
		disablePercentDisplay: (bbObj.hasOwnProperty(&quot;disablePercentDisplay&quot;) &amp;&amp; truetypes.indexOf(bbObj.disablePercentDisplay) &gt;= 0 ? true : false),
		noEmails: (bbObj.hasOwnProperty(&quot;noEmails&quot;) &amp;&amp; bbObj.noEmails == true ? true : false),
		statusValue: (bbObj.hasOwnProperty(&quot;statusValue&quot;) &amp;&amp; bbObj.statusValue != &quot;&quot; ? bbObj.statusValue : &quot;&quot;),
		customDisplayItems: (bbObj.hasOwnProperty(&quot;customDisplayItems&quot;) ? bbObj.customDisplayItems : &quot;&quot;),
		customMenuItems: (bbObj.hasOwnProperty(&quot;customMenuItems&quot;) ? bbObj.customMenuItems : &quot;&quot;),
		remoteDepositProcess: (bbObj.hasOwnProperty(&quot;remoteDepositProcess&quot;) &amp;&amp; truetypes.indexOf(bbObj.remoteDepositProcess) &gt;= 0 ? true : false),
		initiateCallback: (bbObj.hasOwnProperty(&quot;initiateCallback&quot;) ? bbObj.initiateCallback : &quot;&quot;),
		confirmCompleteCallback: (bbObj.hasOwnProperty(&quot;confirmCompleteCallback&quot;) ? bbObj.confirmCompleteCallback : &quot;&quot;),
		completedCallback: (bbObj.hasOwnProperty(&quot;completedCallback&quot;) ? bbObj.completedCallback : &quot;&quot;),
		terminateCallback: (bbObj.hasOwnProperty(&quot;terminateCallback&quot;) ? bbObj.terminateCallback : &quot;&quot;),
		failedCallback: (bbObj.hasOwnProperty(&quot;failedCallback&quot;) ? bbObj.failedCallback : &quot;&quot;),
		manifestCallback: (bbObj.hasOwnProperty(&quot;manifestCallback&quot;) ? bbObj.manifestCallback : &quot;&quot;),
		availableCallback: (bbObj.hasOwnProperty(&quot;availableCallback&quot;) ? bbObj.availableCallback : &quot;&quot;),
		bonusCalculationCallback: (bbObj.hasOwnProperty(&quot;bonusCalculationCallback&quot;) ? bbObj.bonusCalculationCallback : &quot;&quot;),
		worldScript: bbObj.worldScript,
		postStatusMessages: (bbObj.hasOwnProperty(&quot;postStatusMessages&quot;) ? bbObj.postStatusMessages : []),
		data: (bbObj.hasOwnProperty(&quot;data&quot;) ? bbObj.data : null),
		acceptedDate: (bbObj.hasOwnProperty(&quot;accepted&quot;) &amp;&amp; truetypes.indexOf(bbObj.accepted) &gt;= 0 ? clock.adjustedSeconds : 0),
	});

	this._updateRequired = true;

	// auto-accepted items should get their manifest entry updated immediately
	if (bbObj.hasOwnProperty(&quot;accepted&quot;) &amp;&amp; bbObj.accepted === true) {
		this.$addManifestEntry(id);
		// send an email (if installed)
		this.$sendEmail(player.ship.dockedStation, &quot;accepted&quot;, id);
		// update f4 interface entry, if docked
		if (player.ship.docked) this.$initInterface(player.ship.dockedStation);
	}

	this.$triggerBBEvent(&quot;missionAdded&quot;);
	return id;
}

//-------------------------------------------------------------------------------------------------------------
// adds an item to the BB main menu
this.$addMainMenuItem = function $addMainMenuItem(mnu) {
	if (mnu.hasOwnProperty(&quot;text&quot;) === false || mnu.text === &quot;&quot;) {
		throw &quot;Invalid BB menu setting: &#39;text&#39; property must be supplied and not blank.&quot;;
	}
	if (mnu.hasOwnProperty(&quot;worldScript&quot;) === false || mnu.worldScript === &quot;&quot;) {
		throw &quot;Invalid BB menu setting: &#39;worldScript&#39; property must be supplied and not blank.&quot;;
	}
	if (mnu.hasOwnProperty(&quot;menuCallback&quot;) === false || mnu.menuCallback === &quot;&quot;) {
		throw &quot;Invalid BB menu setting: &#39;menuCallback&#39; property must be supplied and not blank.&quot;;
	}

	this._mainMenuItems.push({
		text: mnu.text,
		color: (mnu.hasOwnProperty(&quot;color&quot;) ? mnu.color : this._menuColor),
		unselectable: (mnu.hasOwnProperty(&quot;unselectable&quot;) ? mnu.unselectable : false),
		autoRemove: (mnu.hasOwnProperty(&quot;autoRemove&quot;) ? mnu.autoRemove : false),
		worldScript: mnu.worldScript,
		menuCallback: mnu.menuCallback
	})
}

//-------------------------------------------------------------------------------------------------------------
// removes an item from the main menu based on worldScript name and function callback name
this.$removeMainMenuItem = function $removeMainMenuItem(wsName, fnName) {
	for (var i = this._mainMenuItems.length - 1; i &gt;= 0; i--) {
		if (this._mainMenuItems[i].worldScript === wsName &amp;&amp; this._mainMenuItems[i].menuCallback === fnName) {
			this._mainMenuItems.splice(i, 1);
		}
	}
}

//-------------------------------------------------------------------------------------------------------------
// sets the default BB background to a new guiTextureSpecifier
this.$setBackgroundDefault = function $setBackgroundDefault(gui) {
	this._background = gui;
}

//-------------------------------------------------------------------------------------------------------------
// resets the default BB background back to the default
this.$resetBackgroundDefault = function $resetBackgroundDefault() {
	this._background = this._backgroundDefault;
}

//-------------------------------------------------------------------------------------------------------------
// sets the default BB overlay to a new guiTextureSpecifier
this.$setOverlayDefault = function $setOverlayDefault(gui) {
	this._overlay = gui;
}

//-------------------------------------------------------------------------------------------------------------
// resets the default BB overlay back to the default
this.$resetOverlayDefault = function $resetOverlayDefault() {
	this._overlay = this._overlayDefault;
}

//-------------------------------------------------------------------------------------------------------------
// registers a worldscript function to be called whenever a particular event occurs
this.$registerBBEvent = function $registerBBEvent(wsName, fnName, eventName) {
	var list = this._eventRegister[eventName];
	if (!list) list = [];
	var found = false;
	for (var i = 0; i &lt; list.length; i++) {
		if (list[i].worldScript === wsName &amp;&amp; list[i].functionName === fnName) {
			found = true;
			break;
		}
	}
	if (found === false) {
		list.push({
			worldScript: wsName,
			functionName: fnName
		});
		this._eventRegister[eventName] = list;
	}
}

//-------------------------------------------------------------------------------------------------------------
this.$unregisterBBEvent = function $unregisterBBEvent(wsName, fnName, eventName) {
	var list = this._eventRegister[eventName];
	if (!list) return;
	for (var i = 0; i &lt; list.length; i++) {
		if (list[i].worldScript === wsName &amp;&amp; list[i].functionName === fnName) {
			list.splice(i, 1);
			break;
		}
	}
}

//-------------------------------------------------------------------------------------------------------------
// performs all callbacks for a given event
this.$triggerBBEvent = function $triggerBBEvent(eventName, param) {
	if (!this._eventRegister) return;
	var list = this._eventRegister[eventName];
	if (!list) return;
	for (var i = 0; i &lt; list.length; i++) {
		try {
			if (param) {
				worldScripts[list[i].worldScript][list[i].functionName](param);
			} else {
				worldScripts[list[i].worldScript][list[i].functionName]();
			}
		} catch (err) {
			log(this.name, &quot;!!ERROR: Unable to call event callback. Event:&quot; + eventName + &quot;, WS:&quot; + list[i].worldScript + &quot; FN:&quot; + list[i].functionName + &quot; Error:&quot; + err);
		}
	}
}

//-------------------------------------------------------------------------------------------------------------
// external function call to reorder the list randomly
this.$shuffleBBList = function $shuffleBBList() {
	for (var i = 0; i &lt; this._shuffleTries; i++)
		this._data.sort(function (a, b) {
			return Math.random() - 0.5;
		}); // shuffle order so it isn&#39;t always the same variant being checked first
}

//-------------------------------------------------------------------------------------------------------------
// external function call to remove a particular custom menu item from a BB entry
this.$removeCustomMenuItem = function $removeCustomMenuItem(bbID, index) {
	var itm = this.$getItem(bbID);
	if (itm.customMenuItems) {
		var mnu = item.customMenuItems;
		if (mnu != &quot;&quot; &amp;&amp; mnu.length &gt; index) {
			mnu.splice(index, 1);
		}
	}
}

//-------------------------------------------------------------------------------------------------------------
// looks for any completed missions whose completion method is &quot;WHEN_DOCKED_SOURCE&quot;, &quot;WHEN_DOCKED_STATIONKEY&quot; or &quot;WHEN_DOCKED_ANYWHERE&quot;
this.$checkForCompleteOnDock = function $checkForCompleteOnDock(station) {
	this._stationKeyDefault = this.$getStationKeyDefault(station);
	for (var i = this._data.length - 1; i &gt;= 0; i--) {
		var item = this._data[i];
		// look for any active missions
		if (item.accepted === true) {
			// check if this mission is complete within the time required, and if the completion type is one of the &quot;DOCKED&quot; types.
			// logic: if the mission is flagged as completed (percentComplete = 1), and we can only set percentComplete to 1 if it&#39;s still within the time allowed (see $updateBBMissionPercentage)
			if (item.percentComplete === 1 &amp;&amp; this.$isMissionExpired(item) === false) { // clock.adjustedSeconds &lt; item.expiry
				if (((item.completionType === &quot;WHEN_DOCKED_SOURCE&quot; &amp;&amp; item.source === system.ID &amp;&amp; (item.stationKey === &quot;&quot; || this.$checkMissionStationKey(item.worldScript, station, item.stationKey) === true)) ||
						(item.completionType === &quot;WHEN_DOCKED_STATIONKEY&quot; &amp;&amp; (item.stationKey === &quot;&quot; || this.$checkMissionStationKey(item.worldScript, station, item.stationKey) === true)) ||
						item.completionType === &quot;WHEN_DOCKED_ANYWHERE&quot;)) {

					var result = &quot;&quot;;
					if (item.confirmCompleteCallback) {
						result = worldScripts[item.worldScript][item.confirmCompleteCallback](item.ID);
					}
					if (result === &quot;&quot;) {
						// complete the mission
						this.$completeBBMission(item.ID);
					} else {
						// add the error details to the arrival report.
						player.addMessageToArrivalReport(result);
						// fail the mission
						this.$failedBBMission(item.ID, false);
					}
				}
			} else if (clock.adjustedSeconds &gt;= item.expiry &amp;&amp; item.expiry &gt; 0) {
				// too late, so fail the mission
				this.$failedBBMission(item.ID, false);
			}
		}
	}
}

//-------------------------------------------------------------------------------------------------------------
// returns the current completed percentage for a mission
this.$percentCompleted = function $percentCompleted(bbID) {
	var itm = this.$getItem(bbID);
	if (itm) return itm.percentComplete;
	return 0;
}

//-------------------------------------------------------------------------------------------------------------
// updates the completed percentage of a mission
this.$updateBBMissionPercentage = function $updateBBMissionPercentage(bbID, pct) {
	var itm = this.$getItem(bbID);
	// only update missions that are still active (if it&#39;s expired, no further updates should happen)
	if (itm &amp;&amp; (clock.adjustedSeconds &lt; itm.expiry || itm.expiry === -1)) {
		itm.percentComplete = pct;
		// tell the originator to update their manifest text
		if (itm.manifestCallback != &quot;&quot;) {
			worldScripts[itm.worldScript][itm.manifestCallback](itm.ID);
		}
		// check if we&#39;ve completed the mission and the completion type is set to &quot;IMMEDIATE&quot;
		if (pct === 1) {
			itm.completionTime = clock.adjustedSeconds;
			switch (itm.completionType) {
				case &quot;IMMEDIATE&quot;:
					// theoretically there should be no need to call the confirmCompleteCallback here, 
					// as the calling worldScript has just flagged the mission complete.
					this.$completeBBMission(bbID);
					break;
				case &quot;AT_SOURCE&quot;:
				case &quot;WHEN_DOCKED_SOURCE&quot;:
					this.$revertChartMarker(bbID);
					break;
				case &quot;AT_STATIONKEY&quot;:
				case &quot;WHEN_DOCKED_STATIONKEY&quot;:
				case &quot;WHEN_DOCKED_ANYWHERE&quot;:
				case &quot;ANYWHERE&quot;:
					this.$removeChartMarker(bbID);
					break;
			}
		}
		return;
	}
}

//-------------------------------------------------------------------------------------------------------------
// updates the manifest screen text for a particular mission
// this should be called by the originating script when the manifestCallback routine is called
this.$updateBBManifestText = function $updateBBManifestText(bbID, newtext) {
	var item = this.$getItem(bbID);
	item.manifestText = newtext;
	// grab a copy of the first version of the manifest so we can use it in emails.
	if (item.originalManifestText === &quot;&quot;) item.originalManifestText = newtext;
	this.$refreshManifest();
}

//-------------------------------------------------------------------------------------------------------------
// updates the status text for a particular mission
this.$updateBBStatusText = function $updateBBStatusText(bbID, newtext) {
	var item = this.$getItem(bbID);
	item.statusText = newtext;
}

//-------------------------------------------------------------------------------------------------------------
// executes various functions when a mission is completed
this.$completeBBMission = function $completeBBMission(bbID) {
	var item = this.$getItem(bbID);
	// execute the callback
	if (item.completedCallback != &quot;&quot;) worldScripts[item.worldScript][item.completedCallback](item.ID);
	// pay the player their payment
	if (item.payment != 0 || item.bonusCalculationCallback != &quot;&quot;) {
		// calculate the payment amount. normally percentComplete will be 1.0, but the &quot;allowPartialComplete&quot; flag means we should always scale the figure
		var total = item.payment * item.percentComplete;
		// add the deposit, if present
		//total += (item.deposit &amp;&amp; item.deposit &gt; 0 ? item.deposit * item.percentComplete : 0); -- deposit amount should be included in payment amount
		// apply the factored penalty, if present. Completing 30% of a mission means 70% of the penalty will apply.
		if (item.allowPartialComplete &amp;&amp; item.penalty &gt; 0) total -= item.penalty * (1 - item.percentComplete);
		if (item.percentComplete === 1 &amp;&amp; item.bonusCalculationCallback !== &quot;&quot;) {
			var bonus = worldScripts[item.worldScript][item.bonusCalculationCallback](item.ID);
			total += bonus;
		}
		player.credits += total;

		if (total !== 0) {
			if (player.ship.status === &quot;STATUS_DOCKING&quot;) {
				// work out what message to add to the arrival report
				var msg = &quot;&quot;;
				if (item.arrivalReportText != &quot;&quot;) {
					msg = item.arrivalReportText;
				} else {
					msg = expandDescription(&quot;[bb-arrival-completed]&quot;, {
						description: item.description,
						payment: formatCredits(total, true, true)
					});
				}
				player.addMessageToArrivalReport(msg);
			} else {
				player.consoleMessage(expandDescription(&quot;[bb-console-completed]&quot;, {
					description: item.description,
					payment: formatCredits(total, true, true)
				}), 5);
			}
		}
	}
	// send an email (if installed)
	this.$sendEmail(player.ship.dockedStation, &quot;success&quot;, item.ID, total);

	// remove item from manifest screen
	this.$removeManifestEntry(item.ID);
	// remove the mission from the list
	this.$removeBBMission(item.ID);
	// update the interface screen entry
	if (player.ship.dockedStation) this.$initInterface(player.ship.dockedStation);
}

//-------------------------------------------------------------------------------------------------------------
// fails the mission (either through manual termination, or by docking after the time expires)
this.$failedBBMission = function $failedBBMission(bbID, manual) {
	var item = this.$getItem(bbID);
	var pen = 0;

	// call the failed function, if supplied
	if (manual === false &amp;&amp; item.failedCallback !== &quot;&quot;) {
		worldScripts[item.worldScript][item.failedCallback](bbID);
	}
	// call the terminate function, if supplied
	if (manual === true &amp;&amp; item.terminateCallback !== &quot;&quot;) {
		worldScripts[item.worldScript][item.terminateCallback](bbID);
	}

	// if there was a penalty for failing the mission, penalise the player now
	if (item.penalty != 0) {
		pen = Math.round(item.penalty * (1 - item.percentComplete));
		// if they&#39;ve partially completed the mission, and the specs allow for it, give the player the amount they&#39;ve completed
		if (item.allowPartialComplete &amp;&amp; item.payment &gt; 0 &amp;&amp; item.percentComplete &gt; 0) {
			pen -= (item.payment &amp; item.percentComplete);
		}
		player.credits -= pen;
	}
	if (player.ship.status === &quot;STATUS_DOCKING&quot;) {
		// work out what message to add to the arrival report
		var msg = &quot;&quot;;
		if (pen === 0) {
			msg = expandDescription(&quot;[bb-arrival-failed-nopenalty]&quot;, {
				description: item.description
			});
		} else if (pen &gt; 0) {
			msg = expandDescription(&quot;[bb-arrival-failed-penalty]&quot;, {
				description: item.description,
				penalty: formatCredits(pen, true, true)
			});
		} else {
			msg = expandDescription(&quot;[bb-arrival-failed-payment]&quot;, {
				description: item.description,
				payment: formatCredits(Math.abs(pen), true, true)
			})
		}
		player.addMessageToArrivalReport(msg);
	} else {
		var type = &quot;failed&quot;;
		if (manual === true) type = &quot;terminate&quot;;

		if (pen === 0) {
			player.consoleMessage(expandDescription(&quot;[bb-console-&quot; + type + &quot;-nopenalty]&quot;, {
				description: item.description
			}), 5);
		} else if (pen &gt; 0) {
			player.consoleMessage(expandDescription(&quot;[bb-console-&quot; + type + &quot;-penalty]&quot;, {
				description: item.description,
				penalty: formatCredits(pen, true, true)
			}), 5);
		} else {
			player.consoleMessage(expandDescription(&quot;[bb-console-&quot; + type + &quot;-payment]&quot;, {
				description: item.description,
				penalty: formatCredits(Math.abs(pen), true, true)
			}), 5);
		}
	}
	// send an email (if installed)
	if (manual === false) {
		// if the manual flag is false (ie not from the player manually terminating the mission)
		this.$sendEmail(player.ship.dockedStation, &quot;fail&quot;, item.ID, pen);
	} else {
		// send an email (if installed)
		this.$sendEmail(player.ship.dockedStation, &quot;terminated&quot;, item.ID, pen);
	}

	// remove item from manifest screen
	this.$removeManifestEntry(item.ID);
	this.$removeBBMission(item.ID);
	this.$initInterface(player.ship.dockedStation);
}

//-------------------------------------------------------------------------------------------------------------
// removes a mission from the datalist
this.$removeBBMission = function $removeBBMission(bbID) {
	for (var i = this._data.length - 1; i &gt;= 0; i--) {
		if (this._data[i].ID === bbID) {
			this._data.splice(i, 1);
			return;
		}
	}
}

//-------------------------------------------------------------------------------------------------------------
// returns the next ID number for new missions
this.$nextID = function $nextID() {
	var ok = false;
	do {
		this._nextID += 1;
		if (this._nextID &gt; 30000) this._nextID = 1;
		ok = true;
		// is this id available?
		for (var i = 0; i &lt; this._data.length; i++) {
			if (this._data[i].ID === this._nextID) {
				// dang it. lets do this loop again
				ok = false;
				break;
			}
		}
	} while (ok === false);
	var result = this._nextID;
	return result;
}

//-------------------------------------------------------------------------------------------------------------
// counts the number of missions available at the current station
this.$countAvailable = function $countAvailable(station) {
	var avail = 0;
	for (var i = 0; i &lt; this._data.length; i++) {
		if (this._data[i].source === system.ID &amp;&amp; this._data[i].accepted === false &amp;&amp; (this._data[i].expiry === -1 || this.$isMissionExpired(this._data[i]) === false) &amp;&amp;
			(this._data[i].stationKey === &quot;&quot; || this.$checkMissionStationKey(this._data[i].worldScript, station, this._data[i].stationKey) === true))
			avail += 1;
	}
	return avail;
}

//-------------------------------------------------------------------------------------------------------------
// counts the number of active missions (but not expired missions)
this.$countActive = function $countActive() {
	var active = 0;
	for (var i = 0; i &lt; this._data.length; i++) {
		if (this._data[i].accepted === true) active += 1;
	}
	return active;
}

//-------------------------------------------------------------------------------------------------------------
// returns true if a mission has expired, otherwise false
this.$isMissionExpired = function $isMissionExpired(itm) {
	if (itm.expiry === -1) return false;
	var checkTime = 0;
	if (itm.completionTime != 0 &amp;&amp; itm.stopTimeAtComplete === true) {
		checkTime = itm.completionTime;
	} else {
		checkTime = clock.adjustedSeconds + (itm.accepted === false ? this.$estimatedMissionTime(itm) : 0);
		// if we&#39;re at the destination system, give a little bit of leeway
		if (itm.destination === system.ID) checkTime -= 1800;
	}

	if (checkTime &lt; itm.expiry &amp;&amp; itm.expiry &gt; 0) {
		return false;
	} else {
		return true;
	}
}

//-------------------------------------------------------------------------------------------------------------
// returns true if the mission is going to be hard to complete within the time frame, otherwise false
this.$isMissionCloseToExpiry = function $isMissionCloseToExpiry(itm) {
	var result = false;
	// assume anything in another galaxy is close to expiry
	if (itm.destinationGalaxy !== galaxyNumber) return true;

	var time = this.$estimatedMissionTime(itm);
	if (time === -1) return result;

	// check if the destination system is not the current system
	if (itm.destination != system.ID &amp;&amp; itm.destination &lt;= 255 &amp;&amp; itm.destination &gt;= 0 &amp;&amp; itm.percentComplete &lt; 1) {
		if (clock.adjustedSeconds + time &gt; itm.expiry &amp;&amp; itm.expiry &gt; 0) result = true;
	} else {
		if (itm.expiry &gt; 0 &amp;&amp; itm.expiry - clock.adjustedSeconds &lt; 1800 &amp;&amp; itm.percentComplete &lt; 1) result = true;
	}
	return result;
}

//-------------------------------------------------------------------------------------------------------------
// performs callback to determine if mission is actually available to the player
this.$isMissionAvailable = function $isMissionAvailable(itm) {
	if (itm.accepted === true) return true;
	if (itm.hasOwnProperty(&quot;availableCallback&quot;) &amp;&amp; itm.availableCallback != &quot;&quot;) {
		var test = worldScripts[itm.worldScript][itm.availableCallback](itm.ID);
		if (test === &quot;&quot;) {
			return true;
		} else {
			return false;
		}
	} else {
		return true;
	}
}

//-------------------------------------------------------------------------------------------------------------
// performs the availableCallback and returns the unavailability reason, if any
this.$missionUnavailableReason = function $missionUnavailableReason(bbID) {
	var itm = this.$getItem(bbID);
	if (itm.accepted === true) return &quot;&quot;;
	if (itm.hasOwnProperty(&quot;availableCallback&quot;) === false || itm.availableCallback === &quot;&quot;) return &quot;&quot;;
	return worldScripts[itm.worldScript][itm.availableCallback](bbID);
}

//-------------------------------------------------------------------------------------------------------------
// estimated amount of time the mission is likely to take
this.$estimatedMissionTime = function $estimatedMissionTime(itm) {
	if (itm.percentComplete === 1 &amp;&amp; ((itm.stopTimeAtComplete === true &amp;&amp; (itm.completionTime &lt; itm.expiry || itm.expiry === -1)) ||
			(itm.stopTimeAtComplete === false &amp;&amp; (clock.adjustedSeconds &lt; itm.expiry || itm.expiry === -1))))
		return -1;
	var time = 0;
	// first, check if the destination system is not the current system
	if (itm.destination != system.ID &amp;&amp; itm.destination &lt;= 255 &amp;&amp; itm.destination &gt;= 0 &amp;&amp; itm.percentComplete &lt; 1) {
		// calculate time for a return journey
		var info = null;
		var route = null;
		// outward journey
		if (itm.destination != system.ID &amp;&amp; itm.destination &gt;= 0 &amp;&amp; itm.destination &lt;= 255) {
			info = System.infoForSystem(galaxyNumber, itm.destination);
			route = system.info.routeToSystem(info, &quot;OPTIMIZED_BY_TIME&quot;);
			if (route) {
				time += route.time * 3600;
				// plus 15 minutes transit time in each system
				time += route.route.length * 900;
			}
		} else {
			time += 24 * 3600;
		}
		// return journey (if stopTimeAtComplete is false)
		if (itm.stopTimeAtComplete === false &amp;&amp; route != null) {
			switch (itm.completeType) {
				case &quot;AT_SOURCE&quot;:
				case &quot;WHEN_DOCKED_SOURCE&quot;:
					if (itm.source === system.ID) {
						time += route.time * 3600;
						// plus 30 minutes transit time in each system
						time += route.route.length * 1800;
					} else {
						var src = System.infoForSystem(galaxyNumber, itm.source);
						route = src.routeToSystem(info, &quot;OPTIMIZED_BY_TIME&quot;);
						time += route.time * 3600;
						// plus 15 minutes transit time in each system
						time += route.route.length * 900;
					}
					break;
			}
		}
		// bit of a buffer
		time += 900;
	} else {
		if (itm.expiry &gt; 0 &amp;&amp; itm.percentComplete &lt; 1) time = itm.expiry - clock.adjustedSeconds;
	}
	return time;
}

//-------------------------------------------------------------------------------------------------------------
// returns the mission details for a particular mission
this.$getItem = function $getItem(bbID) {
	var checkval = parseInt(bbID);
	for (var i = 0; i &lt; this._data.length; i++) {
		if (this._data[i].ID === checkval) return this._data[i];
	}
	return null;
}

//-------------------------------------------------------------------------------------------------------------
// gets the data index of a particular BB item
// should not be used in most cases, as list can be resorted, making the index stale
this.$getIndex = function $getIndex(bbID) {
	var checkval = parseInt(bbID);
	for (var i = 0; i &lt; this._data.length; i++) {
		if (this._data[i].ID === bbID) return i;
	}
	return -1;
}

//-------------------------------------------------------------------------------------------------------------
this.$addStationKey = function $addStationKey(missionWorldScript, stn, stationKey) {
	var found = false;
	for (var i = 0; i &lt; this._stationKeys.length; i++) {
		if (this._stationKeys[i].station === stn &amp;&amp; this._stationKeys[i].worldScript === missionWorldScript &amp;&amp; this._stationKeys[i].key === stationKey) {
			found = true;
		}
	}
	if (found === false) {
		this._stationKeys.push({
			station: stn,
			worldScript: missionWorldScript,
			key: stationKey
		});
	}
}

//-------------------------------------------------------------------------------------------------------------
// checks if the station/worldScript combination has any specific station keys added. Return true if found, otherwise false
this.$stationHasKeys = function $stationHasKeys(worldScript, stn) {
	for (var i = 0; i &lt; this._stationKeys.length; i++) {
		if (this._stationKeys[i].station === stn &amp;&amp; this._stationKeys[i].worldScript === worldScript) return true;
	}
	return false;
}

//-------------------------------------------------------------------------------------------------------------
// works out the stationKey for the current station
this.$getStationKeyDefault = function $getStationKeyDefault(station) {
	var stnKey = &quot;&quot;;
	// does the station have a particular station key set in script info?
	if (station.scriptInfo.bb_station_key) stnKey = station.scriptInfo.bb_station_key;
	// what about in the script object for the station? try there too...
	if (stnKey === &quot;&quot; &amp;&amp; station.script.bb_station_key) stnKey = station.script.bb_station_key;
	// if not, does this station have an allegiance value set
	if (stnKey === &quot;&quot; &amp;&amp; station.allegiance != null) stnKey = station.allegiance;
	return stnKey;
}

//-------------------------------------------------------------------------------------------------------------
// checks the current stationKey against mission&#39;s station keys. returns true if the current stationKey is one of the mission&#39;s station keys
// otherwise false
this.$checkMissionStationKey = function $checkMissionStationKey(missionWorldScript, station, missionStnKey) {
	// a blank station key means anywhere
	if (missionStnKey === &quot;&quot;) return true;
	var items = missionStnKey.split(&quot;,&quot;);
	var def = this.$getStationKeyDefault(station);
	var found = false;
	var useDefault = (this.$stationHasKeys(missionWorldScript, station) ? false : true);

	for (var i = 0; i &lt; items.length; i++) {
		if (useDefault === true) {
			if (items[i] === def) found = true;
		} else {
			for (var j = 0; j &lt; this._stationKeys.length; j++) {
				if (this._stationKeys[j].station === station &amp;&amp; items[i] === this._stationKeys[j].key &amp;&amp; this._stationKeys[j].worldScript === missionWorldScript) found = true;
			}
		}
	}
	return found;
}

//-------------------------------------------------------------------------------------------------------------
// works out whether the bulletin board is hidden on this station
this.$stationIsAllowedBB = function $stationIsAllowedBB(station) {
	var result = true;
	if (station.scriptInfo &amp;&amp; station.scriptInfo.bb_hide &amp;&amp; station.scriptInfo.bb_hide === 1) result = false;
	if (station.script &amp;&amp; station.script.bb_hide &amp;&amp; station.script.bb_hide === 1) result = false;
	return result;
}

//-------------------------------------------------------------------------------------------------------------
this.$initInterface = function $initInterface(station) {
	if (!station) return;
	// get the station key for this station
	this._stationKeyDefault = this.$getStationKeyDefault(station);
	// count how many missions are available here
	var avail = this.$countAvailable(station);
	// count how many missions are active
	var active = this.$countActive();
	// create some additional text to add to the interface screen
	var addtext = (avail &gt; 0 ? avail + &quot; available&quot; : &quot;&quot;) + (avail &gt; 0 &amp;&amp; active &gt; 0 ? &quot;, &quot; : &quot;&quot;) + (active &gt; 0 ? active + &quot; active&quot; : &quot;&quot;);
	if (addtext != &quot;&quot;) addtext = &quot; (&quot; + addtext + &quot;)&quot;;
	// work out the prefix for the interface
	if ((addtext != &quot;&quot; || this._alwaysShowBB === true) &amp;&amp; this.$stationIsAllowedBB(station) === true) {
		var prefix = &quot;Station&quot;;
		if (station.allegiance === &quot;galcop&quot;) prefix = &quot;GalCop&quot;;

		station.setInterface(this.name, {
			title: prefix + &quot; bulletin board&quot; + addtext,
			category: &quot;Contracts&quot;,
			summary: &quot;Lists any local or specialised mission opportunities available at this station.&quot;,
			callback: this.$showBB.bind(this)
		});
	} else {
		station.setInterface(this.name, null);
	}
}

//-------------------------------------------------------------------------------------------------------------
this.$showBB = function $showBB() {
	this._lastChoice = [&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;];
	this._maxpage = Math.ceil(this.$countAvailable(player.ship.dockedStation) / this._msRows);
	this._curpage = 0;
	this._displayType = 0;
	if (this._oldVersion != parseFloat(this.version)) this._displayType = 99;
	this.$triggerBBEvent(&quot;open&quot;);
	this._bbExiting = 1;
	this._routeMode = &quot;OPTIMIZED_BY_NONE&quot;;
	if (player.ship.hasEquipmentProviding(&quot;EQ_ADVANCED_NAVIGATIONAL_ARRAY&quot;)) {
		this._routeMode = player.ship.routeMode;
		// if we have the array, by the current setting is &quot;NONE&quot;, default to jumps
		if (this._routeMode === &quot;OPTIMIZED_BY_NONE&quot;) this._routeMode = &quot;OPTIMIZED_BY_JUMPS&quot;;
	}
	this.$showPage();
}

//-------------------------------------------------------------------------------------------------------------
this.$showPage = function $showPage() {
	function compareID(a, b) {
		return ((a.ID &gt; b.ID) ? 1 : -1);
	}

	function compareDate(a, b) {
		return ((a.acceptedDate &gt; b.acceptedDate) ? 1 : -1);
	}

	function comparePayment(a, b) {
		return (((a.payment - a.deposit) &lt; (b.payment - b.deposit)) ? 1 : -1);
	}

	var p = player.ship;
	var stn = p.dockedStation;

	if (this._displayType === -1) {
		this._displayType = 0;
		return;
	}

	this._hudHidden = p.hudHidden;
	if (this.$isBigGuiActive() === false) p.hudHidden = true;
	this._bbOpen = true;

	var text = &quot;&quot;;
	var opts;
	var curChoices = {};
	var def = &quot;&quot;;
	var iStart = 0;
	var iEnd = 0;
	var items = 0;
	var flagCol = 1.0;
	var jmpIndent = 6.45;

	if (defaultFont.measureString(&quot;•&quot;) &gt; 1) flagCol = defaultFont.measureString(&quot;•&quot;) + 0.1;

	// help for new updates
	if (this._displayType === 99) {
		var update = false;
		if (this._oldVersion === 1.4) {
			update = true;
			var ln = 0;
			curChoices[&quot;0&quot; + ln.toString() + &quot;_A&quot;] = {
				text: &quot;New feature for version 1.5: On/Near Path Notifications.&quot;,
				alignment: &quot;LEFT&quot;,
				unselectable: true,
				color: &quot;whiteColor&quot;
			};
			ln += 1;
			curChoices[(ln &lt;= 9 ? &quot;0&quot; : &quot;&quot;) + ln.toString() + &quot;_A&quot;] = &quot;&quot;;
			ln += 1;
			var lines = this.$columnText(&quot;Available or active mission items whose destination systems are directly on your currently plotted course will be coloured green on the mission listing. For example:&quot;, 32);
			for (var i = 0; i &lt; lines.length; i++) {
				curChoices[(ln &lt;= 9 ? &quot;0&quot; : &quot;&quot;) + ln.toString() + &quot;_A&quot;] = {
					text: lines[i],
					unselectable: true,
					alignment: &quot;LEFT&quot;,
					color: this._itemColor
				};
				ln += 1;
			}
			curChoices[(ln &lt;= 9 ? &quot;0&quot; : &quot;&quot;) + ln.toString() + &quot;_A&quot;] = {
				text: this.$padTextRight(&quot; &quot;, flagCol) +
					this.$padTextRight(&quot;Sample mission 1&quot;, 13) +
					this.$padTextRight(&quot;Lave&quot;, 5) +
					this.$padTextLeft(&quot;10 hrs&quot;, 5) +
					this.$padTextLeft(formatCredits(100, false, true), 5) +
					this.$padTextLeft(&quot;&quot;, 3),
				alignment: &quot;LEFT&quot;,
				color: this._onPathColor,
				unselectable: true
			};
			ln += 1;
			curChoices[(ln &lt;= 9 ? &quot;0&quot; : &quot;&quot;) + ln.toString() + &quot;_A&quot;] = &quot;&quot;;
			ln += 1;
			lines = this.$columnText(&quot;Available or active mission items whose destination systems are within 7ly of any system on your currently plotted course will be coloured dark green on the mission listing. For example:&quot;, 32);
			for (var i = 0; i &lt; lines.length; i++) {
				curChoices[(ln &lt;= 9 ? &quot;0&quot; : &quot;&quot;) + ln.toString() + &quot;_A&quot;] = {
					text: lines[i],
					alignment: &quot;LEFT&quot;,
					unselectable: true,
					color: this._itemColor
				};
				ln += 1;
			}
			curChoices[(ln &lt;= 9 ? &quot;0&quot; : &quot;&quot;) + ln.toString() + &quot;_A&quot;] = {
				text: this.$padTextRight(&quot; &quot;, flagCol) +
					this.$padTextRight(&quot;Sample mission 2&quot;, 13) +
					this.$padTextRight(&quot;Tionisla&quot;, 5) +
					this.$padTextLeft(&quot;15 hrs&quot;, 5) +
					this.$padTextLeft(formatCredits(200, false, true), 5) +
					this.$padTextLeft(&quot;&quot;, 3),
				alignment: &quot;LEFT&quot;,
				color: this._nearPathColor,
				unselectable: true
			};
			ln += 1;
			curChoices[(ln &lt;= 9 ? &quot;0&quot; : &quot;&quot;) + ln.toString() + &quot;_A&quot;] = &quot;&quot;;
			ln += 1;
			lines = this.$columnText(&quot;You can change the range for near systems, and also use markers to highlight these missions. Configuration options can be found in Library Config&quot; + (worldScripts.Lib_Config ? &quot;&quot; : &quot; (if Library.OXP is installed)&quot;) + &quot;.&quot;, 32);
			for (var i = 0; i &lt; lines.length; i++) {
				curChoices[(ln &lt;= 9 ? &quot;0&quot; : &quot;&quot;) + ln.toString() + &quot;_A&quot;] = {
					text: lines[i],
					alignment: &quot;LEFT&quot;,
					unselectable: true,
					color: this._itemColor
				};
				ln += 1;
			}
			// spacers
			for (var i = 0; i &lt; (this._msRows + 5) - ln; i++) {
				curChoices[(ln + i &lt;= 9 ? &quot;0&quot; : &quot;&quot;) + (ln + i).toString() + &quot;_A&quot;] = &quot;&quot;;
			}
			this._oldVersion = 1.5;
		}

		if (update === true) {
			curChoices[&quot;98_EXIT&quot;] = {
				text: &quot;Press Enter to continue&quot;,
				color: this._menuColor
			};

			var opts = {
				screenID: &quot;oolite-bbsystem-main-map&quot;,
				title: &quot;Bulletin Board - Update Info&quot;,
				allowInterrupt: true,
				exitScreen: &quot;GUI_SCREEN_INTERFACES&quot;,
				choices: curChoices,
				initialChoicesKey: &quot;98_EXIT&quot;,
				message: text
			};
			if (this._overlay !== &quot;&quot;) opts.overlay = this._overlay;
			if (this._background !== &quot;&quot;) opts.background = this._background;
		} else {
			// if there were no updates this time, switch back to the opening list
			this._displayType = 0;
		}
	}

	// main mission list
	if (this._displayType === 0) {
		this.$triggerBBEvent(&quot;preListDisplay&quot;);
		if (this._data.length &gt; 0) {
			text = $padTextRight(&quot; &quot;, flagCol + 0.3) +
				this.$padTextRight(expandDescription(&quot;[bb-header-description]&quot;), 13) +
				this.$padTextRight(expandDescription(&quot;[bb-header-destination]&quot;), 5) +
				this.$padTextLeft(expandDescription(&quot;[bb-header-expiry]&quot;), 5) +
				this.$padTextLeft(expandDescription(&quot;[bb-header-payment]&quot;), 5) +
				this.$padTextLeft(&quot;%&quot;, 3) + &quot;\n\n&quot;;
			var active = this.$countActive();
			this._maxpage = Math.ceil((this.$countAvailable(stn) + (active &gt; 0 ? 1 : 0) + active) / this._msRows);
			if (this._maxpage === 0) this._maxpage = 1;
			if (this._curpage &gt; (this._maxpage - 1)) this._curpage = this._maxpage - 1;

			this._data.sort(comparePayment);
			var subdata = [];
			var top = 0;
			// add any missions available at this station
			for (var i = 0; i &lt; this._data.length; i++) {
				if (this._data[i].source === system.ID &amp;&amp; this._data[i].accepted === false &amp;&amp; (this._data[i].expiry === -1 || this.$isMissionExpired(this._data[i]) === false) &amp;&amp; // this._data[i].expiry &gt; clock.adjustedSeconds
					(!this._data[i].stationKey || this._data[i].stationKey === &quot;&quot; || this.$checkMissionStationKey(this._data[i].worldScript, stn, this._data[i].stationKey) === true)) {
					if (this.$isMissionAvailable(this._data[i]) === true) {
						// available missions should go at the top of the list
						subdata.splice(top, 0, this._data[i]);
						top += 1;
					} else {
						// any missions that are unavailable for whatever reason are put at the bottom
						subdata.push(this._data[i]);
					}
				}
			}
			// then put all the accepted missions at the top of the list
			this._data.sort(compareDate);
			top = 0;
			for (var i = 0; i &lt; this._data.length; i++) {
				if (this._data[i].accepted === true) {
					subdata.splice(top, 0, this._data[i]);
					top += 1;
				}
			}
			if (top !== 0) {
				// insert a dummy record to force a space between accepted and available missions
				subdata.splice(top, 0, {
					ID: -1
				});
			}
			this._itemList.length = 0;
			if (subdata.length &gt; 0) {
				// grab a copy of all the ID&#39;s of items in the list
				for (var i = 0; i &lt; subdata.length; i++) {
					if (subdata[i].ID != -1) this._itemList.push(subdata[i].ID);
				}
				// set out initial end point
				iStart = (this._curpage * this._msRows);
				iEnd = iStart + this._msRows;
				if (iEnd &gt; subdata.length) iEnd = subdata.length;
				for (var i = iStart; i &lt; iEnd; i++) {
					items += 1;
					if (subdata[i].ID === -1) {
						// add a spacer
						curChoices[&quot;01_ITEM-&quot; + (items &lt; 10 ? &quot;0&quot; : &quot;&quot;) + items + &quot;~0&quot;] = {
							text: &quot;&quot;,
							alignment: &quot;LEFT&quot;,
							unselectable: true
						};
					} else {
						// work out color of item
						var colr = this._itemColor;
						var onPath = this.$systemInCurrentPlot(subdata[i].destination);
						var nearPath = (onPath === false ? this.$systemNearCurrentPlot(subdata[i].destination) : false);
						if (this._useMarkers === 0 || this._useMarkers === 2) {
							if (onPath === true) colr = this._onPathColor;
							if (nearPath === true) colr = this._nearPathColor;
						}

						if (subdata[i].accepted === false &amp;&amp; subdata[i].expiry &gt; 0 &amp;&amp; subdata[i].expiry &lt; clock.adjustedSeconds) colr = this._warningColor;
						if (this.$isMissionAvailable(subdata[i]) === false) colr = this._unavailableColor;
						if (this.$isMissionCloseToExpiry(subdata[i]) === true) colr = this._menuColor;

						curChoices[&quot;01_ITEM-&quot; + (items &lt; 10 ? &quot;0&quot; : &quot;&quot;) + items + &quot;~&quot; + subdata[i].ID] = {
							text: this.$padTextRight((subdata[i].accepted === true ? &quot;•&quot; : &quot; &quot;), flagCol) +
								this.$padTextRight(subdata[i].description, 13) +
								this.$padTextRight(subdata[i].destinationName + (this._useMarkers === 1 || this._useMarkers === 2 ? (onPath === true ? &quot; †&quot; : (nearPath === true ? &quot; ‡&quot; : &quot;&quot;)) : &quot;&quot;), 5) +
								this.$padTextLeft((subdata[i].percentComplete === 1 &amp;&amp; subdata[i].stopTimeAtComplete === true ? &quot; &quot; : (subdata[i].expiry === -1 ? &quot; &quot; : this.$getTimeRemaining(subdata[i].expiry, true))), 5) +
								this.$padTextLeft((subdata[i].payment &gt; 0 ? formatCredits(subdata[i].payment - subdata[i].deposit, true, true) : &quot;&quot;), 5) +
								this.$padTextLeft((subdata[i].accepted === true &amp;&amp; (!subdata[i].disablePercentDisplay || subdata[i].disablePercentDisplay === false) ? (subdata[i].percentComplete * 100).toFixed(1) : &quot;&quot;), 3),
							alignment: &quot;LEFT&quot;,
							color: colr
						};
					}
				}
				for (var i = 0; i &lt; (((this._msRows + 1) - this._mainMenuItems.length) - items); i++) {
					curChoices[&quot;02_SPACER_&quot; + i] = &quot;&quot;;
				}
			} else {
				text += &quot;No items to display&quot;;
			}
			if (this._mainMenuItems.length &gt; 0) {
				for (var i = 0; i &lt; this._mainMenuItems.length; i++) {
					var col = this._menuColor;
					if (this._mainMenuItems[i].hasOwnProperty(&quot;color&quot;)) col = this._mainMenuItems[i].color;
					var disabled = false;
					if (this._mainMenuItems[i].hasOwnProperty(&quot;unselectable&quot;) &amp;&amp; this._mainMenuItems[i].unselectable === true) {
						disabled = true;
						col = this._disabledColor;
					}
					curChoices[&quot;03_MENU~&quot; + (i &lt; 10 ? &quot;0&quot; : &quot;&quot;) + i.toString()] = {
						text: this._mainMenuItems[i].text,
						color: col,
						unselectable: disabled
					};
				}
			}
			if (this._curpage &lt; this._maxpage - 1) {
				curChoices[&quot;10_GOTONEXT&quot;] = {
					text: &quot;[bb-nextpage]&quot;,
					color: this._menuColor
				};
			} else {
				curChoices[&quot;10_GOTONEXT&quot;] = {
					text: &quot;[bb-nextpage]&quot;,
					color: this._disabledColor,
					unselectable: true
				};
			}
			if (this._curpage &gt; 0) {
				curChoices[&quot;11_GOTOPREV&quot;] = {
					text: &quot;[bb-prevpage]&quot;,
					color: this._menuColor
				};
			} else {
				curChoices[&quot;11_GOTOPREV&quot;] = {
					text: &quot;[bb-prevpage]&quot;,
					color: this._disabledColor,
					unselectable: true
				};
			}
		} else {
			text += &quot;\n&quot; + expandDescription(&quot;[bb-no-items]&quot;);
			this._maxpage = 1;
		}

		curChoices[&quot;99_EXIT&quot;] = {
			text: &quot;Exit&quot;,
			color: this._exitColor
		};
		var def = &quot;99_EXIT&quot;;
		if (this._lastChoice[this._displayType] != &quot;&quot;) def = this._lastChoice[this._displayType];

		var opts = {
			screenID: &quot;oolite-bbsystem-main-map&quot;,
			title: &quot;Bulletin Board - Page &quot; + (this._curpage + 1) + &quot; of &quot; + this._maxpage,
			allowInterrupt: true,
			exitScreen: &quot;GUI_SCREEN_INTERFACES&quot;,
			choices: curChoices,
			initialChoicesKey: def,
			message: text
		};
		if (this._overlay !== &quot;&quot;) opts.overlay = this._overlay;
		if (this._background !== &quot;&quot;) opts.background = this._background;

		this.$triggerBBEvent(&quot;postListDisplay&quot;);
	}

	// mission details
	if (this._displayType === 1) {
		var govs = new Array();
		for (var i = 0; i &lt; 8; i++)
			govs.push(String.fromCharCode(i));
		var spc = String.fromCharCode(31);
		var colWidth = 11;
		var output = [];
		var item = this.$getItem(this._selectedItem);
		this.$triggerBBEvent(&quot;preItemDisplay&quot;, this._selectedItem);

		// build up the array of output lines
		// mission description
		output.push(this.$padTextRight(expandDescription(&quot;[bb-item-description]&quot;), colWidth) + item.description);
		output.push(&quot;&quot;);
		if (this._showID === true) {
			output.push(this.$padTextRight(&quot;Mission ID:&quot;, colWidth) + item.ID);
		}
		// mission details
		var coltext = [];
		// allow for newline characters in the details text
		var secthead = false;
		var dtls = item.details.split(&quot;\n&quot;);
		for (var j = 0; j &lt; dtls.length; j++) {
			coltext = this.$columnText(dtls[j], 32 - colWidth);
			for (var i = 0; i &lt; coltext.length; i++) {
				if (secthead === false) {
					output.push(this.$padTextRight(expandDescription(&quot;[bb-item-details]&quot;), colWidth) + coltext[i]);
					secthead = true;
				} else {
					output.push(this.$padTextRight(&quot; &quot;, colWidth) + coltext[i]);
				}
			}
		}
		output.push(&quot;&quot;);

		var rt = null;
		var dist = 0;
		var time = 0;
		var jumps = 0;
		var expired = this.$isMissionExpired(item);

		var sysID = system.ID;
		if (system.ID === -1) sysID = p.targetSystem;

		// source system info (only shown once a mission is accepted)
		if (item.source != sysID || item.accepted === true) {
			if (item.sourceGalaxy === galaxyNumber) {
				var orig = System.infoForSystem(galaxyNumber, item.source);
				var origtext = &quot;&quot;;
				rt = System.infoForSystem(galaxyNumber, sysID).routeToSystem(orig, this._routeMode);
				if (rt) {
					dist = rt.distance;
					time = rt.time;
					jumps = rt.route.length - 1;
					if (this._routeMode === &quot;OPTIMIZED_BY_NONE&quot;) {
						origtext = orig.name + &quot; (&quot; + govs[orig.government] + spc + &quot;TL&quot; + (orig.techlevel + 1) +
							(item.source === system.ID ? &quot;, current system)&quot; : &quot;, dist: &quot; + dist.toFixed(1) + &quot;ly, &quot; +
								(jumps &gt; 0 ? jumps + &quot; jump&quot; + (jumps &gt; 1 ? &quot;s&quot; : &quot;&quot;) + &quot;, &quot; : &quot;&quot;) + time.toFixed(1) + &quot; hrs)&quot;);
					} else {
						origtext = orig.name + &quot; (&quot; + govs[orig.government] + spc + &quot;TL&quot; + (orig.techlevel + 1) +
							(item.source === system.ID ? &quot;, current system)&quot; : &quot;, dist: &quot; + dist.toFixed(1) + &quot;ly)&quot;);
					}
				} else {
					dist = System.infoForSystem(galaxyNumber, sysID).distanceToSystem(orig);
					origtext = orig.name + &quot; (&quot; + govs[orig.government] + spc + &quot;TL&quot; + (orig.techlevel + 1) + &quot;, dist:&quot; + dist.toFixed(1) + &quot;ly, unreachable)&quot;;
				}
			} else {
				origtext = item.sourceName + &quot; (G&quot; + (item.sourceGalaxy + 1) + &quot;, unreachable)&quot;;
			}
			secthead = false;
			coltext = this.$columnText(origtext, 32 - colWidth);
			for (var k = 0; k &lt; coltext.length; k++) {
				if (secthead === false) {
					output.push(this.$padTextRight(expandDescription(&quot;[bb-item-originating]&quot;), colWidth) + coltext[k]);
					secthead = true;
				} else {
					output.push(this.$padTextRight(&quot; &quot;, colWidth) + coltext[k]);
				}
			}
		}

		// destination system info
		var textitem = &quot;&quot;;
		if (item.destination &lt; 256) {
			if (item.destination &gt;= 0 &amp;&amp; item.destination &lt;= 255) {
				if (item.destinationGalaxy === galaxyNumber) {
					var sys = System.infoForSystem(galaxyNumber, item.destination);

					rt = System.infoForSystem(galaxyNumber, sysID).routeToSystem(sys, this._routeMode);
					if (rt) {
						dist = rt.distance;
						time = rt.time;
						jumps = rt.route.length - 1;
					} else {
						dist = -1;
						time = -1;
						jumps = -1;
					}

					if (dist &gt;= 0) {
						if (this._routeMode !== &quot;OPTIMIZED_BY_NONE&quot;) {
							textitem = sys.name + &quot; (&quot; + govs[sys.government] + spc + &quot;TL&quot; + (sys.techlevel + 1) +
								(item.destination === system.ID ? &quot;, current system)&quot; : &quot;, dist: &quot; + dist.toFixed(1) + &quot;ly, &quot; +
									(jumps &gt; 0 ? jumps + &quot; jump&quot; + (jumps &gt; 1 ? &quot;s&quot; : &quot;&quot;) + &quot;, &quot; : &quot;&quot;) + time.toFixed(1) + &quot; hrs)&quot;);
						} else {
							// if we don&#39;t have the array, the distance is point-to-point, not route based.
							if (p.hasEquipmentProviding(&quot;EQ_ADVANCED_NAVIGATIONAL_ARRAY&quot;) === false) dist = system.info.distanceToSystem(sys);
							textitem = sys.name + &quot; (&quot; + govs[sys.government] + spc + &quot;TL&quot; + (sys.techlevel + 1) +
								(item.destination === system.ID ? &quot;, current system)&quot; : &quot;, dist: &quot; + dist.toFixed(1) + &quot;ly, &quot; + time.toFixed(1) + &quot; hrs)&quot;);
						}
					} else {
						dist = System.infoForSystem(galaxyNumber, sysID).distanceToSystem(sys);
						textitem = sys.name + &quot; (&quot; + govs[sys.government] + spc + &quot;TL&quot; + (sys.techlevel + 1) + &quot;, dist:&quot; + dist.toFixed(1) + &quot; ly, unreachable)&quot;;
					}
				} else {
					textitem = item.destinationName + &quot; (G&quot; + (item.destinationGalaxy + 1) + &quot;)&quot;;
				}
			} else if (item.destination === -1) {
				textitem = &quot;Interstellar space&quot;;
			}
			secthead = false;
			coltext = this.$columnText(textitem, 32 - colWidth);
			for (var k = 0; k &lt; coltext.length; k++) {
				if (secthead === false) {
					output.push(this.$padTextRight(expandDescription(&quot;[bb-item-destination]&quot;), colWidth) + coltext[k]);
					secthead = true;
				} else {
					output.push(this.$padTextRight(&quot; &quot;, colWidth) + coltext[k]);
				}
			}
		}

		// expiry (if required)
		if (item.expiry &gt; 0 &amp;&amp; (item.percentComplete &lt; 1 || item.stopTimeAtComplete === false)) {
			var closeExpiry = this.$isMissionCloseToExpiry(item);
			var exp = this.$getTimeRemaining(item.expiry);
			output.push(
				this.$padTextRight(expandDescription(&quot;[bb-item-expiry]&quot;), colWidth) +
				exp +
				(exp.indexOf(&quot;day&quot;) &gt;= 0 ? &quot; (&quot; + this.$getTimeRemaining(item.expiry, true) + &quot;)&quot; : &quot;&quot;) +
				((closeExpiry === true &amp;&amp; item.expiry &gt; clock.adjustedSeconds) ? &quot; **&quot; : &quot;&quot;)
			);
			if (closeExpiry === true) output.push(this.$padTextRight(&quot; &quot;, colWidth) + &quot;** Close to expiry warning&quot;);
		}
		// payment amount
		if (item.payment &gt; 0) {
			output.push(this.$padTextRight(expandDescription(&quot;[bb-item-payment]&quot;), colWidth) + formatCredits(item.payment, true, true));
		}
		// bonus amount (if applicable)
		if (expired === false &amp;&amp; item.percentComplete === 1 &amp;&amp; item.bonusCalculationCallback !== &quot;&quot;) {
			var bonus = worldScripts[item.worldScript][item.bonusCalculationCallback](item.ID);
			output.push(this.$padTextRight(expandDescription(&quot;[bb-item-bonus]&quot;), colWidth) + formatCredits(bonus, true, true));
		}
		// penalty amount (if required)
		if (item.penalty &gt; 0 &amp;&amp; ((item.accepted === true &amp;&amp; (item.percentComplete &lt; 1 || expired === true)) || item.accepted === false)) {
			output.push(this.$padTextRight(expandDescription(&quot;[bb-item-penalty]&quot;), colWidth) + formatCredits(item.penalty * (1 - item.percentComplete), true, true));
		}
		// deposit amount (if supplied)
		if (item.deposit &amp;&amp; item.deposit &gt; 0) {
			output.push(this.$padTextRight(expandDescription(&quot;[bb-item-deposit]&quot;), colWidth) + formatCredits(item.deposit, true, true));
			output.push(this.$padTextRight(expandDescription(&quot;[bb-item-netpayment]&quot;), colWidth) + formatCredits(item.payment - item.deposit, true, true));
		}
		// add any custom items (making sure we allow for long text items)
		if (item.customDisplayItems &amp;&amp; item.customDisplayItems != &quot;&quot;) {
			for (var i = 0; i &lt; item.customDisplayItems.length; i++) {
				secthead = false;
				dtls = item.customDisplayItems[i].value.toString().split(&quot;\n&quot;);
				if (dtls &amp;&amp; dtls.length &gt; 0) {
					for (var j = 0; j &lt; dtls.length; j++) {
						coltext = this.$columnText(dtls[j], 32 - colWidth);
						for (var k = 0; k &lt; coltext.length; k++) {
							if (secthead === false) {
								output.push(this.$padTextRight(expandDescription(item.customDisplayItems[i].heading), colWidth) + coltext[k]);
								secthead = true;
							} else {
								output.push(this.$padTextRight(&quot; &quot;, colWidth) + coltext[k]);
							}
						}
					}
				}
			}
		}
		if (item.accepted === true) {
			// percentage completed (if required)
			if (!item.disablePercentDisplay || item.disablePercentDisplay === false) {
				output.push(this.$padTextRight(expandDescription(&quot;[bb-item-percentcomplete]&quot;), colWidth) + (item.percentComplete * 100).toFixed(1) + &quot;%&quot;);
			}
			// any mission status text
			if (item.manifestText != &quot;&quot; || item.statusText != &quot;&quot;) { // item.percentComplete &lt; 1 &amp;&amp; 
				if (item.statusText != &quot;&quot;) {
					coltext = this.$columnText(item.statusText, 32 - colWidth);
				} else {
					coltext = this.$columnText(item.manifestText, 32 - colWidth);
				}
				for (var i = 0; i &lt; coltext.length; i++) {
					if (i === 0) {
						output.push(this.$padTextRight(expandDescription(&quot;[bb-item-status]&quot;), colWidth) + coltext[i]);
					} else {
						output.push(this.$padTextRight(&quot; &quot;, colWidth) + coltext[i]);
					}
				}
			}
		}

		var cmdCount = 0;
		// add &quot;Accept Mission&quot;&quot; item
		if (item.accepted === false) {
			var test = this.$missionUnavailableReason(item.ID);
			if (test === &quot;&quot;) {
				curChoices[&quot;30_ACCEPT&quot;] = {
					text: &quot;[bb-item-accept]&quot;,
					color: this._menuColor
				};
			} else {
				curChoices[&quot;30_ACCEPT&quot;] = {
					text: &quot;Unavailable (&quot; + test + &quot;)&quot;,
					color: this._disabledColor,
					unselectable: true
				};
			}
			cmdCount += 1;
		}
		var completeAvail = false;
		if (item.accepted === true) {
			// add &quot;Terminate mission&quot; item
			if (item.percentComplete &lt; 1 || expired === true) {
				if (item.allowTerminate === true) {
					curChoices[&quot;31_TERMINATE&quot;] = {
						text: &quot;[bb-item-cancel]&quot; + (item.penalty &gt; 0 ? expandDescription(&quot;[bb-item-cancel-warning]&quot;) : &quot;&quot;),
						color: this._menuColor
					};
					cmdCount += 1;
				}
			}
			if (expired === false &amp;&amp; (item.percentComplete === 1 || (item.allowPartialComplete &amp;&amp; item.percentComplete &gt; 0))) {
				var result = &quot;&quot;;
				if (item.confirmCompleteCallback &amp;&amp; item.confirmCompleteCallback !== &quot;&quot;) {
					result = worldScripts[item.worldScript][item.confirmCompleteCallback](item.ID)
				}
				switch (item.completionType) {
					case &quot;AT_SOURCE&quot;:
						// if the allowPartialComplete is on, the player should get a &quot;Complete Mission&quot; option, but only at the source station
						// for any other station we want to hide the option completely
						if (item.sourceGalaxy === galaxyNumber) {
							if (item.source != system.ID) {
								if (item.percentComplete === 1) {
									curChoices[&quot;32_COMPLETE&quot;] = {
										text: expandDescription(&quot;[bb-item-complete]&quot;) + &quot; (return to &quot; + System.infoForSystem(galaxyNumber, item.source).name + &quot;)&quot;,
										color: this._disabledColor,
										unselectable: true
									};
								} else if (this.$checkMissionStationKey(item.worldScript, stn, item.stationKey) === false &amp;&amp; item.percentComplete === 1) {
									curChoices[&quot;32_COMPLETE&quot;] = {
										text: expandDescription(&quot;[bb-item-complete]&quot;) + expandDescription(&quot;[bb-item-dock-original]&quot;),
										color: this._disabledColor,
										unselectable: true
									};
								} else {
									curChoices[&quot;32_COMPLETE&quot;] = {
										text: expandDescription(&quot;[bb-item-complete]&quot;) + (item.percentComplete &lt; 1 ? expandDescription(&quot;[bb-item-partial]&quot;) : &quot;&quot;),
										color: this._disabledColor,
										unselectable: true
									};
								}
							} else {
								if (this.$checkMissionStationKey(item.worldScript, stn, item.stationKey) === false &amp;&amp; item.percentComplete === 1) {
									curChoices[&quot;32_COMPLETE&quot;] = {
										text: expandDescription(&quot;[bb-item-complete]&quot;) + expandDescription(&quot;[bb-item-dock-original]&quot;),
										color: this._disabledColor,
										unselectable: true
									};
								} else {
									curChoices[&quot;32_COMPLETE&quot;] = {
										text: expandDescription(&quot;[bb-item-complete]&quot;) + (result != &quot;&quot; ? &quot; (&quot; + result + &quot;)&quot; : (item.percentComplete &lt; 1 ? expandDescription(&quot;[bb-item-partial]&quot;) : &quot;&quot;)),
										color: (result != &quot;&quot; ? this._disabledColor : this._menuColor),
										unselectable: (result != &quot;&quot; ? true : false)
									};
								}
							}
							if (curChoices[&quot;32_COMPLETE&quot;].unselectable === false) completeAvail = true;
							cmdCount += 1;
						}
						break;
					case &quot;AT_STATIONKEY&quot;:
						if (this.$checkMissionStationKey(item.worldScript, stn, item.stationKey) === false &amp;&amp; item.percentComplete === 1) {
							curChoices[&quot;32_COMPLETE&quot;] = {
								text: expandDescription(&quot;[bb-item-complete]&quot;) + expandDescription(&quot;[bb-item-dock-original]&quot;),
								color: this._disabledColor,
								unselectable: true
							};
						} else {
							curChoices[&quot;32_COMPLETE&quot;] = {
								text: expandDescription(&quot;[bb-item-complete]&quot;) + (result != &quot;&quot; ? &quot; (&quot; + result + &quot;)&quot; : (item.percentComplete &lt; 1 ? expandDescription(&quot;[bb-item-partial]&quot;) : &quot;&quot;)),
								color: (result != &quot;&quot; ? this._disabledColor : this._menuColor),
								unselectable: (result != &quot;&quot; ? true : false)
							};
						}
						if (curChoices[&quot;32_COMPLETE&quot;].unselectable === false) completeAvail = true;
						cmdCount += 1;
						break;
					case &quot;ANYWHERE&quot;:
						curChoices[&quot;32_COMPLETE&quot;] = {
							text: expandDescription(&quot;[bb-item-complete]&quot;) + (result != &quot;&quot; ? &quot; (&quot; + result + &quot;)&quot; : (item.percentComplete &lt; 1 ? expandDescription(&quot;[bb-item-partial]&quot;) : &quot;&quot;)),
							color: (result != &quot;&quot; ? this._disabledColor : this._menuColor),
							unselectable: (result != &quot;&quot; ? true : false)
						};
						if (curChoices[&quot;32_COMPLETE&quot;].unselectable === false) completeAvail = true;
						cmdCount += 1;
						break;
				}
			}
		}
		// add &quot;Show Map&quot; item (if applicable)
		if ((item.percentComplete &lt; 1 || completeAvail === false) &amp;&amp; item.destinationGalaxy === galaxyNumber &amp;&amp; item.destination != system.ID &amp;&amp; item.destination &gt;= 0 &amp;&amp; item.destination &lt;= 255) {
			if (item.hasOwnProperty(&quot;forceLongRangeChart&quot;) === true &amp;&amp; item.forceLongRangeChart === true) {
				curChoices[&quot;25_SHOWMAP_LONG&quot;] = {
					text: &quot;[bb-item-showmap]&quot;,
					color: this._menuColor
				};
			} else {
				var dist = Math.round(system.info.distanceToSystem(sys), 2);
				if (dist &gt;= 50 || (dist &gt; 7.2 &amp;&amp; oolite.compareVersion(&quot;1.87&quot;) &gt; 0)) {
					curChoices[&quot;25_SHOWMAP_LONG&quot;] = {
						text: &quot;[bb-item-showmap]&quot;,
						color: this._menuColor
					};
				} else if (dist &gt; 7.0 &amp;&amp; oolite.compareVersion(&quot;1.87&quot;) &lt;= 0) {
					curChoices[&quot;25_SHOWMAP_CUSTOM&quot;] = {
						text: &quot;[bb-item-showmap]&quot;,
						color: this._menuColor
					};
				} else {
					curChoices[&quot;25_SHOWMAP_SHORT&quot;] = {
						text: &quot;[bb-item-showmap]&quot;,
						color: this._menuColor
					};
				}
			}
			cmdCount += 1;
		}
		// add any &quot;Set Course For&quot; items (if applicable)
		if ((item.percentComplete &lt; 1 || completeAvail === false) &amp;&amp; item.destination != system.ID &amp;&amp; item.destinationGalaxy === galaxyNumber &amp;&amp; item.destination &gt;= 0 &amp;&amp; item.destination &lt;= 255 &amp;&amp; this.$systemInCurrentPlot(item.destination) === false &amp;&amp; p.hasEquipmentProviding(&quot;EQ_ADVANCED_NAVIGATIONAL_ARRAY&quot;)) {
			curChoices[&quot;96_SETCOURSE~&quot; + item.destination] = {
				text: &quot;Set course for &quot; + sys.name,
				color: this._menuColor
			};
			cmdCount += 1;
		}
		if (item.percentComplete === 1 &amp;&amp; item.source != system.ID &amp;&amp; item.sourceGalaxy === galaxyNumber &amp;&amp; this.$systemInCurrentPlot(item.source) === false &amp;&amp; p.hasEquipmentProviding(&quot;EQ_ADVANCED_NAVIGATIONAL_ARRAY&quot;)) {
			curChoices[&quot;96_SETCOURSE~&quot; + item.source] = {
				text: &quot;Set course for &quot; + System.systemNameForID(item.source),
				color: this._menuColor
			};
			cmdCount += 1;
		}
		// process any custom menu items
		if (item.customMenuItems &amp;&amp; item.customMenuItems != &quot;&quot;) {
			for (var i = 0; i &lt; item.customMenuItems.length; i++) {
				var mnu = item.customMenuItems[i];
				var a_only = true;
				var m_avail = &quot;&quot;;
				if (mnu.hasOwnProperty(&quot;activeOnly&quot;) === true &amp;&amp; mnu.activeOnly === false) a_only = false;
				if (item.accepted == a_only) {
					if (mnu.hasOwnProperty(&quot;condition&quot;) === true) m_avail = worldScripts[mnu.worldScript][mnu.condition](item.ID);
					if (m_avail === &quot;&quot;) {
						curChoices[&quot;97_CUSTOM~&quot; + i] = {
							text: mnu.text,
							color: this._menuColor
						};
						cmdCount += 1;
					}
					if (m_avail !== &quot;&quot;) {
						curChoices[&quot;97_CUSTOM~&quot; + i] = {
							text: mnu.text + &quot; (&quot; + m_avail + &quot;)&quot;,
							color: this._disabledColor,
							unselectable: true
						};
						cmdCount += 1;
					}
				}
			}
		}
		if (this._itemList.indexOf(this._selectedItem) === this._itemList.length - 1) {
			curChoices[&quot;19_NEXTMISSION&quot;] = {
				text: &quot;[bb-item-nextmission]&quot;,
				color: this._disabledColor,
				unselectable: true
			};
		} else {
			curChoices[&quot;19_NEXTMISSION&quot;] = {
				text: &quot;[bb-item-nextmission]&quot;,
				color: this._menuColor
			};
		}

		curChoices[&quot;98_EXIT&quot;] = {
			text: &quot;[bb-item-close]&quot;,
			color: this._exitColor
		};
		cmdCount += 1;

		var start = 0;
		var end = output.length - 1;
		var extratext = &quot;&quot;;

		// check to see if we need to use paging
		if (output.length &gt; (27 - (cmdCount + 1))) {
			// paging required
			cmdCount += 2;
			var pagelen = (27 - (cmdCount + 1));
			var maxpage = Math.ceil(output.length / pagelen);
			if (this._displayPage === 0 &amp;&amp; this._displayPage &lt; maxpage - 1) {
				curChoices[&quot;21_NEXTPAGE&quot;] = {
					text: &quot;[bb-nextpage]&quot;,
					color: this._menuColor
				};
			} else {
				curChoices[&quot;21_NEXTPAGE&quot;] = {
					text: &quot;[bb-nextpage]&quot;,
					color: this._disabledColor,
					unselectable: true
				};
			}
			if (this._displayPage &gt; 0) {
				curChoices[&quot;22_PREVPAGE&quot;] = {
					text: &quot;[bb-prevpage]&quot;,
					color: this._menuColor
				};
			} else {
				curChoices[&quot;22_PREVPAGE&quot;] = {
					text: &quot;[bb-prevpage]&quot;,
					color: this._disabledColor,
					unselectable: true
				};
			}
			start = this._displayPage * pagelen;
			end = this._displayPage * pagelen + pagelen - 1;
			if (end &gt; output.length - 1) end = output.length - 1;
			extratext = &quot; - Page &quot; + (this._displayPage + 1) + &quot; of &quot; + maxpage;
		}

		// output the text lines
		for (var i = start; i &lt;= end; i++) {
			text += output[i] + &quot;\n&quot;;
		}

		var def = &quot;98_EXIT&quot;;
		if (this._lastChoice[this._displayType] != &quot;&quot;) def = this._lastChoice[this._displayType];

		var opts = {
			screenID: &quot;oolite-bbsystem-item-map&quot;,
			title: expandDescription(&quot;[bb-item-heading]&quot;) + extratext,
			allowInterrupt: true,
			exitScreen: &quot;GUI_SCREEN_INTERFACES&quot;,
			choices: curChoices,
			initialChoicesKey: def,
			message: text
		};
		if (this._overlay !== &quot;&quot;) opts.overlay = this._overlay;
		if (item.overlay !== &quot;&quot;) opts.overlay = item.overlay;

		if (this._background !== &quot;&quot;) opts.background = this._background;
		if (item.background !== &quot;&quot;) opts.background = item.background;

		if (item.model != &quot;&quot;) {
			opts[&quot;model&quot;] = item.model;
			if (item.modelPersonality &amp;&amp; item.modelPersonality != 0) opts[&quot;modelPersonality&quot;] = item.modelPersonality;
			if (item.spinModel &amp;&amp; item.spinModel === false) opts[&quot;spinModel&quot;] = false;
			// if a model as been set, remove any overlay
			delete opts[&quot;overlay&quot;];
		}
		this.$triggerBBEvent(&quot;postItemDisplay&quot;, this._selectedItem);
	}

	// short range chart/custom chart
	if (this._displayType === 2 || this._displayType === 3 || this._displayType === 7) {
		// force the route mode to be the same as the player&#39;s current route mode
		// this is because the short range chart doesn&#39;t have the option of switching between modes
		//if (p.hasEquipmentProviding(&quot;EQ_ADVANCED_NAVIGATIONAL_ARRAY&quot;)) this._routeMode = p.routeMode;
		text = &quot;&quot;;
		var item = this.$getItem(this._selectedItem);
		this.$triggerBBEvent(&quot;preItemChartDisplay&quot;, this._selectedItem);
		var sys = System.infoForSystem(galaxyNumber, item.destination);
		var screenPos = false;
		if (item.destination != system.ID &amp;&amp; p.hasEquipmentProviding(&quot;EQ_ADVANCED_NAVIGATIONAL_ARRAY&quot;) &amp;&amp; this._routeMode !== &quot;OPTIMIZED_BY_NONE&quot;) {
			var rt = System.infoForSystem(galaxyNumber, system.ID).routeToSystem(sys, this._routeMode);
			if (rt &amp;&amp; rt.route.length &gt; 1) {
				screenPos = true;
				if (this._displayType === 3) {
					text = &quot;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&quot; + this.$padTextRight(&quot;&quot;, jmpIndent) + expandDescription(&quot;[bb-item-jumps]&quot;) + &quot; &quot; + (rt.route.length - 1);
				} else {
					text = &quot;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&quot; + this.$padTextRight(&quot;&quot;, jmpIndent) + expandDescription(&quot;[bb-item-jumps]&quot;) + &quot; &quot; + (rt.route.length - 1);
				}
			}
		}
		var lines = &quot;\n&quot;;
		if (screenPos == false) {
			if (this._displayType === 3) {
				lines= &quot;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&quot;;
			} else {
				lines = &quot;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&quot;;
			}
		}
		text += lines + this.$padTextRight(item.description, 20) + this.$padTextLeft((item.payment &gt; 0 ? &quot;Payment: &quot; + formatCredits(item.payment, true, true) : &quot;&quot;), 12);

		// we need to get the current plot info before we switch the players destination, otherwise the check will always be true
		var inCurrPlot_dest = this.$systemInCurrentPlot(item.destination);
		var inCurrPlot_src = this.$systemInCurrentPlot(item.source);

		// hold the player&#39;s destination
		this._suspendedDestination = p.targetSystem;
		// override it for the display
		p.targetSystem = item.destination;

		if (item.accepted === false) {
			this.$addAdditionalMarkers(this._selectedItem);
			this._tempMarkers = this._selectedItem;
			var test = this.$missionUnavailableReason(item.ID);
			if (test === &quot;&quot;) {
				curChoices[&quot;30_ACCEPT&quot;] = {
					text: &quot;[bb-item-accept]&quot;,
					color: this._menuColor
				};
			} else {
				curChoices[&quot;30_ACCEPT&quot;] = {
					text: expandDescription(&quot;[bb-item-unavailable]&quot;) + &quot; (&quot; + test + &quot;)&quot;,
					color: this._disabledColor,
					unselectable: true
				};
			}
		}

		var bg = &quot;&quot;;
		switch (this._displayType) {
			case 2:
				bg = &quot;SHORT_RANGE_CHART&quot;;
				break;
			case 3:
				bg = &quot;LONG_RANGE_CHART&quot;;
				break;
			case 7:
				bg = &quot;CUSTOM_CHART&quot;;
				break;
		}
		if (oolite.compareVersion(&quot;1.87&quot;) &lt;= 0) {
			if (p.hasEquipmentProviding(&quot;EQ_ADVANCED_NAVIGATIONAL_ARRAY&quot;)) {
				if (this._routeMode === &quot;OPTIMIZED_BY_JUMPS&quot;) {
					bg += &quot;_SHORTEST&quot;;
					curChoices[&quot;26_SHORTEST&quot;] = {
						text: &quot;[bb-item-shortest]&quot;,
						color: this._disabledColor,
						unselectable: true
					};
					curChoices[&quot;27_QUICKEST&quot;] = {
						text: &quot;[bb-item-quickest]&quot;,
						color: this._menuColor
					};
				} else {
					bg += &quot;_QUICKEST&quot;;
					curChoices[&quot;26_SHORTEST&quot;] = {
						text: &quot;[bb-item-shortest]&quot;,
						color: this._menuColor
					};
					curChoices[&quot;27_QUICKEST&quot;] = {
						text: &quot;[bb-item-quickest]&quot;,
						color: this._disabledColor,
						unselectable: true
					};
				}
			}
		}
		var result = &quot;&quot;;
		if (item.confirmCompleteCallback &amp;&amp; item.confirmCompleteCallback !== &quot;&quot;) {
			result = worldScripts[item.worldScript][item.confirmCompleteCallback](item.ID)
		}
		curChoices[&quot;20_RETURN&quot;] = {
			text: &quot;[bb-item-return]&quot;,
			color: this._menuColor
		};
		if ((item.percentComplete &lt; 1 || result != &quot;&quot;) &amp;&amp; item.destination != system.ID &amp;&amp; inCurrPlot_dest === false &amp;&amp; p.hasEquipmentProviding(&quot;EQ_ADVANCED_NAVIGATIONAL_ARRAY&quot;)) {
			curChoices[&quot;96_SETCOURSE~&quot; + item.destination] = {
				text: &quot;Set course for &quot; + sys.name,
				color: this._menuColor
			};
		}
		if (item.percentComplete === 1 &amp;&amp; item.source != system.ID &amp;&amp; inCurrPlot_src === false &amp;&amp; p.hasEquipmentProviding(&quot;EQ_ADVANCED_NAVIGATIONAL_ARRAY&quot;)) {
			curChoices[&quot;96_SETCOURSE~&quot; + item.source] = {
				text: &quot;Set course for &quot; + System.systemNameForID(item.source),
				color: this._menuColor
			};
			cmdCount += 1;
		}
		if (this._nextContractOnMap === false) {
			curChoices[&quot;97_CLOSE&quot;] = {
				text: &quot;[bb-item-close]&quot;,
				color: this._exitColor
			};
			def = &quot;97_CLOSE&quot;;
		} else {
			if (this._itemList.indexOf(this._selectedItem) === this._itemList.length - 1) {
				curChoices[&quot;19_NEXTMISSION&quot;] = {
					text: &quot;[bb-item-nextmission]&quot;,
					color: this._disabledColor,
					unselectable: true
				};
			} else {
				curChoices[&quot;19_NEXTMISSION&quot;] = {
					text: &quot;[bb-item-nextmission]&quot;,
					color: this._menuColor
				};
			}
			def = &quot;20_RETURN&quot;;
		}
		if (this._lastChoice[this._displayType] != &quot;&quot;) def = this._lastChoice[this._displayType];

		var opts = {
			screenID: (this._displayType === 3 ? &quot;oolite-bbsystem-longrangechart-map&quot; : &quot;oolite-bbsystem-shortrangechart-map&quot;),
			title: &quot;Mission Details - Chart&quot;,
			backgroundSpecial: bg,
			allowInterrupt: true,
			exitScreen: &quot;GUI_SCREEN_INTERFACES&quot;,
			choices: curChoices,
			initialChoicesKey: def,
			message: text
		};
		// a custom chart view, for missions with destinations between 7 and 50 LY away (Oolite 1.87 only)
		if (this._displayType === 7) {
			var dist = Math.round(system.info.distanceToSystem(sys), 2);
			for (var i = 0; i &lt; this._zoomDist.length; i++) {
				if (dist &gt;= this._zoomDist[i].dist) {
					opts[&quot;customChartZoom&quot;] = this._zoomDist[i].zoom;
					break;
				}
			}
			// calculate the midpoint between the source and destination, so we get the best view of the route
			var point1 = system.info.coordinates;
			var point2 = sys.coordinates;
			var xdiff = (point1.x - point2.x) / 2;
			var ydiff = (point1.y - point2.y) / 2;
			opts[&quot;customChartCentreInLY&quot;] = new Vector3D(point1.x - xdiff, point1.y - ydiff, 0);
		}
		if (this._overlay !== &quot;&quot;) opts.overlay = this._overlay;
		if (item.overlay !== &quot;&quot;) opts.overlay = item.overlay;
		if (item.mapOverlay !== &quot;&quot;) opts.overlay = item.mapOverlay;

		this.$triggerBBEvent(&quot;postItemChartDisplay&quot;, this._selectedItem);
	}

	// confirm terminate
	if (this._displayType === 4) {
		var item = this.$getItem(this._selectedItem);
		text = expandDescription(&quot;[bb-confirm-terminate]&quot;);
		curChoices[&quot;40_YES&quot;] = {
			text: &quot;[bb-item-confirm-yes]&quot;,
			color: this._menuColor
		};
		curChoices[&quot;41_NO&quot;] = {
			text: &quot;[bb-item-confirm-no]&quot;,
			color: this._menuColor
		};
		def = &quot;41_NO&quot;;

		var opts = {
			screenID: &quot;oolite-bbsystem-confirmterminate-map&quot;,
			title: &quot;Mission Terminate - Confirmation&quot;,
			allowInterrupt: true,
			exitScreen: &quot;GUI_SCREEN_INTERFACES&quot;,
			choices: curChoices,
			initialChoicesKey: def,
			message: text
		};

		if (this._overlay !== &quot;&quot;) opts.overlay = this._overlay;
		if (item.overlay !== &quot;&quot;) opts.overlay = item.overlay;

		if (this._background !== &quot;&quot;) opts.background = this._background;
		if (item.background !== &quot;&quot;) opts.background = item.background;

		if (item.model != &quot;&quot;) {
			opts[&quot;model&quot;] = item.model;
			if (item.modelPersonality &amp;&amp; item.modelPersonality != 0) opts[&quot;modelPersonality&quot;] = item.modelPersonality;
			if (item.spinModel &amp;&amp; item.spinModel === false) opts[&quot;spinModel&quot;] = false;
			// if a model as been set, remove any overlay
			delete opts[&quot;overlay&quot;];
		}
	}

	// unable to complete mission screen result
	if (this._displayType === 5) {
		var item = this.$getItem(this._selectedItem);
		text = expandDescription(&quot;[bb-unable-to-complete]&quot;) + &quot;\n\n&quot; + this._notCompleteText;
		curChoices[&quot;97A_CLOSE&quot;] = {
			text: &quot;[bb-item-close]&quot;,
			color: this._menuColor
		};
		def = &quot;97A_CLOSE&quot;;

		var opts = {
			screenID: &quot;oolite-bbsystem-incomplete-map&quot;,
			title: &quot;Mission Details - Incomplete&quot;,
			allowInterrupt: true,
			exitScreen: &quot;GUI_SCREEN_INTERFACES&quot;,
			choices: curChoices,
			initialChoicesKey: def,
			message: text
		};

		if (this._overlay !== &quot;&quot;) opts.overlay = this._overlay;
		if (item.overlay !== &quot;&quot;) opts.overlay = item.overlay;

		if (this._background !== &quot;&quot;) opts.background = this._background;
		if (item.background !== &quot;&quot;) opts.background = item.background;

		if (item.model != &quot;&quot;) {
			opts[&quot;model&quot;] = item.model;
			if (item.modelPersonality != 0) opts[&quot;modelPersonality&quot;] = item.modelPersonality;
			if (item.spinModel === false) opts[&quot;spinModel&quot;] = false;
			// if a model as been set, remove any overlay
			delete opts[&quot;overlay&quot;];
		}
	}

	// post messages
	if (this._displayType === 10 || this._displayType === 11 || this._displayType === 12) {
		var type = [&quot;initiated&quot;, &quot;completed&quot;, &quot;terminated&quot;];
		var post = this._holdItem;
		text = expandDescription(post.text);
		if (!post.return || post.return === &quot;list&quot;) {
			curChoices[&quot;97_CLOSE&quot;] = {
				text: &quot;[bb-item-close]&quot;,
				color: this._menuColor
			};
			def = &quot;97_CLOSE&quot;;
		}
		if (post.return &amp;&amp; post.return === &quot;item&quot;) {
			curChoices[&quot;97A_CLOSE&quot;] = {
				text: &quot;[bb-item-close]&quot;,
				color: this._menuColor
			};
			def = &quot;97A_CLOSE&quot;;
		}
		if (post.return &amp;&amp; post.return === &quot;exit&quot;) {
			curChoices[&quot;99_EXIT&quot;] = {
				text: &quot;[bb-item-close]&quot;,
				color: this._menuColor
			};
			def = &quot;99_EXIT&quot;;
		}
		var opts = {
			screenID: &quot;oolite-bbsystem-incomplete-map&quot;,
			title: expandDescription(&quot;[bb-title-&quot; + type[this._displayType - 10] + &quot;]&quot;),
			allowInterrupt: true,
			exitScreen: &quot;GUI_SCREEN_INTERFACES&quot;,
			choices: curChoices,
			initialChoicesKey: def,
			message: text
		};

		if (this._overlay !== &quot;&quot;) opts.overlay = this._overlay;
		if (post.overlay !== &quot;&quot;) opts.overlay = post.overlay;

		if (this._background !== &quot;&quot;) opts.background = this._background;
		if (post.background !== &quot;&quot;) opts.background = post.background;

		if (post.model &amp;&amp; post.model != &quot;&quot;) {
			opts[&quot;model&quot;] = post.model;
			if (post.modelPersonality &amp;&amp; post.modelPersonality != 0) opts[&quot;modelPersonality&quot;] = post.modelPersonality;
			if (post.spinModel &amp;&amp; post.spinModel === false) opts[&quot;spinModel&quot;] = false;
			// if a model as been set, remove any overlay
			delete opts[&quot;overlay&quot;];
		}
	}

	mission.runScreen(opts, this.$bbHandler, this);
}

//-------------------------------------------------------------------------------------------------------------
// handles player selections on the BB screen
this.$bbHandler = function $bbHandler(choice) {

	if (this._suspendedDestination &gt;= 0) player.ship.targetSystem = this._suspendedDestination;
	this._suspendedDestination = -1;
	if (this._tempMarkers &gt;= 0) {
		this.$removeChartMarker(this._tempMarkers);
	}

	if (!choice) {
		this.$triggerBBEvent(&quot;exit&quot;);
		return;
	}

	var newChoice = &quot;&quot;;

	this._lastChoice[this._displayType] = choice;

	// selected bb item from main list
	if (choice.indexOf(&quot;01_ITEM&quot;) &gt;= 0) {
		this._selectedItem = parseInt(choice.substring(choice.indexOf(&quot;~&quot;) + 1));
		this._displayType = 1;
		this._displayPage = 0;
		// from screen 0 into screen 1, always default to the &quot;Exit&quot; option.
		this._lastChoice[this._displayType] = &quot;98_EXIT&quot;;
	}
	// user defined bb main menu item
	if (choice.indexOf(&quot;03_MENU&quot;) &gt;= 0) {
		var idx = parseInt(choice.substring(choice.indexOf(&quot;~&quot;) + 1));
		worldScripts[this._mainMenuItems[idx].worldScript][this._mainMenuItems[idx].menuCallback]();
		if (this._mainMenuItems[idx] &amp;&amp; this._mainMenuItems[idx].hasOwnProperty(&quot;autoRemove&quot;) &amp;&amp; this._mainMenuItems[idx].autoRemove === true) {
			this._mainMenuItems.splice(idx, 1);
		}
		// if the function needs to display a mission page during it&#39;s callback, 
		// it should set BulletinBoardSystem._displayPage = -1 before it finishes
		// that will jump the BB out of it&#39;s cycle
		// then, to jump back in, set BulletinBoardSystem._displayPage to 0 and call BulletinBoardSystem.$showPage()
		// that will return the BB back to the main contract listing page
	}
	// selected &quot;set course to&quot; from details page
	if (choice.indexOf(&quot;96_SETCOURSE&quot;) &gt;= 0) {
		var dest = parseInt(choice.substring(choice.indexOf(&quot;~&quot;) + 1));
		if (dest &gt;= 0 &amp;&amp; dest &lt;= 255) {
			player.ship.targetSystem = dest;
			player.ship.infoSystem = player.ship.targetSystem;
			player.consoleMessage(&quot;Course set for &quot; + System.systemNameForID(dest));
		}
	}
	if (choice.indexOf(&quot;97_CUSTOM&quot;) &gt;= 0) {
		var idx = parseInt(choice.substring(choice.indexOf(&quot;~&quot;) + 1));
		var item = this.$getItem(this._selectedItem);
		var mnu = item.customMenuItems[idx];

		if (mnu.worldScript &amp;&amp; mnu.worldScript != &quot;&quot; &amp;&amp; mnu.callback &amp;&amp; mnu.callback != &quot;&quot;) {
			worldScripts[mnu.worldScript][mnu.callback](item.ID);
			if (mnu.hasOwnProperty(&quot;autoRemove&quot;) &amp;&amp; mnu.autoRemove === true) item.customMenuItems.splice(idx, 1);
		}
		newChoice = &quot;98_EXIT&quot;;
	}
	// other choices
	switch (choice) {
		case &quot;11_GOTOPREV&quot;:
			this._curpage -= 1;
			if (this._curpage === 0) newChoice = &quot;10_GOTONEXT&quot;;
			break;
		case &quot;10_GOTONEXT&quot;:
			this._curpage += 1;
			if (this._curpage === this._maxpage - 1) newChoice = &quot;11_GOTOPREV&quot;;
			break;
		case &quot;19_NEXTMISSION&quot;:
			for (var i = 0; i &lt; this._itemList.length; i++) {
				if (this._itemList[i] === this._selectedItem) {
					var target = i + 1;
					if (target &lt; this._itemList.length) {
						this._displayType = 1;
						this._displayPage = 0;
						this._selectedItem = this._itemList[target];
						this._lastChoice[0] = &quot;99_EXIT&quot;;
					}
					break;
				}
			}
			break;
		case &quot;21_NEXTPAGE&quot;:
			this._displayPage += 1;
			break;
		case &quot;22_PREVPAGE&quot;:
			this._displayPage -= 1;
			break;
		case &quot;25_SHOWMAP_SHORT&quot;:
			this._displayType = 2;
			break;
		case &quot;25_SHOWMAP_CUSTOM&quot;:
			this._displayType = 7;
			break;
		case &quot;25_SHOWMAP_LONG&quot;:
			this._displayType = 3;
			break;
		case &quot;26_SHORTEST&quot;:
			this._routeMode = &quot;OPTIMIZED_BY_JUMPS&quot;;
			newChoice = &quot;27_QUICKEST&quot;;
			break;
		case &quot;27_QUICKEST&quot;:
			this._routeMode = &quot;OPTIMIZED_BY_TIME&quot;;
			newChoice = &quot;26_SHORTEST&quot;;
			break;
		case &quot;30_ACCEPT&quot;:
			var item = this.$getItem(this._selectedItem);
			if (item.deposit &amp;&amp; item.deposit &gt; 0) {
				if (player.credits &lt; item.deposit) {
					player.consoleMessage(&quot;Unable to accept mission. Insufficient credits to cover required deposit.&quot;, 5);
					break;
				} else {
					if (item.hasOwnProperty(&quot;remoteDepositProcess&quot;) === false || item.remoteDepositProcess === false) {
						player.credits -= item.deposit;
						player.consoleMessage(&quot;Deposit amount of &quot; + formatCredits(item.deposit, true, true) + &quot; was deducted from your account.&quot;, 4);
					}
				}
			}
			if (!item.hasOwnProperty(&quot;playAcceptedSound&quot;) || item.playAcceptedSound === true) this.$playAcceptContractSound();
			item.accepted = true;
			item.acceptedDate = clock.adjustedSeconds;
			if (item.initiateCallback !== &quot;&quot;) worldScripts[item.worldScript][item.initiateCallback](item.ID);
			// add item to manifest screen
			this.$addManifestEntry(item.ID);
			// send an email (if installed)
			this.$sendEmail(player.ship.dockedStation, &quot;accepted&quot;, item.ID);

			this.$initInterface(player.ship.dockedStation);

			if (this.$postDisplayAvailable(item.ID, &quot;initiated&quot;) === true) {
				this._displayType = 10;
				this.$storePostMessageDetails(item.ID, &quot;initiated&quot;);
			}
			break;
		case &quot;31_TERMINATE&quot;:
			this._displayType = 4;
			break;
		case &quot;32_COMPLETE&quot;:
			var item = this.$getItem(this._selectedItem);
			var result = &quot;&quot;;
			if (item.confirmCompleteCallback &amp;&amp; item.confirmCompleteCallback !== &quot;&quot;) {
				result = worldScripts[item.worldScript][item.confirmCompleteCallback](item.ID)
			}
			if (result === &quot;&quot;) {
				this._displayType = 0;
				if (this.$postDisplayAvailable(item.ID, &quot;completed&quot;) === true) {
					this._displayType = 11;
					this.$storePostMessageDetails(item.ID, &quot;completed&quot;);
				}
				this.$completeBBMission(item.ID);
			} else {
				this._notCompleteText = result;
				this._displayType = 5;
			}
			break;
		case &quot;20_RETURN&quot;:
			this._displayType = 1;
			break;
		case &quot;40_YES&quot;:
			this._displayType = 0;
			if (this.$postDisplayAvailable(this._selectedItem, &quot;terminated&quot;) === true) {
				this._displayType = 12;
				this.$storePostMessageDetails(this._selectedItem, &quot;terminated&quot;);
			}
			this.$failedBBMission(this._selectedItem, true);
			break;
		case &quot;41_NO&quot;:
			this._displayType = 1;
			break;
		case &quot;97_CLOSE&quot;:
			this._displayType = 0;
			break;
		case &quot;97A_CLOSE&quot;:
			this._displayType = 1;
			this._displayPage = 0;
			break;
		case &quot;98_EXIT&quot;:
			this._displayType = 0;
			break;
	}

	if (newChoice != &quot;&quot;) this._lastChoice[this._displayType] = newChoice;

	if (choice != &quot;99_EXIT&quot;) {
		this.$showPage();
	} else {
		this._bbExiting = 2;
		this.$triggerBBEvent(&quot;close&quot;);
	}
}

//-------------------------------------------------------------------------------------------------------------
// returns true if a HUD with allowBigGUI is enabled, otherwise false
this.$isBigGuiActive = function $isBigGuiActive() {
	if (oolite.compareVersion(&quot;1.83&quot;) &lt;= 0) {
		return player.ship.hudAllowsBigGui;
	} else {
		var bigGuiHUD = [&quot;XenonHUD.plist&quot;, &quot;coluber_hud_ch01-dock.plist&quot;]; // until there is a property we can check, I&#39;ll be listing HUD&#39;s that have the allow_big_gui property set here
		if (bigGuiHUD.indexOf(player.ship.hud) &gt;= 0) {
			return true;
		} else {
			return false;
		}
	}
}

//-------------------------------------------------------------------------------------------------------------
// appends space to currentText to the specified length in &#39;em&#39;
this.$padTextRight = function $padTextRight(currentText, desiredLength, leftSwitch) {
	if (currentText == null) currentText = &quot;&quot;;
	var hairSpace = String.fromCharCode(31);
	var ellip = &quot;…&quot;;
	var currentLength = defaultFont.measureString(currentText);
	var hairSpaceLength = defaultFont.measureString(hairSpace);
	// calculate number needed to fill remaining length
	var padsNeeded = Math.floor((desiredLength - currentLength) / hairSpaceLength);
	if (padsNeeded &lt; 1) {
		// text is too long for column, so start pulling characters off
		var tmp = currentText;
		do {
			tmp = tmp.substring(0, tmp.length - 2) + ellip;
			if (tmp === ellip) break;
		} while (defaultFont.measureString(tmp) &gt; desiredLength);
		currentLength = defaultFont.measureString(tmp);
		padsNeeded = Math.floor((desiredLength - currentLength) / hairSpaceLength);
		currentText = tmp;
	}
	// quick way of generating a repeated string of that number
	if (!leftSwitch || leftSwitch === false) {
		return currentText + new Array(padsNeeded).join(hairSpace);
	} else {
		return new Array(padsNeeded).join(hairSpace) + currentText;
	}
}

//-------------------------------------------------------------------------------------------------------------
// appends space to currentText to the specified length in &#39;em&#39;
this.$padTextLeft = function $padTextLeft(currentText, desiredLength) {
	return this.$padTextRight(currentText, desiredLength, true);
}

//-------------------------------------------------------------------------------------------------------------
// arranges text into a array of strings with a particular column width
this.$columnText = function $columnText(originalText, columnWidth) {
	var returnText = [];
	if (defaultFont.measureString(originalText) &gt; columnWidth) {
		var hold = originalText;
		do {
			var newline = &quot;&quot;;
			var remain = &quot;&quot;;
			var point = hold.length;
			do {
				point = hold.lastIndexOf(&quot; &quot;, point - 1);
				newline = hold.substring(0, point).trim();
				remain = hold.substring(point + 1).trim();
			} while (defaultFont.measureString(newline) &gt; columnWidth);
			returnText.push(newline);
			if (remain != &quot;&quot;) {
				if (defaultFont.measureString(remain) &lt;= columnWidth) {
					returnText.push(remain);
					hold = &quot;&quot;;
				} else {
					hold = remain;
				}
			} else {
				hold = &quot;&quot;;
			}
		} while (hold != &quot;&quot;);
	} else {
		returnText.push(originalText);
	}
	return returnText;
}

//-------------------------------------------------------------------------------------------------------------
// returns a string containing the days, hours, minutes (and possibly seconds) remaining until the expiry time is reached
this.$getTimeRemaining = function $getTimeRemaining(expiry, hoursOnly) {
	var hrsOnly = (hoursOnly &amp;&amp; hoursOnly === true ? true : false);
	var diff = expiry - clock.adjustedSeconds;
	var result = &quot;&quot;;
	if (diff &gt; 0) {
		var days = (hrsOnly === true ? 0 : Math.floor(diff / 86400));
		var hours = Math.floor((diff - (days * 86400)) / 3600);
		var mins = Math.floor((diff - (days * 86400 + hours * 3600)) / 60);
		var secs = Math.floor(diff - (days * 86400) - (hours * 3600) - (mins * 60));
		// special case - reduce 1 hour down to mins
		if (days === 0 &amp;&amp; hours === 1 &amp;&amp; mins &lt; 40) {
			hours = 0;
			mins += 60;
		}
		// special case - reduce 1 min down to secs
		if (days === 0 &amp;&amp; hours === 0 &amp;&amp; mins === 1 &amp;&amp; secs &lt; 40) {
			mins = 0;
			secs += 60;
		}
		if (hrsOnly === true &amp;&amp; mins &gt; 30 &amp;&amp; hours &gt; 1) hours += 1;
		if (days &gt; 0) result += days + (days &gt; 1 ? &quot; days&quot; : &quot; day&quot;);
		if (hours &gt; 0) result += (result === &quot;&quot; ? &quot;&quot; : &quot; &quot;) + hours + (hours &gt; 1 ? &quot; hrs&quot; : &quot; hr&quot;);
		if (hrsOnly === false || (hours === 0 &amp;&amp; mins &gt; 0)) {
			if (mins &gt; 0) result += (result === &quot;&quot; ? &quot;&quot; : &quot; &quot;) + mins + (mins &gt; 1 ? &quot; mins&quot; : &quot; min&quot;);
		}
		if (hrsOnly === false || (hours === 0 &amp;&amp; mins === 0 &amp;&amp; secs &gt; 0)) {
			if (hours === 0 &amp;&amp; secs &gt; 0) result += (result === &quot;&quot; ? &quot;&quot; : &quot; &quot;) + secs + (secs &gt; 1 ? &quot; secs&quot; : &quot; sec&quot;);
		}
	} else {
		if (hrsOnly === false) {
			result = &quot;No time - mission time expired!&quot;;
		} else {
			result = &quot;Expired&quot;;
		}
	}
	return result;
}

//-------------------------------------------------------------------------------------------------------------
// adds a mark to the galactic chart when a new mission is accepted
// also forces the manifest details to be updated
this.$addManifestEntry = function $addManifestEntry(bbID) {
	var item = this.$getItem(bbID);
	if (!item) return;
	if (item.destination &gt;= 0 &amp;&amp; item.destination &lt;= 255) {
		if (item.markerShape != &quot;NONE&quot;)
			mission.markSystem({
				system: item.destination,
				name: item.worldScript + &quot;_&quot; + bbID,
				markerShape: item.markerShape,
				markerColor: item.markerColor,
				markerScale: item.markerScale
			});
	}
	this.$addAdditionalMarkers(bbID);

	// if we don&#39;t have any manifest text yet, tell the originator to populate it
	if (item.manifestText === &quot;&quot; &amp;&amp; item.manifestCallback)
		worldScripts[item.worldScript][item.manifestCallback](item.ID);

	this.$refreshManifest();
}

//-------------------------------------------------------------------------------------------------------------
this.$addAdditionalMarkers = function $addAdditionalMarkers(bbID) {
	var item = this.$getItem(bbID);
	if (item.hasOwnProperty(&quot;additionalMarkers&quot;) === true) {
		for (var i = 0; i &lt; item.additionalMarkers.length; i++) {
			var ai = item.additionalMarkers[i];
			mission.markSystem({
				system: ai.system,
				name: item.worldScript + &quot;_&quot; + bbID,
				markerShape: ai.markerShape,
				markerColor: ai.markerColor,
				markerScale: ai.markerScale
			});
		}
	}
}

//-------------------------------------------------------------------------------------------------------------
// refreshes the mission text on the manifest screen
this.$refreshManifest = function $refreshManifest() {
	function compareDate(a, b) {
		return ((a.acceptedDate &gt; b.acceptedDate) ? 1 : -1);
	}
	this._data.sort(compareDate);
	var textData = [];
	textData.push(expandDescription(&quot;[bb-manifest-header]&quot;));
	for (var i = 0; i &lt; this._data.length; i++) {
		if (this._data[i].accepted === true) {
			if (this._data[i].manifestText != &quot;&quot;) {
				// make sure the mission text will fit on the display by breaking up the text into screen-width columns
				var coltext = this.$columnText(this._data[i].manifestText, 30);
				for (var j = 0; j &lt; coltext.length; j++) {
					textData.push((j === 0 ? &quot;&quot; : &quot; &quot;) + coltext[j]);
				}
			}
		}
	}
	if (textData.length === 1) {
		mission.setInstructions(null, this.name);
	} else {
		mission.setInstructions(textData, this.name);
	}
}

//-------------------------------------------------------------------------------------------------------------
// reverts the chart marker back to the source location (for when a mission is complete and the player needs to return to the source for payment)
this.$revertChartMarker = function $revertChartMarker(bbID) {
	var item = this.$getItem(bbID);
	if (item.markerShape != &quot;NONE&quot;) {
		// remove the existing chart marker
		this.$removeChartMarker(bbID);
		// point it at the source system
		mission.markSystem({
			system: item.source,
			name: item.worldScript + &quot;_&quot; + bbID,
			markerShape: item.markerShape,
			markerColor: item.markerColor,
			markerScale: item.markerScale
		});
	}
}

//-------------------------------------------------------------------------------------------------------------
this.$removeChartMarker = function $removeChartMarker(bbID) {
	var item = this.$getItem(bbID);
	// remove the chart marker
	if (item &amp;&amp; (item.markerShape != &quot;NONE&quot; || (item.hasOwnProperty(&quot;additionalMarkers&quot;) === true &amp;&amp; item.additionalMarkers.length &gt; 0))) {
		// we&#39;re cycling through every possible system in case the destination was updated mid-mission
		for (var i = 0; i &lt;= 255; i++) {
			mission.unmarkSystem({
				system: i,
				name: item.worldScript + &quot;_&quot; + bbID
			});
		}
	}
}

//-------------------------------------------------------------------------------------------------------------
// removes the manifest screen entry for a particular mission
this.$removeManifestEntry = function $removeManifestEntry(bbID) {
	// remove the chart marker
	this.$removeChartMarker(bbID);

	var item = this.$getItem(bbID);
	// make sure this item gets removed from the manifest display as well
	if (item) item.manifestText = &quot;&quot;;

	this.$refreshManifest();
}

//-------------------------------------------------------------------------------------------------------------
// sends confirmation emails (if the email system is installed)
this.$sendEmail = function $sendEmail(station, eventType, missID, trueAmt) {
	var email = worldScripts.EmailSystem;
	// don&#39;t bother sending email if the system isn&#39;t installed
	if (email == null) return;

	var itm = this.$getItem(missID);
	if (!itm || (itm.hasOwnProperty(&quot;noEmails&quot;) &amp;&amp; itm.noEmails === true)) return;

	var text = &quot;&quot;;
	var subj = &quot;Confirmed: &#39;&quot; + itm.description + &quot;&#39;&quot;;

	if (trueAmt == null) trueAmt = itm.payment;

	switch (eventType) {
		case &quot;accepted&quot;:
			text += &quot;This is to confirm that you have agreed to the following mission: &quot; + itm.manifestText;
			text += (itm.payment &gt; 0 ? &quot;\n\nThe agreed payment for successfully completing this mission is &quot; + formatCredits(itm.payment, true, true) + &quot;.&quot; : &quot;&quot;);
			if (itm.penalty &gt; 0) text += &quot;\n\nIf you are unable to complete the mission within the time period allowed, you will be penalised &quot; + formatCredits(itm.penalty, true, true) + &quot;.&quot;;
			subj += &quot; accepted&quot;;
			break;
		case &quot;terminated&quot;:
			text += &quot;This is to confirm that you have terminated the following mission: &quot; + itm.originalManifestText;
			if (trueAmt &gt; 0) {
				text += &quot;\n\nYou have be penalised &quot; + formatCredits(trueAmt, true, true) + &quot; for terminating the mission before completion.&quot;;
			} else if (trueAmt &lt; 0) {
				text += &quot;\n\nBecause you have partially completed the mission, you have been awarded &quot; + formatCredits(trueAmt, true, true) + &quot;, which has been credited to your account.&quot;;
			}
			subj += &quot; terminated&quot;;
			break;
		case &quot;success&quot;:
			text += &quot;This is to confirm that you have successfully completed the following mission: &quot; + itm.originalManifestText;
			if (trueAmt &gt; 0) text += &quot;\n\nThe agreed payment for successfully completing this mission was &quot; + formatCredits(trueAmt, true, true) + &quot;, which has been credited to your account.&quot;;
			subj += &quot; completed&quot;;
			break;
		case &quot;fail&quot;:
			text += &quot;This is to confirm that you have failed to complete the following mission within the specified time period: &quot; + itm.originalManifestText;
			if (trueAmt &gt; 0) {
				text += &quot;\n\nBecause of this, you have been penalised &quot; + formatCredits(trueAmt, true, true) + &quot;.&quot;;
			} else if (trueAmt &lt; 0) {
				text += &quot;\n\nHowever, because you have partially completed the mission, you have been awarded &quot; + formatCredits(trueAmt, true, true) + &quot;, which has been credited to your account.&quot;;
			}
			subj += &quot; failed&quot;;
			break;
	}

	// each station can have it&#39;s own BB admin name
	var stnName = &quot;default&quot;;
	if (station == null) {
		if (system != -1) stnName = system.mainStation.displayName;
	} else {
		stnName = station.displayName;
	}

	if (this._bbAdminName[stnName] == null || this._bbAdminName[stnName] === &quot;&quot;) this.$setupRepName(stnName);

	text += expandDescription(&quot;\n\n[name]\nBulletin Board Administration Authority&quot;, {
		name: this._bbAdminName[stnName]
	});

	var emailID = email.$createEmail({
		sender: &quot;Bulletin Board Admin&quot;,
		subject: subj,
		date: global.clock.seconds,
		message: text
	});

	if (emailID &amp;&amp; emailID &gt; 0) {
		itm.lastEmailID = emailID;
	}
}

//-------------------------------------------------------------------------------------------------------------
// sets up the admin authority user name for confirmation emails
this.$setupRepName = function $setupRepName(stationName) {
	this._bbAdminName[stationName] = randomName() + &quot; &quot; + randomName();
}

//-------------------------------------------------------------------------------------------------------------
// returns true if the passes System ID is in the player&#39;s currently plotted course, otherwise false
this.$systemInCurrentPlot = function $systemInCurrentPlot(sysID) {

	var result = false;
	var target = player.ship.targetSystem;

	if (oolite.compareVersion(&quot;1.81&quot;) &lt; 0) {
		// in 1.81 or greater, the target system could be more than 7 ly away. It becomes, essentially, the final destination.
		// there could be multiple interim stop points between the current system and the target system.
		// the only way to get this info is to recreate a route using the same logic as entered on the ANA, and pick item 1
		// from the list. That should be the next destination in the list.
		var myRoute = System.infoForSystem(galaxyNumber, global.system.ID).routeToSystem(System.infoForSystem(galaxyNumber, target), player.ship.routeMode);
		if (myRoute) {
			if (myRoute.route.indexOf(sysID) &gt;= 0) result = true;
		}
	} else {
		if (target === sysID) result = true;
	}

	return result;
}

//-------------------------------------------------------------------------------------------------------------
// returns true if the passes System ID is in the player&#39;s currently plotted course, otherwise false
this.$systemNearCurrentPlot = function $systemNearCurrentPlot(sysID) {
	var result = false;
	var target = player.ship.targetSystem;

	if (oolite.compareVersion(&quot;1.81&quot;) &lt; 0) {
		// in 1.81 or greater, the target system could be more than 7 ly away. It becomes, essentially, the final destination.
		// there could be multiple interim stop points between the current system and the target system.
		// the only way to get this info is to recreate a route using the same logic as entered on the ANA, and pick item 1
		// from the list. That should be the next destination in the list.
		var myRoute = System.infoForSystem(galaxyNumber, global.system.ID).routeToSystem(System.infoForSystem(galaxyNumber, target), player.ship.routeMode);
		if (myRoute) {
			for (var i = 0; i &lt; myRoute.route.length; i++) {
				var rtSys = myRoute.route[i];
				var sys = System.infoForSystem(galaxyNumber, rtSys).systemsInRange(this._nearPathRange);
				for (var j = 0; j &lt; sys.length; j++) {
					if (sys[j].systemID === sysID) {
						result = true;
						break;
					}
				}
				if (result === true) break;
			}
		}
	} else {
		var sys = System.infoForSystem(galaxyNumber, target).systemsInRange(this._nearPathRange);
		for (var i = 0; i &lt; sys.length; i++) {
			if (sys[i].systemID === sysID) {
				result = true;
				break;
			}
		}
	}

	return result;
}

//-------------------------------------------------------------------------------------------------------------
// returns true if there is a post-display message available for a particular status, otherwise false
this.$postDisplayAvailable = function $postDisplayAvailable(bbID, type) {
	var item = worldScripts.BulletinBoardSystem.$getItem(bbID);
	var list = item.postStatusMessages;
	var result = false;
	if (list &amp;&amp; list.length &gt; 0) {
		for (var i = 0; i &lt; list.length; i++) {
			if (list[i].status === type) result = true;
		}
	}
	return result;
}

//-------------------------------------------------------------------------------------------------------------
// returns the post display dictionary item for a particular status
this.$getPostDisplay = function $getPostDisplay(bbItem, type) {
	var list = bbItem.postStatusMessages;
	var result = {};
	if (list &amp;&amp; list.length &gt; 0) {
		for (var i = 0; i &lt; list.length; i++) {
			if (list[i].status === type) result = list[i];
		}
	}
	return result;
}

//-------------------------------------------------------------------------------------------------------------
// stores details of a particular post message dictionary
// this is so we can delete the BB item but still show the message to the player
this.$storePostMessageDetails = function $storePostMessageDetails(bbID, type) {
	var item = this.$getItem(bbID);
	var post = this.$getPostDisplay(item, type);
	this._holdItem = {};
	this._holdItem[&quot;text&quot;] = post.text;
	if (post.model) this._holdItem[&quot;model&quot;] = post.model;
	if (post.modelPersonality) this._holdItem[&quot;modelPersonality&quot;] = post.modelPersonality;
	if (post.spinModel) this._holdItem[&quot;spinModel&quot;] = post.spinModel;
	if (post.overlay) this._holdItem[&quot;overlay&quot;] = post.overlay;
	if (post.background) this._holdItem[&quot;background&quot;] = post.background;
	if (post.return) this._holdItem[&quot;return&quot;] = post.return;
}

//-------------------------------------------------------------------------------------------------------------
// make sure all records have an accepted date value (used for sorting)
this.$addAcceptedDate = function $addAcceptedDate() {
	for (var i = 0; i &lt; this._data.length; i++) {
		if (this._data[i].hasOwnProperty(&quot;acceptedDate&quot;) === false) {
			if (this._data[i].accepted === true) {
				this._data[i].acceptedDate = clock.adjustedSeconds;
			} else {
				this._data[i].acceptedDate = 0;
			}
		}
	}
}

//-------------------------------------------------------------------------------------------------------------
this.$systemNameForID = function $systemNameForID(dest) {
	if (dest === 256) return &quot;&quot;;
	return System.systemNameForID(dest);
}

//-------------------------------------------------------------------------------------------------------------
// adds additional data elements to records, in not present
this.$updateData = function $updateData() {
	for (var i = 0; i &lt; this._data.length; i++) {
		if (this._data[i].hasOwnProperty(&quot;sourceGalaxy&quot;) === false) this._data[i].sourceGalaxy = galaxyNumber;
		if (this._data[i].hasOwnProperty(&quot;destinationGalaxy&quot;) === false) this._data[i].destinationGalaxy = galaxyNumber;
		if (this._data[i].hasOwnProperty(&quot;sourceName&quot;) === false) this._data[i].sourceName = System.systemNameForID(this._data[i].source);
		if (this._data[i].hasOwnProperty(&quot;destinationName&quot;) === false) this._data[i].destinationName = this.$systemNameForID(this._data[i].destination);
	}
}

//-------------------------------------------------------------------------------------------------------------
// look for any orphaned system marks and remove them
this.$dataCleanup = function $dataCleanup() {
	var mk = mission.markedSystems;
	for (var i = mk.length - 1; i &gt;= 0; i--) {
		if (mk[i].name.indexOf(&quot;GalCopBB_Missions&quot;) &gt;= 0) {
			// get the mission ID
			var id = parseInt(mk[i].name.substring(mk[i].name.lastIndexOf(&quot;_&quot;) + 1));
			if (this.$getItem(id) === null) {
				mission.unmarkSystem({
					system: mk[i].system,
					name: mk[i].name
				});
			}
		}
	}
}

//-------------------------------------------------------------------------------------------------------------
this.$playAcceptContractSound = function $playAcceptContractSound() {
	var sound = new SoundSource;
	sound.sound = &quot;[contract-accepted]&quot;;
	sound.play();
}</pre></td>
                </tr>
            </table>
        </a>
    </body>
</html>
