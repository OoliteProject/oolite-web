<html>
    <head>
        <title>Expansion Telescope v2</title>
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <table border="0" width="100%">
            <tr>
                <td>Back to <a href='../index.html'>Index</a></td>
                <td align="right"><small>Page generated: Oct 11, 2023, 3:16:48 PM</small></td>
            </tr>
        </table>

        <h1>Expansion Telescope v2</h1>

        <h2>Content</h2>
        <ul>
          <li><a href="#warnings">Warnings</a></li>
          <li><a href="#manifest">Manifest</a></li>
          <li><a href="#documentation">Documentation</a></li>
          <li><a href="#equipment">4 Equipment</a></li>
          <li><a href="#ships">1 Ships</a></li>
          <li><a href="#models">0 Models</a></li>
          <li><a href="#scripts">9 Scripts</a></li>
        </ul>

          <a name="warnings">
            <h2>Warnings</h2>
            <ol>
                <li>http://wiki.alioth.net/index.php/Telescope%20v2 -&gt; 404 Not Found</li>
                <li>Low hanging fuit: Information URL exists...</li>
                <li>Conflict Expansions mismatch between OXP Manifest and Expansion Manager at character position 0060 (DIGIT ZERO vs LATIN SMALL LETTER N)</li>
                <li>Unknown key &#39;upload_date&#39; at https://wiki.alioth.net/img_auth.php/a/a2/Norby.cag.Telescope.oxz!manifest.plist</li>
            </ol>
          </a>

        <a name="manifest">
        <h2>Manifest</h2>
            <table border="1">
                <tr>
                    <th></th>
                    <th>from Expansion Manager's OXP list</th>
                    <th>from Expansion Manifest</th>
                </tr>
                <tr>
                    <td>Description</td>
                    <td>Extended targeting and scanning features, masslock borders and sniper ring.</td>
                    <td>Extended targeting and scanning features, masslock borders and sniper ring.</td>
                </tr>
                <tr>
                    <td>Identifier</td>
                    <td>oolite.oxp.Norby.cag.Telescope</td>
                    <td>oolite.oxp.Norby.cag.Telescope</td>
                </tr>
                <tr>
                    <td>Title</td>
                    <td>Telescope v2</td>
                    <td>Telescope v2</td>
                </tr>
                <tr>
                    <td>Category</td>
                    <td>Equipment</td>
                    <td>Equipment</td>
                </tr>
                <tr>
                    <td>Author</td>
                    <td>Norby, cag</td>
                    <td>Norby, cag</td>
                </tr>
                <tr>
                    <td>Version</td>
                    <td>2.1.2</td>
                    <td>2.1.2</td>
                </tr>
                <tr>
                    <td>Tags</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Required Oolite Version</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Maximum Oolite Version</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Required Expansions</td>
                    <td>
                            <li>oolite.oxp.cag.station_options:1.1.1</li>
                    </td>
                    <td>
                            <li>oolite.oxp.cag.station_options:1.1.1</li>
                    </td>
                </tr>
                <tr>
                    <td>Optional Expansions</td>
                    <td>
                            <li>oolite.oxp.Norby.cag.Telescope_Extender:2.1</li>
                            <li>oolite.oxp.Norby.CombatMFD:1.9</li>
                    </td>
                    <td>
                            <li>oolite.oxp.Norby.cag.Telescope_Extender:2.1</li>
                            <li>oolite.oxp.Norby.CombatMFD:1.9</li>
                    </td>
                </tr>
                <tr>
                    <td>Conflict Expansions</td>
                    <td>
                            <li>oolite.oxp.Norby.Telescope:0</li>
                            <li>oolite.oxp.Norby.Telescope_Extender:0</li>
                            <li>oolite.oxp.Norby.HUDSelector:0</li>
                    </td>
                    <td>
                            <li>oolite.oxp.Norby.Telescope:</li>
                            <li>oolite.oxp.Norby.Telescope_Extender:</li>
                            <li>oolite.oxp.Norby.HUDSelector:</li>
                    </td>
                </tr>
                <tr>
                    <td>Information URL</td>
                    <td><a target="_blank" href="http://wiki.alioth.net/index.php/Telescope">http://wiki.alioth.net/index.php/Telescope</a></td>
                    <td><a target="_blank" href="">n/a</a></td>
                </tr>
                <tr>
                    <td>Download URL</td>
                    <td><a target="_blank" href="https://wiki.alioth.net/img_auth.php/a/a2/Norby.cag.Telescope.oxz">https://wiki.alioth.net/img_auth.php/a/a2/Norby.cag.Telescope.oxz</a></td>
                    <td><a target="_blank" href="https://wiki.alioth.net/img_auth.php/a/a2/Norby.cag.Telescope.oxz">https://wiki.alioth.net/img_auth.php/a/a2/Norby.cag.Telescope.oxz</a></td>
                </tr>
                <tr>
                    <td>License</td>
                    <td>CC BY-NC-SA 4.0</td>
                    <td>CC BY-NC-SA 4.0</td>
                </tr>
                <tr>
                    <td>File Size</td>
                    <td>n/a</td>
                </tr>
                <tr>
                    <td>Upload date</td>
                    <td>1668116135</td>
                </tr>
            </table>
                </a>

        <a name="documentation">
        <h2>Documentation</h2>
        
        <h3>Telescope readme.txt</h3>
        <pre>Telescope forum topic: http://bb.aegidian.org/viewtopic.php?f=4&amp;t=14961

Quick start as a Hunter
=======================

* Copy the .oxp folder to the AddOns directory, hold down the Shift when starting the game the first time after copying.
* Buy Telescope with Extender equipment or load the included savegame (&quot;Telescope demo.oolite-save&quot;). Injectors, ECM System, Fuel Scoop, Military Laser and Scanner Targeting Enhancement are used also in this guide.
* After undock (F1) you can see the magnified target in top center position.
* If you bought Gravity Scanner then stop near the station, turn off your weapons with underscore (_) and wait for the scan results.
* Turn your ship where you see lollipops at the edge of your IFF scanner. The Panorama targeting will countinually change the box to the most centered target.
* Choose your enemy for the strength of your ship: start with a small ship flying alone.
* Use Injectors (i) to fly into scanner range where you can see a Red ball which means visible ship with bounty. Do not hunt Yellow traders and Purple police ships if you want to remain in clean status.
* Use Ctrl+arrow keys to put the target into the middle of the crosshairs to turn on the sniper ring which magnify the difference from the correct line-up.
* Turn on your weapons (_) and fire (a). You can try to hit with Military laser over normal scanner range but within 30km and a stopped target will turn when successful, but if your target is too small then fly inside 25.6km where the red target box indicate the correct line-up.
* Press ident (r) to lock the most centered target if there are more, press again to start auto steering or to lock another if it&#39;s more centered than the current target.
* Telescope can be primed (Shift+N) then activated (n) to lock the nearest target, mode (b) change the function of the activate key.
* If a missile is coming then a cyan ball warns you: start ECM (e), target it (t), try to avoid (i) or shoot it (a).
* If you win and the pilot ejected then shot down the derelict ship to get the bounty, then fly after the small White balls and scoop the Escape Pod, metal fragments and cargo pods.
* Fly back to the station and dock to get the reward for the pilot and sell the cargo (F8). Congratulations, you are richer. :)


Telescope Equipment
===================

This OXP realizes some requests for an extended scanner described in this topic:
http://bb.aegidian.org/viewtopic.php?f=6&amp;t=13274
Can determine the direction, distance, orientation and legal status of all visible ships.

The detection range is equal with the scanner range if you use it without the Telescope Extender (still or willfully), but you can use the following features:

Visual targeting
================

The virtual model of the target ship is displayed and a console message shows the name, range and direction.
The direction is marked by &lt;^ or v&gt; symbols to read faster than the Port Up or Down Starboard words.
The ranges and directions are calculated continually to help turn in line and see the decreasing range while traveling to the target.
The orientation of the model is equal with the target if you centered it and you can spin the model if turn around your ship.
You can set the size of the model with the $VisualTargetNormalSize &amp; $VisualTargetCombatSize variables when docked at the station or in the Scripts/telescope.js.

Lightballs
==========

Far targets get coloured lightball markers in the view and lollipops with darker colours near the edge of the scanner.

Red: Hostile ship with bounty (pirates and thargoids),
Pink: Tharglet until active and Drones with bounty in HardShips OXP,
Yellow: Neutral ship with clean status (traders and co),
Purple: Police,
Cyan: Missile or Mine,
Green: Buoy or Station,
Blue: Derelict (Wormhole also from Oolite v1.79),
White: Cargo, Escape Pod or Sun,
Gray: last known position of a lost target (moved out of telescope range),
Lightgray: Planet or Moon (a bit darker than Planet),
Orange: Gravity Scanner detected ship too far to be visible,
Brown: Gravity Scanner detected ship under 130t mass (less dangerous, especially with ShipVersion OXP).
Black: lollipops in red alert over 30km to help focus on near targets.

Beacons are identified in the whole system due to the transmitted radio signals.
If a ship transmits a beaconcode then it&#39;s detected anywhere but coloured as a ship and turns to orange if too far to be visible.

The current target is also marked with a gray &quot;shadow&quot; lollipop at the edge of the IFF scanner to help determine the direction, especially at close range, to avoid zooming the scanner. 
If the target is closer than 1000m, the lightball will be removed as the ship almost covers the ball and cargo pods are large enough large to detect with your eyes, but the shadow lollipop still remain.
You can set the minimum distance with the $LightBallMinDist variable when docked at the station or in the file Scripts/telescope.js.

Targets within the range of the Military Laser (30km) are marked with a larger ball and a normal (not darker) coloured lollipop.
You can use this feature to determine exactly where you can open fire on the target so it&#39;s large enough to stand a chance of being hit.

You can disable the lighballs of the ships by setting $LightBalls to false, but non-ships with Blue, Cyan, Gray, Green and White colours will remain to help find these. Auto targeting functions can still lock far targets; there seems to be an empty box but the ships are in there.

Sniper ring
===========

If you have almost lined up with your target who is between 10 and 30km then a ring will appear.
The movement of this ring magnifies the variance to the correct line-up, to help fine tune your aim.
You can hit if the target box of the Scanner Targeting Enhancement switches to red.

Snipers can use the distances between 25.6 and 30km to fire before the enemy can see the attacker on its scanner.
This was possible without Telescope, but the size of the ball gives another aid to knowing when the target runs out of range; and the ring can guide your aim without red box, which only works in the normal scanner range.

If you think this is a cheat then fire only when the target can also see you (red box) or set the $SniperRange variable to 25600 which will shorten the appearance of the ring and the largest ball (but there&#39;s no way to shorten the range of the Military Laser).

Auto steering
=============

With the Telescope primed (Shift+N) the activate button (&quot;n&quot;) can steer to the nearest lightball-marked target, which is useful in picking up cargo from the near field, rather than zooming the scanner to find them. Now you can just press activate instead of hitting zoom, locate, turn and unzoom.

Auto-steering starts only if your ship flys in a line (not turning) and stops instantly if you touch the controls. It will stop steering before a perfect line-up so as not to aim for you.

In Red Alert the activate button steers to the nearest attacker. You can disable this by turning off the weapons, in which case you can lock and steer to any near target regardless of the alert condition.

Auto scanning
=============

Telescope checks for new targets every second and performs an autoscan if it finds one: simple light sensors can see new dots in the whole sky without using energy but must zoom with the main scope to determine the ship type which needs 2 energy points.
The autoscan can be turned off if you set $AutoScan false in the telescope.js file but it&#39;s usually worth the cost to get new information sooner.

Far target locking
==================

You can lock far targets also which is not in the normal scanner (beacons and planets are always lockable). The distance is shown before the name of the ship with Scanner Targeting Enhancement, due to the fact that the second line shows the range of the virtual marker (which is always near the edge of the IFF Scanner).
We must use this workaround because the core game does not allow locking onto a target outside of normal scanner range. So the locked marker coinsides with the lock of the target (can only fix this in the core game).

If you cannot see a ship then it may have been destroyed, jumped out or flew farther than the visible range; or it has a Military Scanner Jammer and you do not have a Jammer Filter so you cannot get target lock.

When a target flys too far and is lost, the telescope renames it to &#39;Lost target&#39; until the next scan.

Masslock borders
================

In green alert you will see circles around detected targets where these ships can block your Torus Drive.
Without a Telescope Extender, these are shown around planets and stations only, but if you buy one, it allows for detection of ships that you can  see with your Mark-1 eyeball (escort ships at 2x, traders near 4x scanner range) and you will then get circles around all the ships before you.

Until you enter these circles you will stay in condition green, but cloaked ships can cause surprises.

The colour of a masslock border is the same as the lightball in the middle (see above).

To get the shortest route, you can safely go forward near the largest circle without touching it or going inside. Imagine this is the border of a sphere so if you fly direct to the center then you will be masslocked sooner than if you flew to a point of the circle. If you steer just a little outside the circle, you will fly forward as near as possible without masslock.

These are also a good indicator of the distance to the ships because the radius of the circles represent exactly one scanner range for the ship at its center.
Planets have rings that are double its radius as they can masslock you within this range.
The sun also has a large masslock field but this is not displayed by rings - it&#39;s less important and mainly a distraction.

You can also turn on masslock borders in non-green alerts if you turn off your weapons.
You can turn off all circles completely with the Telescope primed to the Lightballs menu (see below).

Keypress functions
==================

The ident button (&quot;r&quot;) gets a new feature from Telescope: it can lock the most centered target even if it&#39;s not shown on the screen.
The next press will start auto steering to the target if the most centered target is the same, otherwise it will lock onto the new target.  If the auto steer completes successfully, the lock is automatically released, otherwise a third ident press will unlock it.
In Red Alert it will not narrow the locking to the attackers; it can lock any target.

(Works only if there was a locked target beforehand, due to the triggering of the shipTargetLost event, so if there&#39;s no target it won&#39;t get called. Press &quot;r&quot; again or get something into the crosshair or use equipment buttons to lock a target.  Usually only an issue when leaving a station, exitting witchspace or Torus drive.)

If you turn off the weapons with the underscore button (&quot;_&quot;) then a scan happens and you enter into &quot;Navigation Mode&quot;, where autolock helps you see through targets, continually relocks to the most centered target.
This button is choosed to avoid unwanted fire if you have turrets.
In Red Alert you can lock any target and see far targets if you turn this mode on.

With the Telescope primed (Shift+N), the mode button (&quot;b&quot;) cycles through the functions of the activate (&quot;n&quot;) button:

 Nearest target
 Rescan
 Step forward in the target list
 Step back in the target list
 Steering: off / nearest target only / both nearest and step in the list
 Lightballs: off / navigation only / ships / masslock borders / large
 Sniper ring km: off / 5-25.6 / 10-25.6 / 15-25.6 / 5-30 / 10-30 / 15-30
 Targets: 20 and limitation in red alert / 50 / 100 / 200
 Visual target: off / weapons off / no ring / no station / no question mark / all
 Visual target size: 1-8

The first 4 functions are commands which happen instantly when activated.
The &quot;Step forward&quot; and &quot;Step back&quot; will rescan if you step over the end of the target list.
The Target list contains hostiles first, if any, then all ships in normal scanner (25.6km), followed by Cargo and Escape Pods, then ending with ships which are not in the normal scanner.

The last 6 functions are some of customizable properties in the telescope.js file, which you can during flight.
Your settings are stored into missionVariables and saved when you save your game after docking.

[When the core game provides more equipment buttons, a back button could step back to the previous function (maybe Ctrl+&quot;b&quot;).
With a second equipment button (maybe Ctrl+&quot;n&quot;) settings could be separated from the commands.]

 Cost: 500.0 Cr.
 Techlevel: 5


Telescope Extender
==================

You must install &quot;Telescope Extender and Gravity Scanner&quot; OXZ package and buy this equipment separatedly to confirm you want step over the rules of the standard game.
This will increase the detection range based on the size of the target so you can lock onto it when the core game sets it to isVisible and shows at least a dot in the sky.
For example you can see:
-Adder at 32 km,
-Viper and escort ships around 50 km (2x scanner range),
-Anaconda, Boa, Cobra MkIII and Python about 100 km (4x scanner range),
-Rock Hermit in almost 500 km (if not visible from the Main Station then fly around),
-Coriolis Station at 1000 km (right from the witchpoint).

(new) Once a cargo/escape pod comes within scanner range, its RFID frequency is isolated and stored along with its data, backscatter analysis and distortion characteristics of the local environs. Although originally designed for short-range, ship to ship transfer, this feature allows it to be tracked beyond scanner range.  Due to the vagarious and ever present background radio noise, this added range varies widely from 0 to 16 km.  Once beyond this extended range, the telescope purges all relevant data, as it is quite large and quickly becomes obsolete if not constantly updated.

 Cost: 500.0 Cr.
 Techlevel: 5


Gravity Scanner Equipment
=========================

You must install the separated &quot;Telescope Extender and Gravity Scanner&quot; OXZ package to use this and the following uber-ranged equipments.

If the mass of your ship more than 130t (Cobra MkIII and above) and there is a station within 5km, you can then extend the detection range of Telescope using a mass detector, which scales by third power of distance:
the mass of the target in kg must be larger than d2*d2*d2/100 where d2 = distance*2 in km.  
(new) And, as gravity waves are not affected by mass, the scanner can detect ships behind planets and moons.

Detection of the player ships and the Hard versions in HardShips OXP:
                 t    km   Hard t  km
Adder           11    52    23     66
Moray           40    79    81     100
Cobra Mk I      47    84    94     106
Fer-de-Lance    51    86    102    108
Asp             59    90    118    114
Cobra Mk III    186   132   371    167
Boa             192   134   385    169
Python          222   141   445    177
Anaconda        430   175   1289   253

Beacons are detected in the whole system and Rock Hermits usually as well (from 900km).

A station needs to be near as the largest parts of the gravity scanner system is fitted into the stations, which broadcast some important data and it needs a large mass (at least 10.000t, the station itself) nearby as a reference to refine the results.
Mobile bases can scan anywhere.

It takes 4 minutes from undock or hyperjump to reach the maximal detection range when your ship is on the move.
The detection progresses 4 times faster when your ship is stopped, needing only 60 seconds to finish.

The mass is scaled with the elapsed time: an Anaconda is detected at half time as its half mass (215t) would, which means 140km, and needs more time to detect it from the maximal 175km.

The Gravity scanner works only when you turn off your weapons with underscore (&quot;_&quot;) button, otherwise only visible targets are displayed.
You can define a more comfortable key in the Oolite/oolite.app/Resources/Config/keyconfig.plist file.

The auto-relock feature will contiunually change your target to the most centered one, so the box will jump during your turn; your ship helps browse the many targets. The ident (&quot;r&quot;) button can lock the same target only in this mode, it cannot step to the second centered target.

Gravity scan consume 8 energy points (visual scan uses only 2).
You can hear the sound of the Gravity Scanner at work, which is to remind you of the energy usage.

Orange and Brown lollipops and lightballs mark the detected targets out of the visible range.
Brown if the ship is under 130t mass which means small ships, usually escorts - avoid Orange ones and target single Browns while your ship is not very strong.
The mass usually cannot tell if a ship is pirate or not, coloured identification need visual contact.

If you see a lighter ball then there are two or more ship in the same place.
The smallest orange and brown ball means the target is farther than 150km, these get dark orange and dark brown lollipops.

The Gravity Scanner cannot determine the orientation. If the target is not visible then the view position of the virtual model will be a fixed view from the top.

There are no passive gravity sensors so AutoScan will happen only if a new target arrives into the visible range.
When you undock or arrive at a new system, the telescope scan is performed automatically but if you want to scan the final frontier then you must turn off your weapons.

Beware: aliens can sometimes detect the signal of a Gravity Scan, so if your ship is not strong then do not use it often and pay for the full repair if it&#39;s damaged.

 Cost: 10000.0 Cr.
 Techlevel: 5


Secondary Gravity Scanner Equipment
===================================

Cuts in half the time to get the full detection range and works as a single scanner if the primary one is damaged.
Can only fit into ships over 400t mass (Anaconda and heavy OXP ships).

 Cost: 20000.0 Cr.
 Techlevel: 5


Small Dish Equipment
====================

Detect ships from one third farther out (for example an Asp at 120km) but can only fit onto ships over 130t mass (from Cobra MkIII) due to the size.

Needs Gravity Scanner, it is a just piece of metal.

Fast CPUs can draw 200 targets without relevant FPS drop, slow systems draw it also but with some drop (tested on Intel Atom netbook). In this case scan for Gravity targets only when needed and turn it off when Telescope range is reached.

This is not a primable equipment (there are no buttons on the pure alloy) and a passive extension so will not increase the energy usage of the scan.

(new) dish will allow detecton of abandoned Rock Hermits.

 Cost: 5000.0 Cr.
 Techlevel: 5


Large Dish Equipment
====================

Detect ships from double the range (an Asp at 180km) but can only fit onto ships over 400t mass (Anaconda and over) due to the size.

Small Dish will not increase this range further so you can refund it when you buy a Large Dish.

Ships over 1000t (Hard Anaconda and big OXP ships) can use the hull mass to refine the gravity signals to reach 4 times range than without Large Dish.

Will only show the nearest 200 targets to save CPU and avoid serious FPS drops in systems with many ships.

(new) dish will allow detecton of abandoned Rock Hermits.

 Cost: 10000.0 Cr.
 Techlevel: 5



Cheap Repairs
=============

You can buy small fixes for 1/10 the cost of the new equipment instead of the normal 1/2 price but the following drawbacks will be applied:

Telescope: get back the lightballs &amp; masslock rings but will not fix the virtual model display, auto steering and sniper ring, and
           lose ability to adjust those settings when docked at station.
Gravity Scanner: the cheap spare parts can interfere with the hyperdrive and often cause misjumps.
Small and Large Dish: usees less durable alloys and can break during hyperjump.

After a cheap fix you can buy the full repair which costs the difference between cheap and normal repair: 2/5 of the full price.
You can only refund fully repaired equipment.


Dependencies:
=============

Oolite v1.77 or later. No shaders needed.

Instructions:
=============

Copy the &quot;.oxz&quot; file into ManagedAddOns folder if not obtained via the in-game manager.
Or, unzip the file, and then move the folder name ending in &quot;.oxp&quot; into the AddOns directory of your Oolite installation.
Savegame included: put the &quot;Telescope demo.oolite-save&quot; file into the oolite-saves directory to load it.


Settings in Scripts/telescope.js: (deprecated)
=================================

All user variables are now available when docked:  F4 - Telescope Options

The station options take precedence over the following (as it&#39;s driven by the missiontext!).  
Of special note is that most options default to &#39;off&#39;, so as not to overwhelm initiates.  Values in previously saved games will be respected.

Available via primable equipment:
---------------------------------
$LightBalls = false; //turn on or off all lightballs, but marks on the scanner will remain

$ShipLightBalls = false; //turn on or off the lightballs with scanner markers of the ships, but cargo, etc. remain
Non-ships with Blue, Cyan, Gray, Green and White colours will remain to help find these. Auto targeting functions still can lock far targets, the targeted ship are in an empty box.

$LargeLightBalls = false; //lightballs are increasing depending on the distance or remains small

$MassLockBorders = false; //coloured circles around ships and planets in green alert

$BrightMassLockBorders = false; //brighter coloured circles around ships and planets in green alert

$SniperMinRange = 10000; //meters, show sniper ring if the target is over this distance

$SniperRange = 25600; //meters, if the target is inside then show sniper ring and large lightball, max 30000 (military laser range)
Set it to to 25600 if you want to shorten the appearance of the sniper ring in the name of the fair play.

$Steering = 0; //auto steering if lock nearest or step in the target list with activate, 0: off, 1: nearest only, 2: each in step
A setting of 1 or 2 will enable the auto steer function of the ident key.

$MaxTargets = 100; //limitable to reduce FPS drop in systems with many ships, min. 20, max. 200

$Ring = true; //show a ring around the visual target

$ShowVisualStation = true; //show or not show the 3D model of the targeted station

$ShowVisualQuestionMark = false; //if a ship has no virtual model in effecdata.plist show a big &quot;?&quot; model

$ShowVisualTarget = 1; //0 to turn the model off, 1 to show only when weapons are off-line, 2 to always show the model.  

$VisualTargetCombatSize = 4; //size of the visual target with online weapons (between 0 and 10, default: 4)
If size is 0 then the visual target is not shown at all with weapons online.

$VisualTargetNormalSize = 6; //zoomed size of the visual target with offline weapons (between 0 and 8, default: 6)
If size is 0 then the visual target is not shown at all with weapons offline.

Available at station only:
--------------------------
$AutoScan = true; //check continually for new isVisible isPiloted target and scan if found
Scanning use a very little energy if a new target arrived but you strongly need this to avoid often scan manually.

$AutoScanMaxRange = 1000000; //meters, how far targets will be reported

$FarStatus = false; //red ball reveal pirates over normal scanner if true
If false then bounty detected within 25.6km only which is more real and exciting but Thargoids get red ball at any range and a red ship will not change back to yellow if fly over the normal scanner range.

$AutoLock = 1; //if no target and something in crosshairs with max. this degree diff., 1=lightball size, 0=off
AutoLock is set to 1 degree (size of a lightball) and lock only if no current target to make it similar with the original ident function plus can lock far targets also. Disabled if set to 0 but in this case you can lock targets in 25.6km only.

$GravLock = 20; //gravity scanner relock in this degree cone (0-180, 20=about the screen)
Panorama targeting offer auto-relock to the most centered target during manual turning and can be switched on or off in-game first with the weapons and second with the ident button when you see gravity targets. Disabled if set it to 0 but it is not recommended due to in this case you can not lock far targets, so set it to 1 degree at least, or simply use the ident button in-game to reduce it to the level of the AutoLock and leave the possibility to turn it on again.

$IdentLock = 180; //if ident pressed or target lost then lock in this degree (0-180, 180=the whole sphere)
Can lock the most centered target even if behind you if set it to 180 and the second press will unlock it so you can clear the virtual model when not needed. If set it to 1 then the locking radius reduced to the size of a lightball so can do unlock only. Note the AutoLock will relock in 0.25 second if the target centered exactly, in this case turn a bit before unlock.
Red alert is an exception where the IdentLock target hostiles only (who target you) to help find attackers. Can be override with AutoLock and GravLock, so if you unlock the current target and point exactly to another then the AutoLock will target it regardless of the hostile&#39;s status, or if you point it and turn weapons quickly off and on again then lock it regardless from you has lock on another target (but not too quickly, the timed function need max. 0.25 second to lock).

$IdentDelay = 4; //(new) quarter seconds; targeting is suspended following the unlock mentioned above.  I.e. it prevents immediately locking the target just unlocked. This comes down to a pilot&#39;s style, whether or not you move the aim point before/after unlocking.

$LightBallMinDist = 1000; //meters, if target is inside then remove the lightball marker

$LightBallShipMinDist = 5000; //meters, if target is ship and inside then remove the lightball marker

$MassLockFwdOnly = false; //(new) limits masslock borders to the forward view

$RedAlertDist = 30000; //show lollipops in red alert within this distance only

$SniperRingSize = 2; //size of the sniper ring (between 1 and 5, default: 2)

$ModelRingColor = [0.33, 0.33, 0.33]; //(new) colour of ring around 3D model, default is a light gray.  [0,0,0] sets it to match the reticle&#39;s color, [1,1,1] the reticle&#39;s locking color.

$Thargoids = false; //you will get aliens right after undock to test Telescope

$VTarget_HUD_shift = [0, 0, 0]; //position shift for your HUD&#39;s built-in visual target screen if any


Script_info support:
====================

OXP makers can alter the detection of any objects in shipdata.plist to avoid revealing mission secrets.

Stations with non-standard roles and ships with the word &quot;stealth&quot; within their dataKey or role are detected in normal scanner range only. Must specify &quot;telescope&quot; script_info key to detect it farther to stay compatible with the existing OXPs, for example Rescue Stations.oxp, Stealth.oxp and Vector.oxp.

Standard Station roles: &quot;station&quot;, &quot;coriolis&quot;, &quot;dodo&quot;, &quot;dodec&quot;, &quot;dodecahedron&quot;, &quot;ico&quot;, &quot;icosa&quot;, &quot;icosahedron&quot; and &quot;rockhermit&quot;.

Hiding ships need &quot;stealth&quot; role or set telescope = 0; in script_info.

 script_info = {
 	telescope = 0;
 };

* 0: detected within normal scanner only as without telescope.
* 1: detected in visible range only (due to gravity scanner can see a ship with 1kg mass from 2km only).
* Positive integer: give new mass to the ship in kg which can increase the gravity detection.
* Negative integer: will be substracted from the ship.mass in kg to reduce gravity detection.

If this key is not placed at all then get the normal detection.
Objects with disabled detection (0) are not detected when arrive into visible range (need scanner range), but once detected then tracked over scanner range while in visible range until next scan (small help and save performance).


Problems:
=========

If you do not see the model of a ship (or see a question mark if enabled) then you probably installed a custom ship OXP.
The core game currently does not support making visual effects from ships directly, but there is a workaround: copy the Config/shipdata.plist files in your OXPs to effectdata.plist or insert into the full contents if exists to avoid overwrite.

If the model still not appear and the definition of the ship using like_ship then copy the model = &quot;filename.dat&quot;; from the original ship into the section of this ship. Original cobras arrived after I do this only.

If a custom ship use shaders with uniforms then you may see errors in the log but the visual target usually appear with less detail (need several core improvements to fix properly). To avoid the errors you can try commenting out the referred lines with // from the effectdata.plist or replace the inputs with fix numbers based on the wiki. For example the Griff Boa ( http://wiki.alioth.net/index.php/Griff_Boa ) is included in the effectdata.plist file of the Telescope OXP.

If you ride a custom ship and the visual target is misaligned (not in the top center position) then copy the view_position values from your shipdata.plist into the $ShipLibViewPosition array in Scripts/shiplib.js .
From Oolite v1.79 the player.ship.viewPositionForward property solve this.

Alternatively, the oxp ships with a Python script to generate a custom effectdata.plist for the telescope by reading all the shipdata.plist files of installed oxp/oxz files.

---

Opened wormholes are not auto targetable. You can put a box around with the standard ident but the script receive an empty target only. Can not get a pointer from the list of allShips nor allVisualEffects in v1.77, but from v1.79 the isWormhole flag will solve this.
The core games requires a manual ident of a wormhole, so it won&#39;t be recognized by Telescope until you do that.

---

If a ship flys over a station then the lightball hides behind the station. To solve this need resizeable flashers which will be available from Oolite v1.79 only.

---

Right after undock or hyperjump the first ident press can not target the most centered ship, only the second press. The first does not call any event, so you must press &quot;r&quot; again.
This is only an issue if your AutoLock and GravLock settings preclude an auto lock. For example, launching from a main station with default values will lock on the beaon immediately.  But exiting witchspace with no ships in front of you leaves you with no target, so a 2nd key press is needed (we&#39;ve hijacked the shipTargetLost event and you have to have one before you can lose it!).

---

Distant targets writes double message when locked, sometimes the first shows the name of the previous target. This seems to be a problem in the core game (tried to log it but only one log line created). Simply ignore the first message.


License:
========

This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike License version 4.0.
If you are re-using any piece of this OXP, please let me know by sending an e-mail to norbylite@gmail.com.
ScanSound source: http://soundbible.com/878-Martian-Scanner.html

Changelog:
==========
 2018.04.01. v2.0  BETA: rewritten to optimize for speed and reduce garbage generated, using many of the ideas from
                   http://aegidian.org/bb/viewtopic.php?f=4&amp;t=18837&amp;sid=3f1a12295fd26646177719d96d41b0e9 (OXP Performance tips)
 2017.06.24. v1.15 Optimized for speed by enclosing frame callbacks in closures.
 2015.05.25. v1.13 Asteroids are lockable with ident press not in the crosshairs also.
                   Selectable bright masslock borders.
 2014.10.28. v1.12 Masslock borders with very bright textures for fluxxx.
 2014.10.28. v1.11 Masslock border brightness is adjusted.
                   Default lightball size is smaller, except for large ships over 400t mass.
                   Very far targets over 1000km show a dot only.
                   Show hostile/offender/derelict flag in CombatMFD.
 2014.10.12. v1.10 A fix to prevent sudden target changes reported by Bogatyr.
 2014.10.11. v1.9  Show the list of the nearest 10 targets in a MFD.
                   The newest detected target is displayed in the CombatMFD if installed.
                   A small fix if Visual target:off and size is changed, thanks to Anthony.
 2014.07.06. v1.8  Fixed the restore of lightball settings after load game, thanks to Anthony.
                   Dark far lollipops in yellow alert except if weapons are offline.
                   Virtual target model is within a ring by default with offline weapons also.
                   Range extenders are separated into Telescope Extender and Gravity Scanner OXZ.
 2014.01.28. v1.7  Targets marked with dots from far distances for FarPlanets OXP.
                   Lock the nearest from overlapping targets within 0.5 degree.
                   $TelescopeRedAlertDist change lollipops over 30km to black in red alert.
                   Reduced chanche of timeLimit.
 2014.01.16. v1.6  Fixed reorientation during Asteroid hunting, thanks to Duggan.
                   Improvements for FarPlanets OXP.
                   Sun is added into the target list and got orange lollipop.
                   Planet lollipop color is changed to lightgray, masslockborder also.
                   Targets over $TelescopeSniperRange (30km) get tiny lightballs.
 2014.01.04. v1.5  Planets are targetable within scanner range also.
 2014.01.02. v1.4  Polished masslock borders and planet targets.
 2013.12.29. v1.3  Masslock borders: coloured circles around ships and planets.
                   Planets are included into the target list.
                   In Oolite 1.79 show visual target models of new ship graphics.
                   Thinner ring around visual target, smaller sniper ring.
 2013.11.02. v1.2  Gravity Scanner can fit from 130t mass again but restricted to use near stations.
                   Small Dish introduced, Large Dish need at least an Anaconda.
                   Ship lightballs minimal distance raised to 10km, cargo lightballs stay at 1km.
                   Lightball size of ships under 30t mass reduced to tiny.
                   Fixed infinite lost messages caused by piloted rocks in Lave.oxp.
 2013.10.22. v1.1  Double ident press will start auto steering to the target.
                   Need Telescope Extender to see over scanner range.
                   Gravity Scanner need ship with at least 400t mass.
                   Custom stations are lockable from 4x scanner range.
 2013.08.06. v1.0  Telescope configurable during fly: press mode key to cycle, activate to choose.
                   Settings stored into missionVariables and restored with load game.
                   Gravity Scanner is not primable anymore due to functions merged into Telescope.
 2013.08.03. v0.92 FCB speed almost doubled by Svengali, many thanks to him!
                   Maximal handled Telescope targets increased to 200.
                   False $TelescopeFarStatus to do not reveal pirates over normal scanner range.
                   Gravity scan need some time to calculate.
                   Added Secondary Gravity Scanner Equipment for faster scan in large ships.
                   $TelescopeLargeLightBalls set to false by default for small balls.
                   $TelescopeLightBalls can turn off lightballs but leave lollipops on the scanner.
                   $TelescopeShipLightBalls turn off ship lightballs only and show non-ships only.
 2013.07.23. v0.91 Cheap repairs get nice drawbacks.
                   Gravity scan sometimes detected by aliens.
                   FCB speed improvements to prevent Timelimit in trunk.
                   Fixed rescan bug if target has Military Jammer awarded by ShipVersion OXP.
                   Changed $TelescopeShowVisualTarget to always show the model in weapons off mode.
 2013.07.20. v0.90 Activate steer to the nearest target or to the nearest attacker in Red Alert.
                   Mode lock and steer to the most centered target or attacker in Red Alert.
                   Large lightballs added, show within $TelescopeSniperMinRange (10km).
                   Added telescope script_info key and hide custom Stations, thanks to Svengali.
                   Added $TelescopeThargoids if you want a test in instant action.
                   Fixed $TelescopeRedAlertLimiter, thanks to Solonar.
 2013.07.17. v0.86 Gravity Scanner cost increased, repair discounted.
                   Tharglet get small pink lightball until active.
 2013.07.16. v0.85 Debug version to Duggan and Solonar with many Tharglets and without crash.
 2013.07.15. v0.84 Internal updates to avoid timeLimit.
 2013.07.15. v0.83 Gravity Scanner range reduced and made another performance improvements.
 2013.07.14. v0.82 Added $TelescopeGravLock and $TelescopeIdentLock sensitivity in degree.
                   Added $TelescopeShowVisualStation and $TelescopeShowVisualQuestionMark.
                   Added is_external_dependency = yes; to griff boa, thanks to Svengali.
                   Bugfixes and preformance improvements.
                   Can lock asteroids in crosshairs with ident press.
 2013.07.11. v0.81 Added $TelescopeAutoLock, if 0 then must manually lock targets as before.
 2013.06.17. v0.8  Lightballs and shadow lollipop added.
 2013.06.10. v0.7  Visual targeting and Auto steering added.
 2013.05.05. v0.6  Minor fixes.
 2013.04.08. v0.5  First working version.
 2013.03.31. v0.1  First test files.
</pre>
        <h3>effect data/effectdata readme.txt</h3>
        <pre>In order for telescope&#39;s 3D close-up to work, the oxp requires effects data
on the ship targetted.  Unfortunately, oolite cannot create effects
from &#39;shipdata.plist&#39; files, so any ships that are absent from telescope&#39;s
&#39;effectdata.plist&#39; file will not show up.

You have some options if you should encounter this:
   
 * run the included Python script to create a custom &#39;effectdata.plist&#39; 
   file from all of your installed oxp&#39;s,
   
 * just live with it by adjusting its options,

 * manually edit telescope&#39;s &#39;effectdata.plist&#39; file and add the contents 
   of the problem ship&#39;s &#39;shipdata.plist&#39; file
   
[telescope&#39;s &#39;effect data&#39; folder also contains &#39;effectdata.required.plist&#39;,
data essential to telescope, for those of you who&#39;d like to roll your own.
Do not edit it - the Python script relies on it! Use a copy.]

Note: if any ships listed in &#39;effectdata.plist&#39; are not loaded 
      (ie. you&#39;re running with a subset of those ships), you will get 
	  numerous errors in the log file.  These may be ignored as there is
	  no problem loading effect data for absent ships.  The converse,
	  lacking effect data for loaded ships, will result in a big &#39;?&#39; 
	  displayed instead of the 3-D model (if you have the 
	  ShowVisualQuestionMark option turned on).

	  If these log errors are a problem for you, they can be suppressed
	  by copying the file
	    logcontrol.plist
	  from &#39;oolite.app/Resources/Config&#39; to your &#39;AddOns&#39; folder.  
	  Edit your copy and search for &#39;shipData.load.error&#39; and change its 
	  value to &#39;no&#39;.
	  This will stop ALL shipdata load errors.
	  (if you&#39;re writing an oxp that deals with shipdata, leave it alone
	   to catch any of your errors)


Python Script
=============
   
In telescope&#39;s &#39;effect data&#39; folder is the script &#39;collect_shipdata.py&#39;,
a Python (2 or 3) script.  It can be run from anywhere unless you have 
multiple Oolite installations.  In that case, run it from any folder within
the Oolite installation you&#39;re updating.  It will generate a custom
&#39;effectdata.plist&#39; file for all the oxp&#39;s that Oolite will load and update 
your telescope, be it oxp or oxz.
    
Windows users: there is an executalbe (.exe) version of this script.
 Due to its size (4.15 MB), it is a separate download found at:
 https://www.dropbox.com/s/i2diyvg240hr5jy/collect_shipdata.exe?dl=0

Be sure to hold down the Shift key the next time you start oolite, so the 
new effects are loaded.


Live With It
============

This situation is not expected to be resolved soon if ever.  It would entail 
major recoding of the core game to be able to create effects from shipdata.

The 3D close-up is but one feature of the telescope oxp and should you 
encounter ships that don&#39;t resolve, you can:

 * turn on &#39;ShowVisualQuestionMark&#39;, which will display a big &#39;?&#39; where
   a ship would normally appear, so you&#39;re not nose to screen trying to 
   see a ship that&#39;s not there
   
 * turn off &#39;ShowVisualStation&#39; if those are the problem
 
 * turn off the close-up&#39;s border with the &#39;Ring&#39; option, so you&#39;re not 
   staring at an empty ring
   
 * turn off this feature altogether with the &#39;ShowVisualTarget&#39; option
 

Manual Editing
==============

This is not the preferred option obviously, but if you must, start with a 
copy of the current &#39;effectdata.plist&#39; file, if it&#39;s only a few problem ships. 

 * add in the contents of the &#39;shipdata.plist&#39; file(s)
 
  * rename all &#39;like_ship&#39; keys to &#39;like_effect&#39;
  
  * delete any &#39;shaders&#39; keys (they are not used)
  
As for &#39;flashers&#39;, that&#39;s your call. The script output has them removed.

For those of you who&#39;d like to roll your own, data essential to telescope can 
be found in telescope&#39;s &#39;effect data&#39; folder, in the &#39;effectdata.required.plist&#39;
file.  Using a COPY, add the shipdata from you ships, make the above changes, 
save it as a replacement of telescope&#39;s &#39;effectdata.plist&#39; in its Config folder 
and you&#39;re good to go.

Be sure to hold down the Shift key the next time you start oolite, so the new effects are loaded.

</pre>
        </a>

        <a name="equipment">          
        <h2>Equipment</h2>
            <table>
                <tr>
                    <th>Name</th>
                    <th>Visible</th>
                    <th>Cost [deci-credits]</th>
                    <th>Tech-Level</th>
                </tr>
                <tr>
                    <td><a href="../equipment/EQ_TELESCOPE.html">Telescope</a></td>
                    <td>yes</td>
                    <td align="right">5000</td>
                    <td align="center">5+</td>
                </tr>
                <tr>
                    <td><a href="../equipment/EQ_TELESCOPE_FULLREPAIR.html">Finish Repair: Telescope</a></td>
                    <td>yes</td>
                    <td align="right">2000</td>
                    <td align="center">5+</td>
                </tr>
                <tr>
                    <td><a href="../equipment/EQ_TELESCOPE_REFUND.html">Refund Telescope</a></td>
                    <td>yes</td>
                    <td align="right">0</td>
                    <td align="center">5+</td>
                </tr>
                <tr>
                    <td><a href="../equipment/EQ_TELESCOPE_REPAIR.html">Repair: Telescope (targeting only)</a></td>
                    <td>yes</td>
                    <td align="right">500</td>
                    <td align="center">5+</td>
                </tr>
            </table>
        </a>

        <a name="ships">    
        <h2>Ships</h2>
            <table>
                <tr>
                    <th>Name</th>
                </tr>
                <tr>
                    <td><a href="../ships/telescopemarker.html">Telescope marker</a></td>
                </tr>
            </table>
        </a>

        <a name="models">    
        <h2>Models</h2>
            This expansion declares no models. This may be related to warnings.
        </a>

        <a name="scripts">    
        <h2>Scripts</h2>
            <table>
                <tr>
                    <th>Path</th>
                </tr>
                <tr>
                    <td valign="top">Scripts/largeonly.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name        = &quot;largeonly&quot;;
this.author      = &quot;Norby&quot;;
this.copyright   = &quot;2013 Norbert Nagy&quot;;
this.licence     = &quot;CC BY-NC-SA 3.0&quot;;
this.description = &quot;This equipment is usable only for ships over 130t like the Cobra III or Rocket Miner.&quot;;
this.version     = &quot;1.0&quot;;

this.allowAwardEquipment = function(eqKey, ship, context)
{
//	player.consoleMessage( eqKey+&quot; &quot;+ship+&quot; &quot;+context );//debug
	if( ship.mass &gt;= 130000 ) return true;
	else return false;
}
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/notforsmall.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name        = &quot;notforsmall&quot;;
this.author      = &quot;Norby&quot;;
this.copyright   = &quot;2013 Norbert Nagy&quot;;
this.licence     = &quot;CC BY-NC-SA 3.0&quot;;
this.description = &quot;This equipment can not fit into small ships like the Adder or Rocket Fighter.&quot;;
this.version     = &quot;1.0&quot;;

this.allowAwardEquipment = function(eqKey, ship, context)
{
//bugfix for eqs with conditions scripts: need double replaceShip() to work!
//player.replaceShip(shipname, pers); player.replaceShip(shipname, pers);
//call twice! the first always got false for allow without run this script.
//Proof: if you uncomment the following line, only the 2nd call will write into the log.
//log(&quot;notforsmall&quot;, eqKey+&quot; &quot;+ship.name+&quot; &quot;+ship.mass+&quot; &quot;+context );

	if( ship.mass &gt;= 30000 ) return true;
	else return false;
}
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/telescope.js</td>
                    <td><pre>this.name		 = &quot;telescope&quot;;
this.author		 = &quot;Norby, cag&quot;;
this.copyright	 = &quot;2018 Norbert Nagy, cag&quot;;
this.license	 = &quot;CC BY-NC-SA 4.0&quot;;
this.description = &quot;Telescope mark all visible ships, show vitrual model, sniper ring and more.&quot;;
this.version	 = &quot;2.0&quot;;

/* jshint elision: true, shadow: true, esnext: true, curly: false, maxerr: 1000, asi: true,
		  laxbreak: true, undef: true, unused: true, evil: true,  forin: true, eqnull: true,
		  noarg: true, eqeqeq: true, boss: true, loopfunc: true, strict: true, nonew: true, noempty: false
*/

/*jslint indent: 4, white: true, debug: true, continue: true, sub: true, css: false, todo: true,
		 on: false, fragment: false, vars: true, nomen: true, plusplus: true, bitwise: true,
		 regexp: true, newcap: true, unparam: true, sloppy: true, eqeq: true, stupid: true
*/

/* global addFrameCallback, clock, EquipmentInfo, isValidFrameCallback, log,
		  missionVariables, oolite, player, Quaternion, removeFrameCallback, SoundSource,
		  system,  Timer, worldScripts, Vector3D, Script
*/

		(function(){
/* validthis: true */

&quot;use strict&quot;;

/*
 * customizable subset of property values also available in-game as primable equipment
 */

// NB: editting these values here WILL NOT take effect! Provided as illistration only.
//	   Use the in-station option facility (F4).	 If you insist on editing this
//	   file, make sure your changes are made in:
//			this._load_missionVariables()
//	   Default values get assigned there in the absence of missionVariables

// &#39;config&#39; page
this.$AutoScan = true;					//check continually for new isVisible isPiloted target and scan if found
this.$AutoScanMaxRange = 1e6;			//meters, how far targets will be reported
this.$AutoLock = 1;						//degrees, if no target and something in crosshairs within this diff. from center, 1=lightball size, 0=off
this.$GravLock = 20;					//degrees, navigation scanner relock in this center cone ( 0-180, 20=about the screen height)
this.$IdentLock = 180;					//degrees, if ident pressed or target lost then lock in this center cone ( 0-180, 90=anything fwd,180=the whole sphere )
this.$IdentDelay = 4;					//(new) quarter seconds, time targeting is suspended following Ident unlock, default: 4 (1 sec)
										// otherwise it *could* immediately re-acquire same target!
										// - this comes down to a pilot&#39;s style, whether or not you move the aim point before/after unlocking
this.$FarStatus = false;				//red ball reveal pirates over normal scanner if true
this.$MaxTargets = 200;					//limitable to reduce FPS drop in systems with many ships, min. 4, max. 200
this.$RedAlertDist = 30000;				//meters, show lollipops in red alert within this distance only
this.$Steering = 0;						//auto steering if lock nearest or each step in the target list with activate, 2: each, 1: nearest only, 0 off;

this.$LightBalls = true;				//turn on or off all lightballs, but markes on the scanner will be remain
this.$ShipLightBalls = true;			//turn on or off the lightballs with scanner markers of the ships, but cargo, etc. remain
this.$LargeLightBalls = false;			//lightballs are increasing depending on the distance or remains small
this.$LightBallMinDist = 1000;			//meters, if target is inside then remove the lightball marker
this.$LightBallShipMinDist = 5000;		//meters, if target is ship and inside this range then remove the lightball marker

this.$DEFAULT_ML_RINGS = 23;			// as per 1.15, in green Alert or weapons off-line
this.$MassLockRings = 23;				//coloured circles around ships and planets in green alert or weapons off-line
										// - (new) now are bit flags for when to show
this.$MassLockViewDirn = 1;				//(new) bit flags for in which view masslock rings are shown
this.$BrightMassLockRings = false;		//brighter circles around ships and planets

this.$SniperRingSize = 2;				//size of the sniper ring ( between 1 and 5, default: 2 )
this.$SniperRingActive = 42;			//states when sniper ring is active (6: 3 alerts * 2 weapons states)
this.$SniperRange = 25600;				//meters, if the target is inside then show sniper ring
this.$SniperMinRange = 10000;			//meters, show sniper ring if the target is over this distance
this.$SniperRingColor = [0.3, 0.3, 0.3];//(new) colour of the sniper ring, default is lightGrayColor

this.$ShowVisualTarget = 0;				//show 3D model of target, 2: on, 1: only when weaps off-line, 0 off;
this.$VisualTargetNormalSize = 6;		//zoomed size of the visual target with off-line weapons ( between 0 and 8, default: 6 )
this.$VisualTargetCombatSize = 4;		//size of the visual target with online weapons ( between 0 and 8, default: 4 )
this.$VisualTargetRing = true;			//show a ring around the visual target
this.$ShowVisualStation = true;			//show or not show the 3D model of the targeted station
this.$ShowVisualQuestionMark = false;	//if a ship has no visual model in effecdata.plist show a big &quot;?&quot; model
this.$ModelRingColor = [0.3, 0.3, 0.3]; //(new) colour of ring around 3D model, default is lightGrayColor
this.$VTarget_HUD_shift = [0, 0, 0];	//position shift for your HUD&#39;s built-in visual target screen if any

// &#39;UI_and_docs&#39; page
this.$ConsoleMsgDurn = 5;				// duration in sec for console messages
this.$GravScanMsgFreq = 3;				// bit flags for frequency of gravity scanner update msgs
this.$IdentMessages = true;				// flag for displaying/suppressing Ident key messages
this.$ShowSummary = true;				// display a summary of changes when exiting station options
										// - first conditionally displayed option

// &#39;experimental&#39; page					// new options/features
this.$TargetOnlyHostile = false;		// ignore targeting cargo, pods and rocks in Red Alert
this.$RemoveInFlight = false;			// cut in half # of entries in equipment&#39;s mode cycle

// constants for MFD(s) filtering
this.$MFD_DYNAMIC_ALLSET = 127;			// highest bit = 64, Number(&#39;0x007f&#39;)
this.$MFD_STATIC_ALLSET = 4095;			// highest bit = 2048, Number(&#39;0x0fff&#39;)

this.$MFDFiltering = false;				// toggle for filtering MFD output
this.$MFDPrimaryStatic = this.$MFD_STATIC_ALLSET;// bit flags for filtering MFD using static properties
this.$MFDPrimaryDynamic = this.$MFD_DYNAMIC_ALLSET;// bit flags for filtering MFD using dynamic properties
this.$SeparateMFDs = false;				// toggle for adding an auxiliary MFD
this.$MFDAuxStatic = this.$MFD_STATIC_ALLSET; // bit flags for filtering MFD using static properties
this.$MFDAuxDynamic = this.$MFD_DYNAMIC_ALLSET;// bit flags for filtering MFD using dynamic properties
this.$Thargoids = false;				//you will get some aliens right after undock to test Telescope

// Beta licence feature in station options (testing dynamics)
this.$BetaLicence = &#39;&#39;;					// choice for licence of experimental options
this.$BetaLicenceTimestamp = &#39;&#39;;		// date of player accepting license agreement for experimental options
this.$BetaLicenceSystem = &#39;&#39;;			// system where this occured; preserved in missionVariables (_reloadFromStn)

this.$DebugMessages = false;			// flag for logging debug messages

///////////////////////////////////////////////////////////////////////////////////////////////////
// internal properties, should not touch //////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

this.$PrimaryMFD_name = &#39;TelescopeMFD&#39;;
this.$AuxilaryMFD_name = &#39;TelescopeAuxMFD&#39;;

this.$are_Steering = false;				// flag as to whether ship is auto-steering
this.$DamageMsg = true;					// flag to show messgage less frequently

this.$FixedTel = 0;						//cheaply fixed Telescope with drawbacks
this.$FixedGS = 0;						//cheaply fixed Gravity Scanner with drawbacks
this.$FixedSD = 0;						//cheaply fixed Small Dish with drawbacks
this.$FixedLD = 0;						//cheaply fixed Large Dish with drawbacks
this.$GravScanCount = 0;				//Gravity Scan counter to call aliens
this.$IdentKeyPress = 0;				// count for &#39;ident&#39; key presses: 1st to lock target, 2nd to steer (if turned on), next press will unlock
// IdentKeyPress values
this.$IDENT_READY = 0;
this.$IDENT_LOCKED = 1;
this.$IDENT_STEERING = 2;
this.$IDENT_UNLOCK = 3;
this.$IDENT_STEER_DELAY = 4;
this.$IDENT_STEP_DELAY = 5;

this.$MaxRange = 1e15;					//10^15m, usable part of double precision for filteredEntities
this.$MASSLOCK_RING_SCALE = 41.8;		//masslock ring scale, used for .scale() calc&#39;s
										// to abort the resultant events shipTargetAcquired &amp; shipTargetLost
this.$SoundScan = null;					//scan soundsource
this.$Timer_auto_updates = null;		//AutoScan timer get targets from normal scanner and do scan if new far target in the front view
this.$extenderActive = null;			// maintained for _condition statements in Station Options

// values from activate/mode in flight changes
//	 missionVariables - are VERY slow, so only use on load/save game
this.$TelescopeMenuSteering		= 1;	// defaults low so as to not overwhelm initiates
this.$TelescopeMenuLightballs	= 3;
this.$TelescopeMenuMasslockRings= 1;
this.$TelescopeMenuSniper		= 2;
this.$TelescopeMenuTargets		= 3;
this.$TelescopeMenuVisual		= 1;
this.$TelescopeMenuVisualSize	= 4;

this.$UserChangedSettings = 0;			// bit flags to signal changes in-game; see _SetLightballs et. al.
this.$SightingsMap = [];				// persistent array of Sightings that comprise all the telescope sees
this.$curr_Sighting = { map: null, ent: null, marker: null, marker_type: null, name: null };	// info on current Sighting
this.$Sighting_events_FCB = null;		// store frame callback for _Sighting_events()
this.$fps_closure = null;				// closure for fps_monitor
this.$Telescope_not_in_use = true;		// flag set in startUpComplete where it&#39;s determined if player has a telescope, used to stop event handlers

///////////////////////////////////////////////////////////////////////////////////////////////////
// legacy properties for oxp support //////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

// new: a simpler way to get the entity a far target marker is refering to is a property
//      of the telescope marker: ps.target.$TelescopeTarget
//   eg. var target = ps.target;
//       if( target.dataKey === &#39;telescopemarker&#39; )
//           target = target.$TelescopeTarget;
//   OR  var target = ps.target.dataKey === &#39;telescopemarker&#39; ? ps.target.$TelescopeTarget : ps.target;

this.$fakeTelescopeList = function() {
	this[ 0 ] = null;
};

this.$fakeTelescopeList.prototype.length = 1;

this.$fakeTelescopeList.prototype.indexOf = function indexOf( ent ) {
	var that = indexOf;
	var ws = (that.ws = that.ws || worldScripts.telescope);
	var mapping = (that.mapping = that.mapping || ws.$SightingsMap);

	var index = ws._Sighting_index( ent );
	if( index &lt; 0 ) return -1;
	this[ 0 ] = mapping[ index ].ent;
	return 0;
};

this.$TelescopeList = new this.$fakeTelescopeList();
this.$TelescopeListi = 0;
// changing variable &amp; fn names breaks all external oxp references
// - external refs usually just ws.$TelescopeList[ ws.$TelescopeListi - 1 ], ie. current far target
// so we&#39;ll maintain TelescopeList as a one element array and set TelescopeListi to 0 or 1 accordingly

this.$TelescopeVPos = [0, 0, 0];		// maintain for Carriers oxp  (position of the visual effect)
this.$TelescopeVPosHUD = [0, 0, 0];		// maintain for Carriers oxp  (position shift for your HUD&#39;s built-in visual target screen if any)
this.$TelescopeSteerFCB = null;			// maintain for Towbar oxp
this.$TelescopeTargetSet = false;		// used by Telescope and EscortDeck

this.$TelescopeRing = null;				// maintain for VimanaHUD oxp
this.$TelescopeVSize = null;			// maintain for VimanaHUD oxp
this.$TelescopeVZoomSize = null;		// maintain for VimanaHUD oxp
//flag scanning to avoid double scan; it&#39;s like a write lock: when we set ps.target, we use this

///////////////////////////////////////////////////////////////////////////////////////////////////
// world script events ////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

///
this.startUp = function startUp() {
	var ws = worldScripts.telescope;
///
if( worldScripts.NShields ) // too much logging
	worldScripts.NShields._logging = false;
///

	try {
		ws.$SoundScan = new SoundSource();
		ws.$SoundScan.sound = &quot;ScanSound.ogg&quot;;						//sound of the Gravity Scanner
		ws.$SoundScan.loop = false;
		ws.$SoundScan.repeatCount = 1;

		var hud = worldScripts.hudselector;
		if( hud ) {
			hud.startUpComplete = ws.$HUDStartUpComplete;
			hud.$HUDSelectorSetMFDs = ws.$HUDSelectorSetMFDs;
			ws._registerHUDSelector();
		}
		// create sightings closure
		ws._init_Sightings_closure();
		ws._load_missionVariables();
		if( ws.$DebugMessages ) {
			ws._debug_Sightings_closure();
		}
		ws._reload_config( ws.$DebugMessages );						// if DebugMessages, will call _report_config
	} catch( err ) {
		log( ws.name, ws._reportError( err, startUp, ws.$SoundScan, 1 ) );
		if( ws.$DebugMessages )
			throw err;
	}
}

this.startUpComplete = function startUpComplete() {
	var ws = worldScripts.telescope;
	var ps = player &amp;&amp; player.ship;

	var fps = worldScripts.telescope_fps_monitor;
	if( fps ) {
		var fm = ws.$fps_closure = fps._fps_monitor_closure;		// not called as it self-initiates
		//	_init_fps_monitor( oxp_name, paused, no_fcb )
		fm._init_fps_monitor(  &#39;telescope&#39;, true );
		//	_setup_fps_report( minutes, shortterm, longterm, filelog, console, duration )
		fm._setup_fps_report(  1,		2,		   5,		 ws.$DebugMessages, false );
		//	_setup_fps_calc( cut_low, cut_high, harmonic, fps_only, median, mode,  mean,  high,	 low )
		fm._setup_fps_calc(	 2,		  0,		true,	  false,	false,	false, false, true,	 true );
	}
	ws._initOxpVars();												// moved from startUp as some oxp&#39;s will load after us
	// extenderActive is used in station options&#39; _condition statements
	ws.$extenderActive = ps.equipmentStatus( &#39;EQ_TELESCOPEEXT&#39; ) === &#39;EQUIPMENT_OK&#39;;
	ws._startStationOptions();

	if( ps.equipmentStatus( &#39;EQ_TELESCOPE&#39; ) === &#39;EQUIPMENT_UNAVAILABLE&#39; ) {
		ws.$Telescope_not_in_use = true;							// ship has no telescope, prevent world script handlers from running
	} else {
		ws.$Telescope_not_in_use = false;
	}
}

// load &amp; save events /////////////////////////////////////////////////////////////////////////////

this._load_missionVariables = function _load_missionVariables() {
	var ws = worldScripts.telescope;
	var item = null, bool = [false, true];
	// remember menu values loaded so can switch 1.15 &lt;-&gt; 2.0 repeatedly
	var menuLightballs = false, menuSniper = false, menuSteering = false,
		menuTargets = false, menuVisual = false, menuVisualSize = false;
	// TelescopeVisualTargetRing is unique to ver.2
	var savedIsOrig = missionVariables.$TelescopeVisualTargetRing === null;

/// original telescope missionVariables
	// inflight options
	// - the original used these to store option values; here we store options on their own
	//   thus, we apply these first so inflight config is in sync

	if( savedIsOrig ) {
		item = missionVariables.$TelescopeMenuLightballs;
		if( item !== null ) {
			ws._oldSetLightballs( item );
			menuLightballs = true;									// preserve LightBalls, ShipLightBalls, MassLockRings, BrightMassLockRings &amp; LargeLightBalls
		}
	} else {
		item = missionVariables.$TelescopeMenuLightballs;
		if( item !== null ) ws._SetLightballs( item );
		item = missionVariables.$TelescopeMenuMasslockRings;
		if( item !== null ) ws._SetMasslockRings( item );
	}
	item = missionVariables.$TelescopeMenuSniper;
	if( item !== null ) {
		ws._SetSniper( item );
		menuSniper = savedIsOrig;									// preserve SniperRange, SniperMinRange
	}
	item = missionVariables.$TelescopeMenuSteering;
	if( item !== null ) {
		ws._SetSteering( item );
		menuSteering = savedIsOrig;									// preserve Steering
	}
	item = missionVariables.$TelescopeMenuTargets;
	if( item !== null ) {
		ws._SetTargets( item );
		menuTargets = savedIsOrig;									// preserve MaxTargets
	}
	item = missionVariables.$TelescopeMenuVisual;
	if( item !== null ) {
		ws._SetVisual( item );
		menuVisual = savedIsOrig;									// preserve ShowVisualTarget, VisualTargetRing, TelescopeRing, ShowVisualStation, ShowVisualQuestionMark
	}
	item = missionVariables.$TelescopeMenuVisualSize;
	if( item !== null ) {
		ws._SetVisualSize( item );
		menuVisualSize = savedIsOrig;								// preserve VisualTargetCombatSize, TelescopeVSize, VisualTargetNormalSize, TelescopeVZoomSize
	}

	// state of equipment
	// - these missionVariables are common to both the original and this version

	item = missionVariables.$TelescopeFixedTel;
	ws.$FixedTel = item !== null ? item : 0;
	item = missionVariables.$TelescopeFixedGS;
	ws.$FixedGS = item !== null ? item : 0;
	item = missionVariables.$TelescopeFixedSD;
	ws.$FixedSD = item !== null ? item : 0;
	item = missionVariables.$TelescopeFixedLD;
	ws.$FixedLD = item !== null ? item : 0;
	// renamed from original $TelescopeGSC -&gt; $TelescopeGravScanCount
	item = savedIsOrig ? missionVariables.$TelescopeGSC : missionVariables.$TelescopeGravScanCount;
	ws.$GravScanCount = item !== null ? item : 0;

/// new station options
	// light balls

	if( savedIsOrig ) {
		if( !menuLightballs ) {										// 1.15 defaults
			ws.$LightBalls = true;
			ws.$ShipLightBalls = true;
			ws.$MassLockRings = this.$DEFAULT_ML_RINGS;				// default green alert or weapons off-line
			ws.$BrightMassLockRings = false;
			ws.$LargeLightBalls = false;
		} // else set via _SetLightballs above
	} else {
		let isBetaSaveGame = !missionVariables.hasOwnProperty( &#39;$TelescopeMassLockRings&#39; );
		item = missionVariables.$TelescopeMassLockBorders;
		if( item !== null ) {										// renamed from beta
			delete missionVariables.$TelescopeMassLockBorders;
			if( isBetaSaveGame ) {
				missionVariables.TelescopeMassLockRings = item;
			}
		}
		item = missionVariables.$TelescopeBrightMassLockBorders;
		if( item !== null ) {										// renamed from beta
			delete missionVariables.$TelescopeBrightMassLockBorders;
			if( isBetaSaveGame ) {
				missionVariables.TelescopeBrightMassLockRings = item;
			}
		}
		item = missionVariables.$TelescopeLightBalls;
		ws.$LightBalls = item !== null ? bool[ item ] : true;		// default on
		item = missionVariables.$TelescopeShipLightBalls;
		ws.$ShipLightBalls = item !== null ? bool[ item ] : true;
		item = missionVariables.$TelescopeLargeLightBalls;
		ws.$LargeLightBalls = item !== null ? bool[ item ] : false;	// default off

		item = missionVariables.$TelescopeMassLockRings;
		ws.$MassLockRings = item !== null ? item : this.$DEFAULT_ML_RINGS; // default green alert or weapons off-line
		item = missionVariables.$TelescopeShowMassLock;
		if( item !== null ) {										// deprecated from beta (using MassLockRings flags only)
			delete missionVariables.$TelescopeShowMassLock;
			if( item === 0 &amp;&amp; isBetaSaveGame ) {
				ws.$MassLockRings = 0;								// were turned off
			}
		}
		item = missionVariables.$TelescopeBrightMassLockRings;
		ws.$BrightMassLockRings = item !== null ? bool[ item ] : false;	// default off
	}

	item = savedIsOrig ? null : missionVariables.$TelescopeLightBallMinDist;
	ws.$LightBallMinDist = item !== null ? item : 1000;
	item = savedIsOrig ? null : missionVariables.$TelescopeLightBallShipMinDist;
	ws.$LightBallShipMinDist = item !== null ? item : 5000;

	item = savedIsOrig ? null : missionVariables.$TelescopeMassLockViewDirn;
	ws.$MassLockViewDirn = item !== null ? item : 1;				// default forward view only

	// sniper ring

	item = savedIsOrig ? null : missionVariables.$TelescopeSniperRingSize;
	ws.$SniperRingSize = item !== null ? item : 2;
	item = savedIsOrig ? null : missionVariables.$TelescopeSniperRingActive;
	ws.$SniperRingActive = item !== null ? item : 42;
	item = savedIsOrig ? null : missionVariables.$TelescopeSniperRingColor;
	ws.$SniperRingColor = item !== null ? JSON.parse( item ) : [0.3, 0.3, 0.3];

	if( savedIsOrig ) {
		if( !menuSniper ) {											// 1.15 defaults
			ws.$SniperRange = 25600;
			ws.$SniperMinRange = 10000;
		} // else set via _SetSniper above
	} else {
		item = missionVariables.$TelescopeSniperRange;
		ws.$SniperRange = item !== null ? item : 25600;
		item = missionVariables.$TelescopeSniperMinRange;
		ws.$SniperMinRange = item !== null ? item : 10000;
	}

	// visual target

	if( savedIsOrig ) {
		if( !menuVisual ) {											// 1.15 defaults
			ws.$ShowVisualTarget = 0;
			ws.$VisualTargetRing = true;
			ws.$TelescopeRing = true;								// maintain for oxps
			ws.$ShowVisualStation = true;
			ws.$ShowVisualQuestionMark = false;
		} // else set via _SetVisual above
	} else {
		item = missionVariables.$TelescopeShowVisualTarget;
		ws.$ShowVisualTarget = item !== null ? item : 0;			// default is choice &#39;Off&#39;
		item = missionVariables.$TelescopeVisualTargetRing;
		ws.$VisualTargetRing = item !== null ? bool[ item ] : true;
		ws.$TelescopeRing = ws.$VisualTargetRing;					// maintain for oxps
		item = missionVariables.$TelescopeShowVisualStation;
		ws.$ShowVisualStation = item !== null ? bool[ item ] : true;
		item = missionVariables.$TelescopeShowVisualQuestionMark;
		ws.$ShowVisualQuestionMark = item !== null ? bool[ item ] : false;
	}

	if( savedIsOrig ) {
		if( !menuVisualSize ) {										// 1.15 defaults
			ws.$VisualTargetNormalSize = 6;
			ws.$TelescopeVZoomSize = 6;								// maintain for oxps
			ws.$VisualTargetCombatSize = 4;
			ws.$TelescopeVSize = 4;									// maintain for oxps
		} // else set via _SetVisualSize above
	} else {
		item = missionVariables.$TelescopeVisualTargetNormalSize;
		ws.$VisualTargetNormalSize	= item !== null ? item : 6;
		ws.$TelescopeVZoomSize = ws.$VisualTargetNormalSize;		// maintain for oxps
		item = missionVariables.$TelescopeVisualTargetCombatSize;
		ws.$VisualTargetCombatSize	= item !== null ? item : 4;
		ws.$TelescopeVSize = ws.$VisualTargetCombatSize;			// maintain for oxps
	}

	item = savedIsOrig ? null : missionVariables.$TelescopeModelRingColor;
	ws.$ModelRingColor = item !== null ? JSON.parse( item ) : [0.3, 0.3, 0.3];
	item = savedIsOrig ? null : missionVariables.$TelescopeVTarget_HUD_shift;
	ws.$VTarget_HUD_shift = item !== null ? JSON.parse( item ) : [0, 0, 0];
	ws.$TelescopeVPosHUD = ws.$VTarget_HUD_shift;					// maintain for oxps

	// miscellaneous

	if( savedIsOrig ) {
		if( !menuSteering ) {										// 1.15 defaults
			ws.$Steering = 0;
		} // else set via _SetSteering above
	} else {
		item = missionVariables.$TelescopeSteering;
		ws.$Steering = item !== null ? item : 0;					// default is choice &#39;Off&#39;
	}

	if( savedIsOrig ) {
		if( !menuTargets ) {										// 1.15 defaults
			ws.$MaxTargets = 200;
		} // else set via _SetTargets above
	} else {
		item = missionVariables.$TelescopeMaxTargets;
		ws.$MaxTargets = item !== null ? item : 200;
	}

	item = savedIsOrig ? null : missionVariables.$TelescopeRemoveInFlight;
	ws.$RemoveInFlight = item !== null ? bool[ item ] : false;
	item = savedIsOrig ? null : missionVariables.$TelescopeAutoScan;
	ws.$AutoScan = item !== null ? bool[ item ] : true;
	item = savedIsOrig ? null : missionVariables.$TelescopeAutoScanMaxRange;
	ws.$AutoScanMaxRange = item !== null ? item : 1e6;
	item = savedIsOrig ? null : missionVariables.$TelescopeFarStatus;
	ws.$FarStatus = item !== null ? bool[ item ] : false;
	item = savedIsOrig ? null : missionVariables.$TelescopeAutoLock;
	ws.$AutoLock = item !== null ? item : 1;						// default cone of radius 1 degree
	item = savedIsOrig ? null : missionVariables.$TelescopeGravLock;
	ws.$GravLock = item !== null ? item : 20;						// default cone of radius 20 degrees
	item = savedIsOrig ? null : missionVariables.$TelescopeIdentLock;
	ws.$IdentLock = item !== null ? item : 180;						// default cone of radius 180 degrees, ie. whole sky
	item = savedIsOrig ? null : missionVariables.$TelescopeIdentDelay;
	ws.$IdentDelay = item !== null ? item : 4;						// time in 0.25 seconds, ie. 1 second
	item = savedIsOrig ? null : missionVariables.$TelescopeRedAlertDist;
	ws.$RedAlertDist = item !== null ? item : 30000;				// default to max range of military laser
	// - not a cheat, really, as just showing lollipop where shot came from, cannot target w/o extender

	// UI &amp; docn
	item = savedIsOrig ? null : missionVariables.$TelescopeConsoleMsgDurn;
	ws.$ConsoleMsgDurn = item !== null ? item : 5;					// time in seconds
	item = savedIsOrig ? null : missionVariables.$TelescopeGravScanMsgFreq;
	ws.$GravScanMsgFreq = item !== null ? item : 3;					// default is choices &#39;progress endpoints&#39; &amp; &#39;progress quarterly update&#39;
	item = savedIsOrig ? null : missionVariables.$TelescopeIdentMessages;
	ws.$IdentMessages = item !== null ? bool[ item ] : true;
	item = savedIsOrig ? null : missionVariables.$TelescopeShowSummary;
	ws.$ShowSummary = item !== null ? bool[ item ] : true;
	item = savedIsOrig ? null : missionVariables.$TelescopeDebugMessages;
	ws.$DebugMessages = item !== null ? bool[ item ] : false;

	// MFD(s) &amp; filtering
	item = savedIsOrig ? null : missionVariables.$TelescopeMFDFiltering;
	ws.$MFDFiltering = item !== null ? bool[ item ] : false;
	item = savedIsOrig ? null : missionVariables.$TelescopeMFDfilterStatic;
	ws.$MFDPrimaryStatic = item !== null ? item : ws.$MFD_STATIC_ALLSET;
	item = savedIsOrig ? null : missionVariables.$TelescopeMFDfilterDynamic;
	ws.$MFDPrimaryDynamic = item !== null ? item : ws.$MFD_DYNAMIC_ALLSET;
	item = savedIsOrig ? null : missionVariables.$TelescopeSeparateMFDs;
	ws.$SeparateMFDs = item !== null ? bool[ item ] : false;
	item = savedIsOrig ? null : missionVariables.$TelescopeMFDAuxStatic;
	ws.$MFDAuxStatic = item !== null ? item : ws.$MFD_STATIC_ALLSET;
	item = savedIsOrig ? null : missionVariables.$TelescopeMFDAuxDynamic;
	ws.$MFDAuxDynamic = item !== null ? item : ws.$MFD_DYNAMIC_ALLSET;
	// $Thargoids was never saved in original so it remains a one-off switch from a station dock

	if( missionVariables.$TelescopeOptionsSaveGameReminder ) // never implemented
		delete missionVariables.$TelescopeOptionsSaveGameReminder;

	item = savedIsOrig ? null : missionVariables.$TelescopeBetaLicence;
	if( item !== null ) {
		ws.$BetaLicence = item;
		ws.$BetaLicenceTimestamp = missionVariables.$TelescopeBetaLicenceTimestamp;
		ws.$BetaLicenceSystem = missionVariables.$TelescopeBetaLicenceSystem;
	}

	ws.$UserChangedSettings = 0;									// clear flags as _initOxpVars will updateMenuVars
}

this.playerWillSaveGame = function playerWillSaveGame( /*message*/ ) {
	var that = playerWillSaveGame;
	var ws = (that.ws = that.ws || worldScripts.telescope);

	if( missionVariables.hasOwnProperty( &#39;$TelescopeRedAlertLimiter&#39; ) )// removed from beta
		delete missionVariables.$TelescopeRedAlertLimiter;

	// inflight options
	missionVariables.$TelescopeMenuLightballs			= ws._getOldLightballs();	// set to conform with 1.15
	missionVariables.$TelescopeMenuMasslockRings		= ws.$TelescopeMenuMasslockRings; // 1.15 will ignore
	missionVariables.$TelescopeMenuSniper				= ws.$TelescopeMenuSniper;
	missionVariables.$TelescopeMenuSteering				= ws.$TelescopeMenuSteering;
	missionVariables.$TelescopeMenuTargets				= ws.$TelescopeMenuTargets;
	missionVariables.$TelescopeMenuVisual				= ws.$TelescopeMenuVisual;
	missionVariables.$TelescopeMenuVisualSize			= ws.$TelescopeMenuVisualSize;

	// state of equipment
	missionVariables.$TelescopeGravScanCount			= ws.$GravScanCount;
	missionVariables.$TelescopeGSC						= ws.$GravScanCount;
	// - added to ensure reversion to original is complete
	missionVariables.$TelescopeFixedTel					= ws.$FixedTel;
	missionVariables.$TelescopeFixedGS					= ws.$FixedGS;
	missionVariables.$TelescopeFixedSD					= ws.$FixedSD
	missionVariables.$TelescopeFixedLD					= ws.$FixedLD;

	// NB: boolean values must be stored as 0 or 1, else loads false, true as strings(!) which are always true

	// light balls
	missionVariables.$TelescopeLightBalls				= ws.$LightBalls ? 1 : 0;
	missionVariables.$TelescopeShipLightBalls			= ws.$ShipLightBalls ? 1 : 0;
	missionVariables.$TelescopeLargeLightBalls			= ws.$LargeLightBalls ? 1 : 0;
	missionVariables.$TelescopeLightBallMinDist			= ws.$LightBallMinDist;
	missionVariables.$TelescopeLightBallShipMinDist		= ws.$LightBallShipMinDist;

	// masslock rings
	missionVariables.$TelescopeMassLockRings			= ws.$MassLockRings;
	missionVariables.$TelescopeBrightMassLockRings		= ws.$BrightMassLockRings ? 1 : 0;
	missionVariables.$TelescopeMassLockViewDirn			= ws.$MassLockViewDirn ? ws.$MassLockViewDirn : 1;

	// sniper ring
	missionVariables.$TelescopeSniperRingSize			= ws.$SniperRingSize;
	missionVariables.$TelescopeSniperRingActive			= ws.$SniperRingActive;
	missionVariables.$TelescopeSniperRange				= ws.$SniperRange;
	missionVariables.$TelescopeSniperMinRange			= ws.$SniperMinRange;
	missionVariables.$TelescopeSniperRingColor			= JSON.stringify( ws.$SniperRingColor );

	// visual target
	missionVariables.$TelescopeShowVisualTarget			= ws.$ShowVisualTarget;
	missionVariables.$TelescopeVisualTargetNormalSize	= ws.$VisualTargetNormalSize;
	missionVariables.$TelescopeVisualTargetCombatSize	= ws.$VisualTargetCombatSize;
	missionVariables.$TelescopeShowVisualStation		= ws.$ShowVisualStation ? 1 : 0;
	missionVariables.$TelescopeShowVisualQuestionMark	= ws.$ShowVisualQuestionMark ? 1 : 0;
	missionVariables.$TelescopeVisualTargetRing			= ws.$VisualTargetRing ? 1 : 0;
	missionVariables.$TelescopeModelRingColor			= JSON.stringify( ws.$ModelRingColor );
	missionVariables.$TelescopeVTarget_HUD_shift		= JSON.stringify( ws.$VTarget_HUD_shift );

	// option available on station
	missionVariables.$TelescopeRemoveInFlight			= ws.$RemoveInFlight ? 1 : 0;	// new
	missionVariables.$TelescopeSteering					= ws.$Steering;
	missionVariables.$TelescopeMaxTargets				= ws.$MaxTargets;
	missionVariables.$TelescopeAutoScan					= ws.$AutoScan ? 1 : 0;
	missionVariables.$TelescopeAutoScanMaxRange			= ws.$AutoScanMaxRange;
	missionVariables.$TelescopeFarStatus				= ws.$FarStatus ? 1 : 0;
	missionVariables.$TelescopeAutoLock					= ws.$AutoLock;
	missionVariables.$TelescopeGravLock					= ws.$GravLock;
	missionVariables.$TelescopeIdentLock				= ws.$IdentLock;
	missionVariables.$TelescopeIdentDelay				= ws.$IdentDelay;
	missionVariables.$TelescopeRedAlertDist				= ws.$RedAlertDist;

	// new options - UI_and_docs
	missionVariables.$TelescopeConsoleMsgDurn			= ws.$ConsoleMsgDurn;
	missionVariables.$TelescopeGravScanMsgFreq			= ws.$GravScanMsgFreq;
	missionVariables.$TelescopeIdentMessages			= ws.$IdentMessages ? 1 : 0;
	missionVariables.$TelescopeShowSummary				= ws.$ShowSummary ? 1 : 0;
	missionVariables.$TelescopeDebugMessages			= ws.$DebugMessages ? 1 : 0;

	// new options - experimental
	missionVariables.$TelescopeMFDFiltering				= ws.$MFDFiltering ? 1 : 0;
	missionVariables.$TelescopeMFDfilterStatic			= ws.$MFDPrimaryStatic;
	missionVariables.$TelescopeMFDfilterDynamic			= ws.$MFDPrimaryDynamic;
	missionVariables.$TelescopeSeparateMFDs				= ws.$SeparateMFDs ? 1 : 0;
	missionVariables.$TelescopeMFDAuxStatic				= ws.$MFDAuxStatic;
	missionVariables.$TelescopeMFDAuxDynamic			= ws.$MFDAuxDynamic;
	// Thargoids was never saved in original so it remains a one-off switch from a station dock

	// $TelescopeBetaLicenceTimestamp &amp; $TelescopeBetaLicenceSystem are saved in _reloadFromStn(), maybe
	missionVariables.$TelescopeBetaLicence				= ws.$BetaLicence;
}

// station &amp; witchspace events ////////////////////////////////////////////////////////////////////

this.shipWillLaunchFromStation = function shipWillLaunchFromStation( /*station*/ ) {
	var that = shipWillLaunchFromStation;
	var ws = (that.ws = that.ws || worldScripts.telescope);

	var ps = player &amp;&amp; player.ship;
	if( ws.$Telescope_not_in_use ) return;							// no telescope, nothing to do
	ws._set_vShip_posn( ps.viewPositionForward, ws.$VTarget_HUD_shift );
	ws._AddShips();
}

this.shipExitedWitchspace =
this.shipLaunchedFromStation = function shipLaunchedFromStation( /*station*/ ) {
	var that = shipLaunchedFromStation;
	var ws = (that.ws = that.ws || worldScripts.telescope);

	if( ws.$DebugMessages &amp;&amp; global.console &amp;&amp; console.writeJSMemoryStats )
		console.writeJSMemoryStats();

	if( !ws.$GravScanCount ) ws.$GravScanCount = 0;					//start to count gravity scans (a missionVariables)
	if( !ws._init_player_vars() ) {									// equipment damaged, nothing to do
		ws._shutdown_Sightings();
		if( ws.$DebugMessages &amp;&amp; player.ship.equipmentStatus( &#39;EQ_TELESCOPE&#39; ) !== &#39;EQUIPMENT_UNAVAILABLE&#39; )
			log(ws.name, &#39;shipLaunchedFromStation, _init_player_vars failed, quitting before making mapping or starting Timer!&#39; );
		return;
	}
	ws._restart_after_shutdown();
	ws._create_Sightings();
	ws._StartTimer( 1 );											// delay to allow _create_Sightings to finish -curr&#39;ly takes ~20 frames
}

this.shipWillDockWithStation = function shipWillDockWithStation( /*station*/ ) { // called by shipWillEnterWitchspace
	var that = shipWillDockWithStation;
	var ws = (that.ws = that.ws || worldScripts.telescope);

	ws._set_curr_Sighting( null, &#39;shipWillDockWithStation&#39; );	// no parms clears it
	ws._StopTimer();
	ws._shutdown_Sightings();

	if( ws.$DebugMessages &amp;&amp; global.console &amp;&amp; console.writeJSMemoryStats )
		console.writeJSMemoryStats();
}

this.shipWillEnterWitchspace = function shipWillEnterWitchspace( /*cause, destination*/ ) {
	var that = shipWillEnterWitchspace;
	var ws = (that.ws = that.ws || worldScripts.telescope);
	var random = (that.random = that.random || Math.random);

	//	log(ws.name, &#39;in shipWillEnterWitchspace, arguments:&#39;+arguments );
	var ps = player &amp;&amp; player.ship;
	if( ws.$FixedGS === 1 &amp;&amp; random() &gt; 0.5 ) {
		ps.scriptedMisjump = true;									//meet Thargoids due to the cheap Grav.Sc. repair
		player.consoleMessage(&quot;Gravity Scanner caused misjump!&quot;);
	}
	if( ws.$FixedSD === 1 &amp;&amp; random() &gt; 0.2 ) {
		ps.setEquipmentStatus(&quot;EQ_SMALLDISH&quot;, &quot;EQUIPMENT_DAMAGED&quot;);
		player.consoleMessage(&quot;Small Dish damaged during hyperjump!&quot;, 10);
	}
	if( ws.$FixedLD === 1 &amp;&amp; random() &gt; 0.2 ) {
		ps.setEquipmentStatus(&quot;EQ_LARGEDISH&quot;, &quot;EQUIPMENT_DAMAGED&quot;);
		player.consoleMessage(&quot;Large Dish damaged during hyperjump!&quot;, 10);
	}
	ws.shipWillDockWithStation();
}

this.shipWillExitWitchspace = function shipWillExitWitchspace() {	//use this event due to shipExitedWitchspace is not working in v1.77
	var that = shipWillExitWitchspace;
	var ws = (that.ws = that.ws || worldScripts.telescope);

	if( ws.$Telescope_not_in_use ) return;							// no telescope, nothing to do

	ws._AddShips();													//do not call shipLaunchedFromStation() to avoid a bug
}

// ship events ////////////////////////////////////////////////////////////////////////////////////

this.shipBeingAttackedUnsuccessfully =
this.shipBeingAttacked = function shipBeingAttacked( whom ) {
	var that = shipBeingAttacked;
	var ws = (that.ws = that.ws || worldScripts.telescope);
	var mapping = (that.mapping = that.mapping || ws.$SightingsMap);

	if( ws.$Telescope_not_in_use ) return;							// no telescope, nothing to do
	if( !whom || !whom.isValid ) return;
	if( player.ship.equipmentStatus( &#39;EQ_TELESCOPE&#39; ) !== &#39;EQUIPMENT_OK&#39; ) return;
	var found = ws._Sighting_index( whom, &#39;shipBeingAttacked&#39; );
	if( found &lt; 0 ) {												// not registered
		found = ws._add_Sighting( whom, false, true, &#39;shipBeingAttacked&#39; );
		if( found &lt; 0 ) {
			log( ws.name, &#39;shipBeingAttacked, Yikes! _add_Sighting returned &quot;&#39;
				+ ws.$add_Sighting_errors[ found ] + &#39;&quot; trying to add &#39; + whom );
		}
	}
	if( found &lt; 0 ) return;											// failed to add!
	var map = mapping[ found ];
	map.rank = &#39;bad&#39;;
}

this.shipDied =														// used instead of shipKilledOther, as catches more cases
this.shipScoopedOther = function shipScoopedOther( whom ) {			// NB: scooped objects become hostile, ie. they target ps (even splinters!)
	var that = shipScoopedOther;
	var ws = (that.ws = that.ws || worldScripts.telescope);

	if( ws.$Telescope_not_in_use ) return;							// no telescope, nothing to do
	ws._delete_Sighting( whom, &#39;shipScoopedOther&#39; );				// will reset target lock, clear HUD, if it&#39;s player&#39;s target
}

this.shipSpawned = function shipSpawned( ship ) {					//detect missile launch immediately
	var that = shipSpawned;
	var ws = (that.ws = that.ws || worldScripts.telescope);

	if( ws.$Telescope_not_in_use ) return;							// no telescope, nothing to do
																	// - not testing scanClass, as conflicts w/ some oxp&#39;s
	if( ship.isVisualEffect ) return;
	if( ship.dataKey == &#39;telescopemarker&#39; ) return;					// dataKey == &#39;telescope-shadow&#39; caught by isVisualEffect
	var ps = player &amp;&amp; player.ship;
	if( !ps || !ps.isValid || ps.alertCondition === 0 ) 			//player died or docked (alertCondition === 0)
		return;
	if( !ws.$Timer_auto_updates ) return;							//no timer means in witchspace
	if( ws._Sighting_index( ship ) &gt;= 0 ) return;					// already in mapping! sometimes, check_if_new_targets can get there 1st

	let index = ws._add_Sighting( ship, false, false, &#39;shipSpawned&#39; );
	if( index &lt; -1 &amp;&amp; index &gt; -6 &amp;&amp; ws.$DebugMessages ) {
		let reason = ws.$add_Sighting_errors[ index ];
		log(ws.name, &#39;shipSpawned, isVisible = &#39; + ship.isVisible
			+ &#39;, distance = &#39; + ship.position.distanceTo( ps ).toFixed() + &#39;, mass = &#39; + ship.mass
			+ &#39;, w/ ship = &#39; + ship + &#39;\n\t Yikes! _add_Sighting returned: &#39; + reason );
	}

/*
///testing if isVisible bug still present; 1.92 (Jan/22) set record: wreckage @ 31,733,066 m!
/// - problem is that .isVisible is always true when an ent is spawned and it may not be
///   properly set before we try to add it to the list of sightings
/// - new solution is to ignore anything spawned w/i last ??? second; here we try to get a feel
///   for what a good interval should be for use in grow_new_list, _add_Sighting: SPAWN_DELAY
if( ws.$DebugMessages ) {
	let dist = ps.position.distanceTo( ship ), spawn = ship.spawnTime;
	let now = clock.absoluteSeconds;
	if( dist &gt; 5e6 &amp;&amp; ship.isVisible &amp;&amp; ship.scanClass !== &#39;CLASS_NO_DRAW&#39;
			&amp;&amp; ship.status !== &#39;STATUS_LAUNCHING&#39; ) {
		log(ws.name, &#39;shipSpawned, ship &quot;&#39; + ship.entityPersonality + &#39;&quot; at &#39; + dist.toFixed() + &#39; has isVisible true! ####, spawnTime: &#39;
			+ spawn.toFixed(4) + &#39;: , diff from now: &#39; + (spawn &gt; 0 ? (now - spawn).toFixed(4) : &#39;n/a&#39;) + &#39;, ship:&#39; + ship );
		let timr = new Timer( ws, ws._isVisMonitor, 0.05, 0.25 );
		timr.$spawnedShip = ship;
		ws.$isVisTimers.push( timr );
	}
}
 */
}
///
this.$isVisTimers = [];
this._isVisMonitor = function _isVisMonitor() {

	function suicide() {
		if( timeRef.isRunning ) {
			timeRef.stop();
		}
		let idx = ws.$isVisTimers.indexOf( timeRef );
		if( idx &lt; 0 ) {
			log(&#39;_isVisMonitor, timeRef (&#39;+timeRef+&#39;) not found in $isVisTimers: &#39; + ws.$isVisTimers);
		} else {
			ws.$isVisTimers.splice( idx, 1 );	// modify array be removing 1 item at idx
		}
		timeRef = that.timeRef = null;
	}

	var that = _isVisMonitor;
	var ws = (that.ws = that.ws || worldScripts.telescope);
	var timeRef = (that.timeRef = that.timeRef || ws.$isVisTimers[ws.$isVisTimers.length - 1]);
	var ship = timeRef.$spawnedShip;
	if( !ship || ship.inValid ) {
		log(&#39;_isVisMonitor, failed to capture ship: &#39; + ship );
		suicide();
		return;
	}
	let now = clock.absoluteSeconds;
	if( ship.isVisible ) {
		log(&#39;_isVisMonitor, timeRef (&#39;+timeRef+&#39;), ship &quot;&#39; + ship.entityPersonality + &#39;&quot; still isVisible after &#39; + (now - ship.spawnTime).toFixed(4) + &#39;: &#39; + ship );
	} else {
		log(&#39;_isVisMonitor, timeRef (&#39;+timeRef+&#39;), ship &quot;&#39; + ship.entityPersonality + &#39;&quot; NO LONGER isVisible after &#39; + (now - ship.spawnTime).toFixed(4) + &#39;: &#39; + ship );
		suicide();
	}
}
///

this.$add_Sighting_errors = { &#39;-1&#39;: &#39;!mappingReady&#39;, &#39;-2&#39;: &#39;maplen &gt;= MaxTargets&#39;, &#39;-3&#39;: &#39;!ent.isValid&#39;,
							  &#39;-4&#39;: &#39;player died or docked&#39;, &#39;-5&#39;: &#39;already in mapping&#39;, &#39;-6&#39;: &#39;!_has_good_status&#39;,
							  &#39;-7&#39;: &#39;!notable_ent&#39;, &#39;-8&#39;: &#39;rank === ukn&#39;, &#39;-9&#39;: &#39;wreckage&#39;, &#39;-10&#39;: &#39;younger than SPAWN_DELAY&#39; };

this.shipTargetAcquired = function shipTargetAcquired( target ) {	//if locked target by hand then set as the actual item in the list
	var that = shipTargetAcquired;
	var ws = (that.ws = that.ws || worldScripts.telescope);
	var mapping = (that.mapping = that.mapping || ws.$SightingsMap);
	var curr_S = (that.curr_S = that.curr_S || ws.$curr_Sighting);
	var IDENT_READY = (that.IDENT_READY = that.IDENT_READY || ws.$IDENT_READY);
	var IDENT_STEER_DELAY = (that.IDENT_STEER_DELAY = that.IDENT_STEER_DELAY || ws.$IDENT_STEER_DELAY);

	if( ws.$Telescope_not_in_use ) return;							// no telescope, nothing to do
	if( !target || !target.isValid || ws.$TelescopeTargetSet )		//no target or we have just set ps.target
		return;
if( ws.$DebugMessages &amp;&amp; target === curr_S.marker )
	log(ws.name, &#39;shipTargetAcquired, re-acquired same target, should we bail out?&#39;);

	if( target === curr_S.marker ) {								// marker for target outside scannerRange
		target = curr_S.ent || null;
	}
	var isNewTarget = target !== curr_S.ent;
	var index = ws._Sighting_index( target, &#39;shipTargetAcquired&#39; ); // already scanned?
	if( index &lt; 0 ) {												// try adding it (should only fail if $MaxTargets reached)
		index = ws._add_Sighting( target, false, false, &#39;shipTargetAcquired&#39; );
		if( index === -2 ) {
			player.consoleMessage( (mapping.length &gt;= ws.$MaxTargets
					? &#39;Telescope memory is full.&#39; : &#39;Telescope unable to lock target.&#39;), ws.$ConsoleMsgDurn );
			ws._set_curr_Sighting( null, &#39;shipTargetAcquired&#39; );		// no parms resets
			if( ws.$DebugMessages )
				log(ws.name, &#39;shipTargetAcquired, maplen (&#39; + mapping.length + &#39;) &gt;= MaxTargets (&#39; + ws.$MaxTargets
					+ &#39;), curr_Sighting being reset! &#39; +  target );
			return;
		}
	}

if( ws.$DebugMessages ) log(ws.name, &#39;shipTargetAcquired, new target (&#39; + target.entityPersonality + &#39;), index: &#39; + index
+ &#39;, IdentKeyPress: &#39; + ws.$IdentKeyPress + &#39;: &#39; + target );

	if( isNewTarget ) {
		let identKeyPress = ws.$IdentKeyPress;
		if( identKeyPress &gt; IDENT_READY &amp;&amp; identKeyPress &lt; IDENT_STEER_DELAY ) {// it was &#39;locked&#39;, not in delay
			if( ws.$IdentMessages )
				player.consoleMessage( &#39;Telescope lock released&#39;, ws.$ConsoleMsgDurn );
			ws.$IdentKeyPress = IDENT_READY;
// if( ws.$DebugMessages ) log(&#39;shipTargetAcquired, identKeyPress = IDENT_READY&#39;);
		}
	}
	ws._manage_marker( mapping[ index ], false, &#39;shipTargetAcquired&#39; );
}

this.shipTargetCloaked = function shipTargetCloaked() {
	var that = shipTargetCloaked;
	var ws = (that.ws = that.ws || worldScripts.telescope);
	var curr_S = (that.curr_S = that.curr_S || ws.$curr_Sighting);
	var IDENT_READY = (that.IDENT_READY = that.IDENT_READY || ws.$IDENT_READY);

	if( ws.$Telescope_not_in_use ) return;							// no telescope, nothing to do
	var target = curr_S.ent || null;
	if( target &amp;&amp; target.isCloaked ) {
		ws._delete_Sighting( target, &#39;shipTargetCloaked&#39; );
		if( ws.$IdentKeyPress &gt; IDENT_READY ) {						// it was &#39;locked&#39;
			if( ws.$IdentMessages )
				player.consoleMessage( &#39;Telescope lock released&#39;, ws.$ConsoleMsgDurn );
			ws.$IdentKeyPress = IDENT_READY;
// if( ws.$DebugMessages ) log(&#39;shipTargetCloaked, identKeyPress = IDENT_READY&#39;);
		}
	}
}

this.shipTargetLost = function shipTargetLost( target ) {			// used to re-purpose ident key fn
	var that = shipTargetLost;
	var ws = (that.ws = that.ws || worldScripts.telescope);
	var curr_S = (that.curr_S = that.curr_S || ws.$curr_Sighting);
	var _has_bad_status = (that._has_bad_status = that._has_bad_status || ws._has_bad_status);

	if( ws.$Telescope_not_in_use ) { 								// no telescope, nothing to do
		return;
	}
	var ps = player &amp;&amp; player.ship;
	if( !ps || !ps.isValid || ps.alertCondition === 0 ) { 			//player died or docked
		return;
	}
	if( ws.$TelescopeTargetSet || ws.$IdentLock === 0 ) {			//set by script OR disabled by user
		return;
	}
// if( ws.$DebugMessages ) log(&#39;shipTargetLost, ws.$IdentKeyPress: &#39; + ws.$IdentKeyPress );
	if( target === curr_S.marker ) {								// telescopemarker was last target
		target = curr_S.ent;
	} else if( !target || target !== curr_S.ent ) {
		target = curr_S.ent || null;
	}

	var target_dead = !target										//target destroyed, jumped, docked else lost by ident key press
						|| _has_bad_status( target )				// _has_bad_status now checks .isValid, isWormhole
						|| target.energy &lt;= 0;						// !isValid no longer enough, as not always set before this event

/*
	if( ws.$DebugMessages ) log(ws.name, &#39;shipTargetLost, ship target was &#39;
		+ (target === curr_S.marker ? &#39; (&#39; + curr_S.marker_type + &#39;) &#39;:&#39;&#39;)
		+ (target ? &#39; @&#39; + Math.floor(target.position.distanceTo(ps)) + &#39;, &#39; + target : &#39;null&#39; )
		+ &#39;\n\t marker was &#39; + (curr_S.marker ? &#39;@&#39; + Math.floor(curr_S.marker.position.distanceTo(ps))
										+ (curr_S.marker_type === &#39;marker&#39; ? &#39;, a marker&#39; : &#39;, a shadow&#39;) : &#39;empty&#39; )
		+&#39;\n\t ent was &#39;+ (target ? &#39;@&#39; + Math.floor(target.position.distanceTo(ps)) + &#39;, &#39; + target : &#39;null&#39;)
		+ &#39;\n\t IdentKeyPress = &#39; + ws.$IdentKeyPress
		+ &#39;, target.isValid = &#39; + (target ? target.isValid : &#39;&lt;target is null&gt;&#39;)
		+ &#39;, target_dead = &#39; + target_dead + &#39;, ps.target = &#39; + ps.target
		+ (curr_S.lightball ? &#39;\nlightball (&#39; + curr_S.map.ve_colour + &#39;) @&#39;
								+ Math.floor(curr_S.lightball.position.distanceTo(ps)) : &#39;&#39;)
		);
	// if( ws.$DebugMessages &amp;&amp; worldScripts.telescope_debug ) worldScripts.telescope_debug._curr_S_report();
 */

	if( ws.$IdentKeyPress &lt; ws.$IDENT_STEER_DELAY )					// IdentDelay timer not running
		// when target_dead is true, _mostCentered won&#39;t allow an &#39;ident&#39; lock
		ws._mostCentered( &quot;ident&quot;, !target_dead );					//lock-steer?-unlock target
}

this.weaponsSystemsToggled = function weaponsSystemsToggled( /* state */ ) {
	var that = weaponsSystemsToggled;
	var ws = (that.ws = that.ws || worldScripts.telescope);

	if( player &amp;&amp; player.ship ) {									// reset state (esp. for Navigation mode)
		ws.$IdentKeyPress = ws.$IDENT_READY;
// if( ws.$DebugMessages ) log(&#39;weaponsSystemsToggled, identKeyPress = IDENT_READY&#39;);
	}
}

// equipment events ///////////////////////////////////////////////////////////////////////////////

this.$telescopeEquipment = [
		&#39;EQ_TELESCOPE&#39;, &#39;EQ_TELESCOPEEXT&#39;,
		&#39;EQ_GRAVSCANNER&#39;, &#39;EQ_GRAVSCANNER2&#39;,
		&#39;EQ_SMALLDISH&#39;, &#39;EQ_LARGEDISH&#39; ];

this.equipmentDestroyed =
this.equipmentDamaged = function equipmentDamaged( equipment ) {
	var that = equipmentDamaged;
	var ws = (that.ws = that.ws || worldScripts.telescope);
	var telEq = (that.telEq = that.telEq || ws.$telescopeEquipment);

	if( telEq.indexOf( equipment ) === -1 ) {
		return;
	}
	if( equipment === &#39;EQ_TELESCOPE&#39; ) {
		ws._StopTimer();
		ws._shutdown_Sightings();
		return;
	}
	if( equipment === &#39;EQ_TELESCOPEEXT&#39; ) {
		ws.$extenderActive = false;									// only used in station options
	}
	ws._init_player_vars();											// update status of equipment vars
	ws._create_Sightings();											//remove lost targets, autoscan will scan again
}

this.equipmentRepaired = function equipmentRepaired( equipment ) {
	var that = equipmentRepaired;
	var ws = (that.ws = that.ws || worldScripts.telescope);
	var telEq = (that.telEq = that.telEq || ws.$telescopeEquipment);

	if( telEq.indexOf( equipment ) === -1 ) {						// not a relevant repair - thanks Milo
		return;
	}
	var ps = player &amp;&amp; player.ship;
	if( equipment === &#39;EQ_TELESCOPE&#39; ) {
		ws.$FixedTel = 0;
		if( ws._init_player_vars() ) {
			ws._restart_after_shutdown();
			if( ps &amp;&amp; ps.isInSpace ) {								// emulate launch if fixed in space
				ws._StartTimer( 1 );								// delay to allow _create_Sightings to finish -curr&#39;ly takes 20+ frames
			}
		} else {
			ws._StopTimer();
			ws._shutdown_Sightings();
			return;
		}
	} else if( equipment === &#39;EQ_TELESCOPEEXT&#39; ) {
		ws.$extenderActive = true;
	} else if( equipment === &#39;EQ_GRAVSCANNER&#39; ) {
		ws.$FixedGS = 0;
	} else if( equipment === &#39;EQ_GRAVSCANNER2&#39; ) {
		ws.$FixedGS = 0;
	} else if( equipment === &#39;EQ_SMALLDISH&#39; ) {
		ws.$FixedSD = 0;
	} else if( equipment === &#39;EQ_LARGEDISH&#39; ) {
		ws.$FixedLD = 0;
	}
	ws._init_player_vars();											// update status of equipment vars
	ws._create_Sightings();											//remove lost targets, autoscan will scan again
}

this.playerBoughtEquipment = function playerBoughtEquipment( equipment ) {
	var that = playerBoughtEquipment;
	var ws = (that.ws = that.ws || worldScripts.telescope);
	var telEq = (that.telEq = that.telEq || ws.$telescopeEquipment);
	var random = (that.random = that.random || Math.random);
	var round = (that.round = that.round || Math.round);
	var floor = (that.floor = that.floor || Math.floor);
	var restock = (that.restock = that.restock || {});				// dictionary of stations&#39; restocking fee

	var ps = player &amp;&amp; player.ship;
	var actualEq = equipment,
		endsWith = &#39;&#39;,
		parsed = equipment.split( &#39;_&#39; );
	if( parsed.length === 3 ) {
		actualEq = parsed[ 0 ] + &#39;_&#39; + parsed[ 1 ];
		endsWith = parsed[ 2 ];
	}
	if( telEq.indexOf( actualEq ) === -1 ) {
		return;
	}
	if( endsWith === &#39;&#39; ) {											// bought actual equipment
		if( equipment === &#39;EQ_TELESCOPE&#39; ) {
			ws.$FixedTel = 0;
			ws.$Telescope_not_in_use = false;
			ws._registerHUDSelector();
			ps.setMultiFunctionText( ws.$PrimaryMFD_name, &#39;&#39; );		// make core aware now for other oxp&#39;s that play with MFDs
			ps.setMultiFunctionText( ws.$AuxilaryMFD_name, &#39;&#39; );
		} else if( equipment === &#39;EQ_TELESCOPEEXT&#39; ) {
			ws.$extenderActive = true;
		} else if( equipment === &#39;EQ_GRAVSCANNER&#39;
				|| equipment === &#39;EQ_GRAVSCANNER2&#39; ) {
			ws.$FixedGS = 0;
		} else if( equipment === &#39;EQ_SMALLDISH&#39; ) {
			ws.$FixedSD = 0;
		} else if( equipment === &#39;EQ_LARGEDISH&#39; ) {
			ws.$FixedLD = 0;
		}
		return;
	}
	if( endsWith === &#39;REFUND&#39; ) {									// sold actual equipment
		ps.removeEquipment( equipment );							//remove the &#39;bought&#39; refund eq
		if( ps.equipmentStatus( actualEq ) === &#39;EQUIPMENT_OK&#39; ) {
			if( actualEq === &#39;EQ_TELESCOPEEXT&#39; ) {
				ws.$extenderActive = false;
			}
			ps.removeEquipment( actualEq );							// the refund voucher
			clock.addSeconds( ( actualEq[ 3 ] === &#39;G&#39; ? 1800 : 4500 ) );// dish work takes longer
			let infoForKey = EquipmentInfo.infoForKey( actualEq );
			let rate, refund = infoForKey.price / 10;				// .plist price is in tenths of credits
			let station = player.dockedStation;
			if( restock.hasOwnProperty( station ) )					// fee cached to be consistent
				rate = restock[ station ];
			else													// random fee 1-5%
				rate = that.restock[ station ] =  floor( (random() * (0.051 - 0.01) + 0.01) * 100 );
				// rate = that.restock[ station ] = random() &lt; 0.5 ? 0.05 : 0.1;
			let fee = round( refund * rate );
			refund -= fee;
			player.credits += refund;
			player.consoleMessage( &#39;Refunded &#39; + refund + &#39; credits (less &#39;
									+ (rate * 100) + &#39;% commission) for &#39;
									+ infoForKey.name, ws.$ConsoleMsgDurn * 2 );
		}
	} else if( endsWith === &#39;REPAIR&#39; || endsWith === &#39;FULLREPAIR&#39;) {
		// remainder deals with repairs (this function is called after equipmentRepaired)
		ps.setEquipmentStatus( actualEq, &#39;EQUIPMENT_OK&#39; );
		ps.removeEquipment( equipment );							// the repair voucher
		clock.addSeconds( ( actualEq[ 3 ] === &#39;G&#39; ? 3600 : 9000 ) );// dish work takes longer
		if( actualEq === &#39;EQ_TELESCOPE&#39; ) {
			ws.$FixedTel = endsWith === &#39;REPAIR&#39; ? 1 : 0;			//with drawback (lightballs only)
		} else if( equipment === &#39;EQ_TELESCOPEEXT&#39; ) {
			ws.$extenderActive = true;								// has no cheap repair option
		} else if( actualEq === &#39;EQ_GRAVSCANNER&#39;
			  || actualEq === &#39;EQ_GRAVSCANNER2&#39; ) {
			ws.$FixedGS = endsWith === &#39;REPAIR&#39; ? 1 : 0;			//with drawback (misjump)
		} else if( actualEq === &#39;EQ_SMALLDISH&#39; ) {
			ws.$FixedSD = endsWith === &#39;REPAIR&#39; ? 1 : 0;			//with drawback (break during jump)
		} else if( actualEq === &#39;EQ_LARGEDISH&#39; ) {
			ws.$FixedLD = endsWith === &#39;REPAIR&#39; ? 1 : 0;			//with drawback (break during jump)
		}
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// station options ////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

this._startStationOptions = function _startStationOptions() {
	var ws = worldScripts.telescope;
	var so = worldScripts.station_options;

	try {
		if( so ) {													// pass callback functions and initialize station options
			let missionKeys;
			if( ws.$BetaLicence === 1 ) {							// &#39;experimental&#39; page is active, set keys
				missionKeys = {
					&#39;telescope_BetaLicenceTimestamp&#39;: ws.$BetaLicenceTimestamp,
					&#39;telescope_BetaLicenceSystem&#39;: ws.$BetaLicenceSystem,
				};
			} else {												// replace &#39;experimental&#39; page with licence agreement
				missionKeys = {
					&#39;telescope_optionPages&#39;: &quot;[telescope_optionPages_licence]&quot;,
					&#39;telescope_optionTabStops&#39;: &quot;[telescope_optionTabStops_licence]&quot;,
					&#39;telescope_licence_summary&#39;: &#39;[telescope_licence_undeclared]&#39;,
					&#39;telescope_licence_short&#39;: &#39;[telescope_licence_asking]&#39;,
					// set temporal strings to present tense in case player accepts
					&#39;telescope_licenceAcceptance&#39;: expandDescription( &#39;[telescope_experimental_accepts]&#39; ),
					&#39;telescope_licenceRegistered&#39;: expandDescription( &#39;[telescope_experimental_registers]&#39; ),
					// - not sure why but these won&#39;t expand otherwise (but telescope_licence_summary &amp; telescope_licence_short do work???)
					// &#39;telescope_licenceAcceptance&#39;: &#39;[telescope_experimental_accepts]&#39;,
					// &#39;telescope_licenceRegistered&#39;: &#39;[telescope_experimental_registers]&#39;,
				};
			}
			// _initStationOptions( hostOxp, keyPrefix, optionsAllowedCallback, callPWSG, notifyCallback, suppressSummary, missionKeys	 )
			let okay = so.$O_initStationOptions( ws, &#39;telescope_&#39;, ws._stnOptionsAllowed, true, ws._reloadFromStn, false, missionKeys );
			if( !okay )
				return;
			if( so.$O_getReminder4Oxp ) { 							// absent from version 1.0
				let rmdr = so.$O_getReminder4Oxp( &#39;telescope_&#39; );
				if( rmdr ) {
					ws.$ShowSummary = rmdr.reportSummary;
				} else {
					log( ws.name, &#39;_startStationOptions, station_options _getReminder4Oxp returned: &quot;&#39; + rmdr + &#39;&quot;&#39; );
				}
			}
		} else {
			log( ws.name, &#39;_startStationOptions, station_options oxp is missing!&#39; );
		}
	} catch( err ) {
		log( ws.name, ws._reportError( err, _startStationOptions ) );
		if( ws.$DebugMessages )
			throw err;
	}
}

this._BetaLicenceAnswered = function _BetaLicenceAnswered( response ) {		// _execute fn for station_options
	var ws = worldScripts.telescope;
	var so = worldScripts.station_options;

	// once licence is accepted, expiramental page is added.  The licence page remains
	// available until next station or next ship/equipment change or the player tries
	// to alter the acceptance.  These all result in a call to _setLicenceMissionVar()
	// which removes the licence page.
	var missionKeys;
	if( response === 1 ) {
		// preserve licence agreement info;  .length &gt; 0 &amp;&amp; !missionVariables =&gt; first time
		// - all subsequent values will be skipped, preserving the original
		// NB: here we&#39;re ASSUMING timestamp &amp; system are set as a pair, ie. at the same time
		if( ws.$BetaLicenceTimestamp.length &gt; 0 &amp;&amp; !missionVariables.$TelescopeBetaLicenceTimestamp ) {
			missionVariables.$TelescopeBetaLicenceTimestamp = ws.$BetaLicenceTimestamp;
			missionVariables.$TelescopeBetaLicenceSystem = ws.$BetaLicenceSystem;
			// insert experimental page, update text
			missionKeys = {
				&#39;telescope_BetaLicenceTimestamp&#39;: ws.$BetaLicenceTimestamp,
				&#39;telescope_BetaLicenceSystem&#39;: ws.$BetaLicenceSystem,
				&#39;telescope_optionPages&#39;: &quot;[telescope_optionPages_licence_accepted]&quot;,
				&#39;telescope_optionTabStops&#39;: &quot;[telescope_optionTabStops_licence_accepted]&quot;,
				&#39;telescope_licence_summary&#39;: &#39;[telescope_licence_accept]&#39;,
				&#39;telescope_licence_short&#39;: &#39;[telescope_licence_answered]&#39;,
			};
		} else if( ws.$BetaLicenceTimestamp.length &gt; 0 ) { // set a 2nd time??? reset missionKeys
			// player tries to undo licence acceptance, which we do not allow
			ws._setLicenceMissionVar()
			return;
		}
	} else {
		// rejection is only allowed when !$BetaLicence; once accepted, it cannot be changed
		// - see telescope_BetaLicence_assign in missiontext.plist
		missionKeys = {
			&#39;telescope_licence_summary&#39;: &quot;[telescope_licence_reject]&quot;,
		};
	}
	so.$O_updateMissionKeys( &#39;telescope_&#39;, missionKeys );
}

this._stnOptionsAllowed = function _stnOptionsAllowed() {			// callback fn for station_options
	var ws = worldScripts.telescope;
	var ps = player &amp;&amp; player.ship;

	ws._setLicenceMissionVar()
	return ps &amp;&amp; ps.equipmentStatus( &#39;EQ_TELESCOPE&#39; ) === &#39;EQUIPMENT_OK&#39;;
}

this._setLicenceMissionVar = function _setLicenceMissionVar() {		// if accepted, change tense for environmental summary
	var ws = worldScripts.telescope;
	var so = worldScripts.station_options;

	// called from _BetaLicenceAnswered, _stnOptionsAllowed &amp; _reloadFromStn, text will
	// (text will remain unchanged until this function is called)
	if( ws.$BetaLicence === 1										// licence accepted, ensure tense correct
			&amp;&amp; missionVariables.$TelescopeBetaLicence === null ) {
		// player entering station_options having accepted licence on previous visit
		so.$O_updateMissionKeys( &#39;telescope_&#39;,
			{
				&#39;telescope_licenceAcceptance&#39;: expandDescription( &#39;[telescope_experimental_has_accepted]&#39; ),
				&#39;telescope_licenceRegistered&#39;: expandDescription( &#39;[telescope_experimental_has_registered]&#39; ),
				// - not sure why but these won&#39;t expand otherwise (but telescope_licence_summary &amp; telescope_licence_short do work???)
				// &#39;telescope_licenceAcceptance&#39;: &#39;[telescope_experimental_has_accepted]&#39;,
				// &#39;telescope_licenceRegistered&#39;: &#39;[telescope_experimental_has_registered]&#39;,
				&#39;telescope_optionPages&#39;: &#39;[telescope_optionPages_experimental]&#39;,
				&#39;telescope_optionTabStops&#39;: &#39;[telescope_optionTabStops_experimental]&#39;,
			} );
		missionVariables.$TelescopeBetaLicence = ws.$BetaLicence;
	}
}

this._reloadFromStn = function _reloadFromStn( names, pages ) {		// callback fn for station_options
	var ws = worldScripts.telescope;

	ws._setLicenceMissionVar()
	if( pages &amp;&amp; pages.length &gt; 0 ) {
		ws._reload_config();
		if( names.indexOf( &#39;DebugMessages&#39; ) &gt;= 0 ) {
			ws._debug_Sightings_closure();
		}
	}
	if( ws.$DebugMessages ) {
		log(ws.name, &#39;_reloadFromStn, pages = &#39; + pages + &#39;\n\t names = &#39; + names );
		ws._report_config();
	}

/* ShowSummary is now an option
	var so = worldScripts.station_options;
	// retrieve summary reporting status to support conditional option ShowSummary
	if( so &amp;&amp; so.$O_getReminder4Oxp ) {
		var rmdr = so.$O_getReminder4Oxp( &#39;telescope_&#39; );
		if( rmdr ) {
			ws.$ShowSummary = rmdr.reportSummary;
log(&#39;_reloadFromStn, saving  ShowSummary: &#39; + ws.$ShowSummary );
		}
	}
 */
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// oxp support ////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

this.$Telescope_List = function $Telescope_List( step ) {			// not used here, ?for other oxp&#39;s (was used in telescopeeq.js)
	var that = $Telescope_List;
	var ws = (that.ws = that.ws || worldScripts.telescope);

	if( step )
		ws._chg_curr_Sighting( step );								// user steps fwd/back through list of Sightings
	else
		ws._auto_updates( true );									// user performs &#39;rescan&#39;
}

this.$Telescope_Scan = function _Scan() {							// not used here, ?for other oxp&#39;s
	var that = _Scan;
	var ws = (that.ws = that.ws || worldScripts.telescope);

if( ws.$DebugMessages ) log(ws.name, &#39;Telescope_Scan, FORCED new scan &#39;	 );
	ws._auto_updates( true );										// true forces a completely new mapping to be built
}

this.$Telescope_Show = function _Show() {							// not used here, ?for other oxp&#39;s
	var that = _Show;
	var ws = (that.ws = that.ws || worldScripts.telescope);

	ws.$Telescope_Show2( true );
}

this.$Telescope_Show2 = function _Show2( showname ) {				 // not used here, for other oxp&#39;s: EscortDeck
	var that = _Show2;
	var ws = (that.ws = that.ws || worldScripts.telescope);
	var mapping = (that.mapping = that.mapping || ws.$SightingsMap);
	var curr_S = (that.curr_S = that.curr_S || ws.$curr_Sighting);

	var map = null,
		index = ws.$TelescopeListi;
	if( index === 0 ) {
		index = curr_S.index;
	} else {
		index -= 1;				// TelescopeListi is always index + 1
	}
	map = index &gt;= 0 &amp;&amp; index &lt; mapping.length ? mapping[ index ] : null;
	ws._manage_marker( map, showname || false, &#39;_Show&#39; );
}

// HUDSelector ////////////////////////////////////////////////////////////////////////////////////

this.$HUDStartUpComplete = function() {
    if( !this.$HUDSelectorDefaultMFDs || this.$HUDSelectorDefaultMFDs.length === 0 ) {
        //set default MFDs first time in order of $HUDSelectorMFDs array
        this.$HUDSelectorDefaultMFDs = [];
        for(var i = 0; i &lt; this.$HUDSelectorMFDs.length; i++) {
            if(this.$HUDSelectorMFDs[i] &amp;&amp; this.$HUDSelectorMFDs[i][0]) {
                // var w = this.$HUDSelectorMFDs[i][0]; //worldScripts name
                // if( worldScripts[w] ) {
                    // this.$HUDSelectorDefaultMFDs[i] = w;
                // }
// $HUDSelectorSetMFDs assumes $HUDSelectorDefaultMFDs entries will be
//  [ worldScripts name, mfd name (maybe) ]
                let [w, m] = this.$HUDSelectorMFDs[i];
                if( worldScripts[w] ) {
                    this.$HUDSelectorDefaultMFDs[i] = m || w;
                }
            }
        }
    }
    log(this.name, &quot;HUDs: &quot;+this.$HUDSelectorHUDs);//debug
    if (this.$debug)
        for (var i=0; i&lt;this.$HUDSelectorHUDs.length; i++)
            log(this.name, i+&quot;: &quot;+this.$HUDSelectorHUDs[i]);
    this.$HUDSelectorRestoreHUD();
    this.$setInterface();
}

this.$HUDSelectorSetMFDs = function(h) {
	var dLen = h.$HUDSelectorDefaultMFDs.length,
		mLen = player.ship.multiFunctionDisplayList.length;
// must not exceed mLen else could fill empty slots when we wrap
//   for(var i = 0; i &lt; h.$HUDSelectorDefaultMFDs.length; i++) {
    for(var i = 0; i &lt; dLen &amp;&amp; i &lt; mLen; i++) {
//        log(h.name, i+&quot;. MFD: &quot;+h.$HUDSelectorDefaultMFDs[i]);//debug
        if(h.$HUDSelectorDefaultMFDs[i]) {
            var w = h.$HUDSelectorDefaultMFDs[i]; //worldScripts or MFD name
            var mfd = -1;
            if( w &amp;&amp; w.length &gt; 0 &amp;&amp; w != &quot;undefined&quot; ) {
                for(var j = 0; j &lt; h.$HUDSelectorMFDs.length; j++) {
                    if( h.$HUDSelectorMFDs[j][0] == w
                        || h.$HUDSelectorMFDs[j][1] == w ) mfd = j;
                }
            }
            var m = null;
            if( mfd &gt; -1) m = h.$HUDSelectorMFDs[mfd][1]; //MFD name
            if( !m ) m = w; //mfd name is equal with worldScripts name
            if( m &amp;&amp; worldScripts[w] &amp;&amp; w != &quot;undefined&quot; )
                player.ship.setMultiFunctionDisplay(i, m);
            else if( w &amp;&amp; w.length &gt; 0 ) player.ship.setMultiFunctionDisplay(i, w);
            else player.ship.setMultiFunctionDisplay(i, &quot;&quot;);
//            log(h.name, i+&quot;. MFD: &quot;+w+&quot; &quot;+m+&quot; &quot;+worldScripts[w]);//debug
        }
    }
}

/*
this.$HUDstartUpComplete = function() {
	var hud = worldScripts.hudselector,
		defaults = hud.$HUDSelectorDefaultMFDs,
		mfdDB = hud.$HUDSelectorMFDs;

	if( !defaults  ) {// should never happen
		hud.$HUDSelectorDefaultMFDs = defaults = [];
		log( this.name, &#39;$HUDstartUpComplete, WARNING: hud.$HUDSelectorDefaultMFDs array got deleted!&#39; )
	}
	if( defaults.length === 0 ) {
		//set default MFDs first time in order of $HUDSelectorMFDs array
		for( let idx = 0, len = mfdDB.length; idx &lt; len; idx++ ) {
			let [wsName, mfdName] = mfdDB[ idx ];	// an array of [worldScripts.name, mfdName], mfdName may be absent
			if( wsName &amp;&amp; worldScripts.hasOwnProperty( wsName ) ) {
				defaults[ idx ] = mfdName ? mfdName : wsName;
			}
		}
	}
	log( hud.name, &quot;HUDs: &quot;+hud.$HUDSelectorHUDs );//debug
	if( hud.$debug ) {
		for( let idx=0, len = hud.$HUDSelectorHUDs.length; idx &lt; len; idx++ )
			log( hud.name, idx + &quot;: &quot; + hud.$HUDSelectorHUDs[ idx ] );
	}
	hud.$HUDSelectorRestoreHUD();
	hud.$setInterface();
log(&#39;HUDstartUpComplete,    exit, MFDs: &#39; + hud.$HUDSelectorMFDs );
log(&#39;HUDstartUpComplete,   DefaultMFDs: &#39; + hud.$HUDSelectorDefaultMFDs );
log(&#39;HUDstartUpComplete, MFDisplayList: &#39; + player.ship.multiFunctionDisplayList );
}

// : &#39; +  + &#39;
this.$HUDSelectorSetMFDs = function( hud ) {
	if( !hud ) return;
	var mfdDB = hud.$HUDSelectorMFDs;								// nested array of MFDs registered with hudselector
	if( !mfdDB ) return;

	var ps = player &amp;&amp; player.ship,
		defaults = hud.$HUDSelectorDefaultMFDs;
	var slot = 0, numSlots = ps.multiFunctionDisplays,
		dLen = defaults.length, mLen = mfdDB.length;

	for( let dx = 0; dx &lt; dLen; dx++ ) { //  &amp;&amp; slot &lt; numSlots
		let wsName, mfdName,
			defName = defaults[ dx ]; 	//worldScripts name or MFD name
		if( defName &amp;&amp; defName != &quot;undefined&quot; ) {
			wsName = mfdName = null;
			for( let mx = 0; mx &lt; mLen; mx++ ) {
				[wsName, mfdName] = mfdDB[ mx ];
				if( mfdName == defName || wsName == defName ) {	// check MFD name first
					break;
				}
			}
			let key = mfdName || wsName;
			if( key &amp;&amp; defName != &quot;undefined&quot; &amp;&amp; worldScripts.hasOwnProperty( defName ) ) {
				ps.setMultiFunctionDisplay( slot++, key );
			} else if( defName &amp;&amp; defName.length &gt; 0 ) {
				ps.setMultiFunctionDisplay( slot++, defName );
			} else {
				ps.setMultiFunctionDisplay( slot, &quot;&quot; );
			}
		 log( hud.name, dx + &quot;. MFD: &quot; + defName + &quot; &quot; + key + &quot; &quot; + worldScripts[ defName ] );//debug
		}
	}
log(&#39;HUDSelectorSetMFDs,    exit, MFDs: &#39; + hud.$HUDSelectorMFDs );
log(&#39;HUDSelectorSetMFDs,   DefaultMFDs: &#39; + hud.$HUDSelectorDefaultMFDs );
log(&#39;HUDSelectorSetMFDs, MFDisplayList: &#39; + player.ship.multiFunctionDisplayList );
}

*/

// : &#39; +  + &#39;
this._registerHUDSelector = function _registerHUDSelector() {		// called in startUp
	var ws = worldScripts.telescope;
	var hud = worldScripts.hudselector;
	if( !hud ) return;
	var mfdDB = hud.$HUDSelectorMFDs;								// nested array of MFDs registered with hudselector

	var telName = worldScripts.telescope.name;
	for( let idx = 0, len = mfdDB.length; idx &lt; len; idx++ ) {
		// there is no $HUDSelectorRemoveMFD, so ...
		let [hudscript, mfdName] = mfdDB[ idx ];
		if( hudscript === telName &amp;&amp; !mfdName ) {					// set for telescope &lt;= 1.15
			for( let mvi = idx; mvi &lt; len - 1; mvi++ ) {			// remove from mfdDB
				mfdDB[ mvi ] = mfdDB[ mvi + 1 ];
			}
			mfdDB.length = --len;
		}
	}
	hud.$HUDSelectorAddMFD( telName, ws.$PrimaryMFD_name )
	hud.$HUDSelectorAddMFD( telName, ws.$AuxilaryMFD_name )
}

/*
this._registerHUDSelector = function _registerHUDSelector() {		// called in startUp
	var ws = worldScripts.telescope;
	var hud = worldScripts.hudselector;
	if( !hud ) return;
	var mfdDB = hud.$HUDSelectorMFDs;								// nested array of MFDs registered with hudselector
	if( !mfdDB ) return;

	var telName = worldScripts.telescope.name;
	var isOld = false, ver = hud.version.split( &#39;.&#39; );
	if( ver.length &gt; 1 &amp;&amp; parseInt( ver[ 1 ], 10 ) &lt; 18 )
		isOld = true;

	if( isOld ) {
		let changed = false, primary = false, auxilary = false;
		for( let idx = 0, len = mfdDB.length; idx &lt; len; idx++ ) {
			let [hudscript, mfdName] = mfdDB[ idx ];
			if( hudscript === telName ) {
				if( !mfdName || mfdName === telName ) {					// old telescope in saved game
					mfdDB[ idx ] = [ telName, ws.$PrimaryMFD_name ];	// replace (keep initial position)
					primary = changed = true;
				} else if( mfdName === &#39;telescopeAux&#39; ) {  				// old telescope in saved game
					mfdDB[ idx ] = [ telName, ws.$AuxilaryMFD_name ];	// replace (keep initial position)
					auxilary = changed = true;
				} else {												// detect new MFDs
					if( mfdName === ws.$PrimaryMFD_name )
						primary = true;
					else if( mfdName === ws.$AuxilaryMFD_name )
						auxilary = true;
				}
			}
		}
		if( !primary )
			mfdDB.push( [ telName, ws.$PrimaryMFD_name ] );
		if( !auxilary )
			mfdDB.push( [ telName, ws.$AuxilaryMFD_name ] );
		if( changed || !primary || !auxilary ) {
			hud.$HUDSelectorSetMFDs( hud );
		}
	} else {
/// once working, add some old version names &amp; see what needs doing
		for( let idx = 0, len = mfdDB.length; idx &lt; len; idx++ ) {
			let [hudscript, mfdName] = mfdDB[ idx ];
			if( hudscript === telName
					&amp;&amp; ( !mfdName || mfdName === hudscript 			// set for telescope &lt;= 1.15
						|| mfdName === &#39;telescopeAux&#39; ) ) {			// old telescope in saved game
				for( let mvi = idx; mvi &lt; len - 1; mvi++ ) {		// remove from mfdDB
					mfdDB[ mvi ] = mfdDB[ mvi + 1 ];
				}
				mfdDB.length = --len;
			}
		}
		hud.$HUDSelectorAddMFD( telName, ws.$PrimaryMFD_name )
		hud.$HUDSelectorAddMFD( telName, ws.$AuxilaryMFD_name )
	}
log(&#39;_registerHUDSelector,    exit, MFDs: &#39; + hud.$HUDSelectorMFDs );
log(&#39;_registerHUDSelector,   DefaultMFDs: &#39; + hud.$HUDSelectorDefaultMFDs );
log(&#39;_registerHUDSelector, MFDisplayList: &#39; + player.ship.multiFunctionDisplayList );
}

*/

///////////////////////////////////////////////////////////////////////////////////////////////////
// Telescope methods //////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

// inialization ///////////////////////////////////////////////////////////////////////////////////

this._init_Sightings_closure = function _init_Sightings_closure() {	// initialize closures &amp; expose functions
	var ws = worldScripts.telescope;

	var sc = ws._Sightings_closure();
	ws.$Sighting_closure = sc;

	ws._initOxpVars = sc._initOxpVars;
	ws._init_player_vars = sc._init_player_vars;
	ws._reload_config = sc._reload_config;
	ws._adjustMLFlags = sc._adjustMLFlags;
	ws._getShowState = sc._getShowState;
	ws._getShowStateText = sc._getShowStateText;
	ws._currMLFlags = sc._currMLFlags;
	ws._shutdown_Sightings = sc._shutdown_Sightings;
	ws._restart_after_shutdown = sc._restart_after_shutdown;
	ws._has_bad_status = sc._has_bad_status;
	ws._Sighting_index = sc._Sighting_index;
	ws._set_curr_Sighting = sc._set_curr_Sighting;
	ws._add_Sighting = sc._add_Sighting;
	ws._delete_Sighting = sc._delete_Sighting;
	ws._nearest_Sighting = sc._nearest_Sighting;
	ws._chg_curr_Sighting = sc._chg_curr_Sighting;
	ws._reposition_effects = sc._reposition_effects;
	ws._update_Sightings = sc._update_Sightings;
	ws._newList = sc._newList;
	ws._call_pending = sc._call_pending;
	ws._create_Sightings = sc._create_Sightings;
	ws._update_target_marker = sc._update_target_marker;
	ws._manage_marker = sc._manage_marker;
	ws._mostCentered = sc._mostCentered;
	ws._auto_updates = sc._auto_updates;
	ws._resetIdentDelay = sc._resetIdentDelay;
	ws._steerFCB = sc._steerFCB;
	ws._clear_HUD_Effects = sc._clear_HUD_Effects;
	ws._showVShip = sc._showVShip;
	ws._set_vShip_posn = sc._set_vShip_posn;
	ws._hud_effects = sc._hud_effects;
	ws._relativeDirection = sc._relativeDirection;
	ws._report_config = sc._report_config;
	ws._report_autovars = sc._report_autovars;
}

this._debug_Sightings_closure = function _debug_Sightings_closure() {	// expose debug functions
	var ws = worldScripts.telescope;

	var sc = ws.$Sighting_closure;

	if( !sc || !ws.$DebugMessages ) return;

	ws.reset_common_vars = sc.reset_common_vars;
	ws.index_in_list = sc.index_in_list;
	ws.getDetected = sc.getDetected;
	ws.is_hostile = sc.is_hostile;
	ws.grav_scan_dist = sc.grav_scan_dist;
	ws.check_Sightings = sc.check_Sightings;
	ws.select_Sightings = sc.select_Sightings;
	ws.add_lt_ball = sc.add_lt_ball;
	ws.lb_effect_size = sc.lb_effect_size;
	ws.update_lt_ball = sc.update_lt_ball;
	ws.add_ml_ring = sc.add_ml_ring;
	ws.ml_effect_size = sc.ml_effect_size;
	ws.update_ml_ring = sc.update_ml_ring;
	ws.proc_stealthy = sc.proc_stealthy;
	ws.update_one_Sighting = sc.update_one_Sighting;
	ws.update_some = sc.refresh_Sightings;
	ws.classify_ship = sc.classify_ship;
	ws.is_ignored_ship = sc.is_ignored_ship;
	ws.process_new_targets = sc.process_new_targets;
	ws.fns_are_pending = sc.fns_are_pending;
	ws.set_fn_pending = sc.set_fn_pending;
	ws.clear_all_pending = sc.clear_all_pending;
	ws.show_pending = sc.show_pending;
	ws.grow_new_list = sc.grow_new_list;
	ws.notable_ent = sc.notable_ent;
	ws.check_if_new_targets = sc.check_if_new_targets;
	ws.update_MFDs = sc.update_MFDs;
	ws.qualifyMFD = sc.qualifyMFD;
	ws.set_displayName = sc.set_displayName;
	ws.showTargetName = sc.showTargetName;
	ws.showShipReport = sc.showShipReport;
	ws.entityIsNamed = sc.entityIsNamed;
	ws.planetIsNamed = sc.planetIsNamed;
	ws.sunName = sc.sunName;
	ws.orbName = sc.orbName;
	ws.planetNameString = sc.planetNameString;
	ws.report_scan_progress = sc.report_scan_progress;
}

this._StartTimer = function _StartTimer( delay ) {
	var that = _StartTimer;
	var ws = (that.ws = that.ws || worldScripts.telescope);

	var ps = player &amp;&amp; player.ship;
	if( !ps ) return;
	if( ps.equipmentStatus(&#39;EQ_TELESCOPE&#39;) === &#39;EQUIPMENT_OK&#39; ) {
		//AutoScan timer get targets from normal scanner and do scan if a new target is visible
		//need at least 1 sec delay when called from shipWillExitWitchspace to avoid many gray balls
		if( ws.$Timer_auto_updates || ws.$Sighting_events_FCB ) {
			ws._StopTimer();
		}
		ws.$Timer_auto_updates = new Timer( ws, ws._auto_updates, delay, 0.25 );
		ws.$Sighting_events_FCB = addFrameCallback( ws._Sighting_events.bind(ws) );
	}
}

this._StopTimer = function _StopTimer() {
	var that = _StopTimer;
	var ws = (that.ws = that.ws || worldScripts.telescope);

	let timer = ws.$Timer_auto_updates;
	if( timer ) {
		if( timer.isRunning ) {
			timer.stop();
		}
		ws.$Timer_auto_updates = null;								// discard Timer as timer == null =&gt; docked or in witchspace
	}
	let fcb = ws.$Sighting_events_FCB;
	if( fcb ) {
		if( isValidFrameCallback( fcb ) ) {
			removeFrameCallback( fcb );
		}
		ws.$Sighting_events_FCB = null;
	}
}

/*		(function () {	//	IIFE for re-loading _Sighting_events
	if( isValidFrameCallback( ws.$Sighting_events_FCB ) )
		removeFrameCallback( ws.$Sighting_events_FCB );
	ws.$Sighting_events_FCB = addFrameCallback( ws._Sighting_events.bind( ws ) );
})()
//*/

this._Sighting_events = function _Sighting_events( delta ) {		//delta is the time since the last frame
	function fps_missisng() { return -1 }

	var that = _Sighting_events;
	var ws = (that.ws = that.ws || worldScripts.telescope);
	var short_term_fps = (that.short_term_fps = that.short_term_fps || ws.$fps_closure ? ws.$fps_closure._short_term_fps : fps_missisng);
	var reset_fps_mon =	 (that.reset_fps_mon  = that.reset_fps_mon	|| ws.$fps_closure ? ws.$fps_closure._reset_fps_monitor : fps_missisng);
	if( that.speedup_tried === undefined ) that.speedup_tried = false;// persistent flag for speed-up attempt
	if( that.speedup_fps === undefined ) that.speedup_fps = -1;		// persistent variable for short_term_fps value
	if( that.tasks === undefined ) that.tasks = 1;					// persistent # of pending tasks processed each frame

	if( !ws._init_player_vars() ) return;							// equipment damaged, nothing to do

	var speedup_tried = that.speedup_tried,
		speedup_fps = that.speedup_fps,
		tasks = that.tasks;

	ws._update_target_marker();										// must be 1st, as set variables used by followng (eg. target_vector)
	if( ws.$are_Steering ) {										// steering must preceed _hud_effects
		ws._steerFCB( delta );
	}
	ws._hud_effects( delta );
	ws._reposition_effects();
	if( !speedup_tried ) {											// reduce overhead if tried &amp; failed
		let fps = short_term_fps();
		if( fps &gt; 0 ) {												// takes 2 minutes to get 1st report
			if( ws.$DebugMessages ) log(ws.name, &#39;_Sighting_events, got fps of &#39; + fps );
			reset_fps_mon( delta, true );							// restart &amp; wipe data to have another 2 minute wait
			if( speedup_fps &lt; 0 ) {									// 1st time through
				if( fps &gt; 65 ) {									// candidate for processing 2 tasks (2.38+ ms/frame diff)
					that.speedup_fps = fps;
					that.tasks = 2;									// try faster rate
					if( ws.$DebugMessages ) log(ws.name, &#39;_Sighting_events, trying out &#39;
											   + that.tasks + &#39; tasks/frame&#39; );
				} else {											// 1st reading was low, shut down checking on slower machines
					that.tasks = 1;
					that.speedup_tried = true;
					if( ws.$DebugMessages ) log(ws.name, &#39;_Sighting_events, running too slow (&#39; + fps
											   + &#39;) for trial of higher tasks/frame&#39; );
				}
			} else {												// back after another 2 minutes
				if( fps &lt;= 60 ) {									// extra task caused frame rate to fall too much
					that.tasks = 1;									// revert to single task each frame
					that.speedup_tried = true;
					if( ws.$DebugMessages ) log(ws.name, &#39;_Sighting_events, fps cost too high(&#39;
											   + speedup_fps + &#39; -&gt; &#39; + fps + &#39;), reverting to &#39;
											   + that.tasks + &#39; tasks/frame&#39; );
				} else {											// still over 60, keep new rate &amp; shut down checking
					that.speedup_tried = true;
					if( ws.$DebugMessages ) log(ws.name, &#39;_Sighting_events, fps still over 60 (&#39; + fps
											   + &#39;), continuing with &#39; + that.tasks + &#39; tasks/frame&#39; );
				}
			}
		}
	}
	ws._call_pending( tasks );
}

// mode/activate methods //////////////////////////////////////////////////////////////////////////

this.$SET_LIGHTBALLS = 1;											// bit flags to reinit cached $UserChangedSettings
this.$SET_MASSLOCKRINGS = 2;
this.$SET_SNIPER = 4;
this.$SET_STEERING = 8;
this.$SET_TARGETS = 16;
this.$SET_VISUAL = 32;
this.$SET_VISUAL_SIZE = 64;

this._getOldLightballs = function _getOldLightballs() { 			// return values expected by 1.15
	var that = _getOldLightballs;
	var ws = ( that.ws = that.ws || worldScripts.telescope );
/*
	subitem:			1		2				3				4				5						6
	version 1.15
	[ &quot;Lightballs:&quot;, &quot;off&quot;, &quot;navigation only&quot;, &quot;ships&quot;, &quot;masslock borders&quot;, &quot;bright masslock borders&quot;, &quot;large&quot; ],
	version 2
	[ &quot;Lightballs:&quot;, &quot;off&quot;, &quot;navigation only&quot;, &quot;include ships&quot;, &quot;large&quot; ],
	[ &quot;Masslock rings:&quot;, &quot;current alert/weapons state: off&quot;, &quot;current alert/weapons state: on&quot;, &quot;brighter&quot; ],
 */
	var subitem = 1;	//off
	if( ws.$LightBalls ) 			subitem = 2;
	if( ws.$ShipLightBalls ) 		subitem = 3;
	if( ws.$MassLockRings &amp;&amp; ws.$LightBalls &amp;&amp; ws.$ShipLightBalls )	{// don&#39;t turn on LightBalls &amp; ShipLightBalls if MassLockRings
		// lesser of evils: it&#39;s an inperfect mapping from 1.15&#39;s list of bools to v2&#39;s situational masslock rings
		subitem = 4;
	}
	if( ws.$BrightMassLockRings )	subitem = 5;
	if( ws.$LargeLightBalls ) 		subitem = 6;					// will turn on (bright) masslock rings &lt;meh&gt;
	return subitem;
}
// : &#39; +  + &#39;

this._oldSetLightballs = function _oldSetLightballs( subitem ) { 	// handle as 1.15 would; 2.0 changes will overwrite
	var that = _oldSetLightballs;
	var ws = ( that.ws = that.ws || worldScripts.telescope );

//	if( subitem === 1 ) { //off
	ws.$LightBalls = 			subitem &gt;= 2;						//ship off
	ws.$ShipLightBalls = 		subitem &gt;= 3;						//small
	ws.$MassLockRings = 		subitem &gt;= 4 ? this.$DEFAULT_ML_RINGS : 0;
	ws.$BrightMassLockRings = 	subitem &gt;= 5;						//use brighter borders
	ws.$LargeLightBalls = 		subitem &gt;= 6;						//large
}

this._SetLightballs = function _SetLightballs( subitem ) {			//set config variables from telescopeeq.js also
	var that = _SetLightballs;
	var ws = (that.ws = that.ws || worldScripts.telescope);

	ws.$UserChangedSettings |= ws.$SET_LIGHTBALLS;					// set bit flag to reinit _Sightings_closure cached vars
	ws.$DamageMsg = true;
	ws.$LightBalls =			subitem &gt;= 2;						//ship off
	ws.$ShipLightBalls =		subitem &gt;= 3;						//small
	ws.$LargeLightBalls =		subitem &gt;= 4;						//large
	if( ws._update_Sightings )
		ws._update_Sightings( true );

}

this._SetMasslockRings = function _SetMasslockRings( subitem ) {	//set config variables from telescopeeq.js also
	var that = _SetMasslockRings;
	var ws = (that.ws = that.ws || worldScripts.telescope);

	ws.$UserChangedSettings |= ws.$SET_MASSLOCKRINGS;				// set bit flag to reinit _Sightings_closure cached vars
	ws.$DamageMsg = true;
	// ws.$MassLockRings =		subitem &gt;= 2;
	// MassLockRings is no longer a boolean but a set of bitflags
	if( subitem &gt;= 2 ) {											// enabling masslock rings
		ws._adjustMLFlags( true );									// add current state to flags
	} else {														// disabling masslock rings
		ws._adjustMLFlags( false );									// remove current state from flags
	}
	ws.$BrightMassLockRings = 	subitem &gt;= 3;						//use brighter borders
	if( ws._update_Sightings )
		ws._update_Sightings( true );
}

this._SetSniper = function _SetSniper( subitem ) {
	var that = _SetSniper;
	var ws = (that.ws = that.ws || worldScripts.telescope);

	ws.$UserChangedSettings |= ws.$SET_SNIPER;						// set bit flag to reinit _Sightings_closure cached vars
	ws.$DamageMsg = true;
	if( subitem === 1 ) { //off
		ws.$SniperRange = 10000;
		ws.$SniperMinRange = 10000;
	} else {
		var minitem = subitem;
		if( subitem &lt; 5 )
			ws.$SniperRange = 25600;
		else {
			minitem = subitem - 3;
			ws.$SniperRange = 30000;
		}
		ws.$SniperMinRange = 5000 * ( minitem - 1 );				//5, 10 or 15km
	}
}

this._SetSteering = function _SetSteering( subitem ) {
	var that = _SetSteering;
	var ws = (that.ws = that.ws || worldScripts.telescope);

	ws.$UserChangedSettings |= ws.$SET_STEERING;					// set bit flag to reinit _Sightings_closure cached vars
	ws.$DamageMsg = true;
	ws.$Steering = subitem - 1;
}

this._SetTargets = function _SetTargets( subitem ) {
	var that = _SetTargets;
	var ws = (that.ws = that.ws || worldScripts.telescope);

	ws.$UserChangedSettings |= ws.$SET_TARGETS;						// set bit flag to reinit _Sightings_closure cached vars
	ws.$DamageMsg = true;
	if( subitem === 1 ) {											//20 and limitation in red alert
		ws.$MaxTargets = 20;
	} else {
		if( subitem === 2 )
			ws.$MaxTargets = 50;
		else if( subitem === 3 )
			ws.$MaxTargets = 100;
		else
			ws.$MaxTargets = 200;
	}
}

this._SetVisual = function _SetVisual( subitem ) {
	var that = _SetVisual;
	var ws = (that.ws = that.ws || worldScripts.telescope);

	ws.$UserChangedSettings |= ws.$SET_VISUAL;						// set bit flag to reinit _hud_effects_closure cached vars
	ws.$DamageMsg = true;
	if( subitem === 1 ) {
		ws.$ShowVisualTarget = 0;									// always off
	} else if( subitem === 2 ) {
		ws.$ShowVisualTarget = 1;									// on only when weapons off-line
	} else {
		ws.$ShowVisualTarget = 2;									// always on
	}
	ws.$VisualTargetRing = subitem &gt; 3;
	ws.$TelescopeRing = subitem &gt; 3;								// maintain for oxps
	ws.$ShowVisualStation = subitem &gt; 4;							//no station
	ws.$ShowVisualQuestionMark = subitem &gt; 5;						//no &quot;?&quot;
}

this._SetVisualSize = function _SetVisualSize( subitem ) {
	var that = _SetVisualSize;
	var ws = (that.ws = that.ws || worldScripts.telescope);

	ws.$UserChangedSettings |= ws.$SET_VISUAL_SIZE;					// set bit flag to reinit _hud_effects_closure cached vars
	ws.$DamageMsg = true;
	if( ws.$VisualTargetCombatSize !== 0 ) {						// not disabled in station options
		ws.$VisualTargetCombatSize = subitem;						//1-8
		ws.$TelescopeVSize = subitem;								// maintain for oxps
	}
	if( ws.$VisualTargetNormalSize !== 0 ) {						// not disabled in station options
		ws.$VisualTargetNormalSize = subitem;						//1-8
		ws.$TelescopeVZoomSize = subitem;							// maintain for oxps
	}
}

// miscellaneous methods //////////////////////////////////////////////////////////////////////////////

this._AddShips = function _AddShips() {								// add ships/aliens for debugging
	var that = _AddShips;
	var ws = (that.ws = that.ws || worldScripts.telescope);
	var wop = (that.wop = that.wop || worldScripts[ &quot;oolite-populator&quot; ]);

	if( ws.$DebugMessages &amp;&amp; !system.isInterstellarSpace ) { //need check due to called from shipWillExitWitchspace also
		//system.addShips(&quot;shuttle&quot;, 1, system.mainStation.position, 50000);//demo visible target
		//system.addShips(&quot;trader&quot;, 1, system.mainStation.position, 20000);//demo near target
		wop._addFreighter( system.mainStation );
		wop._addMediumHunterReturn( system.mainStation );
/* for specific ship model, enclose model name in [], eg. addShips(&#39;[vector_geek]&#39;, ...)
		system.addShips(&quot;asteroid&quot;, 10, system.mainStation.position, 20000);//test rock target
		system.addShips(&quot;rescue_station&quot;, 1, system.mainStation.position, 20000);//test custom station
		system.addShips(&quot;rescue_blackbox&quot;, 1, system.mainStation.position, 10000);//test custom ship
		system.addShips(&quot;rescue_blackbox_generic&quot;, 1, system.mainStation.position, 10000);//test custom ship
		system.addShips(&quot;stealth_base&quot;, 1, system.mainStation.position, 20000);//test custom station
		system.addShips(&quot;stealth_barracuda&quot;, 1, system.mainStation.position, 10000);//test stealth ship
		system.addShips(&quot;stealth_mine&quot;, 1, system.mainStation.position, 20000);//test stealth mine
		system.addShips(&quot;vector_areidisAlpha&quot;, 1, system.mainStation.position, 20000);//test custom station
		system.addShips(&quot;vector_arn&quot;, 1, system.mainStation.position, 10000);//test custom ship
		system.addShips(&quot;griff_NPC_prototype_boa_decals_from_red_channel&quot;,
			1, system.mainStation.position, 10000);//test visual effect shader uniforms, need Griff Boa OXP
 */
	}

	if( ws.$Thargoids ) { //test Telescope in instant action
		system.addShips(&quot;tharglet&quot;, 4, system.mainStation.position, 30000);
		system.addShips(&quot;thargoid&quot;, 4, system.mainStation.position, 30000);
//			system.addShips(&quot;police&quot;, 4, system.mainStation.position, 30000);
		player.ship.scriptedMisjump = true; //meet Thargoids in the next hyperjump also
	}
}

this._reportError = function _reportError( err, func, parms, depth, goDeep ) {
	// constants - adjust as needed
	var FILE_LEN = 100;		// cut-off len for file spec.
	var FNAME_LEN = 40;		// cut-off len for function name
	var ARGS_LEN = 60;		// cut-off len for arguments string
	var STRING_LEN = 120;	// cut-off for long strings
	var IPAD = &#39; &#39;;			// inside padding, eg. after array open bracket, before close bracket

	function trim_str( str ) {
		var result, len = str.length;
		if( len === 0 )
			return &#39;&lt;empty string&gt;&#39;;
		result = str.replace( /[\u180e\u2000-\u200a\u202f\u205f\u3000]+/g, &#39; &#39; );
		result = result.replace( /[\n]+/g, &#39;\\n&#39; ).replace( /[\t]+/g, &#39;\\t&#39; )
		result = &#39;&quot;&#39; + (len &gt; STRING_LEN ? result.substr(0, STRING_LEN) + &#39; ...&#39; : result) + &#39;&quot;&#39;;
		return result
	}

	var padding = [];
	function mkSpacePad( count ) {
		if( typeof count === &#39;number&#39; ) {
			padding.length = count + 1;
			return padding.join(&#39; &#39;);
		}
		return &#39; &#39;;
	}

	function countObjKeys( obj, deep ) {	// Object.keys( obj ).length only counts hasOwnProperty ones
		var count = 0;						// deep overrides goDeep
		if( goDeep || deep ) {
			for( let prop in obj )
				if( prop )					// this is just to silence JSLint
					count++;
		} else {
			count = Object.keys( obj ).length;
		}
		return count;
	}

	function rptType( obj ) {
		if( Array.isArray( obj ) ) {
			let len = obj.length;
			return len &gt; 0 ? &#39;&lt;array of &#39; + len + &#39;&gt;&#39; : &#39;[]&#39;;
		} else if( obj instanceof Script ) {
			return &#39;[Script &quot;&#39; + obj.name + &#39;&quot; version &#39; + obj.version + &#39;]&#39;;
		} else if( typeof obj === &#39;object&#39; ) {
			let len = countObjKeys( obj, true );	// ignore goDeep when counting
			return len &gt; 0 ? &#39;&lt;object of &#39; + len + &#39;&gt;&#39; : &#39;{}&#39;;
		} else {
			return obj;
		}
	}

	function hasComplex( obj ) {
		for( let prop in obj ) {
			if( goDeep || obj.hasOwnProperty( prop ) ) {
				let item = obj[ prop ];
				if( Array.isArray( item ) || (typeof item === &#39;object&#39; &amp;&amp; item !== null) )
					return true;
			}
		}
		return false;
	}

	function showComplex( obj, recurse ) {
		var isArray = Array.isArray( obj );
		var len = isArray ? obj.length : countObjKeys( obj );
		if( len === 0 ) return isArray ? &#39;[]&#39; : &#39;{}&#39;;
		var index = 0,
			str = (isArray ? &#39;[&#39; : &#39;{&#39;) + IPAD,
			strLen = str.length;
		var recursable = recurse &gt; 0 &amp;&amp; hasComplex( obj );
		for( let prop in obj ) {
			if( goDeep || obj.hasOwnProperty( prop ) ) {
				let item = obj[ prop ];
				let propStr = isArray ? &#39;&#39; :
							(goDeep &amp;&amp; !obj.hasOwnProperty( prop ) ? &#39;^&#39; : &#39;&#39;) + prop + &#39;: &#39;;
				let propLen = propStr.length;
				str += propStr;
				if( recursable ) {
					if( index === 0 ) {
						outStarts.push( (outStarts.length &gt; 0
										? outStarts[outStarts.length-1] + propLen + strLen
										: strLen + propLen + strLen) );
					}
					str += fmt_parm( item, recurse );
					if( index &lt; len - 1 ) {		// not the last one
						let inset = outStarts.length &gt; 1 ? outStarts[outStarts.length-2] : strLen;
						str += &#39;,\n&#39; + mkSpacePad( indentLen + inset );
					} else {
						str += IPAD;
					}
				} else {
					str += hasComplex( item ) ? rptType( item ) : fmt_parm( item, 0 );
					str += index &lt; len - 1 ? &#39;, &#39; : IPAD;
				}
				index++;
			}
		}
		if( recursable &amp;&amp; index ) outStarts.pop();
		return str + (isArray ? &#39;]&#39; : &#39;}&#39;);
	}

	var outStarts = [];	// stack of running total of recursed insets
	var parents = [];	// check parm not in parents to avoid endless recursion
	function fmt_parm( parm, recurse ) {
		if( parents.indexOf( parm ) &lt; 0 ) {
			parents.push( parm );
		} else  {
			return parm;
		}
		var type = typeof parm;
		var str = &#39;&#39;;
		if( parm === null ) {
			str += &#39;null&#39;;
		} else if( type === &#39;undefined&#39; ) {
			str += &#39;undefined&#39;;
		} else if( type === &#39;string&#39; ) {
			str += trim_str( parm );
		} else if( type === &#39;boolean&#39; ) {
			str += (parm ? &#39;true&#39; : &#39;false&#39;);
		} else if( type === &#39;function&#39; ) {
			str += &#39;function &#39; + parm.name + &#39;()&#39;;
		} else if( parm instanceof Script ) {
			str += &#39;[Script &quot;&#39; + parm.name + &#39;&quot; version &#39; + parm.version + &#39;]&#39;;
		} else if( parm instanceof Vector3D ) {
			str += &#39;Vector3D: (&#39; + parm.x.toFixed() + &#39;, &#39;
					+ parm.y.toFixed() + &#39;, &#39; + parm.z.toFixed() + &#39;)&#39;;
		} else if( parm instanceof Quaternion ) {
			str += &#39;Quaternion: (&#39; + parm.w.toFixed() + &#39; + &#39; + parm.x.toFixed() + &#39;i + &#39;
					+ parm.y.toFixed() + &#39;j + &#39; + parm.z.toFixed() + &#39;k)&#39;;
		} else if( Array.isArray( parm ) ) {
			str += showComplex( parm, recurse &lt;= 1 ? 0 : recurse - 1 );
		} else if( type === &#39;object&#39; &amp;&amp; parm ) {
			str += showComplex( parm, recurse &lt;= 1 ? 0 : recurse - 1 );
		} else {
			str += rptType( parm );
		}
		parents.pop();
		return str;
	}

	var funcProps = {};
	function propsNotName( obj ) {
		if( typeof obj !== &#39;function&#39; ) return 0;	// backwards compatibity
		for( let key in funcProps ) {				// reset object
			if( funcProps.hasOwnProperty( key ) )
				delete funcProps[ key ];
		}
		for( let key in obj ) {
			if( key !== &#39;name&#39; )
				funcProps[ key ] = obj[ key ];
		}
		return Object.keys( funcProps ).length;
	}

	var parmsLabel = &#39;\n    parameters: &#39;;
	var indentLen = parmsLabel.length - 1;	// -1 for \n
	var fnName = typeof func === &#39;function&#39; ? func.name : func; // backwards compatibity
	var rpt, parmMax, propMax,
		bonus = Array.isArray( parms ) ? 1 : 0;			// don&#39;t count parms being an array as recursion (+ 1)
	if( Array.isArray( depth ) ) {
		parmMax = (depth.length &gt; 0 &amp;&amp; typeof depth[ 0 ] === &#39;number&#39; ? ~~(depth[ 0 ]) : 1) + bonus;
		propMax = (depth.length &gt; 1 &amp;&amp; typeof depth[ 1 ] === &#39;number&#39; ? ~~(depth[ 1 ]) : 1) + bonus;
	} else {
		parmMax = propMax = (typeof depth === &#39;number&#39; ? ~~(depth) : 1) + bonus;
	}
	if( err instanceof Error ) {
		rpt = &#39;\nfunction &#39; + fnName + &#39;() \t caught: \t&#39; + err.name + &#39;: &#39; + err.message;
	} else {		// for thrown strings (user defined errors)
		rpt = &#39;\nfunction &#39; + fnName + &#39;() \t caught: \t&#39; + err;
	}
	if( parms ) {
		rpt += parmsLabel + fmt_parm( parms, parmMax );
	}
	if( propsNotName( func ) ) {
		parmsLabel = &#39;\n    properties: &#39;;
		indentLen = parmsLabel.length - 1;	// -1 for \n
		rpt += parmsLabel + fmt_parm( funcProps, propMax + 1 );	// + 1 as funcProps is an object
	}

	// err is the stack object with properties: message, fileName, lineNumber, stack, name
	//  - stack is a long string containing &lt;function call&gt;@&lt;filename&gt;:&lt;line #&gt; separated by
	//    &#39;\n&#39; for each call in the stack
	if( err &amp;&amp; err.stack ) {
		var lastFile, parsed, frame, fnCall, args, file, line, pad;
		var stk = err.stack.split( /[\n\r]+/ ); // split on line breaks
		for( let idx = 0, len = stk.length; idx &lt; len; idx ++ ) {
			// stack line format: fn(parms)@../AddOns/.../script.js:123
			parsed = stk[ idx ].match( /^\s*(\w+)\((.*?)\)@(.*?):(.*?)$/ );
			if( !parsed || parsed.length &lt; 5 ) break;
			[frame, fnCall, args, file, line] = parsed;
			if( file &amp;&amp; file !== lastFile ) {	// suppress repeat of same filename
				if( file.length &gt; FILE_LEN )
					file = file.substring( file.length - FILE_LEN ) + &#39;...&#39;;
				rpt += &#39;\n    file: &#39; + file;
				lastFile = file;
			}
			pad = line &lt; 10 ? &#39;   &#39; : line &lt; 100 ? &#39;  &#39; : line &lt; 1000 ? &#39; &#39; : &#39;&#39; ;
			rpt += &#39;\n        line: &#39; + pad + line + &#39;,	&#39;;
			if( fnCall.length &gt; FNAME_LEN ) fnCall = fnCall.substring(0, FNAME_LEN) + &#39;...&#39;;
			if( args.length &gt; ARGS_LEN ) args = args.substring(0, ARGS_LEN) + &#39;...&#39;;
			if( args.length ) 					// add spaces inside function&#39;s parenthices
				args = &#39; &#39; + args.replace( /,/g, &#39;, &#39; ) + &#39; &#39;;
			rpt += fnCall + &#39;(&#39; + args + &#39;)&#39;;
		}
	}
	return rpt;
}

/*	profiling in debug console
ws.set_profiling()
ws.clear_profiling()

ws._delete_Sighting( PS.target )
:time ws._delete_Sighting( PS.target )

ws._add_Sighting( PS.target )
:time ws._add_Sighting( PS.target )

ws._create_Sightings();
:time ws.grow_new_list( &#39;start&#39;, false	)
:time ws.update_some( 2 )
:time ws._call_pending( 1 )
ws.time_create()

ws._report_config()
ws._report_autovars()
*/

//	(function () {ws.$VisualTargetRing = true; ws.$UserChangedSettings = 63;})()
//	(function () {ws.$VisualTargetRing = false; ws.$UserChangedSettings = 63;})()

///////////////////////////////////////////////////////////////////////////////////////////////////
// Telescope closure //////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

/*		(function () {	// telescope IIFE for reloading new _Sightings_closure
    var ws = worldScripts.telescope;
    console.clearConsole();
    ws._StopTimer();
    ws._shutdown_Sightings();
    ws._init_Sightings_closure();
    // for debugging  Sighting
    if (ws.$DebugMessages) {
        ws._debug_Sightings_closure();
    }

//ws.time_create = sc.time_create;					ws.time_update = sc.time_update;				//cagiife
//ws.time_refresh = sc.time_refresh;				ws.profile_create = sc.profile_create;		  //cagiife
//ws.profile_update = sc.profile_update;			ws.profile_refresh = sc.profile_refresh;		//cagiife
//ws.set_profiling = sc.set_profiling;				ws.clear_profiling = sc.clear_profiling;			//cagiife


	ws._initOxpVars();
	log(&quot;calling _set_vShip_posn(&quot; + ps.viewPositionForward + &quot;, &quot; + ws.$VTarget_HUD_shift + &quot;)&quot;);
	ws._set_vShip_posn( ps.viewPositionForward, ws.$VTarget_HUD_shift );
	log(&quot;after calling _set_vShip_posn(&quot; + ps.viewPositionForward + &quot;, &quot; + ws.$VTarget_HUD_shift + &quot;)&quot;);

// NB: these are basically shipLaunchedFromStation, so comment out if testing involves launch
	ws._init_player_vars( true );
	ws._restart_after_shutdown();
	ws._create_Sightings();
	ws._StartTimer(1);
})()	// */


// ^gui screen.*?[\w\s]+(?=[\n]^[^g])
// : &#39; +  + &#39;

this._Sightings_closure = function _Sightings_closure() {
	// oxp &#39;constant&#39; variables
	var ws = worldScripts.telescope;
	var AstroLibrary, Carriers, Combat_MFD, Escortdeck, FarPlanets,
		GalacticAlmanac, GalNavy, ILS, Navigation_MFD,
		SniperLock, SniperLockPlus, SpicyHermits, TorusToSun, Towbar,
		VariableMassLock, VimanaHUD, WarpDrive,
		add_Sighting_errors,
		short_term_fps, long_term_fps, current_fps,
		turn_off_fps_monitor, turn_on_fps_monitor, realtime_fps;
		// must be set after all oxp&#39;s loaded, ie. startUpComplete, not startUp where this closure is created

	// game &#39;constant&#39; variables
	var gameSettings = oolite.gameSettings,
		gameWindow = gameSettings.gameWindow,						// can be changed via options menu
		fov = gameSettings.fovValue,								// can be changed via options menu
		sin_fov2, cos_fov2,
		strFontLen = defaultFont.measureString,
		SpaceLen = strFontLen( &#39; &#39; );

	// math function references
	var floor = Math.floor, round = Math.round, ceil = Math.ceil,
		sqrt = Math.sqrt, pow = Math.pow, ln = Math.log,
		sin = Math.sin, cos = Math.cos, acos = Math.acos,
		asin = Math.asin, random = Math.random, abs = Math.abs;

	const LOG10E = Math.LOG10E;
	function log10( num ) { 										// base 10 logarithm of num
		return ln( num ) * LOG10E;
	}

	// function references
	var entitiesWithScanClass = system.entitiesWithScanClass,
		addVisualEffect = system.addVisualEffect,
		addShips = system.addShips,
		consoleMessage = player.consoleMessage,
		isArray = Array.isArray;

	// user settable &#39;constant&#39; variables
	var AutoScan = ws.$AutoScan,
		AutoScanMaxRange = ws.$AutoScanMaxRange,
		GravLock = ws.$GravLock,
		AutoLock = ws.$AutoLock,
		IdentLock = ws.$IdentLock,
		IdentDelay = ws.$IdentDelay,

		FarStatus = ws.$FarStatus,
		MaxTargets = ws.$MaxTargets,								// can config in flight
		RedAlertDist = ws.$RedAlertDist,
		Steering = ws.$Steering,									// can config in flight

		LightBalls = ws.$LightBalls,								// can config in flight
		ShipLightBalls = ws.$ShipLightBalls,						// can config in flight
		LargeLightBalls = ws.$LargeLightBalls,						// can config in flight
		LightBallMinDist = ws.$LightBallMinDist,
		LightBallShipMinDist = ws.$LightBallShipMinDist,

		MassLockRings = ws.$MassLockRings,							// can config in flight
		MassLockViewDirn = ws.$MassLockViewDirn,
		BrightMassLockRings = ws.$BrightMassLockRings,				// can config in flight

		SniperRingSize = ws.$SniperRingSize,
		SniperRingActive = ws.$SniperRingActive,					// new
		SniperRange = ws.$SniperRange,								// can config in flight
		SniperMinRange = ws.$SniperMinRange,						// can config in flight
		SniperRingColor = ws.$SniperRingColor,

		ShowVisualTarget = ws.$ShowVisualTarget,					// can config in flight
		VisualTargetNormalSize = ws.$VisualTargetNormalSize,		// can config in flight
		VisualTargetCombatSize = ws.$VisualTargetCombatSize,		// can config in flight
		VisualTargetRing = ws.$VisualTargetRing,					// can config in flight

		ShowVisualStation = ws.$ShowVisualStation,					// can config in flight
		ShowVisualQuestionMark = ws.$ShowVisualQuestionMark,		// can config in flight
		ModelRingColor = ws.$ModelRingColor,
		// VTarget_HUD_shift is not used in closure but passed in during shipWillLaunchFromStation

		// new/ui
		ConsoleMsgDurn = ws.$ConsoleMsgDurn,
		GravScanMsgFreq = ws.$GravScanMsgFreq,
		IdentMessages = ws.$IdentMessages,
		// ShowSummary is not used in closure; it&#39;s the reportSummary bool from station_options
		debug = ws.$DebugMessages,

		// new/experimental
		TargetOnlyHostile = ws.$TargetOnlyHostile,
		RemoveInFlight = ws.$RemoveInFlight,
		MFDFiltering = ws.$MFDFiltering,
		MFDPrimaryStatic = ws.$MFDPrimaryStatic,
		MFDPrimaryDynamic = ws.$MFDPrimaryDynamic,
		SeparateMFDs = ws.$SeparateMFDs,
		MFDAuxStatic = ws.$MFDAuxStatic,
		MFDAuxDynamic = ws.$MFDAuxDynamic;

	// flags for variables modifiable via activated event - see init_player_vars
	const SET_LIGHTBALLS = ws.$SET_LIGHTBALLS,
		  SET_MASSLOCKRINGS = ws.$SET_MASSLOCKRINGS,
		  SET_SNIPER = ws.$SET_SNIPER,
		  SET_STEERING = ws.$SET_STEERING,
		  SET_TARGETS = ws.$SET_TARGETS,
		  SET_VISUAL = ws.$SET_VISUAL,
		  SET_VISUAL_SIZE = ws.$SET_VISUAL_SIZE;

	// player&#39;s alertCondition
	const DOCKED = 0, GREEN_ALERT = 1, YELLOW_ALERT = 2, RED_ALERT = 3;

	// gravity scan state
	const GS_NONE = 0, GS_STOPPED = 1, GS_RUNNING = 2, GS_DEGRADING = 3, GS_COMPLETE = 4;

	// index used to calc bitflags for masslock view direction
	const VIEWS_LIST = [ &#39;VIEW_FORWARD&#39;, &#39;VIEW_AFT&#39;, &#39;VIEW_PORT&#39;, &#39;VIEW_STARBOARD&#39; ];

	// identKeyPress values
	const IDENT_READY = 0, IDENT_LOCKED = 1, IDENT_STEERING = 2, IDENT_UNLOCK = 3, IDENT_STEER_DELAY = 4, IDENT_STEP_DELAY = 5;

	// MFD names
	const PrimaryMFD_name = ws.$PrimaryMFD_name,
		  AuxilaryMFD_name = ws.$AuxilaryMFD_name;

	// constant values (really!)
	const MASSLOCK_RING_SCALE = ws.$MASSLOCK_RING_SCALE,
		  PRECISION = 1E-8,											// standard for equality: a - b &lt; 1E-8 =&gt; essentially equal
		  QUARTER_SECS_OF_4MIN = 1/960,
		  QUARTER_SECS_OF_2MIN = 1/480,
		  PI = Math.PI,
		  RADIANS_TO_DEGREES = 180 / PI,
		  //DEGREES_TO_RADIANS = PI / 180,
		  QUARTER_ARC = PI / 2,
		  FORTYFIVE_DEGREES = PI / 4,
		  ONE_DEGREE = PI / 180,
		  REL_DIR_HALF_PLUS =  QUARTER_ARC + ONE_DEGREE * 2,		// reduce ambiguity in some cases by excluding an axis close match
		  REL_DIR_HALF_MINUS = QUARTER_ARC - ONE_DEGREE * 2,		//	 for easier nav, eg. to port &amp; up a small bit is 90 &lt;, not 90&lt;^
		  REL_DIR_STRESS = 2,										// ratio of horiz/vert angle to produce a double direction mark
		  VECTOR_ALL_ZEROS = [0, 0, 0],
		  VECTOR_ALL_ONES = [1, 1, 1];

	const SPAWN_DELAY = 0.25;										// fix (?) for .isVisible bug (freshly spawned ships have .isVisible == true)
																	// - ignore spawned ship until 1/2 second has passed

	// globally local variables, &#39;glocals&#39;
	var TelescopeList = ws.$TelescopeList,							// cached ref to back-compatible telescope object for oxp support
		MaxRange = ws.$MaxRange,
		mapping = ws.$SightingsMap, maplen = 0, 	 				// persistent array of Sightings
		mappingReady = false,										// map of size 0 can exist in interstellar -thanks Milo
		curr_S = ws.$curr_Sighting,									// cached ref to permantent telescope object
		selected_Sightings = [],									// for return value of select_Sightings fn
		BuyMsg = true,												//flag to show the buy message once
		ps = player &amp;&amp; player.ship,
		scannerRange, scannerRange_X_2, scannerRange_X_4, scannerRange_X_10;

	var curr_target, viewDirection, viewHasMLRings, identKeyPress,
		viewIsStandard,		// see _reposition_effects (used to decide if to alter masslock orientation)
		headingView = [],	// to calc heading for a view, need perpendicular horizontal vector
		eq_status, equip_ok, ext_ok, grav_eq_ok, grav_eq2_ok, large_ok, small_ok, scanFilter_ok,
		gravScanProgress, gs_mult, gs_state = GS_NONE, stationNearby,
		alertCondition, weaponsOnline, show_on_Alert, show_on_Weapons,
		ps_collisionRadius, ps_injectorsEngaged,ps_mass, ps_maxSpeed, ps_orientation,
		ps_position, prev_psp, ps_speed, ps_torusEngaged, ps_velocity, moving_fast,
		ps_vectorForward, ps_vectorRight, ps_vectorUp;
		// - these are all set in init_player_vars()

	var using_common_vars, hasAtmosphere, isBeacon, isBuoy, is_cargo, isCloaked, is_drone, isFrangible,
		isHostile, is_ignored, isJamming, is_minable, isPiloted, isPlanet, isStation, isSun, isThargoid,
		isVisible, isWormhole, dataKey, distance, mass, primaryRole, radius, scanClass,
		script_mass, shipClassName, status, collisionRadius, gs_curr, gs_max, lb_size,
		ml_size, rank, ve_colour, position = [], ent_vector = [], target_vector = [],
		bounty, has_targets, targeting_ps, in_ents_Targets, in_ps_Targets, dynamicMFD, staticMFD;
		// - these var.s are set as needed by local fns and are shared by all - see reset_common_vars

	var prevMFDTarget = null;										//support for Combat MFD
	var distanceUnits = &#39;m&#39;,										// support for navi_mfd, RandomStationNames &amp; Stranger&#39;s world
		baseDistance = 1000;
	var cd = worldScripts.telescope_debug;

// : &#39; +  + &#39;
//debug = ws.$DebugMessages = false; // for profiling
/* turn off for profiling!!*/

	function _initOxpVars() {										// closure is created in startUp but some values may not be know
																	//	 until startUpComplete (order of loading oxp&#39;s is unpredictible)
		try {
			AstroLibrary = worldScripts.AstroLibrary;
			Combat_MFD = worldScripts.combat_MFD;
			Carriers = worldScripts.carriers;
			Escortdeck = worldScripts.escortdeck;
			FarPlanets = worldScripts.farplanets;
			ILS = worldScripts.ils;
			GalacticAlmanac = worldScripts.RandomStationNames;
			GalNavy = worldScripts.GalNavy;
			Navigation_MFD = worldScripts.navi_mfd;
			PlanetaryCompass = worldScripts[ &#39;planetaryCompass_worldScript.js&#39; ];
			PlanetNames = worldScripts.planetnames;
			SpicyHermits = worldScripts.spicy_hermits_abandoned;
			SniperLock = worldScripts.sniperlock;
			SniperLockPlus = worldScripts.sniperlock_plus;
			TorusToSun = worldScripts.torustosun;
			Towbar = worldScripts.towbar;
			VariableMassLock = worldScripts.variablemasslock;
			VimanaHUD = worldScripts.VimanaHUD;
			WarpDrive = worldScripts.WarpDrive;
			if( VimanaHUD ) {
				// VimanaHUD sets TelescopeVSize &amp; TelescopeVZoomSize in its startUp
				VisualTargetCombatSize = ws.$VisualTargetCombatSize = ws.$TelescopeVSize;
				VisualTargetNormalSize = ws.$VisualTargetNormalSize = ws.$TelescopeVZoomSize;
				// vsizechanged = true;								// force update of current model
			}

			updateMenuVars();
			add_Sighting_errors = ws.$add_Sighting_errors;

			var fps = ws.$fps_closure;
			if( fps ) {
				short_term_fps = fps._short_term_fps;
				long_term_fps = fps._long_term_fps;
				current_fps = fps._current_fps;
				realtime_fps = fps._realtime_fps;
				turn_on_fps_monitor = fps._turn_on_fps_monitor;
				turn_off_fps_monitor = fps._turn_off_fps_monitor;
			}
		} catch( err ) {
			log( ws.name, ws._reportError( err, &#39;_initOxpVars&#39; ) );
			if( debug ) throw err;
		}
	}

	function init_player_statics( ps ) {							// init var that do not differ over frames
		ps_maxSpeed = ps.maxSpeed;
		ps_collisionRadius = ps.collisionRadius;
		scannerRange = ps.scannerRange;
		scannerRange_X_2 = scannerRange * 2;
		scannerRange_X_4 = scannerRange * 4;
		scannerRange_X_10 = scannerRange * 10;
		ws.$extenderActive = ps.equipmentStatus( &#39;EQ_TELESCOPEEXT&#39; ) === &#39;EQUIPMENT_OK&#39;;
		// - other cases of changed status are handles in equipment world event handlers
	}

	function init_player_vars( report ) {
		try {
			return _init_player_vars( report );
		} catch( err ) {
			log( ws.name, ws._reportError( err, &#39;init_player_vars&#39;, report ) );
			if( debug ) throw err;
		}
	}

	function _init_player_vars( report ) {							// init var that may differ from one frame to the next
		let curr_ps = player &amp;&amp; player.ship;
		if( !ps || ps !== curr_ps || !ps_maxSpeed )	{				// 1st time or diff ship
			init_player_statics( curr_ps );
		}
		ps = curr_ps;
		eq_status = ps.equipmentStatus( &#39;EQ_TELESCOPE&#39; );
		equip_ok = eq_status === &#39;EQUIPMENT_OK&#39;;
		if( !equip_ok ) {
			_shutdown_Sightings()
			return false;
		}
		if( !ps_position ) {
			ps_position = alloc_array();
			prev_psp = alloc_array();
		} else { // ps_position = ps.position; is faster but ensuring it&#39;s an array now will streamline any future use
			if( ps_position.length )
				copy_vector( ps_position, prev_psp );
			copy_vector( ps.position, ps_position );
		}
		identKeyPress = ws.$IdentKeyPress;
		let ps_target = ps.target;
		if( identKeyPress === IDENT_READY ) {						// else target is &#39;locked&#39; on curr_S, Steering or in IdentDelay
			curr_target = ps_target || null;
			if( curr_target ) {
				if( curr_target === curr_S.marker ) {				// far target, am targeting marker
					curr_target = curr_S.ent || null;				// fetch real target&#39;s ent
				}
			} else if( curr_S.ent ) {								// ensure kept in sync
				_set_curr_Sighting( null, &#39;_init_player_vars (curr_S.ent but no target)&#39; );
			}
		}
		ps_mass = ps.mass;
		ps_speed = ps.speed;
		if( WarpDrive ) {
			moving_fast = ps_speed &gt; WarpDrive.$basicMaxSpeed;
		} else {
			moving_fast = ps_speed &gt; ps_maxSpeed;					// injectors or torus
		}
		if( moving_fast &amp;&amp; ShowVisualTarget !== 0) {
			/*
			 * NB: setting ps_torusEngaged &amp; ps_torusEngaged only occurs when 3D model is used
			 *     as that&#39;s only place where they&#39;re used (this save 2 ship property get&#39;s/frame)
			 *     If used elsewhere, remove ShowVisualTarget test
			 */
			ps_torusEngaged = ps.torusEngaged;
			ps_injectorsEngaged = ps_torusEngaged ? false : ps.injectorsEngaged;
		} else {
			ps_injectorsEngaged = ps_torusEngaged = false;
		}
		if( !ps_velocity ) ps_velocity = alloc_array();
		copy_vector( ps.velocity, ps_velocity );
		if( !ps_orientation ) ps_orientation = alloc_array();
		copy_quaternion( ps.orientation, ps_orientation );
		basis_vectors_from_quaternion( ps_orientation )
		viewDirection = ps.viewDirection;
		let index = index_in_list( viewDirection, VIEWS_LIST );
		viewHasMLRings = index &gt;= 0 &amp;&amp; index &lt; 4 					// VIEWS_LIST.length
				? MassLockViewDirn &amp; pow( 2, index ) : false;		// bitflag is high
		viewIsStandard = false;										// used to decide orientation of masslock rings in _reposition_effects
		if( viewDirection === &quot;VIEW_FORWARD&quot; ) {
			copy_vector( ps_vectorForward, view_vector );
			viewIsStandard = true;
		} else if( viewDirection === &quot;VIEW_AFT&quot; ) {
			scale_vector( ps_vectorForward, -1, view_vector );
			viewIsStandard = true;
		} else if( viewDirection === &quot;VIEW_STARBOARD&quot; ) {
			copy_vector( ps_vectorRight, view_vector );
			viewIsStandard = true;
		} else if( viewDirection === &quot;VIEW_PORT&quot; ) {
			scale_vector( ps_vectorRight, -1, view_vector );
			viewIsStandard = true;
		}
		let ext_status = ps.equipmentStatus( &#39;EQ_TELESCOPEEXT&#39; ) === &#39;EQUIPMENT_OK&#39;;
		if( ext_status !== ext_ok ) {								// only update when it changes
			ws.$extenderActive = ext_status;
		}
		ext_ok = ext_status;
		let grav_eq2 = ps.equipmentStatus( &#39;EQ_GRAVSCANNER2&#39; );
		grav_eq2_ok = grav_eq2 === &#39;EQUIPMENT_OK&#39;;
		grav_eq_ok = ps.equipmentStatus( &#39;EQ_GRAVSCANNER&#39; ) === &#39;EQUIPMENT_OK&#39;
						&amp;&amp; grav_eq2 !== &#39;EQUIPMENT_DAMAGED&#39;; 		// vs EQUIPMENT_OK || EQUIPMENT_UNKNOWN || EQUIPMENT_UNAVAILABLE
		small_ok = ps.equipmentStatus( &#39;EQ_SMALLDISH&#39; ) === &#39;EQUIPMENT_OK&#39;;
		large_ok = ps.equipmentStatus( &#39;EQ_LARGEDISH&#39; ) === &#39;EQUIPMENT_OK&#39;;

if( report &amp;&amp; debug ) {
	log( ws.name, &#39;_init_player_vars, ext_ok is &#39; + ext_ok + &#39;, grav_eq_ok is &#39; + grav_eq_ok
				 + &#39;, grav_eq2_ok is &#39; + grav_eq2_ok + &#39;, small_ok is &#39; + small_ok  + &#39;, large_ok is &#39; + large_ok
				 + &#39;\n  player ship is &#39; + ps
				 + &#39;\n  curr_target is &#39; + curr_target );
}

		let mult = 1;												// gravity scan + other equipment extends its range
		if( large_ok ) {
			mult = 2;
			if( 	 ps_mass &gt; 1e8 ) mult = 8;						//baseship scan double range third time
			else if( ps_mass &gt; 1e6 ) mult = 4;						//huge player ship double range another time
		} else if( small_ok ) {
			mult = 1.33333;
		}
		gs_mult = mult;
		scanFilter_ok = ps.equipmentStatus( &#39;EQ_MILITARY_SCANNER_FILTER&#39; ) === &#39;EQUIPMENT_OK&#39;;
		alertCondition = player.alertCondition;
		weaponsOnline = ps.weaponsOnline;
		_set_GS_state(); 											// uses stationNearby, grav_eq_ok, weaponsOnline &amp; gravScanProgress
		wide = gameWindow.height / gameWindow.width; ///widescreen correction
		fov = gameSettings.fovValue;								// player may change it
		sin_fov2 = sin( fov/2 );
		cos_fov2 = cos( fov/2 );
		setShowFlags();
		let userChanges = ws.$UserChangedSettings;
		if( userChanges === 0 ) return true;						// reload only when user&#39;s been busy w/ mode/activate fns

		if( userChanges &amp; SET_LIGHTBALLS ) {
			LightBalls = ws.$LightBalls;
			ShipLightBalls = ws.$ShipLightBalls;
			LargeLightBalls = ws.$LargeLightBalls;
			ws.$UserChangedSettings &amp;= ~SET_LIGHTBALLS;
		}
		if( userChanges &amp; SET_MASSLOCKRINGS ) {
			MassLockRings = ws.$MassLockRings;
			BrightMassLockRings = ws.$BrightMassLockRings;
			ws.$UserChangedSettings &amp;= ~SET_MASSLOCKRINGS;
		}
		if( userChanges &amp; SET_SNIPER ) {
			SniperMinRange = ws.$SniperMinRange;
			SniperRange = ws.$SniperRange;
			ws.$UserChangedSettings &amp;= ~SET_SNIPER;
		}
		if( userChanges &amp; SET_STEERING ) {
			Steering = ws.$Steering;
			ws.$UserChangedSettings &amp;= ~SET_STEERING;
		}
		if( userChanges &amp; SET_TARGETS ) {
			MaxTargets = ws.$MaxTargets;
			ws.$UserChangedSettings &amp;= ~SET_TARGETS;
		}
		if( userChanges &amp; SET_VISUAL ) {
			ShowVisualTarget = ws.$ShowVisualTarget;
			VisualTargetRing = ws.$VisualTargetRing;
			ShowVisualStation = ws.$ShowVisualStation;
			ShowVisualQuestionMark = ws.$ShowVisualQuestionMark;
			VisualTargetNormalSize = ws.$VisualTargetNormalSize;
			VisualTargetCombatSize = ws.$VisualTargetCombatSize;
			vsizechanged = true;								// force update of current model
			ws.$UserChangedSettings &amp;= ~SET_VISUAL;
		}
		if( userChanges &amp; SET_VISUAL_SIZE ) {
			VisualTargetNormalSize = ws.$VisualTargetNormalSize;
			VisualTargetCombatSize = ws.$VisualTargetCombatSize;
			vsizechanged = true;								// force update of current model
			ws.$UserChangedSettings &amp;= ~SET_VISUAL_SIZE;
		}
		updateMenuVars();
		return true;
	}

	function reset_common_vars() {									// reset all var&#39;s that are shared by various fn&#39;s
		// we don&#39;t know if we&#39;re set for curr. entity, so all set to -1 &amp; 1st fn that needs it, sets it accordingly
		// we do this to minimize the # of property gets, which are a lot more expensive than testing local vars &lt; 0
		bounty = -1;
		collisionRadius = -1;
		dataKey = -1;
		distance = -1;
		dynamicMFD = 0;
		ent_vector.length = 0;										// re-use array
		gs_curr = -1;
		gs_max = -1;
		has_targets = -1;
		hasAtmosphere = -1;
		in_ents_Targets = -1;
		in_ps_Targets = -1;
		isBeacon = -1;
		isBuoy = -1;
		is_cargo = -1;
		isCloaked = -1;
		is_drone = -1;
		isFrangible = -1;
		isHostile = -1;
		is_ignored = -1;
		isJamming = -1;
		is_minable = -1;
		isPiloted = -1;
		isPlanet = -1;
		isStation = -1;
		isSun = -1;
		isThargoid = -1;
		isVisible = -1;
		isWormhole = -1;
		lb_size = -1;
		mass = -1;
		ml_size = -1;
		position.length = 0;										// re-use array
		primaryRole = -1;
		radius = -1;
		rank = -1;
		scanClass = -1;
		script_mass = undefined;									// scriptInfo: telescope can be 0, 1, any +/- integer
		shipClassName = -1;
		staticMFD = 0;
		status = -1;
		targeting_ps = -1;
		target_vector.length = 0;									// re-use arrays
		target_direction.length = 0;
		ve_colour = -1;
		using_common_vars = true;
	}

	function _reload_config( report ) {								// reload config options chg&#39;d on station
		try {
			AutoScan = ws.$AutoScan;
			AutoScanMaxRange = ws.$AutoScanMaxRange;
			AutoLock = ws.$AutoLock;
			GravLock = ws.$GravLock;
			IdentLock = ws.$IdentLock;

			IdentDelay = ws.$IdentDelay;
			FarStatus = ws.$FarStatus;
			MaxTargets = ws.$MaxTargets;
			RedAlertDist = ws.$RedAlertDist;
			Steering = ws.$Steering;

			LightBalls = ws.$LightBalls;
			ShipLightBalls = ws.$ShipLightBalls;
			LargeLightBalls = ws.$LargeLightBalls;
			LightBallMinDist = ws.$LightBallMinDist;
			LightBallShipMinDist = ws.$LightBallShipMinDist;

			MassLockRings = ws.$MassLockRings;
			MassLockViewDirn = ws.$MassLockViewDirn;
			BrightMassLockRings = ws.$BrightMassLockRings;

			SniperRingSize = ws.$SniperRingSize;
			SniperRingActive = ws.$SniperRingActive;
			SniperRange = ws.$SniperRange;
			SniperMinRange = ws.$SniperMinRange;
			SniperRingColor = ws.$SniperRingColor;

			ShowVisualTarget = ws.$ShowVisualTarget;
			VisualTargetNormalSize = ws.$VisualTargetNormalSize;
			VisualTargetCombatSize = ws.$VisualTargetCombatSize;
			VisualTargetRing = ws.$VisualTargetRing;

			ShowVisualStation = ws.$ShowVisualStation;
			ShowVisualQuestionMark = ws.$ShowVisualQuestionMark;
			ModelRingColor = ws.$ModelRingColor;
			//VTarget_HUD_shift = ws.$VTarget_HUD_shift; 			// not used in closure; gets applied in shipWillLaunchFromStation
			ws.$TelescopeVPosHUD = ws.$VTarget_HUD_shift;			// maintain for oxps

			updateMenuVars();

			// UI_and_docs
			ConsoleMsgDurn = ws.$ConsoleMsgDurn;
			GravScanMsgFreq = ws.$GravScanMsgFreq;
			IdentMessages = ws.$IdentMessages;
			// ShowSummary = ws.$ShowSummary;						// not used in closure
			debug = ws.$DebugMessages;

			// experimental
			TargetOnlyHostile = ws.$TargetOnlyHostile;
			RemoveInFlight = ws.$RemoveInFlight;
			MFDFiltering = ws.$MFDFiltering;
			MFDPrimaryStatic = ws.$MFDPrimaryStatic;
			MFDPrimaryDynamic = ws.$MFDPrimaryDynamic;
			SeparateMFDs = ws.$SeparateMFDs;
			MFDAuxStatic = ws.$MFDAuxStatic;
			MFDAuxDynamic = ws.$MFDAuxDynamic;
			// ws.$Thargoids		 // not used in closure; gets applied in shipWillLaunchFromStation


			if( report ) _report_config();
		} catch( err ) {
			log( ws.name, ws._reportError( err, &#39;_reload_config&#39;, report ) );
			if( debug ) throw err;
		}
	}

	function updateMenuVars() {
		// update TelescopeMenu vars; values are 1-based index, as 0 used for description
		var menu = 1;												// off
		if( MaxTargets &lt; 20 )
			MaxTargets = ws.$MaxTargets = 20;
		else if( MaxTargets &gt; 200 )
			MaxTargets = ws.$MaxTargets = 200;
		menu += MaxTargets &gt; 100 ? 3 : MaxTargets &gt; 50 ? 2 : MaxTargets &gt; 20 ? 1 : 0;
		ws.$TelescopeMenuTargets = menu;

		ws.$TelescopeMenuSteering = Steering + 1;

		menu = 1;													// off
		if( LightBalls ) menu = 2;
		if( ShipLightBalls ) menu = 3;
		if( LargeLightBalls ) menu = 4;
		ws.$TelescopeMenuLightballs = menu;

		menu = 1;													// off
		let state = ws._getShowState(),								// on/off for current alert/weaps state
			currFlags = ws._currMLFlags();
		if( currFlags &amp; state ) {
			menu = 2;
			if( BrightMassLockRings )
				menu = 3;
		}
		ws.$TelescopeMenuMasslockRings = menu;

		menu = 1;													// off
		if( SniperMinRange !== SniperRange ) {
			let min = round(SniperMinRange / 5000);					// round( SniperMinRange / 5000 )
			menu = 1 + (min &lt;= 1 ? 1 : min &gt;= 3 ? 3 : min) + (SniperRange &lt;= 25600 ? 0 : 3);
		}
		ws.$TelescopeMenuSniper = menu;

		menu = 6;													// all
		if( !ShowVisualQuestionMark )	  menu = 5;
		if( !ShowVisualStation )		  menu = 4;
		if( !VisualTargetRing )			  menu = 3;
		if( ShowVisualTarget === 1 )	  menu = 2;
		else if( ShowVisualTarget === 0 ) menu = 1;
		ws.$TelescopeMenuVisual = menu;

		menu = VisualTargetCombatSize &lt; VisualTargetNormalSize
			 ? VisualTargetCombatSize : VisualTargetNormalSize;
		ws.$TelescopeMenuVisualSize = menu &gt; 0 ? menu : 1;
/*
if( debug ) {
	log(&#39;updateMenuVars, TelescopeMenuTargets: &#39; + ws.$TelescopeMenuTargets
		+ &#39;, TelescopeMenuSteering: &#39; + ws.$TelescopeMenuSteering
		+ &#39;, TelescopeMenuLightballs: &#39; + ws.$TelescopeMenuLightballs
		+ &#39;, TelescopeMenuMasslockRings: &#39; + ws.$TelescopeMenuMasslockRings
		+ &#39;, \n\tTelescopeMenuSniper: &#39; + ws.$TelescopeMenuSniper
		+ &#39;, TelescopeMenuVisual: &#39; + ws.$TelescopeMenuVisual
		+ &#39;, TelescopeMenuVisualSize: &#39; + ws.$TelescopeMenuVisualSize
	);
}
 */
	}

	function report_config( limit ) {
		try {
			_report_config( limit );
		} catch( err ) {
			log( ws.name, ws._reportError( err, &#39;report_config&#39; ) );
			if( debug ) throw err;
		}
	}

	function fmtStaticFlags( stat ) {
		var flag = &#39;&#39;;
		if( stat &amp; MFD_SALVAGE )	flag += &#39;| SALVAGE &#39;;
		if( stat &amp; MFD_MINING )		flag += &#39;| MINING &#39;;
		if( stat &amp; MFD_WEAPONS )	flag += &#39;| WEAPONS &#39;;
		if( stat &amp; MFD_TRADERS )	flag += &#39;| TRADERS &#39;;
		if( stat &amp; MFD_POLICE )		flag += &#39;| POLICE &#39;;
		if( stat &amp; MFD_PIRATES )	flag += &#39;| PIRATES &#39;;
		if( stat &amp; MFD_MILITARY )	flag += &#39;| MILITARY &#39;;
		if( stat &amp; MFD_ALIENS )		flag += &#39;| ALIENS &#39;;
		if( stat &amp; MFD_NEUTRAL )	flag += &#39;| NEUTRAL &#39;;
		if( stat &amp; MFD_STATION )	flag += &#39;| STATION &#39;;
		if( stat &amp; MFD_NAVIGATION )	flag += &#39;| NAVIGATION &#39;;
		if( stat &amp; MFD_CELESTIAL )	flag += &#39;| CELESTIAL &#39;;
		return flag.length ? flag + &#39;|&#39; : &#39;&#39;;
	}

	function fmtDynFlags( dyn ) {
		var flag = &#39;&#39;;
		if( dyn &amp; MFD_FRIENDLY )	flag += &#39;| FRIENDLY &#39;;
		if( dyn &amp; MFD_UNSOCIABLE )	flag += &#39;| UNSOCIABLE &#39;;
		if( dyn &amp; MFD_ACTIVE )		flag += &#39;| ACTIVE &#39;;
		if( dyn &amp; MFD_HOSTILE )		flag += &#39;| HOSTILE &#39;;
		if( dyn &amp; MFD_NEARBY )		flag += &#39;| NEARBY &#39;;
		if( dyn &amp; MFD_PROTECTED )	flag += &#39;| PROTECTED &#39;;
		if( dyn &amp; MFD_FARAWAY )		flag += &#39;| FARAWAY &#39;;
		return flag.length ? flag + &#39;|&#39; : &#39;&#39;;
	}

	function fmtSteering() {
		return Steering &gt; 1 ? &quot;&#39;Each in list&#39;&quot; : Steering &gt; 0 ? &quot;&#39;Nearest&#39;&quot; : &quot;&#39;Off&#39;&quot;;
	}

	function fmtMassLockViewDirn() {
		var flag = &#39;&#39;;
		for( let num = 0; num &lt;= 4; num++ ) {
			if( MassLockViewDirn &amp; pow( 2, num ) )
				flag += &#39;| &#39; + VIEWS_LIST[ num ].slice( 5 );
		}
		return flag.length ? flag + &#39; |&#39; : &#39;&#39;;
	}

	function fmtAlertWeapsState( bitflag ) {
		var flag = &#39;&#39;;
		if( bitflag &amp; SHOW_GREEN_WEAPS_OFF )	flag += &#39;| GREEN_OFF &#39;;
		if( bitflag &amp; SHOW_GREEN_WEAPS_ON )	flag += &#39;| GREEN_ON &#39;;
		if( bitflag &amp; SHOW_YELLOW_WEAPS_OFF )	flag += &#39;| YELLOW_OFF &#39;;
		if( bitflag &amp; SHOW_YELLOW_WEAPS_ON )	flag += &#39;| YELLOW_ON &#39;;
		if( bitflag &amp; SHOW_RED_WEAPS_OFF )	flag += &#39;| RED_OFF &#39;;
		if( bitflag &amp; SHOW_RED_WEAPS_ON )		flag += &#39;| RED_ON &#39;;
		if( flag.length )
			return flag + &#39;|&#39;;
		return &#39;&#39;;
	}

	function fmtGSMsgFreq( stat ) {
		var flag = &#39;&#39;;
		if( stat &amp; 1 )	flag += &#39;| ++ endpoints &#39;;
		if( stat &amp; 2 )	flag += &#39;| ++ quarterly &#39;;
		if( stat &amp; 4 )	flag += &#39;| ++ tenths &#39;;
		if( stat &amp; 8 )	flag += &#39;| -- endpoints &#39;;
		if( stat &amp; 16 )	flag += &#39;| -- quarterly &#39;;
		if( stat &amp; 32 )	flag += &#39;| -- tenths &#39;;
		return flag.length ? flag + &#39;|&#39; : &#39;&#39;;
	}

	function _report_config( limit ) {								// also reports on experimental


		var rpt, idt = &#39;    &#39;, pad = &#39;,&#39; + idt,
			flags = &#39;  -&gt;  &#39;, nlIdt = &#39;\n&#39; + idt;
		log( ws.name, &#39;\n&#39; );
		if( !limit || limit === &#39;config&#39; ) {
			rpt = idt	+ &#39;AutoScan = &#39; + AutoScan
				+ pad	+ &#39;AutoScanMaxRange = &#39; + AutoScanMaxRange
				+ pad	+ &#39;AutoLock = &#39; + AutoLock + &#39;&#39;
				+ pad	+ &#39;GravLock = &#39; + GravLock + &#39;&#39;
				+ pad	+ &#39;IdentLock = &#39; + IdentLock + &#39;&#39;
				+ nlIdt + &#39;IdentDelay = &#39; + IdentDelay
				+ pad	+ &#39;FarStatus = &#39; + FarStatus
				+ pad	+ &#39;MaxTargets = &#39; + MaxTargets
				+ pad	+ &#39;RedAlertDist = &#39; + RedAlertDist
				+ pad	+ &#39;Steering = &#39; + fmtSteering()
				+ nlIdt + &#39;LightBalls = &#39; + LightBalls
				+ pad	+ &#39;ShipLightBalls = &#39; + ShipLightBalls
				+ pad	+ &#39;LargeLightBalls = &#39; + LargeLightBalls
				+ pad	+ &#39;LightBallMinDist = &#39; + LightBallMinDist
				+ pad	+ &#39;LightBallShipMinDist = &#39; + LightBallShipMinDist
				+ nlIdt	+ &#39;MassLockRings = &#39; + MassLockRings
				+ flags + fmtAlertWeapsState( MassLockRings )
				+ nlIdt + &#39;MassLockViewDirn = &#39; + MassLockViewDirn
				+ flags + fmtMassLockViewDirn()
				+ nlIdt + &#39;BrightMassLockRings = &#39; + BrightMassLockRings
				+ nlIdt + &#39;SniperRingSize = &#39; + SniperRingSize
				+ pad	+ &#39;SniperRingActive = &#39; + SniperRingActive
				+ flags + fmtAlertWeapsState( SniperRingActive ) // vs binary: .toString(2)
				+ nlIdt + &#39;SniperRange = &#39; + SniperRange
				+ pad	+ &#39;SniperMinRange = &#39; + SniperMinRange
				+ pad	+ &#39;SniperRingColor = &#39; + SniperRingColor
				+ nlIdt + &#39;ShowVisualTarget = &#39; + ShowVisualTarget
				+ pad	+ &#39;VisualTargetNormalSize = &#39; + VisualTargetNormalSize
				+ pad	+ &#39;VisualTargetCombatSize = &#39; + VisualTargetCombatSize
				+ pad	+ &#39;VisualTargetRing = &#39; + VisualTargetRing
				+ nlIdt + &#39;ShowVisualStation = &#39; + ShowVisualStation
				+ pad	+ &#39;ShowVisualQuestionMark = &#39; + ShowVisualQuestionMark
				+ pad	+ &#39;ModelRingColor = &#39; + ModelRingColor
				+ pad	+ &#39;ws.$VTarget_HUD_shift = &#39; + ws.$VTarget_HUD_shift
				+ nlIdt;
			log( ws.name, &#39;config:\n&#39; + rpt );
		}
		if( !limit || limit === &#39;UI_and_docs&#39; ) {
			rpt = idt	+ &#39;ConsoleMsgDurn = &#39; + ConsoleMsgDurn
				+ pad	+ &#39;GravScanMsgFreq = &#39; + GravScanMsgFreq
				+ flags + fmtGSMsgFreq( GravScanMsgFreq )
				+ nlIdt + &#39;IdentMessages = &#39; + IdentMessages
				+ pad	+ &#39;ShowSummary = &#39; + ws.$ShowSummary			// not used in closure
				+ pad	+ &#39;DebugMessages = &#39; + debug
				+ nlIdt;
			log( ws.name, &#39;UI_and_docs:\n&#39; + rpt );
		}
		if( !limit || limit === &#39;experimental&#39; ) {
			rpt = idt	+ &#39;MFDFiltering = &#39; + MFDFiltering
				+ nlIdt + &#39;MFDPrimaryStatic = &#39; + MFDPrimaryStatic
				+ flags + fmtStaticFlags( MFDPrimaryStatic )
				+ nlIdt + &#39;MFDPrimaryDynamic = &#39; + MFDPrimaryDynamic
				+ flags + fmtDynFlags( MFDPrimaryDynamic )
				+ nlIdt + &#39;SeparateMFDs = &#39; + SeparateMFDs
				+ nlIdt + &#39;MFDAuxStatic = &#39; + MFDAuxStatic
				+ flags + fmtStaticFlags( MFDAuxStatic )
				+ nlIdt + &#39;MFDAuxDynamic = &#39; + MFDAuxDynamic
				+ flags + fmtDynFlags( MFDAuxDynamic )
				+ nlIdt + &#39;Thargoids = &#39; + ws.$Thargoids		 			// not used in closure; gets used in _AddShips
				+ nlIdt + &#39;BetaLicenceTimestamp = &#39; + ws.$BetaLicenceTimestamp
				+ pad	+ &#39;BetaLicenceSystem = &#39; + ws.$BetaLicenceSystem
				+ &#39;\n&#39;;
			log( ws.name, &#39;experimental:\n&#39; + rpt );
		}
		log( ws.name, &#39;\n&#39; );
	}

	var have_shutdown = false;
	function shutdown_Sightings() {
		try {
			_shutdown_Sightings();
		} catch( err ) {
			log( ws.name, ws._reportError( err, &#39;_shutdown_Sightings&#39; ) );
			if( debug ) throw err;
		}
	}

	function _shutdown_Sightings() {
		if( have_shutdown ) return;
		if( debug ) log( ws.name, &#39;_shutdown_Sightings, shutting down...&#39;);
		ws.$Telescope_not_in_use = have_shutdown = true;
		clear_all_pending();
		if( ps ) {											// in case called from dock
			equip_ok = ps.equipmentStatus( &#39;EQ_TELESCOPE&#39; ) === &#39;EQUIPMENT_OK&#39;;
			if( MFD_is_visible( PrimaryMFD_name ) )
				doClear_MFD( PrimaryMFD_name );
			if( MFD_is_visible( AuxilaryMFD_name ) )
				doClear_MFD( AuxilaryMFD_name )
		}
		_set_curr_Sighting( null, &#39;_shutdown_Sightings&#39; );	// no parms resets
		ws.$IdentKeyPress = identKeyPress = IDENT_READY;
		_newList();
		if( ps ) 											// in case called from dock
			_clear_HUD_Effects();
		// purge pools -happens either in witchspace or when docked before garbage is collected
		if( debug ) log(ws.name, &#39;_shutdown_Sightings, used_Sightings = &#39; + used_Sightings.length
													  + &#39;, used_arrays = &#39; + used_arrays.length
													  + &#39;, used_pending = &#39; + used_pending.length );

		used_Sightings.length = 0;
		used_arrays.length = 0;
		used_pending.length = 0;
		if( turn_off_fps_monitor )
			turn_off_fps_monitor();

	}

	var system_sun = null;
	var system_name = null;
	var isInterstellarSpace = false;
	var mainPlanet = null;
	var system_planets = null;										// must be init&#39;d after launch; see orbName
	var system_stations = null;
	function _restart_after_shutdown() {							// called only once _init_player_vars() succeeds
																	// - see shipLaunchedFromStation &amp; shipExitedWitchspace
		try {
			if( debug ) log( ws.name, &#39;_restart_after_shutdown, starting up...&#39;);
			ws.$Telescope_not_in_use = have_shutdown = false;
			clearNameCaches();
			system_sun = system.sun;
			if( system_sun &amp;&amp; system_sun.hasGoneNova )				// thanks Milo
				system_sun = null;
			system_name = system.name;
			isInterstellarSpace = system.isInterstellarSpace;
			mainPlanet = system.mainPlanet;
			system_planets = system.planets;
			system_stations = system.stations;

			setDistanceUnits();
			buildEclipsers();

			doClear_MFD( PrimaryMFD_name );
			doClear_MFD( AuxilaryMFD_name );

			stationNearby = false;										//to send gravscanner message after launch
			gravScanProgress = 0;										//begin new gravity detection process
			ws.$IdentKeyPress = identKeyPress = IDENT_READY;			// reset target lock
			_resetIdentDelay();
			if( turn_on_fps_monitor )
				turn_on_fps_monitor();
		} catch( err ) {
			log( ws.name, ws._reportError( err, &#39;_restart_after_shutdown&#39; ) );
			if( debug ) throw err;
		}
	}

	function buildEclipsers() {
		if( !systemEclipsers ) {
			systemEclipsers = alloc_array();
		} else {
			systemEclipsers.length = 0;
			}
		// eclipsers checked from start of array, so put most likely ones first: stations, planets, ARHs, sun
		for( let idx = 0, len = system_stations.length; idx &lt; len; idx++ ) {
			let ent = system_stations[ idx ];
			if( ent &amp;&amp; ent.isValid ) {
				systemEclipsers.push( ent );
			}
		}
		for( let idx = 0, len = system_planets.length; idx &lt; len; idx++ ) {
			let ent = system_planets[ idx ];
			if( ent &amp;&amp; ent.isValid ) {
				systemEclipsers.push( ent );
			}
		}
		if( SpicyHermits ) {
			let abandonedRHs = entitiesWithScanClass( &#39;CLASS_ROCK&#39; );
			for( let idx = 0, len = abandonedRHs.length; idx &lt; len; idx++ ) {
				let ent = abandonedRHs[ idx ];
				if( ent &amp;&amp; ent.isValid
						&amp;&amp; ent.isMinable &amp;&amp; !ent.isFrangible ) {	// normal Rock Hermits caught in system_stations
					systemEclipsers.push( ent );
				}
			}
			free_array( abandonedRHs );
		}
		var sun = fetchSun();
		if( sun ) {
			systemEclipsers.push( sun );
		}
	}

/* Stranger&#39;s OU is system specific
    var mainOrbitVector = new Vector3D(system.sun.position.subtract(system.mainPlanet.position));
    var ouScale = mainOrbitVector.magnitude();  // OU in custom system
 */
/* navi_mfd  (NB: OU is static)
.$unitSetting is index into $distUnits = [&quot;OU&quot;, &quot;km&quot;, &quot;m&quot;] while $rounding = [6, 3, 0];
message += &quot;Distance: &quot; + dist.toFixed(this.$rounding[this.$unitSetting]) + &quot; &quot; + this.$distUnits[this.$unitSetting] +&quot;\n&quot;;
from market inquirer:
	unitBase = worldScripts.navi_mfd.$ostronomicalUnits[worldScripts.navi_mfd.$unitSetting];
	unit = worldScripts.navi_mfd.$distUnits[worldScripts.navi_mfd.$unitSetting];
	rnd = worldScripts.navi_mfd.$rounding[worldScripts.navi_mfd.$unitSetting]
	...
	function dist(entity, rounding) {
		var distInKm = (player.ship.position.distanceTo(entity) - entity.collisionRadius)/unitBase;
		return (distInKm.toFixed(rounding) + &quot; &quot; + unit);
	};
 */
/* randomstationnames: extra units besides (static) OU (NB: strangers world overrides?)
  15800 TS &quot;Torans&quot; == 1000 KM &quot;Kilometres&quot; == 905520 OU &quot;Orthodox Units&quot; == 1609.34 MI &quot;Miles&quot; == 2.08641 CZ &quot;Cavezzi&quot;
 &quot;Torans. One Unit is the distance travelled in one second under Torus Dilation.&quot;;
 &quot;Kilometres. One Unit is the distance travelled by light in three microseconds.&quot;;
 &quot;Orthodox Units. One Unit is the distance between the planet Lave and its Star.&quot;;
 &quot;Miles. One Unit is equal to the combined hight of nine hundred Anciant Earthians.&quot;;
 &quot;Cavezzi. One Unit is one twenty millionth the circumference of Ancient Earth.&quot;;
 - all .toFixed(3) except Cavezzi which is .toFixed(0)

!must be checked upon each launch as configurable in station&#39;s F4
if (missionVariables.random_station_names_units == &quot;Torans&quot;) var unitBase = 15800;
if (missionVariables.random_station_names_units == &quot;Torans&quot;) var unit = &quot;TS&quot;;
if (missionVariables.random_station_names_units == &quot;Kilometres&quot;) var unitBase = 1000;
if (missionVariables.random_station_names_units == &quot;Kilometres&quot;) var unit = &quot;KM&quot;;
if (missionVariables.random_station_names_units == &quot;Orthodox Units&quot;) var unitBase = 905520;
if (missionVariables.random_station_names_units == &quot;Orthodox Units&quot;) var unit = &quot;OU&quot;;
if (missionVariables.random_station_names_units == &quot;Miles&quot;) var unitBase = 1609.34;
if (missionVariables.random_station_names_units == &quot;Miles&quot;) var unit = &quot;MI&quot;;
if (missionVariables.random_station_names_units == &quot;Cavezzi&quot;) var unitBase = 2.08641;
if (missionVariables.random_station_names_units == &quot;Cavezzi&quot;) var unit = &quot;CZ&quot;;
var rounding = missionVariables.random_station_names_mfd_rounding; // is 3 except for CZ where it&#39;s 0
var distranceinUnits = (player.ship.position.distanceTo(entity) - entity.collisionRadius)/missionVariables.random_station_names_mfd_unitBase;
var almanacDisplayDistance = distranceinUnits.toFixed(rounding);
if (almanacDisplayDistance &lt;0) var almanacDisplayDistance = 0;

 */

	function setDistanceUnits() {
		distanceUnits = &#39;m&#39;;
		baseDistance = 1;
		if( GalacticAlmanac ) {
			let units = missionVariables.random_station_names_units;
			// baseDistance = missionVariables.random_station_names_mfd_unitBase;
			if( units === &#39;Torans&#39; ) {
				distanceUnits = &#39;TS&#39;;
				baseDistance = 15800;
			} else if( units === &#39;Kilometres&#39; ) {
				distanceUnits = &#39;KM&#39;;
				baseDistance = 1000;
			} else if( units === &#39;Orthodox Units&#39; ) {
				distanceUnits = &#39;OU&#39;;
				baseDistance = 905520;
			} else if( units === &#39;Miles&#39; ) {
				distanceUnits = &#39;MI&#39;;
				baseDistance = 1609.34;
			} else if( units === &#39;Cavezzi&#39; ) {
				distanceUnits = &#39;CZ&#39;;
				baseDistance = 2.08641;
			}
		} else if( AstroLibrary ) {
			distanceUnits = &#39;OU&#39;;
			if( mainPlanet &amp;&amp; system_sun ) {
				let pos = system_sun.position;
				if( pos )
					baseDistance = pos.subtract( mainPlanet ).magnitude();  // OU in custom system
			} // else continue using that from previous system
		} else if( Navigation_MFD ) {
			let unitSetting = Navigation_MFD.$unitSetting;
			distanceUnits = Navigation_MFD.$distUnits[ unitSetting ];
			baseDistance = Navigation_MFD.$ostronomicalUnits[ unitSetting ];
			// cache &amp; update every system -&gt; _restart_after_shutdown
		}
	}

	function index_in_list( item, list ) {							// for arrays only; faster than indexOf
		if( !list ) return -1;
		var len = list.length;
		while( len-- ) {
			if( list[ len ] === item )
				return len;
		}
		return -1;
	}

	function equal_value( a, b ) { return abs( a - b ) &lt; PRECISION; }
//	function abs_diff( a, b ) { return abs( abs(a) - abs(b) ); }

	// vector functions &amp; array pool //////////////////////////////////////////////////////////////

	function popArrayItem( arr, idx ) {								// garbage free alternative to array slice
		var popped = arr[ idx ], len = arr.length;
		for( var idx = idx; idx &lt; len - 1; idx++ ) {
			arr[ idx ] = arr[ idx + 1 ];
		}
		arr.length = --len;
		return popped;
	}

	var used_arrays = [];

	function free_array( array ) {									// attempt to reduce garbage collection by managing used objects
		if( !array ) return;
		if( !isArray( array ) ) return;
		array.length = 0;											// scrub old data
		used_arrays.push( array );									// toss into recycle bin
		if( used_arrays.length &gt;= 100 ) {							// build up over time
			used_arrays.length = 10;
if( debug ) log(ws.name, &#39;free_array, pool EXCEEDED 100, reduced to 10&#39; );
		}
	}

	function alloc_array() {										// attempt to reduce garbage collection by managing used objects
		if( used_arrays.length &gt; 0 ) {								// re-use old array
			return used_arrays.pop();
		}
		return [];
	}

	/* From Wikipedia
	Because the magnitude of the cross product goes by the sine of the angle between its arguments,
	the cross product can be thought of as a measure of perpendicularity in the same way that the
	dot product is a measure of parallelism. Given two unit vectors, their cross product has a
	magnitude of 1 if the two are perpendicular and a magnitude of zero if the two are parallel.
	The dot product of two unit vectors behaves just oppositely: it is zero when the unit vectors
	are perpendicular and 1 if the unit vectors are parallel.

	Unit vectors enable two convenient identities: the dot product of two unit vectors yields the
	cosine (which may be positive or negative) of the angle between the two unit vectors. The
	magnitude of the cross product of the two unit vectors yields the sine (which will always be positive).
	*/

	function chk_vparms( a, N, parm, testNaN ) { 					// a: vector, N: expected length, parm: callers parm #
		if( !a ) ///throw( &#39;chk_vparms, !a&#39; );
			ws._reportError( &#39;&quot;a&quot; is not defines&#39;, chk_vparms, [a, N, parm, testNaN] )
		var errMsg = &#39;&#39;;
		if( isArray( a ) ) {		/// insignificant difference in profiling
			let len = a.length;
			if( len &gt; 0 &amp;&amp; len &lt; N ) {								// can be 0 if re-used
				errMsg = &#39;isArray but length too short&#39;;
				// chk_vparms[ (&#39;parm isArray but length too short&#39;) ].err = 0;
			}
		} else if( N === 3 &amp;&amp; !(a instanceof Vector3D) ) {
			errMsg = &#39;!isArray and !Vector3D&#39;;
			// chk_vparms[ &#39;parm !isArray and !Vector3D&#39; ].err = 0;
		} else if( N === 4 &amp;&amp; !(a instanceof Quaternion) ) {
			errMsg = &#39;!isArray and !Quaternion&#39;;
			// chk_vparms[ &#39;parm !isArray and !Quaternion&#39; ].err = 0;
		} else if( !isArray( a ) &amp;&amp; !(a instanceof Vector3D) &amp;&amp; !(a instanceof Quaternion) ) {
			errMsg = &#39;is invalid for a vector&#39;;
			// chk_vparms[ (&#39;parm invalid for a vector: &#39; + a) ].err = 0;
		}
		if( errMsg ) {
			errMsg = &#39;caller\&#39;s #&#39; + parm + &#39; parm &#39; + errMsg + &#39;: &#39; + a;
			ws._reportError( errMsg, chk_vparms, [a, N, parm, testNaN] )
			/// throw( errMsg );
			// chk_vparms[ errMsg ].err = 0
		}
		if( testNaN ) {
			let len = isArray( a ) ? a.length : a instanceof Vector3D ? 3 : a instanceof Quaternion ? 4 : 0;
			for( let idx = 0; len &gt; 0 &amp;&amp; idx &lt; N; idx++ ) {
				if( isNaN( a[ idx ] ) ) {
					errMsg = &#39;caller\&#39;s #&#39; + parm + &#39; parm, &#39; +  &#39;item &#39; + idx + &#39; isNaN: &#39; + a[ idx ] + &#39;, parm: &#39; + a;
					ws._reportError( errMsg, chk_vparms, [a, N, parm, testNaN] )
					///throw( errMsg );
					// log( &#39;chk_vparms, item &#39; + idx + &#39; isNaN: &#39; + a[ idx ] );
					// chk_vparms[ &#39;an item isNaN&#39; ].err = 0;
				}
			}
		}
	}

	// NEVER use copy_vector/copy_quaternion when setting a property (eg. ps.position/ps.orientation), as this
	//	 will generate 3/4 property gets/sets (&amp; garbage) vs. just 1 by doing &#39;ps.position = my_var&#39; (&amp; no garbage)
	// Also, ALWAYS use copy_vector/copy_quaternion when getting a property, so all subsequent calculations are
	//	 local (ie. using arrays)
	// Yes, this does generate garbage (array object) but can&#39;t be helped until core gives us a method where we
	//	 provide the destination. Eg. ps.getPosition( my_var );

/*
	function describeVector( vect ) {
		var v = vect.direction();
		// .dot -1..0..1 spans PI radians; abs spans PI/2
		var dot2deg = RADIANS_TO_DEGREES * Math.PI / 2;
		var msg = &#39; -&gt; vector points &#39;, decimals = 3;
		var dotForward = v.dot( ps.vectorForward ), diffForward = Math.abs(dotForward) * dot2deg;
		var dotRight = v.dot( ps.vectorRight ), diffRight = Math.abs(dotRight) * dot2deg;
		var dotUp = v.dot( ps.vectorUp ), diffUp = Math.abs(dotUp) * dot2deg;
		var fwdMsg = false;
		if( equal_value( dotForward, 1 ) ) {
			msg += &#39;directly on heading&#39;;
			fwdMsg = true;
		} else if( !equal_value( dotForward, 0 ) ) {
			msg += diffForward.toFixed(decimals) + &#39; &#39;;
			msg += dotForward &gt; 0 ? &#39;fore &#39; : &#39;aft &#39;;
			msg += dotUp &gt; 0 ? &#39;of zenith&#39; : &#39;of nadir&#39;;
			fwdMsg = true;
		}

		if( !equal_value( dotRight, 0 ) ) {
			if (fwdMsg) {
				msg += &quot;, &quot;;
			}
			msg += diffRight.toFixed(decimals) + &#39; &#39;;
			msg += dotRight &gt; 0 ? &#39;starboard&#39; : &#39;port&#39;;
		}

		if( !equal_value( dotUp, 0 ) ) {
			if (fwdMsg) {
				msg += &quot;, &quot;;
			}
			msg += diffUp.toFixed(decimals) + &#39; &#39;;
			msg += dotUp &gt; 0 ? &#39;up&#39; : &#39;down&#39;;
		}
		return msg;
	}
 */
	function copy_vector( a, b, skipChk ) {							// a -&gt; b
		if( debug &amp;&amp; !skipChk ) {									// skipChk for colors (arrays of length 4)
			chk_vparms( a, 3, 1, true );
			chk_vparms( b, 3, 2 );
		}
		b[0] = a[0];
		b[1] = a[1];
		b[2] = a[2];
	}

	function same_vectors( a, b ) {									// w/i limits of PRECISION
		if( debug ) {
			chk_vparms( a, 3, 1, true );
			chk_vparms( b, 3, 2, true );
		}
		if( !equal_value( b[0], a[0] ) ) return false;
		if( !equal_value( b[1], a[1] ) ) return false;
		if( !equal_value( b[2], a[2] ) ) return false;
		return true;
	}

	function exact_same_vectors( a, b ) {
		if( debug ) {
			chk_vparms( a, 3, 1, true );
			chk_vparms( b, 3, 2, true );
		}
		if( b[0] !== a[0] ) return false;
		if( b[1] !== a[1] ) return false;
		if( b[2] !== a[2] ) return false;
		return true;
	}

	function add_vectors( a, b, c ) {								// a + b -&gt; c
		if( debug ) {
			chk_vparms( a, 3, 1, true );
			chk_vparms( b, 3, 2, true );
			chk_vparms( c, 3, 3 );
		}
		c[0] = a[0] + b[0];
		c[1] = a[1] + b[1];
		c[2] = a[2] + b[2];
	}

	function subtract_vectors( a, b, c ) {							// a - b -&gt; c
		if( debug ) {
			chk_vparms( a, 3, 1, true );
			chk_vparms( b, 3, 2, true );
			chk_vparms( c, 3, 3 );
		}
		c[0] = a[0] - b[0];
		c[1] = a[1] - b[1];
		c[2] = a[2] - b[2];
	}

	function scale_vector( a, s, b ) {								// s * a -&gt; b
		if( debug ) {
			chk_vparms( a, 3, 1, true );
			if( typeof s !== &#39;number&#39; ) log( &#39;scale_vector, s = &#39; + s );
			if( typeof s !== &#39;number&#39; ) scale_vector[ &#39;typeof s !== &quot;number&quot;&#39; ].err = 0;
			chk_vparms( b, 3, 2 );
		}
		b[0] = a[0] * s;
		b[1] = a[1] * s;
		b[2] = a[2] * s;
	}

	function vector_magnitude( a ) {
		if( debug ) chk_vparms( a, 3, 1, true );
		return sqrt( a[0]*a[0]
				   + a[1]*a[1]
				   + a[2]*a[2] );
	}

	function unit_vector( a, b ) {									// |a| -&gt; b
		if( debug ) {
			chk_vparms( a, 3, 1, true );
			chk_vparms( b, 3, 2 );
		}
		var magnitude = vector_magnitude( a );
		let abs_mag = abs( magnitude );
		if( abs_mag === 0 || abs_mag === 1 ) {
			copy_vector( a, b );									// return original vector
		} else {
			scale_vector( a, (1 / magnitude), b );
		}
	}

	function dot_product( a, b ) {
		if( debug ) {
			chk_vparms( a, 3, 1, true );
			chk_vparms( b, 3, 2, true );
		}
		return a[0]*b[0]
			 + a[1]*b[1]
			 + a[2]*b[2];
	}

	var vector = [];												// working vector available to functions
	var __vector = [];												// internal working vectors

/* normal_dot_product
	var __vector2 = [];												// internal working vectors
	function normal_dot_product( a, b ) {
		unit_vector( a, __vector );
		unit_vector( b, __vector2 );
		var dot = dot_product( __vector, __vector2 );
		if( dot &gt; 1 )  dot = 1;		// for identical vectors the dot_product sometimes returns a value &gt; 1.0 because of
		if( dot &lt; -1 ) dot = -1;	// rounding errors, resulting in an undefined result for the acos (see angle_between).
		return dot;
	}


	function angle_between( a, b ) {
		return acos( normal_dot_product( a, b ) );
	}
 */

	function angle_between_unitV( a, b ) {							// faster version as &#39;a&#39; is known to be a unit vector
		unit_vector( b, __vector );
		var dot = dot_product( a, __vector );
		if( dot &gt; 1 )  dot = 1;		// for identical vectors the dot_product sometimes returns a value &gt; 1.0 because of
		if( dot &lt; -1 ) dot = -1;	// rounding errors, resulting in an undefined result for the acos (see angle_between).
		return acos( dot );
	}

	function angle_between_two_unitV( a, b ) {						// faster still as both are known to be a unit vector
		var dot = dot_product( a, b );
		if( dot &gt; 1 )  dot = 1;		// for identical vectors the dot_product sometimes returns a value &gt; 1.0 because of
		if( dot &lt; -1 ) dot = -1;	// rounding errors, resulting in an undefined result for the acos (see angle_between).
		return acos( dot );
	}

	var cross = [];													// working vector available to functions

	function cross_product( a, b, c ) {								// a X b -&gt; c
		if( debug ) {
			if( a === c || b === c ) cross_product[ &#39;&#39; ].err = 0;
			chk_vparms( a, 3, 1, true );
			chk_vparms( b, 3, 2, true );
			chk_vparms( c, 3, 3 );
		}
		c[0] = a[1]*b[2] - (a[2]*b[1]);
		c[1] = a[2]*b[0] - (a[0]*b[2]);
		c[2] = a[0]*b[1] - (a[1]*b[0]);
	}

	function copy_quaternion( a, b ) {								// a -&gt; b
		if( debug ) {
			if( a === b ) copy_quaternion[ &#39;a === b&#39; ].err = 0;
			chk_vparms( a, 4, 1, true );
			chk_vparms( b, 4, 2 );
		}
		b[0] = a[0];
		b[1] = a[1];
		b[2] = a[2];
		b[3] = a[3];
	}

	var quaternion = [];											// working quaternion available to functions
/*
	function quat_dot_product( a, b ) {
		if( debug ) {
			chk_vparms( a, 4, 1, true );
			chk_vparms( b, 4, 2, true );
		}
		return a[0]*b[0]
			 + a[1]*b[1]
			 + a[2]*b[2]
			 + a[3]*b[3];
	}

	function negate_quaternion( a, b ) {								// -a -&gt; b
		if( debug ) {
			if( a === b ) copy_quaternion[ &#39;a === b&#39; ].err = 0;
			chk_vparms( a, 4, 1, true );
			chk_vparms( b, 4, 2 );
		}
		b[0] = -a[0];
		b[1] = -a[1];
		b[2] = -a[2];
		b[3] = -a[3];
	}
 */
	function rotate_vector( vector, quat ) {						// rotate vector by quat (ala rotateBy)
		var that = rotate_vector;
		var qw = (that.qw = that.qw || []);							// working quaternion
		qw.length = 0;

		if( debug ) {
			chk_vparms( vector, 3, 1, true );
			chk_vparms( quat, 4, 2, true );
		}
		qw[0] = 0.0 - quat[1] * vector[0] - quat[2] * vector[1] - quat[3] * vector[2];
		qw[1] = -quat[0] * vector[0] + quat[2] * vector[2] - quat[3] * vector[1];
		qw[2] = -quat[0] * vector[1] + quat[3] * vector[0] - quat[1] * vector[2];
		qw[3] = -quat[0] * vector[2] + quat[1] * vector[1] - quat[2] * vector[0];

		vector[0] = qw[0] * -quat[1] + qw[1] * -quat[0] + qw[2] * -quat[3] - qw[3] * -quat[2];
		vector[1] = qw[0] * -quat[2] + qw[2] * -quat[0] + qw[3] * -quat[1] - qw[1] * -quat[3];
		vector[2] = qw[0] * -quat[3] + qw[3] * -quat[0] + qw[1] * -quat[2] - qw[2] * -quat[1];
	}

	function rotate_about_axis( quat, vector, angle, result ) {
		var that = rotate_about_axis;
		var rotn = (that.rotn = that.rotn || []);
		rotn.length = 0;

		if( debug ) {
			if( quat === result ) rotate_about_axis[ &#39;quat === result&#39; ].err = 0;
			if( typeof angle !== &#39;number&#39; ) log( ws.name, &#39;rotate_about_axis, angle = &#39; + angle );
			if( typeof angle !== &#39;number&#39; ) rotate_about_axis[ &#39;typeof angle !== &quot;number&quot;&#39; ].err = 0;
			chk_vparms( quat, 4, 1, true );
			chk_vparms( vector, 3, 2, true );
			chk_vparms( result, 4, 3 );
			if( !equal_value( 1, vector_magnitude( vector ) ) ) {
				if( debug ) {
					log(&#39;rotate_about_axis, NOT a unit vector, vector: &#39; + vector
						+ &#39; has magnitude: &#39; + vector_magnitude( vector ) );
					// rotate_about_axis[ &#39;vector is not normalized&#39; ].err = 0;
				}
			}
		}
		var a = angle / 2;
		var c = cos(a);
		var s = sin(a);
		// rotation quaternion
		rotn[0] = c;
		rotn[1] = vector[0] * s;
		rotn[2] = vector[1] * s;
		rotn[3] = vector[2] * s;
		// multiply quaternions
		result[0] = quat[0]*rotn[0] - quat[1]*rotn[1] - quat[2]*rotn[2] - quat[3]*rotn[3];
		result[1] = quat[0]*rotn[1] + quat[1]*rotn[0] + quat[2]*rotn[3] - quat[3]*rotn[2];
		result[2] = quat[0]*rotn[2] + quat[2]*rotn[0] + quat[3]*rotn[1] - quat[1]*rotn[3];
		result[3] = quat[0]*rotn[3] + quat[3]*rotn[0] + quat[1]*rotn[2] - quat[2]*rotn[1];
	}

	function vector_forward_from_quaternion( quat ) {
		if( debug ) chk_vparms( quat, 4, 1, true );
		var w, wy, wx;
		var x, xz, xx;
		var y, yz, yy;
		var z, zz;
		var qx, qy, qz;

		w = quat[0];
		x = quat[1];
		y = quat[2];
		z = quat[3];

		xx = 2 * x; yy = 2 * y; zz = 2 * z;
		wx = w * xx; wy = w * yy;
		xx = x * xx; xz = x * zz;
		yy = y * yy; yz = y * zz;

		if( !ps_vectorForward ) ps_vectorForward = alloc_array();
		if( isArray( ps_vectorForward ) ) {
			qx = ps_vectorForward[0] = xz - wy;
			qy = ps_vectorForward[1] = yz + wx;
			qz = ps_vectorForward[2] = 1 - xx - yy;
			if( qx || qy || qz ) {
				unit_vector( ps_vectorForward, ps_vectorForward )
			} else {
				ps_vectorForward[0] = 0;
				ps_vectorForward[1] = 0;
				ps_vectorForward[2] = 1;
			}
		}
	}

	function basis_vectors_from_quaternion( quat ) {
		if( debug ) chk_vparms( quat, 4, 1, true );
		var w, wz, wy, wx;
		var x, xz, xy, xx;
		var y, yz, yy;
		var z, zz;
		var qx, qy, qz;

		w = quat[0];
		x = quat[1];
		y = quat[2];
		z = quat[3];

		xx = 2 * x;	 yy = 2 * y;  zz = 2 * z;
		wx = w * xx; wy = w * yy; wz = w * zz;
		xx = x * xx; xy = x * yy; xz = x * zz;
		yy = y * yy; yz = y * zz;
		zz = z * zz;

		if( !ps_vectorRight ) ps_vectorRight = alloc_array();
		if( isArray( ps_vectorRight ) ) {
			qx = ps_vectorRight[0] = 1 - yy - zz;
			qy = ps_vectorRight[1] = xy - wz;
			qz = ps_vectorRight[2] = xz + wy;
			if( qx || qy || qz ) {
				unit_vector( ps_vectorRight, ps_vectorRight )
			} else {
				ps_vectorRight[0] = 1;
				ps_vectorRight[1] = 0;
				ps_vectorRight[2] = 0;
			}
		}
		if( !ps_vectorUp ) ps_vectorUp = alloc_array();
		if( isArray( ps_vectorUp ) ) {
			qx = ps_vectorUp[0] = xy + wz;
			qy = ps_vectorUp[1] = 1 - xx - zz;
			qz = ps_vectorUp[2] = yz - wx;
			if( qx || qy || qz ) {
				unit_vector( ps_vectorUp, ps_vectorUp )
			} else {
				ps_vectorUp[0] = 0;
				ps_vectorUp[1] = 1;
				ps_vectorUp[2] = 0;
			}
		}
		if( !ps_vectorForward ) ps_vectorForward = alloc_array();
		if( isArray( ps_vectorForward ) ) {
			qx = ps_vectorForward[0] = xz - wy;
			qy = ps_vectorForward[1] = yz + wx;
			qz = ps_vectorForward[2] = 1 - xx - yy;
			if( qx || qy || qz ) {
				unit_vector( ps_vectorForward, ps_vectorForward )
			} else {
				ps_vectorForward[0] = 0;
				ps_vectorForward[1] = 0;
				ps_vectorForward[2] = 1;
			}
		}
	}

	// event call stack ///////////////////////////////////////////////////////////////////////////

	function Pending( fn, parm ) { this.fn = fn; this.parm = parm; }// constructor
	var tasks_pending = [];
	var tasks_deferred = [];										// tasks awaiting current cycle to complete
	var used_pending = [];

	function fns_are_pending() { return tasks_pending.length &gt; 0; }

	function show_pending() {
		if( !debug ) return;
		if( tasks_pending.length &gt; 0 ) {
			let rpt = &#39;&#39;
			for( let task in tasks_pending )
				if( tasks_pending.hasOwnProperty( task ) )
					rpt += &#39;\n\t&#39; + task + &#39;: &#39; + tasks_pending[task].fn.name + &#39;( &#39; + tasks_pending[task].parm + &#39; )&#39;;
			log(ws.name, &#39;tasks_pending = &#39; + rpt );
		} else {
			log(ws.name, &#39;tasks_pending is empty &#39; );
		}
		if( tasks_deferred.length &gt; 0 ) {
			let rpt = &#39;&#39;
			for( let task in tasks_deferred )
				if( tasks_deferred.hasOwnProperty( task ) )
					rpt += &#39;\n\t&#39; + task + &#39;: &#39; + tasks_deferred[task].fn.name + &#39;( &#39; + tasks_deferred[task].parm + &#39; )&#39;;
			log(ws.name, &#39;tasks_deferred = &#39; + rpt );
		} else {
			log(ws.name, &#39;tasks_deferred is empty &#39; );
		}
	}

/* show_pending
function show_pending() { // debug
	if( fns_are_pending() )
		log(ws.name, &#39;show_pending, tasks_pending = \n&#39; + cd._showProps( tasks_pending, &#39;tasks&#39;, false, 2 ) );
	else
		log(ws.name, &#39;show_pending, tasks_pending list is empty&#39; );
	if( tasks_deferred.length &gt; 0 )
		log(ws.name, &#39;show_pending, tasks_deferred = \n&#39; + cd._showProps( tasks_deferred, &#39;tasks&#39;, false, 2 ) );
	else
		log(ws.name, &#39;show_pending, tasks_deferred list is empty&#39; );
}
*/

	function free_pending( event ) {
		if( !event ) return;
		event.fn = null;
		event.parm = null;
		used_pending.push( event );
		if( used_pending.length &gt;= 100 ) {							  // ?build up over time
			used_pending.length = 20;
			if( debug ) log(ws.name, &#39;free_pending, pool EXCEEDED 100, reduced to 20&#39; );
		}
	}

	function alloc_pending( fn, parm ) {
		var event;
		if( used_pending.length &gt; 0 ) {
			event = used_pending.pop();
			event.fn = fn;
			event.parm = parm;
		} else {
			event = new Pending( fn, parm );
		}
		return event;
	}

	function set_fn_pending( fn, parm, deferred ) {
		var passing = parm === undefined ? null : parm;				// parm could be zero
		var event, list = deferred ? tasks_deferred : tasks_pending, idx = list.length;
		while( idx-- ) {											// no dups in stack
			event = list[ idx ];
			if( event.fn === fn &amp;&amp; event.parm === passing ) {
//if( debug ) log(ws.name, &#39;set_fn_pending, duplicate call back function &quot;&#39; + fn.name
//					+&#39;&quot;, parm = &#39;+passing+ &#39; ... DISCARDING.&#39; );
				return;
			}
		}
		list.push( alloc_pending( fn, passing ) );
		if( tasks_pending.length &gt; 10 || tasks_deferred.length &gt; 10 ) {
			log(ws.name, &#39;set_fn_pending, stack has reached &#39;+10+&#39;! BAILING out by creating new Sightings ...&#39; );
			_create_Sightings();
			return;
		}
	}

	function tasks_queued( func ) {
		var len = tasks_pending.length,
			fname = func.name;
		while( len-- &gt; 0 ) {
			if( tasks_pending[ len ].fn.name === fname ) {
				return true;
			}
		}
		len = tasks_deferred.length;
		while( len-- &gt; 0 ) {
			if( tasks_deferred[ len ].fn.name === fname ) {
				return true;
			}
		}
		return false;
	}

/*  purge_pending
	function purge_pending( func ) {
		var len = tasks_pending.length,
			fname = func.name;
		while( len-- &gt; 0 ) {
			let fn = tasks_pending[ len ];
			if( fn.name === fname )
				free_pending( popArrayItem( tasks_pending, len ) );
		}
		len = tasks_deferred.length;
		while( len-- &gt; 0 ) {
			let fn = tasks_deferred[ len ];
			if( fn.name === fname)
				free_pending( popArrayItem( tasks_deferred, len ) );
		}
	}

 */

	function clear_all_pending( keep_deferred ) {
		var len = tasks_pending.length;
		if( len &gt; 0 ) {
			while( len-- )
				free_pending( tasks_pending.pop() );
			tasks_pending.length = 0;
		}
		if( keep_deferred ) return;
		len = tasks_deferred.length;
		if( len &gt; 0 ) {
			while( len-- )
				free_pending( tasks_deferred.pop() );
			tasks_deferred.length = 0;
		}
	}

	function _call_pending( num ) {
		try{
			if( !equip_ok ) return;
			var list = tasks_pending;
			var len = list.length;
			if( len === 0 ) {
				list = tasks_deferred;
				len = list.length;
				if( len === 0 ) return;
			}
			var event, rtn;
			var count = ( num === undefined ? 2 : num );	// Sighting tasks limited to num, scan tasks to 2 arbitrarily
			while( len-- &gt; 0 &amp;&amp; count-- &gt; 0 ) {
				event = list.shift();
				if( event === undefined ) throw &#39;list unexpectedly empty&#39;;
				try {
// log(&#39;_call_pending, list: &#39; + (list === tasks_pending ? &#39;tasks_pending&#39; : &#39;tasks_deferred&#39;) + &#39;, &#39; + event.fn.name + &#39;(&#39; + event.parm + &#39;)&#39; );
					rtn = event.fn( event.parm );
				} catch( err ) {
					log( ws.name, ws._reportError( err, event.fn.name, event.parm ) );
					if( debug ) throw err;
				} finally {
					free_pending( event );
				}
			}
		} catch( err ) {
			log( ws.name, ws._reportError( err, &#39;_call_pending&#39;, num ) );
			if( debug ) throw err;
		}
	}

	// Sighting classification ////////////////////////////////////////////////////////////////////

	function is_hostile( ent, set_all ) {							// returns boolean as to whether an entity is hostile
																	// called in different places in notable_ent
																	//	 set_all is true on update_one_Sighting for all ents
																	// so, using_common_vars is *assumed* true
		var ent_defence, have_scanned = false;
		if( isHostile === true &amp;&amp; !set_all ) return true;			// prevent repeat gets unless directed by set_all

		if( distance &lt; 0 ) distance = _detect_distanceTo( ent );
		if( distance &gt; scannerRange ) {
			if( FarStatus ) {										//reveal pirates over normal scanner if have already been in scannerRange
				let index = _Sighting_index( ent );
				if( index &gt;= 0 ) {
					have_scanned = mapping[ index ].have_scanned;
					if( have_scanned !== true &amp;&amp; have_scanned !== -1 ) {// have never been w/i scannerRange
						isHostile = false;
						if( set_all )
							bounty = has_targets = targeting_ps = in_ents_Targets = in_ps_Targets = false;
						return false;
					}
				}
			} else {												// w/o FarStatus, can only know status inside scannerRange
				isHostile = false;
				if( set_all )
					bounty = has_targets = targeting_ps = in_ents_Targets = in_ps_Targets = false;
				return false;
			}
		}

		if( ent.hasHostileTarget ) {
			isHostile = true;
			if( !set_all ) return true;
		}
		if( bounty &lt; 0 ) bounty = ent.bounty &gt; 0 || ent.markedForFines;
		if( bounty ) {
			isHostile = true;
			if( !set_all ) return true;
		}

		var ent_target = ent.target;
		if( has_targets &lt; 0 ) {										// used to classify for MFD_ACTIVE
			if( ent_target ) has_targets = true;					// targeting itself is not hostile
			ent_defence = ent.defenseTargets;
			if( ent_defence &amp;&amp; ent_defence.length &gt; 0 )				// defending oneself is not hostile
				has_targets = true;
		}

		if( in_ents_Targets &lt; 0 )
			in_ents_Targets = index_in_list( ps, ent_defence ) &gt;= 0;
		if( in_ents_Targets ) {										// or in the defenseTargets of the other ship
			isHostile = true;
			if( !set_all ) return true;
		}

		if( in_ps_Targets &lt; 0 )
			in_ps_Targets = index_in_list( ent, ps.defenseTargets ) &gt;= 0;
		if( in_ps_Targets ) {										// or in player&#39;s defenseTargets
			isHostile = true;
			if( !set_all ) return true;
		}

		if( targeting_ps &lt; 0 ) targeting_ps = ent_target === ps;
		if( alertCondition &gt; YELLOW_ALERT &amp;&amp; targeting_ps ) {		// target is hostile if targeting back during a fight
			isHostile = true;										// otherwise, he&#39;s just checking you over
			if( !set_all ) return true;
		}
		return isHostile &lt; 0 ? false : isHostile;
	}

	function is_jamming( ent ) {
/*
http://oolite.aegidian.org/bb/viewtopic.php?f=4&amp;t=3484#p35623

	The military jammer is a complement to the cloak, not a countermeasure. It makes a ship
	invisible to scanners, except to ships with a military scanner filter (who see it as a purple/orange flashing
	thing). has_military_scanner_filter seems to have fallen out of that list, its also a fuzzy boolean. The
	corresponding player equipment key is EQ_MILITARY_SCANNER_FILTER (and for has_military_jammer,
	EQ_MILITARY_JAMMER).
 */
		if( isJamming &lt; 0 || !using_common_vars ) {
			isJamming = ent.isJamming || false;						// orbs lack a .isJamming prop
		}
		return !scanFilter_ok 										// player has working EQ_MILITARY_SCANNER_FILTER
				&amp;&amp; isJamming;
	}

	function is_cloaked( ent ) {
/*
OoRef _Ship.htm:

	isCloaked : Boolean (read/write)

	true if the ship has a cloaking device which is currently active false otherwise. If the ship
	has a cloaking device and sufficient energy to use it (energy &gt; 0.75 * maxEnergy), you can
	activate it by setting isCloaked to true.

	isJamming : Boolean (read-only)

	true if the ship has a military scanner jammer which is currently active false otherwise.
 */
		if( isCloaked &lt; 0 || !using_common_vars ) {
			isCloaked = ent.isCloaked;
		}
		return isCloaked;
	}

	function is_beacon( ent ) {
		if( isBeacon &lt; 0 || !using_common_vars )
			isBeacon = ent.beaconCode || ent.isBeacon;
		return isBeacon;
	}

	function _has_good_status( ent, ent_status ) {
		if( status &lt; 0 || !using_common_vars )						// ent_status optional, save a property get if already known
			status = ent_status || ent.status;
		if( status === &#39;STATUS_IN_FLIGHT&#39;
				|| status === &#39;STATUS_ACTIVE&#39;
				|| status === &#39;STATUS_EXITING_WITCHSPACE&#39;
				|| status === &#39;STATUS_LAUNCHING&#39; )
			return true;
		if( status === &#39;STATUS_EFFECT&#39; ) {
			if( isWormhole &lt; 0 || !using_common_vars )
				isWormhole = ent.isWormhole;
			if( isWormhole ) {
				if( collisionRadius &lt; 0 || !using_common_vars )
					collisionRadius = ent.collisionRadius;
				if( collisionRadius &gt; 0 )
					return true;
			}
		}
		return false;
	}

	function has_bad_status( ent, ent_status ) {
		try {
			return _has_bad_status( ent, ent_status );
		} catch( err ) {
			log( ws.name, ws._reportError( err, &#39;has_bad_status&#39;, [ ent, ent_status ] ) );
			if( debug ) throw err;
		}
	}

	function _has_bad_status( ent, ent_status ) {
		if( !ent || !ent.isValid ) return true;
		if( !using_common_vars || status &lt; 0 )
			status = ent_status || ent.status;
		if( status === &#39;STATUS_ENTERING_WITCHSPACE&#39;					// ship jumped; needed, as ship still around after this status is achieved
				|| status === &#39;STATUS_BEING_SCOOPED&#39;
				|| status === &#39;STATUS_IN_HOLD&#39;						// ditto, scooped entities stick around &amp; will target you (slivers too!)
				|| status === &#39;STATUS_DOCKED&#39;						//	 - also, if ps.target is set, it becomes null
				|| status === &#39;STATUS_DEAD&#39; )
			return true;
		if( status === &#39;STATUS_EFFECT&#39; ) {
			if( isWormhole &lt; 0 || !using_common_vars )
				isWormhole = ent.isWormhole;
			if( isWormhole ) {
				if( collisionRadius &lt; 0 || !using_common_vars )
					collisionRadius = ent.collisionRadius;
				if( collisionRadius === 0 )							// evaporated
					return true;
			}
		}
		return false;
	}

	function is_ignored_ship( ent ) {								// exclude from mapping marker, docked escorts &amp; towed ship
		if( !ent ) return true;
		if( ent === curr_S.marker ) return true;					// is the &#39;telescopemarker&#39;
		if( status &lt; 0 || !using_common_vars ) status = ent.status;
		if( _has_bad_status( ent, status ) ) return true;
		if( Escortdeck ) {											// skip escorts if docked
			let index = index_in_list( ent, Escortdeck.$EscortDeckShip );
			if( index &gt;= 0 &amp;&amp; Escortdeck.$EscortDeckShipPos[ index ] ) {
				return true;										// ent is on deck so exclude it
			}
		}
		if( Towbar &amp;&amp; ent === Towbar.$TowbarShip ) {
			return true;											//skip the towed ship
		}
		return false;
	}

	function read_scriptInfo( ent, map ) {							//read detection from the scriptInfo telescope entry &amp; * set mass *
		if( !map || map.script_mass === undefined ) {
			let info = ent.scriptInfo;								// can give custom mass to the ship/station
			if( info &amp;&amp; info.telescope ) {
				script_mass = parseInt( info.telescope, 10 );
			} else {
				script_mass = null;
				if( map ) map.script_mass = null;
				if( mass &lt; 0 ) mass = ent.mass;
				return null;
			}
		} else {
			script_mass = map.script_mass;
		}
		// * Positive integer: give new mass to the ship in kg which can increase the gravity detection.
		// * Negative integer: will be substracted from the ship.mass in kg to reduce gravity detection.
		// * 0: detected within normal scanner only as without telescope.
		// * 1: detected in visible range only (due to gravity scanner can see a ship with 1kg mass from 2km only).
		if( script_mass &gt; 0 ) {
			mass = script_mass;
			return script_mass;
		}
		if( mass &lt; 0 ) mass = ent.mass;
		if( script_mass &lt; 0 ) {										//substract the mass instead of overwrite it
			mass += script_mass;
		}
		return script_mass;
	}

	function getDetected( ent, restoring ) {						//read detection from the scriptInfo telescope entry; no need to
																	//	 check using_common_vars, as only called from notable_ent
		// a check for beacons is NOT done here for oxp&#39;s with ents
		// that are to remain hidden but insist on having beacons
		// - radio signals are pervasive except when ... \_O_/
		if( is_cloaked( ent ) ) return false;						// is_jamming ents can be seen, just not targetted
		if( distance &lt; 0 ) distance = _detect_distanceTo( ent );
		if( scanClass === &#39;CLASS_CARGO&#39;								// ent must 1st be detected w/i scannerRange
				&amp;&amp; (!mk_maps || restoring) ) {						// no grow_hidden_scanned array in update cycle
			let index = _Sighting_index( ent );						// need to test RFID range
			let limit = scannerRange;								// newly discovered must be inside scannerRange
			limit += !restoring &amp;&amp; index &lt; 0 ? 0					//	 updating &amp; not in mapping
						: randomInt( 0, scannerRange &gt;&gt; 1 );		// while known ones detectable by RFID
			if( distance &gt; limit )									// RFID not yet detected or lost to background noise
				return false;										//	 (telescope DB garbage collects data on lost RFID, so must re-aquire)
		}
		if( script_mass === undefined )								// has never been read
			script_mass = read_scriptInfo( ent );					//can give custom detection distance to the target ship
		if( script_mass === 0 )										// script_mass = 0: detected within normal scanner only as without telescope.
			return distance &lt; scannerRange;							//	=&gt; am assuming they&#39;re not to be detected beyond scannerRange, else mk work like cargo
			// &quot;once detected then tracked over scanner range while in visible range until next scan (small help and save performance)&quot;
		if( script_mass === 1 ) {									// script_mass = 1: detected in visible range only
			if( isVisible &lt; 0 ) isVisible = ent.isVisible;
			if( !isVisible || (distance &gt; scannerRange &amp;&amp; !ext_ok) )
				return false;
		}
		if( script_mass === null ) {								// old code has any script_mass precluding station test
			if( isStation &lt; 0 ) isStation = ent.isStation;
			if( isStation ) {										//hide custom station over 4x scanner range
				if( primaryRole &lt; 0 ) primaryRole = ent.primaryRole;// 9 compares profiles twice as fast as using index_in_list
				if( primaryRole &amp;&amp; primaryRole !== &#39;station&#39; &amp;&amp; primaryRole !== &#39;coriolis&#39;	   &amp;&amp; primaryRole !== &#39;dodo&#39;
								&amp;&amp; primaryRole !== &#39;dodec&#39;	 &amp;&amp; primaryRole !== &#39;dodecahedron&#39; &amp;&amp; primaryRole !== &#39;ico&#39;
								&amp;&amp; primaryRole !== &#39;icosa&#39;	 &amp;&amp; primaryRole !== &#39;icosahedron&#39;  &amp;&amp; primaryRole.substring(0, 10) !== &#39;rockhermit&#39; )
					// rockhermit role can be &quot;rockhermit&quot;, &quot;rockhermit-chaotic&quot;, &quot;rockhermit-pirate&quot; and more in the future?
					if( distance &gt; scannerRange_X_4 ) return false;
			}
		}
		//stealth ships and non-standard stations detected in normal scanner range only, requested by Svengali
		if( dataKey &lt; 0 ) dataKey = ent.dataKey;
		if( dataKey ) {
			if( dataKey === &#39;vector_arn&#39; || dataKey.indexOf( &#39;stealth&#39; ) &gt;= 0 ) {
				if( distance &gt; scannerRange ) return false;			//mission ship in Vector OXP
			}
		}
		if( primaryRole &lt; 0 ) primaryRole = ent.primaryRole;
		if( primaryRole ) {
			if( primaryRole.indexOf( &#39;stealth&#39; ) &gt;= 0 || primaryRole.indexOf( &#39;rescue_blackbox&#39; ) &gt;= 0 ) {
				if( distance &gt; scannerRange ) return false;			//mission ships in Rescue Stations OXP
			}
		}
		return true;
	}

	// Sighting distance calculations /////////////////////////////////////////////////////////////

	function hullOffset( ent ) {
		var offset = 0;
		if( radius &lt; 0 || !using_common_vars )
			radius = ent.radius || false;
		if( radius ) {												// distance to near surface
			offset = radius;
		} else {													// distance to near (hull) surface
			if( collisionRadius &lt; 0 || !using_common_vars )
				collisionRadius = ent.collisionRadius;
			offset = collisionRadius;
		}
		return offset;
	}

	// dist for near vs. far targets is when .distanceTo === scannerRange, regardless of any radius/collisionRadius
	// - core crosshair shows .distanceTo less cr of target
	// =&gt; marker should read _detect_distanceTo, ie. position.distanceTo - ent.collisionRadius

	function _detect_distanceTo( ent ) {							// to x; distanceTo gives distance to centers, not hulls
		try {
			/// some of this function is duplicated in _reposition_effects for speed
			var that = _detect_distanceTo;
			var distanceTo = (that.distanceTo = that.distanceTo || []);
			distanceTo.length = 0;

			if( (ps_position &amp;&amp; ps_position.length === 0) || !using_common_vars ) {	// set every frame
				copy_vector( ps.position, ps_position );
			}
			subtract_vectors( ps_position, ent.position, distanceTo );
			var distTo = vector_magnitude( distanceTo );			// dist from ship&#39;s hull to x&#39;s center; NB: core crosshairs give hull to hull
			distTo -= hullOffset( ent );							// distance to near surface
			return distTo &lt; 0 ? 0 : distTo;
		} catch( err ) {
			log( ws.name, &#39;, ent.position: &#39; + ent.position + &#39;, distTo: &#39; + distTo
				+ &#39;, radius: &#39; + radius + &#39;, collisionRadius: &#39; + collisionRadius );
			ws._reportError( err, _detect_distanceTo, ent );
		}
	}

	function grav_scan_dist( ent, rtn_curr, map ) {					// return gravity scan distance for ent
		if( radius &lt; 0 ) radius = ent.radius || false;
		if( radius )	 return -1;									// ignore planets, moons &amp; sun
		if( script_mass === undefined )								// will set &#39;mass&#39; variable if required, ie. calling read_scriptInfo() sets both
			script_mass = read_scriptInfo( ent, map );				//	  mass &amp; script_mass, if had not already been called (if script_mass === undefined )
		if( mass === 0 ) return -1;									// ignore wormholes
		var dist;
		if( !rtn_curr || gravScanProgress === 1 ) {					// return max. gravity scan detection distance
			if( !map ) {											// &quot;mass of the target in kg must be larger than d2*d2*d2/100 where d2 = distance*2 in km&quot;
				dist = pow( 100 * mass, 1/3 )						//	 invert &#39;mass &gt; d2*d2*d2/100&#39; =&gt; &#39;d2 &lt; cube root(mass * 100)&#39;
					   * gs_mult * 500;								//	 &#39;* 500&#39; to cnv to meters: &#39;d2 = distance*2 in km&#39; =&gt; &#39;distance = (1000 * d2)/2&#39;
				return dist;
			}
			return map.gs_max_dist;									// skip calc if poss. (when updating)
		} else if( gravScanProgress &gt; 0 &amp;&amp; gravScanProgress &lt; 1 ) { // grav. scan progress varies by mass, so distance varies as the cube root of mass,
			dist = pow( 100 * gravScanProgress * mass, 1/3 )		//	 thus the 2nd call of grav_scan_dist (can&#39;t just scale, ie. use gravScanProgress * max)
				   * gs_mult * 500;
			return dist;
		}
		return 0; // because gravScanProgress === 0
	}

	// Sighting creation &amp; recycling pool /////////////////////////////////////////////////////////

	var used_Sightings = [];

	function free_Sighting( map ) {									// attempt to reduce garbage collection by managing used objects
		if( !map ) return;
		// scrub old data
		// these 3 set in init_Sighting
		map.ent = null;
		map.last_posn.length = 0;
		map.entityPersonality = -1;									// unique ID# for spreading updates across frames
																	//	 and generating random detection distance for cargos
		// these 11 set in mk_Sighting
		map.rank = -1;												// category used for sorting
		map.ent_dist = -1;											// distance to entity measured by whatever equipment is installed
		map.gs_curr_dist = -1;										// distance grows as grav. scan progresses
		map.gs_max_dist = -1;										// max. grav. scan distance, calc&#39;d on creation
		map.script_mass = undefined;								// save scriptInfo so read_scriptInfo() only called once/ent (don&#39;t
																	//	 init to null, as set null when we know there&#39;s no scriptInfo
																	//	  =&gt; needs to be init&#39;d as undefined
		map.dynamicMFD = 0;											// MFD flags for dynamic properties
		map.staticMFD = 0;											// MFD flags for static properties
		map.headingTo = 180;										// in degrees, offset from player&#39;s vectorForward; init behind so not immediately found
		map.ve_colour = &#39;&#39;;											// visualEffect colour
		map.hasJammer = false;										// if true, name is not cached as different if on/off
		map.ml_radius = 0;											// for support of VariableMassLock
		map.have_scanned = false;									// for support of scriptInfo = { telescope = 0 }; =&gt; set to true
																	//	 also used for cargo RFID =&gt; set to a detection range &gt; 0
																	//	 and FarStatus =&gt; set -1 when come w/i scannerRange
		// these may be set in update_one_Sighting et al
		map.lb_size = &#39;&#39;;											// lightball size
		map.ml_size = &#39;&#39;;											// masslock ring size
		let effect = map.lightball;									// visualEffect ref. if any
		if( effect ) {
			effect.remove();
			map.lightball = null;
		}
		effect = map.masslock;										// visualEffect ref. if any
		if( effect ) {
			effect.remove();
			map.masslock = null;
		}
		// toss into recycle bin
		used_Sightings.push( map );
		if( used_Sightings.length &gt;= 300 ) {						  // ?build up over time
			used_Sightings.length = 50;
if( debug ) log(ws.name, &#39;free_Sighting, pool EXCEEDED 300, reduced to 50&#39; );
		}
	}

	function alloc_Sighting() {										// attempt to reduce garbage collection by managing used objects
		if( used_Sightings.length &gt; 0 ) {							// re-use old map
			return used_Sightings.pop();
		}
		return {};
	}

	function mkSighting( ent ) { // assumes &#39;rank&#39; has been set before calling!
		var map = alloc_Sighting();
		map.ent = ent;
		if( position.length === 0 )								   // not already set
			copy_vector( ent.position, position );
		if( !map.last_posn ) map.last_posn = alloc_array();
		copy_vector( position, map.last_posn );						// position @ time of last scan/update -&gt; $ListPos
		if( scanClass === &#39;CLASS_NO_DRAW&#39; ) {						// celestial objects have no personality; [32768, 49151]
			map.entityPersonality = 32768 + floor((position[0] + position[1] + position[2]) % 16384);
		} else if( scanClass === &#39;CLASS_WORMHOLE&#39; ) {				// don&#39;t use collisionRadius, as it varies; [49152, 65535]
			let spawnTime = ent.spawnTime;
			spawnTime -= floor(spawnTime);							// fractional part only; [0, 1]
			map.entityPersonality = 49152 + floor(spawnTime * 16384);
		} else {													// normal entities limited to [0, 32767]
			map.entityPersonality = ent.entityPersonality;
		}
		map.rank = rank;											// category used in sorting
		if( distance &lt; 0 ) distance = _detect_distanceTo( ent );
		map.ent_dist = distance;
		if( gs_curr &lt; 0 ) gs_curr = grav_scan_dist( ent, true );
		map.gs_curr_dist = gs_curr;
		if( gs_max &lt; 0 ) gs_max = grav_scan_dist( ent );
		map.gs_max_dist = gs_max;
		if( script_mass === undefined )
			script_mass = read_scriptInfo( ent );					// also sets &#39;mass&#39;
		map.script_mass = script_mass;
		map.dynamicMFD = dynamicMFD;
		map.staticMFD = staticMFD;
		map.headingTo = 180;
		if( radius &lt; 0 ) radius = ent.radius || false;				// ents available to be swapped out for closer ones
		map.swapable = !radius &amp;&amp; !is_beacon( ent );				//   are those that are not orbs and not beacons
		is_jamming( ent );											// sets isJamming; return includes scanFilter_ok which we ignore here
		map.hasJammer = isJamming;									// never gets set false, need to know ent has one, not if it&#39;s turned on
																	// - used to bypass naming cache, as becomes unknown-ship if it&#39;s on
		if( isWormhole &lt; 0 ) isWormhole = ent.isWormhole;
		if( isWormhole &amp;&amp; !ent.name ) ent.name = &#39;wormhole&#39;;
		if( ve_colour !== -1 ) map.ve_colour = ve_colour;
		if( VariableMassLock ) {
			let ml_radius = VariableMassLock.$Range( mass );		// mass * 0.02 + 17000 //small masslock radius of this ship
			// VariableMassLock scales masslock radius between	Adder (16 t) = 17 km -&gt; Anaconda (438 t) = 26 km
			// - doesn&#39;t enforce an upper bound, so ships heavier than Anaconda will have even larger radius!
			//	 - he&#39;s using checkScanner, so never deals w/ ships beyond scannerRange
			map.ml_radius = ml_radius &gt; scannerRange ? scannerRange // upper limit on ring size
													 : ml_radius;
		}
		map.have_scanned = false;
		if( script_mass === 0 ) {									// ents w/ scriptInfo telescope = 0 use .have_scanned
			map.have_scanned = true;								//	 to be remembered beyond scannerRange once detected within
			// for entities; with scriptInfo.telescope=0, entities are hidden until inside scanner
			// range, &quot;but once detected then tracked over scanner range while in visible range until next scan&quot;
		} else if( is_cargo === true ) {
			map.have_scanned = scannerRange + (map.entityPersonality &gt;&gt; 1);// pod&#39;s RFID range
			// .have_scanned used for cargo&#39;s extended range (RFID tracking) once it&#39;s entered scannerRange
		}
		return map;
	}

	// Sighting functions /////////////////////////////////////////////////////////////////////////

	function Sighting_index( ent ) {
		try {
			return _Sighting_index( ent );
		} catch( err ) {
			log( ws.name, ws._reportError( err, &#39;Sighting_index&#39;, ent ) );
			if( debug ) throw err;
		}
	}

	function _Sighting_index( ent /*,caller*/ ) {					// ent can be either a Sighting or entity
		if( !equip_ok ) return -1;
		if( !ent ) return -1;
		if( mapping === null ) return -1;							// mapping not yet initialized or empty list
		if( ent.ent_dist )											// ent is a Sighting
			return index_in_list( ent, mapping );
		var target = ent === curr_S.marker ? curr_S.ent : ent;
		if( !target || !target.isValid ) return -1;					// target died
		for( let idx = 0; idx &lt; maplen; idx++ ) {
			let map = mapping[ idx ];
			if( target === map.ent ) return idx;
		}
		return -1;
	}

	function set_curr_Sighting( ent, caller ) {
		try {
			_set_curr_Sighting( ent, caller );
		} catch( err ) {
			log( ws.name, ws._reportError( err, &#39;set_curr_Sighting&#39;, ent ) );
			if( debug ) throw err;
		}
	}

	function _set_curr_Sighting( ent /*,caller */ ) {				// ent can be an entity or map to be located
		if( ent === undefined || ent === null ) {					// no parm is signal to reset
			curr_target = curr_S.ent = curr_S.map = null;
			curr_S.index = -1;
			if( curr_S.marker ) removeMarker();						// cannot hang onto it for next target, as still see lollipop
			curr_S.name = &#39;&#39;;
			_clear_HUD_Effects();									// clear model, ring &amp; sniper ring
			ws.$IdentKeyPress = identKeyPress = IDENT_READY;		// ensure it&#39;s reset

			TelescopeList[ 0 ] = null;
			ws.$TelescopeListi = 0;									// $TelescopeListi = 0 =&gt; not in $TelescopeList
// if( debug ) log(&#39;_set_curr_Sighting, curr_S cleared by &#39; + caller);
			return;
		}
		var index = _Sighting_index( ent, &#39;_set_curr_Sighting&#39; );
		if( index &lt; 0 || index &gt;= maplen ) {
			_set_curr_Sighting( null, &#39;_set_curr_Sighting&#39; );		// recurse to reset
			return;
		}
		var map = mapping[ index ];
		curr_S.map = map;
		curr_target = curr_S.ent = map.ent;
		curr_S.index = index;
		// curr_S.marker, curr_S.marker_type remain unchanged unless explicity changed by marker code
		if( curr_S.marker ) {										// oxp&#39;s can retrieve telescope target via marker.target
			curr_S.marker.$TelescopeTarget = curr_target;
		}
		TelescopeList[ 0 ] = curr_target;							// for oxp support, $TelescopeList is always an array of 1 entity
		ws.$TelescopeListi = 1;										// and $TelescopeListi is 1 if have a target, 0 otherwise
// if( debug ) log(&#39;_set_curr_Sighting, (IdentKeyPress=&#39;+identKeyPress +&#39;) curr_S set to &#39;
				// + (map.name ? map.name : map.ent.displayName || map.ent.name) + &#39; by &#39; + caller);
	}

	function farthestToSwap( chkRank, chkDist ) {					// return map for a ship to swap out of mapping
		var maxDist = 0,
			farthest = null,
			secondBest = null,
			psTarget = curr_S.map;
		var saved_isBeacon = isBeacon,								// preserve so don&#39;t repeat property get
			was_using_common_vars = using_common_vars;				// (beaconCode is not a common var)
			isBeacon = -1;
			using_common_vars = false;
		for( let idx = 0; idx &lt; maplen; idx++ ) {
			let map = mapping[ idx ];
			if( map === psTarget ) continue;						// is player&#39;s target
			if( map.rank &lt; chkRank ) continue;						// cannot swap more important entity
			// - can use string compare as ranks are named to be alphabetically increasing
			if( !map.swapable ) continue;							// orbs and beacons are always maintained
																	// in mapping, ie. not available for swap
			let map_dist = map.ent_dist;
			if( map_dist &lt; chkDist ) continue;						// cannot swap closer entity
			if( map_dist &gt; maxDist ) {
				maxDist = map_dist;
				if( farthest )
					secondBest = farthest;							// also a candidate for deletion
				farthest = idx;
			}
		}
		isBeacon = saved_isBeacon;
		using_common_vars = was_using_common_vars;
		if( secondBest !== null ) {
			if( secondBest &lt; farthest ) {
				farthest--;
			}
			_delete_Sighting( secondBest );
		}
		return farthest;
	}

	function numberSwapable() {
		var swapable = 0;
		for( let idx = 0, len = mapping.length; idx &lt; len; idx++ ) {
			if( mapping[idx].swapable ) swapable++;
		}
		return swapable;
	}

	function add_Sighting( ent, is_notable, forced ) {
		try {
			return _add_Sighting( ent, is_notable, forced );
		} catch( err ) {
			log( ws.name, ws._reportError( err, &#39;add_Sighting&#39;, [ ent, is_notable ] ) );
			if( debug ) throw err;
		}
	}

	function _add_Sighting( ent, is_notable, forced /*, caller */ ) {
		if( !equip_ok ) return;
		if( !mappingReady ) return -1;								// launching/exiting witchspace &amp; haven&#39;t made 1st _Scan()
		if( !ent || !ent.isValid ) return -3;						// ship died, docked or jumped
		if( !ps || !ps.isValid || alertCondition === DOCKED ) 		//if player died or docked
			return -4;
		if( _Sighting_index( ent, &#39;_add_Sighting&#39; ) &gt;= 0 ) {		// already in mapping
			return -5;
		}

		let now = clock.absoluteSeconds;
		let spawned = ent.spawnTime;
		if( spawned &gt; 0 &amp;&amp; now - spawned &lt; SPAWN_DELAY ) 			// too new; will be picked up as a new target
			return -10;

		scanClass = ent.scanClass;
		radius = ent.radius || false;
		if( scanClass === &#39;CLASS_NO_DRAW&#39; &amp;&amp; !radius ) {			// not an orb, probably wreckage
			return -9;
		}
		status = ent.status;
		if( !_has_good_status( ent, status ) ) {
			return -6;
		}
		if( !is_notable ) {											// else was done already in check_if_new_targets
			let save_status = status,
				save_scanClass = scanClass,
				save_radius = radius;								// preserve so don&#39;t repeat property get
			reset_common_vars();
			status = save_status;
			scanClass = save_scanClass;
			radius = save_radius;
			if( !notable_ent( ent ) ) {								// sets rank, ve_colour &amp; (maybe) distance
				using_common_vars = false;
				return -7;
			}
		}
		if( rank === &#39;ukn&#39; ) {										// must be detected before it can become lost
			return -8;												//  - rank may be set by caller
		}
		if( distance &lt; 0 ) distance = _detect_distanceTo( ent );	// needed if call farthestToSwap (used in mkSighting)
		let swapable = numberSwapable();							// orbs &amp; beacons excluded from MaxTargets
		if( !forced
				&amp;&amp; alertCondition !== RED_ALERT /// until someone complains, exclude RED_ALERT from MaxTargets restriction
				&amp;&amp; swapable &gt;= MaxTargets ) {						// mapping is full, swap if ent is closer or a priority
			let swapIdx = farthestToSwap( rank, distance );
			if( swapIdx ) {											// found one futher out from ent
				free_Sighting( popArrayItem( mapping, swapIdx ) );
				maplen = mapping.length;
			} else {
				return swapable &gt; 0 ? -8 : -2;
				// -2 used for &#39;memory full&#39; message; -8 =&gt; something else stopped the insert
			}
		}
		found_new = true;
		var map = mkSighting( ent );
		mapping.push( map );
		maplen++;
		var insert_i = maplen - 1;
		update_one_Sighting( map, ent, insert_i );
		if( curr_target === ent &amp;&amp; !profiling ) {
			_manage_marker( map, false, &#39;_add_Sighting&#39; );
		}
		if( !is_notable ) {
			using_common_vars = false;
		}
		return insert_i;
	}

	function delete_Sighting( ent, caller ) {
		try {
			_delete_Sighting( ent, caller );
		} catch( err ) {
			log( ws.name, ws._reportError( err, &#39;delete_Sighting&#39; ) );
			if( debug ) throw err;
		}
	}

	function _delete_Sighting( ent /*, caller */) {					// ent can be an ent, Sighting or index (faster)
		if( !equip_ok ) return;
		if( !mappingReady || maplen === 0 ) return;					// mapping not yet initialized OR it&#39;s empty
		if( ent === null &amp;&amp; ent === undefined ) return;
		var index = typeof( ent ) === &#39;number&#39; ? ent : null;
		if( index !== null &amp;&amp; (index &lt; 0 || index &gt;= maplen ) ) return;

		var found = -1, map = null;
		if( index !== null ) {										// were passed an index, will ignore ent arg
			found = index;
			map = mapping[ found ];
		} else if( ent.ent !== undefined ) {						// were passed a map
			map = ent;
			found = index_in_list( map, mapping );
			if( found &lt; 0 ) {
				if( map === curr_S.map ) {
					_set_curr_Sighting( null, &#39;_delete_Sighting&#39; );
				}
				return;
			}
		} else {													// were passed an ent
			found = _Sighting_index( ent, &#39;_delete_Sighting&#39; );
			if( found &lt; 0 ) {
				return;
			}
			map = mapping[ found ];
		}
		if( map === curr_S.map ) {									// is player&#39;s target
			_set_curr_Sighting( null, &#39;_delete_Sighting2&#39; );		// no parms resets $curr_Sighting
		}
		free_Sighting( popArrayItem( mapping, found ) );
		maplen = mapping.length;
	}

	const RANK_STRS = [ &#39;bad&#39;, &#39;isr&#39;, &#39;loc&#39;, &#39;mng&#39;, &#39;nsr&#39;, &#39;orb&#39;, &#39;ukn&#39; ];
	// names for grouping hostiles(bad), ships in scannerRange(isr), stations &amp; cargo(loc), mining stuff(mng),
	//					  far targets(nsr), sun/planet/moon(orb), lost targets(ukn)

	function select_Sightings( count, rank, compare ) {				// &#39;count&#39; (0 =&gt; all); &#39;rank&#39; (0 =&gt; all) &amp; &#39;compare&#39; are optional but need at least 1
																	//	 &#39;rank&#39; limits search to that group; &#39;compare&#39; is a boolean function applied to each
																	// NB: return null or static array selected_Sightings
		if( !equip_ok ) return null;
		if( !mappingReady || maplen === 0 ) return null;			// launching/exiting witchspace &amp; haven&#39;t made 1st mapping OR it&#39;s empty
		if( count === undefined ) return null;						// no point selecting entire list! (can be zero)
		do {
			if( compare ) break;
			if( rank === 0 ) break;									// all ranks
			if( index_in_list( rank, RANK_STRS ) &gt;= 0 ) break;		// a valid rank
			return null;											// have to specify at least compare fn or some rank
		} while( false );
		selected_Sightings.length = 0;								// remove any previous results
		var num = count ? count : maplen;							// if no count, default to all
		for( let idx = 0; idx &lt; maplen; idx++ ) {
			let map = mapping[ idx ];
			if( rank &amp;&amp; rank !== map.rank ) continue;
			if( compare &amp;&amp; !compare( map ) ) continue;
			selected_Sightings.push( map );
			num--;
			if( num &lt;= 0 ) break;
		}
		return selected_Sightings;
	}

	function check_Sightings( parm ) {								// loop through Sightings &amp; delete those no longer valid
		var that = check_Sightings;									// NB: neither update can delete ents that become !notable (expensive)
		if( that.blocked === undefined ) that.blocked = 0;			//	   so that must (eventually) happen here
		if( that.adjusted === undefined ) that.adjusted = 0;
		var adjusted = that.adjusted,
			blocked = that.blocked;

		if( !equip_ok ) return;
		if( !mappingReady || maplen === 0 ) return;					// mapping not yet initialized OR empty
		if( fns_are_pending() &amp;&amp; parm === false ) {					// called in midst of creating a new mapping, abort!
			blocked = that.blocked = blocked + 1;					// count blocked full checks (can get blocked by update on slow PCs)
			if( blocked &lt; 3 ) return;								// each called once/second, prevent blocks longer than 2 sec
		}															//	 wait for full, not quick check to unblock
		if( parm === false ) that.blocked = 0;						// checking, so reset counter
		var starting, index, quickly, fps, del;
		if( parm === true ) {
			quickly = that.quickly = true;
			fps = that.fps = current_fps ? current_fps() : -1;		// quickly is fast, so check fps/frame
			if( fps &lt; 0 ) fps = that.fps = 30;						//	 current_fps returns -1 until 1st min. has passed
			starting = index = maplen;
		} else if( parm === false || parm === undefined ) {
			quickly = that.quickly = false;
			fps = current_fps ? current_fps() : -1;
			if( fps &lt; 0 ) fps = 30;									//	  current_fps returns -1 until 1st min. has passed
			fps = that.fps = floor(fps / (5 - adjusted));			// store as fn prop for next frames&#39; execution
			starting = index = maplen;								//	 - #/frame scales w/ framerate; override increases #/frame to reduce discarded calls
		} else {													// parm is an index # to resume
			quickly = that.quickly || true;
			fps = that.fps || 6;
			starting = maplen;
			index = parm;
		}
		using_common_vars = !quickly;

		while( index-- ) {											// work backwards thus list, so indices are simple
			let map = mapping[ index ];
			if( !map ) continue;
			if( index &gt; 0 &amp;&amp; index % fps === 0 ) {					// checking list can take more time than we&#39;d like in a frame
				set_fn_pending( check_Sightings, index );			//	 @ 43 fps, 0.33 ms/Sighting; fps/5 = 8 =&gt; 2.67 ms
				return;												// so do a chunk each frame, its size a fn of fps
			}
			let ent = map.ent;
			if( quickly ) {
				scanClass = collisionRadius = isVisible = -1;
			} else {
				reset_common_vars();
			}
			isWormhole = ent ? ent.isWormhole : false;
			if( isWormhole ) _handle_wormhole( ent );				// keep an eye on clock to annouce destination
			del = true;
			do {
				if( !ent || !ent.isValid ) break;					// ship destroyed or wormhole expired
				status = ent.status;
				if( _has_bad_status( ent, status ) ) break;
				distance = map.ent_dist;							// needs to be set for notable_ent
				if( distance &lt; scannerRange &amp;&amp; is_cloaked( ent ) )	// range check limits calls to is_cloaked
					break;
				if( scanClass &lt; 0 ) scanClass = ent.scanClass;
				if( scanClass === &#39;CLASS_CARGO&#39; &amp;&amp; is_ignored_ship( ent ) ) break;
				if( collisionRadius &lt; 0 ) collisionRadius = ent.collisionRadius;
				if( isWormhole &amp;&amp; collisionRadius === 0 ) break;	// wormhole expired
				let have_scanned = map.have_scanned;
				if( have_scanned === true &amp;&amp; !ent.isVisible ) break;// lose sight of hidden (scriptInfo{ telescope= 0;})
				if( typeof have_scanned === &#39;number&#39; &amp;&amp; have_scanned !== -1
						&amp;&amp; distance &gt; have_scanned )				// lose cargo RFID in background noise
					break;
				if( quickly ) {										// restrict check to the above for speed
					del = false;
					break;
				}
				if( notable_ent( ent, false, distance ) ) del = false;
			} while( false );
			if( del ) {
// if( debug ) log(&#39;check_Sightings, deleting (&#39; + ent.entityPersonality + &#39;): &#39; + ent.name );
				_delete_Sighting( index, &#39;check_Sightings&#39; + (quickly ? &#39; -quickly&#39; :&#39;&#39;) ); // not ok, remove
			}
		}
		if( !quickly ) using_common_vars = false;
// if( debug &amp;&amp; starting !== maplen ) {
// 	log(&#39;check_Sightings, started w/ &#39; + starting + &#39;, ended w/ &#39; + maplen );
//		}
	}

	// user Sighting functions ////////////////////////////////////////////////////////////////////

	function chg_curr_Sighting( step ) {
		try {
			_chg_curr_Sighting( step );
		} catch( err ) {
			log( ws.name, ws._reportError( err, &#39;chg_curr_Sighting&#39;, step ) );
			if( debug ) throw err;
		}
	}

///
	function _chg_curr_Sighting( step ) {							// incr or decr used when user steps through the Sightings
		var that = _chg_curr_Sighting;
		if( that.last_curr_S === undefined ) that.last_curr_S = null;// to remember across calls
		var last_curr_S = that.last_curr_S;

		if( !mappingReady || maplen === 0 ) return;					// map not initialized OR empty
		check_Sightings( true );									// clear out any that died, jumped or scooped
		var map, ent, index, skip_scan = false;
		mapping.sort( map_sort_dist );								// match sort of mfd
		// mapping.sort( map_sort_rank_dist );
///??with filtering, must remember what&#39;s in mfd(s) and follow that
/// vs leave as in 1.15, stepping thru all
///?if !separate &amp;&amp; !filtering, scroll primary MFD
///?elif !filtering, jump to aux &amp; scroll it

		if( last_curr_S ) {											// resuming after we forced a rescan by wrapping end of list
			index = _Sighting_index( last_curr_S, &#39;_chg_curr_Sighting&#39; );
			last_curr_S = that.last_curr_S = null;
			skip_scan = true;
		} else {
			index = _Sighting_index( curr_S.map, &#39;_chg_curr_Sighting&#39; );
		}
		if( index &lt; 0 ) {											// no target, start @ list end
			index = step &gt; 0 ? maplen - 1 : 0;
			skip_scan = true;
		}
		map = index &gt;= 0 &amp;&amp; index &lt; maplen ? mapping[ index ] : null;
		if( !map ) {												// no target, default to start of list (may have been removed by rescan)
			_set_curr_Sighting( maplen &gt; 0 ? mapping[ 0 ] : null, &#39;_chg_curr_Sighting&#39; );
			last_curr_S = that.last_curr_S = null;					// ensure it&#39;s cleared before premature exit
			return;
		}
		do {
			index += step;
			if( index &gt;= maplen || index &lt; 0 ) {					// past an end of the mapping
				if( !skip_scan ) {									// so create a new one
					last_curr_S = that.last_curr_S = map.ent;		// remember which ent to resume at
					_auto_updates( true );							// true initiates create (which wipes deferred tasks), suppresses call to _manage_marker in _auto_updates
					set_fn_pending( _chg_curr_Sighting, step, true );// true sets a &#39;deferred&#39; task for after update
					return;
				} else {											// back from creating a new one
					index = index &lt; 0 ? maplen - 1 : 0;
				}
			}
			map = mapping[ index ];
			ent = map.ent;
		} while( ( ent &amp;&amp; ent.isWormhole							// after wormhole scanner started, they become normal Sightings but
					&amp;&amp; ent.$TelescopeScanStart === undefined ) );	//	 not until manually targetted (ie. &#39;r&#39; button), req&#39;d by core
		_manage_marker( map, map.ent_dist &gt; scannerRange,			// distance test prevents double msgs on near targets
						&#39;_chg_curr_Sighting&#39; );						//	 ours &amp; ident msg (still get double @ transition, on telescope marker)
		if( Steering === 2 ) {
		//  ||( Steering === 1 &amp;&amp; ent === findNearestEnt() ) ?is player expecting to steer to nearest when stepping through list
			start_Steering();										//turn to the target
		}

		// suspend _mostCentered while user is stepping
		// - there is no event to tell us player has stopped stepping, so a time limit is used
		// - delay_counter is set to double that of IdentDelay, which gets reset when no longer
		//   stepping
		// - mode() calls _resetIdentDelay if player switches to a different function
		// (all activated() does is call this fn)
		// NB: if weaponsOnline, the stepped ent remains current target (as _mostCentered not called unless have no target)
		//     else navigation mode reasserts itself using GravLock
		delay_counter = IdentDelay * 2;								// suspend mostCentered for twice IdentDelay
		ws.$IdentKeyPress = identKeyPress = IDENT_STEP_DELAY;		// this starts IdentDelay counter once steering complete
	}

	function targeting_player( map ) {
		// called from find_most_central &amp; _nearest_Sighting (via select_Sightings) only in RED_ALERT
		// checks needed, as eg. scooped splinters/cargo targets player
		var ent = map.ent;
		var target = ent.target;
		if( target !== ps ) 				return false;
		if( !ent.isShip &amp;&amp; !ent.isStation ) return false;
		if( ent.isDerelict ) 				return false;			// don&#39;t lock on derelicts when in combat (dybal)
		if( weaponsOnline &amp;&amp; TargetOnlyHostile) {					// limit to hostile targetters (no cargo, pods, etc.)
/// mk an option so player can toggle this fn, default false (like prev. ver.s)
			let weap = target.currentWeapon;
			if( !weap || weap.equipmentKey === &#39;EQ_WEAPON_NONE&#39; )
				return false;
			return true;
		}
		return true;
	}

	function findNearestEnt() {
		var list = mapping,
			len = maplen;
		if( alertCondition &gt; YELLOW_ALERT &amp;&amp; weaponsOnline ) {
			//in Red Alert lock the last attacker if any and weapons are online
			list = select_Sightings( 0, 0, targeting_player );		// first, target those targeting player; 0 =&gt; all, 0 =&gt; any rank
			len = list &amp;&amp; list.length;
			if( !len ) {
				list = select_Sightings( 0, &#39;bad&#39; );				// none, try any hostiles; 0 =&gt; all
				len = list &amp;&amp; list.length;
			}
			if( !len ) {
				list = mapping;										// none found, search entire mapping
				len = maplen;
			}
		}
		var map, ent;
		var min_dist = MaxRange;
		var closest = null;
		while( len-- ) {
			map = list[ len ];
			ent = map.ent;
			if( ent &amp;&amp; ent.isValid ) {
				let dist = map.ent_dist;
				if( dist &lt; min_dist ) {
					closest = map;
					min_dist = dist;
				}
			}
		}
		return closest;
	}

	function nearest_Sighting() {
		try {
			_nearest_Sighting();
		} catch( err ) {
			log( ws.name, ws._reportError( err, &#39;nearest_Sighting&#39; ) );
			if( debug ) throw err;
		}
	}

	function _nearest_Sighting() {									//lock the nearest target
		if( !ps || !ps.isValid || alertCondition === DOCKED )
			return;
		if( !mappingReady || maplen === 0 ) return;					// not yet built OR empty
		check_Sightings( true );									// clear out any that died, jumped or scooped
		var closest = findNearestEnt();
		if( closest ) {
			_manage_marker( closest, true, &#39;_nearest_Sighting&#39; );
			if( Steering &gt; 0 ) start_Steering();					//turn to the target
		}
	}

	// Sighting updating - lightball //////////////////////////////////////////////////////////////

	function add_lt_ball( map, index ) {							// in order to appear on scanner, light ball effects are placed just inside
																	//	 scannerRange, not @ target, as with masslock rings
																	// also called via add_pending_lightballs so DO need to check !using_common_vars
		var lightball = map.lightball;
		if( lightball &amp;&amp; !profiling ) {
			lightball.remove();
			lightball = map.lightball = null;
		}
		if( ve_colour &lt; 0 ) ve_colour = map.ve_colour;
		if( lb_size &lt; 0 ) lb_size = map.lb_size;
		if( !ve_colour || !lb_size ) return;						// must have both
		var ent = map.ent;
		if( scanClass &lt; 0 || !using_common_vars ) scanClass = ent.scanClass;
		if( isFrangible &lt; 0 || !using_common_vars ) isFrangible = ent.isFrangible;
		if( scanClass === &#39;CLASS_ROCK&#39; &amp;&amp; isFrangible ) return;		// Rock Hermits, even abandoned ones, but not asteroids, boulders
		var effect_key = &#39;telescope-&#39; + ve_colour + lb_size;
		lb_position( map, index );
		if( profiling ) return; // else profiler goes BOOM!
		lightball = map.lightball = addVisualEffect( effect_key, lightball_posn );
		if( debug &amp;&amp; !lightball )
			log(ws.name, &#39;add_lt_ball, add effect failed! effect_key = &#39; + effect_key + &#39;, lightball_posn = &#39; + lightball_posn );
	}

	var target_direction = [];										// unit vector to target
	var lightball_posn = [];

	function lb_position( map, index, haveTD ) {					// calc lightball_posn; haveTD == true =&gt; target_direction already calc&#39;d
		// is also called via add_pending_lightballs, so DO need to check !using_common_vars
		var lb_dist;
		if( distance &lt; 0 || !using_common_vars )
			distance = map.ent_dist;								//distance to the target (or to last known pos)
		// light balls for far ships occupy ring inside scannerRange: -400..-600 (400+max_sightings)
		// - target marker lies at scannerRange - 600
		// while ships inside scannerRange have light balls outsice scannerRange: +300..+500 (300+max_sightings)
		if( distance &gt; scannerRange ) {
			lb_dist = scannerRange - 400;
			//do not set closer to scannerRange so won&#39;t leave behind aft markers during torus travel
		} else {													// near ent, core supplies lollipop
			lb_dist = scannerRange + 400;							//show the lightball only without shadow lollipop
		}
		lb_dist -= index;
		// using index to prevent 2 light balls having same distance, so they don&#39;t interfere with each other when coincide in line of sight
		if( rank &lt; 0 || !using_common_vars ) rank = map.rank;
		if( position.length === 0 || !using_common_vars )
			copy_vector( map.last_posn, position );					// if &#39;ukn&#39;, ball shouldn&#39;t move
		if( !haveTD ) {
			if( ent_vector.length === 0 || !using_common_vars ) {
				subtract_vectors( position, ps_position, ent_vector );
			}
			unit_vector( ent_vector, target_direction );			// unit vector to target (or to last known pos)
		} // else calling fn has already calc&#39;d target_direction
		scale_vector( target_direction, lb_dist, vector );
		add_vectors( ps_position, vector, lightball_posn );
		if( moving_fast ) {
			apply_speed_adj( lightball_posn );
		}
	}

	function a_non_ship_colour( colour ) {
		// &quot;non-ships with Blue, Cyan, Gray, Green and White colours will remain to help find these.&quot;
		return colour === &#39;green&#39; || colour === &#39;white&#39; || colour === &#39;cyan&#39;
			|| colour === &#39;blue&#39;  || colour === &#39;gray&#39;	|| colour === &#39;lightgray&#39;;
	}

	function showing_lightball( ent ) {								// separate function to eliminate blinking lollipop
		let showing = true;
		do {
			if( !weaponsOnline ) break;								// show all
			if( curr_target === ent ) break;						// black lollipops except the current target
			if( collisionRadius &lt; 0 || !using_common_vars )
				collisionRadius = ent.collisionRadius;
			let max = RedAlertDist &gt; SniperRange + collisionRadius
					  ? RedAlertDist : SniperRange + collisionRadius;
			if( distance &lt; max ) break;								// flag color relies on alertCondition for gray, black
			if( alertCondition &lt; RED_ALERT ) {						// in Green or Yellow alert, weaponsOnline
				if( scanClass &lt; 0 || !using_common_vars )
					scanClass = ent.scanClass;
				if( scanClass === &#39;CLASS_CARGO&#39; ) break;			// RFID tag (are deleted when go out of range)
				if( is_beacon( ent ) ) break;
			}
			if( alertCondition &lt; YELLOW_ALERT ) {					// in Green alert, weaponsOnline
				if( isVisible &lt; 0 || !using_common_vars )
					isVisible = ent.isVisible;
				showing = isVisible;								// gravity scanner off-line, so visible only
			} else {
				showing = false;									// in Red alert, weaponsOnline &amp; beyond RedAlertDist
			}
		} while( false );
		return showing;
	}

	var black_color = [ 0, 0, 0 ],
		darkgray_color = [ 0.1, 0.1, 0.1 ],
		lightgray_color = [ 2/3, 2/3, 2/3 ];

	function lb_showing_colour( ent, showing ) {					// separate function to eliminate blinking lollipop
		let newColor = null;										//original colour from effectdata.plist
		if( curr_target === ent ) {									// avoid flicker w/ shadow by setting same color
			newColor = lightgray_color;
		} else if( !showing ) {
			if( alertCondition &gt; YELLOW_ALERT )
				newColor = black_color;								//black lollipops in red alert
			else if( alertCondition &gt; GREEN_ALERT )
				newColor = darkgray_color;							//and very dark gray in yellow alert
		}
		return newColor;
	}

	function lb_effect_size( map, showing ) {						// only called via update_one_Sighting so no need to check !using_common_vars
	// &quot;_largeball&quot;, &quot;_ball&quot;, &quot;_marker&quot;, &quot;_smallmarker&quot;, &quot;_tinymarker&quot;, &quot;_dotmarker&quot;, &quot;_flag&quot;; lightgray also has _moon, _moonflag
		var ent = map.ent, collsn_rad = 0;
		if( ve_colour &lt; 0 ) ve_colour = map.ve_colour;
		if( !ve_colour ) return &#39;&#39;;
		if( radius &lt; 0 ) radius = ent.radius || false;
		if( collisionRadius &lt; 0 ) collisionRadius = ent.collisionRadius;
		collsn_rad = radius ? 0 : collisionRadius;					// 0 for planets, moons &amp; sun
		if( distance &lt; 0 ) distance = map.ent_dist;
		if( distance &lt; LightBallMinDist + collsn_rad				//too near
			|| ( distance &lt; LightBallShipMinDist + collsn_rad
				 &amp;&amp; ve_colour !== &#39;cyan&#39; &amp;&amp; ve_colour !== &#39;white&#39; &amp;&amp; ve_colour !== &#39;pink&#39; ) // ship too near
			|| redAlertOptimize() ) {
				//in red alert show ball marked targets only to save CPU and clean scanner (masslock rings are also removed)
			return &#39;&#39;;
		}
		if( !collisionRadius ) { // planets, moons &amp; sun
			if( isVisible &lt; 0 ) isVisible = ent.isVisible;
			if( hasAtmosphere &lt; 0 ) hasAtmosphere = ent.hasAtmosphere;
			if( isVisible &amp;&amp; distance &lt; 1e7 )
				return hasAtmosphere ? &#39;_moonflag&#39; : &#39;_flag&#39;;  //no dot
			else
				return hasAtmosphere ? &#39;_moon&#39;	   : &#39;_dotmarker&#39;;
		}
		if( !LightBalls || (!ShipLightBalls							// user set to off
							&amp;&amp; !a_non_ship_colour( ve_colour )) ) {	//if ship lightballs are disabled then show others only
			return &#39;_flag&#39;;											//lollipop without lightball
		}
		if( !showing ) return &#39;_flag&#39;;								//lollipop without lightball
		if( LargeLightBalls ) {//large balls
			if(	  distance &lt; SniperMinRange + collsn_rad ) return &#39;_largeball&#39;; //xl size
			else if( distance &lt; SniperRange + collsn_rad ) return &#39;_ball&#39;;		//large size
			else if( distance &gt; 1e6 )	return &#39;_tinymarker&#39;; //over 1000km show tiny ball
			else if( distance &gt; 1e5 )	return &#39;_smallmarker&#39;; //over 100km show smaller ball
			return &#39;_marker&#39;;	//average size
		}
		if( script_mass === undefined ) script_mass = read_scriptInfo( ent, map ); // also sets &#39;mass&#39;
		if( distance &gt; 1e6 )
			return &#39;_dotmarker&#39;; //over 1000km
		else if( mass &lt; 4e5 )
			return &#39;_tinymarker&#39;; //escort ship -was hitting here w/ slivers
		else
			return &#39;_smallmarker&#39;; //large ship (Cobra3 and over)
	}

	function update_lt_ball( map, index ) {
		var lightball, new_size, ent;
		var non_ship_colour = a_non_ship_colour( ve_colour );
		var disallowed = !LightBalls								// turned off by user
					|| ( !ShipLightBalls &amp;&amp; !non_ship_colour );		//if ship lightballs are disabled, show others only
		lightball = map.lightball;
		if( lb_size &lt; 0 ) lb_size = map.lb_size;					// get current size
		if( disallowed ) {
			if( lightball &amp;&amp; lb_size !== &#39;_flag&#39; &amp;&amp; !profiling ) {	// need to check for existing, as (Ship)LightBalls are in-game settings
				lightball.remove();
				map.lightball = lightball = null;
			}
		}															// else this is not a ship (&quot;navigation only&quot; lightballs)
		ent = map.ent;
		if( distance &lt; 0 ) distance = map.ent_dist;
		let showing = showing_lightball( ent );
		map.lb_size = new_size = lb_effect_size( map, showing );	// calc size to see if it&#39;s changed
		if( rank &lt; 0 ) rank = map.rank;
		if( position.length === 0 ) {
			copy_vector( map.last_posn, position );				   // lightball doesn&#39;t move if &#39;ukn&#39;
		}
		if( lightball &amp;&amp; new_size === lb_size
					  &amp;&amp; ve_colour === map.ve_colour )
			return;													// need only to reposition existing effect - now done in an fcb
		lb_size = new_size;
		if( lb_size !== &#39;&#39; ) {										// size chg =&gt; add new sized/coloured one
			add_lt_ball( map, index );
			if( map.lightball )
				map.lightball.scannerDisplayColor1 = lb_showing_colour( ent, showing ); // prevent blinking when cycle weapons
		} else if( lightball &amp;&amp; !profiling ) {						// no ball, remove current one
			lightball.remove();
			map.lightball = null;
		}
	}


	// Sighting updating - masslock ring //////////////////////////////////////////////////////////


	const SHOW_GREEN_WEAPS_OFF  = 1,	/// default from 1.15 is
		  SHOW_GREEN_WEAPS_ON	= 2,	/// $TelescopeMassLockBorders &amp;&amp; ( pla === 1 || !ps.weaponsOnline )
		  SHOW_YELLOW_WEAPS_OFF = 4,	/// so 1 | 2 | 4 | 16 = 23, aka $DEFAULT_ML_RINGS
		  SHOW_YELLOW_WEAPS_ON  = 8,
		  SHOW_RED_WEAPS_OFF	= 16,	///
		  SHOW_RED_WEAPS_ON		= 32,
		  SHOW_WEAPS_OFF		= SHOW_GREEN_WEAPS_OFF	| SHOW_YELLOW_WEAPS_OFF	| SHOW_RED_WEAPS_OFF,
		  SHOW_WEAPS_ON			= SHOW_GREEN_WEAPS_ON	| SHOW_YELLOW_WEAPS_ON	| SHOW_RED_WEAPS_ON,
		  SHOW_ALERT_GREEN		= SHOW_GREEN_WEAPS_OFF	| SHOW_GREEN_WEAPS_ON,
		  SHOW_ALERT_YELLOW		= SHOW_YELLOW_WEAPS_OFF | SHOW_YELLOW_WEAPS_ON,
		  SHOW_ALERT_RED		= SHOW_RED_WEAPS_OFF 	| SHOW_RED_WEAPS_ON;

	function setShowFlags() {
		show_on_Alert = alertCondition === GREEN_ALERT  ? SHOW_ALERT_GREEN :
						alertCondition === YELLOW_ALERT ? SHOW_ALERT_YELLOW :
						alertCondition === RED_ALERT    ? SHOW_ALERT_RED : 0;
		show_on_Weapons = weaponsOnline ? SHOW_WEAPS_ON
										: SHOW_WEAPS_OFF;
	}

	// on/off for masslock rings in current alertCondition/weaponsOnline state
	function _getShowState() { return show_on_Weapons &amp; show_on_Alert; }

	function _getShowStateText() {									// text for dynamic activate messages
		var alert = alertCondition === GREEN_ALERT  ? &#39;green&#39; :
					alertCondition === YELLOW_ALERT ? &#39;yellow&#39; :
					alertCondition === RED_ALERT    ? &#39;red&#39; : &#39;docked&#39;;
		var weapons = weaponsOnline ? &#39;online&#39; : &#39;off-line&#39;;
		return [ alert, weapons ];
	}

	function _currMLFlags() {
		return ws.$MassLockRings === null
				? SHOW_ALERT_GREEN | SHOW_WEAPS_OFF 				// default, as player never set flags
				: ws.$MassLockRings;
	}

	function _currSniperRingFlags() {
		return SniperRingActive === null
				? SHOW_WEAPS_ON 									// default, as player never set flags
				: SniperRingActive;
	}

	function _adjustMLFlags( turnOn ) {
		// when traversing state of TelescopeMenuLightballs, player expects masslock rings
		// even if current state missing from MassLockRings, so we fold it in
		// - when turned off, we also remove state from MassLockRings
		var state = _getShowState(),
			currFlags = _currMLFlags();
		if( turnOn ) {												// ensure state is on
			MassLockRings = ws.$MassLockRings = currFlags | state;
		} else {													// turn state off, masslock rings off
			MassLockRings = ws.$MassLockRings = currFlags &amp; ~state;
		}
	}

	function show_ml_ring() {
		if( !viewIsStandard ) return false;							// only shown from inside ship
		if( !viewHasMLRings ) return false;							// looking out wrong porthole
		return ( MassLockRings &amp; show_on_Alert						// test alert state
								&amp; show_on_Weapons ) &gt; 0;			// test weapons state
	}

	var mlVector = [];												// working vector for add_ml_ring to call orientToFace
	function add_ml_ring( map ) {									// only called via update_one_Sighting so no need to check !using_common_vars
		var masslock = map.masslock;
		if( masslock &amp;&amp; !profiling ) {
			masslock.remove();
			map.masslock = masslock = null;
		}
		if( ve_colour &lt; 0 ) ve_colour = map.ve_colour;
		if( ml_size &lt; 0 ) ml_size = map.ml_size;
		if( !ve_colour || !ml_size ) return;						// must have both
		var effect_key = &#39;telescope-&#39; + ve_colour + ml_size;
		var ent = map.ent;
		if( script_mass === undefined ) script_mass = read_scriptInfo( ent, map ); // also sets &#39;mass&#39;
		var ring_radius = VariableMassLock ? map.ml_radius : scannerRange;
		var ring_scale;
		if( isPlanet &lt; 0 ) isPlanet = ent.isPlanet;
		if( isPlanet ) {											// planets (but not suns)
			if( radius	&lt; 0 ) radius = ent.radius || false;
			ring_scale = ( radius + (radius &gt; scannerRange ? radius : scannerRange) ) /* max(radius, scannerRange) */
							/ MASSLOCK_RING_SCALE;
		} else {
			ring_scale = ring_radius / MASSLOCK_RING_SCALE;
		}
		if( profiling ) return; // else profiler goes BOOM!
		if( position.length === 0 ) {
			copy_vector( ent.position, position );
		}
		map.masslock = masslock = addVisualEffect( effect_key, position );
		if( masslock ) {
			masslock.scale( ring_scale ); //ring radius == scanner range
			// not waiting to be orientated in reposition_effects as misaligned ring visible momentarily
			subtract_vectors( position, ps_position, vector );
			unit_vector( vector, mlVector );
			orientToFace( masslock, mlVector );						// orientToFace uses both &#39;vector&#39; &amp; &#39;cross&#39;
		}
	}

	function ml_effect_size( map ) {								// only called via update_one_Sighting so no need to check !using_common_vars
		if( distance &lt; 0 ) distance = map.ent_dist;
		if( distance &lt; scannerRange )		return &#39;&#39;;
		if( distance &gt; 2.5e6 )				return &#39;&#39;;				// current models are not visible beyond 2500 km
		var ent = map.ent;
		if( redAlertOptimize() )			return &#39;&#39;;				// lightballs are also removed
		if( scanClass &lt; 0 ) scanClass = ent.scanClass;
		if( scanClass === &#39;CLASS_CARGO&#39; )	return &#39;&#39;;
		// if( isFrangible &lt; 0 ) isFrangible = ent.isFrangible;
		if( scanClass === &#39;CLASS_ROCK&#39; )	return &#39;&#39;;				// exclude all (abandoned) Rock Hermits, may have the mass but don&#39;t masslock
		if( scanClass === &#39;CLASS_BUOY&#39; )	return &#39;&#39;;
		if( isWormhole &lt; 0 ) isWormhole = ent.isWormhole;
		if( isWormhole )					return &#39;&#39;;
		if( is_cloaked( ent ) )				return &#39;&#39;;
		// if( is_jamming( ent ) )				return &#39;&#39;;
			// since beyond scannerRange, jammer not applicable
		var bright = BrightMassLockRings ? &#39;2&#39; : &#39;&#39;;
		var size = &#39;_ml&#39;;
		var fardist = 3e5;											//far masslock border over this distance (station or gravity scanner target)
		var farplanet = 30;											//far masslock border distance multiplier (an average 5000km planet over 1500km distance)
		if( isPlanet &lt; 0 ) isPlanet = ent.isPlanet;
		if( distance &gt; fardist ){									//far masslock border over this distance (station or gravity scanner target)
			if( isPlanet ) {
				if( radius &lt; 0 ) radius = ent.radius || false;
				let save_radius = radius;
				if( map.planetRadius ) {							// it may be a moon
					radius = map.planetRadius;
				} else {
					if( hasAtmosphere &lt; 0 ) hasAtmosphere = ent.hasAtmosphere;
					if( !hasAtmosphere ) {							// it&#39;s a moon, find it&#39;s planet
						let orb, oi, olen,
							orbs = entitiesWithScanClass( &#39;CLASS_NO_DRAW&#39;, ent, AutoScanMaxRange );
						for( oi = 0, olen = orbs.length; oi &lt; olen; oi++ ) {
							orb = orbs[ oi ];
							if( orb.hasAtmosphere ) {
								radius = orb.radius;				// temporarily override, gets restored by save_radius
								map.planetRadius = radius;			// cache for later
								break;
							}
						}
					}
				}
				if( distance &gt; farplanet * radius )
//							  (radius &lt; 20000 ? 20000 : radius) )	// min. radius for small moons
// when based on radius, a moon gets mlf before its planet, looks wierd
					size = &#39;_mlf&#39;;									//set far masslock border
				else if( distance &lt; 3 * radius )
					size = &#39;_mlt&#39;;									//set thin masslock border
				else
					size = &#39;_ml&#39;;									//set normal masslock border (default)
				radius = save_radius;
			} else {				//is not planet but far
				size = &#39;_mlf&#39;;		//set far masslock border
			}
		} else if( isPlanet ) {										// near a planet
			if( radius	&lt; 0 ) radius = ent.radius || false;
			if( distance &lt; 3 * radius )				size = &#39;_mlt&#39;;	//set thin masslock border
		} else {
//			size = distance &gt; scannerRange_X_2 ? &#39;_ml&#39; : &#39;_mlt&#39;;
			size = &#39;_ml&#39;;
			do {
				if( distance &gt; scannerRange_X_2 )	break;			//check for thin border within 2x scanner range
				if( position.length === 0 ) {
					copy_vector( ent.position, position );
				}
				if( ent_vector.length === 0 ) subtract_vectors( position, ps_position, ent_vector );
				var angle = angle_between_unitV( ps_vectorForward, ent_vector );
				if( angle &lt; FORTYFIVE_DEGREES )		break;			// under 45 degree mean ship is near and ring is out of sight?
				if( angle &gt; QUARTER_ARC )			break;			// and less than 90 degree mean ship&#39;s ring is in front you (it&#39;s parallel to vectorRight)
				let run	 = sin( angle ) * distance;					// sin( angle ) = run / distance
				let rise = cos( angle ) * distance;					// cos( angle ) = rise / distance
				let ring_radius = VariableMassLock ? map.ml_radius : scannerRange;
				let center_dist = run - ring_radius;
				center_dist = center_dist &lt; 0 ? -center_dist : center_dist;
				var fov_cutoff = center_dist / sin_fov2;
				if( cos_fov2 &lt; rise / fov_cutoff ) break;
				size = &#39;_mlt&#39;;										//so if ring is in screen then can be close so need thin border
			} while( false );
		}
		return bright + size;
	}
/*
				if( Math.sin( angle ) &lt; scannerRange/dist )	break;	//and crosshairs points out of ring which is closer

			 \			  ^&lt;--fov/2--&gt; /	   |		  - we have angleTo &amp; hypotenuse, and same orientation (ring parallels vectorRight)
	 |		   \		  |			 /		   |			  sin( angle ) = run / distance	  =&gt; run  = sin( angle ) * distance
	 |			 \		  |&lt;-c_d-&gt;(--r_r---X   |  ^			  cos( angle ) = rise / distance  =&gt; rise = cos( angle ) * distance
	 |			   \	  |		 /			   |  |		  - masslock ring edge is at center_dist = run - ring_radius
	 |				 \	  |	   /			   |  | rise  - for fov at rise, sin( fov/2 ) = center_dist / hypotenuse
	 |				   \  |	 /				   |  |			 =&gt; hypotenuse = center_dist / sin( fov/2 ), called fov_cutoff
	 |---------|---------\_/---------|---------|  |		  - for ring to be visible, cos( fov/2 ) &gt; rise / fov_cutoff
	 2	 scannerRange		   scannerRange		2
						  &lt;----- run ----&gt;
*/

	function update_ml_ring( map ) {								// only called from update_one_Sighting so no need to check !using_common_vars
		var new_size, ent, masslock = map.masslock;
		ent = map.ent;
		var showingMLRings = show_ml_ring();
		if( showingMLRings &amp;&amp; !ext_ok ) {							// &quot;Without a Telescope Extender, these are shown around
			do {													//	 planets and stations only&quot;
				if( isStation &lt; 0 ) isStation = ent.isStation;
				if( isStation ) break;
				if( radius &lt; 0 ) radius = ent.radius || false;
				if( radius ) break;
				showingMLRings = false;
			} while( false );
		}
		if( !showingMLRings ) {
			if( masslock &amp;&amp; !profiling ) {							// need to check for existing, as MassLockRings is an in-game setting
				if( debug ) log(ws.name, &#39;update_ml_ring, as !show_ml_ring, removing masslock ring (&quot;&#39;
											 + map.ml_size + &#39;&quot;) for&#39; + map.ent );
				masslock.remove();
				map.masslock = null;
			}
			return;
		}
		if( isSun &lt; 0 ) isSun = ent.isSun;
		if( isSun ) return;											// no longer has one
		if( ml_size &lt; 0 ) ml_size = map.ml_size;					// get current size
		map.ml_size = new_size = ml_effect_size( map );				// calc size to see if it&#39;s changed
		if( rank &lt; 0 ) rank = map.rank;
		if( position.length === 0 ) {
			copy_vector( map.last_posn, position );					// ring stays w/ lightball, even if &#39;ukn&#39;
		}

		if( masslock &amp;&amp; new_size === ml_size
					 &amp;&amp; ve_colour === map.ve_colour ) {				//move masslock ring
			return;													// need only to _reposition_effects
		}
		ml_size = new_size;
		if( ml_size !== &#39;&#39; &amp;&amp; ve_colour !== &#39;gray&#39; ) {				// size chg =&gt; add new sized
			add_ml_ring( map );
		} else if( masslock &amp;&amp; !profiling ) {
			masslock.remove();
			map.masslock = null;
		}
	}

	// Sighting updating //////////////////////////////////////////////////////////////////////////

	function proc_stealthy( map, ent, have_scanned ) {
		if( have_scanned === true ) {								// ships using scriptInfo {...telescope = 0...}
//			if( map.rank === &#39;ukn&#39; ) {								// lost contact of stealthy ent, wipe all info
			if( !ent.isVisible ) {									// lost contact of stealthy ent, wipe all info
				_delete_Sighting( map.ent, &#39;proc_stealthy&#39; );		//  - threshold is visibility, not gravity
				return true;
			}
		} else if( distance &gt; have_scanned ) {						// cargo pod&#39;s RFID signal lost in noise
			_delete_Sighting( map.ent, &#39;proc_stealthy cargo&#39; );		// also deleted in check_Sightings
			return true;
		}
		return false;
	}

	// bitflags for dynamic MFD filtering
	const MFD_FRIENDLY = 1,		// bounty === 0 &amp;&amp; !markedForFines
		  MFD_UNSOCIABLE = 2,	// bounty || markedForFines
		  MFD_ACTIVE = 4,		// has .target || defenseTargets.length &gt; 0
		  MFD_HOSTILE = 8,		// in_ents_Targets || targeting_ps
		  	MFD_ATTITUDE = 15,	// those of 1st 4 flags used to choose targets
		  MFD_NEARBY = 16,		// distance &lt; scannerRange
		  MFD_PROTECTED = 32,	// .withinStationAegis
		  MFD_FARAWAY = 64,		// distance &gt; scannerRange
		  	MFD_RANGED = 112;	// those of prev. 3 flags used to limit those chosen
		  // if add more flags, be sure to update line 90: this.$MFD_DYNAMIC_ALLSET = 127;

	function update_one_Sighting( map, ent, index, check_notable ) {
		if( check_notable || status &lt; 0 ) status = ent.status;
		if( _has_bad_status( ent, status ) )						// shipScoopedOther can fire &amp; del before we get to it!
			return;
		if( check_notable || distance &lt; 0 )
			distance = map.ent_dist;
		if( check_notable ) {										// false when called from include_ent, _add_Sighting, as already checked
			let save_status = status,								//	 but true from refresh_Sightings
				save_dist = distance;
			reset_common_vars();									//	 prepare for call to notable_ent
			status = save_status;
			distance = save_dist;
			if( !notable_ent( ent ) ) {								// sets rank, ve_colour and (maybe) distance
				if( index !== -1 )									//	 notable_ent checks if eclipsed
					_delete_Sighting( index, &#39;update_one_Sighting&#39; + &#39; CHECK_NOTABLE&#39; );
				return;
			}
			map.staticMFD = staticMFD;
		} else {
			isBeacon = is_beacon( ent );							// fn tests isBeacon &lt; 0
			radius = ent.radius || false;
			let hidden = index &lt; 0 ? false : eclipsed( ent, map );	// index = -1 =&gt; call from include_ent, eclipsed already checked
			if( !isBeacon &amp;&amp; !radius &amp;&amp; hidden ) {
				_delete_Sighting( (index &gt;= 0 ? index : ent), &#39;update_one_Sighting&#39; + &#39; !check_notable&#39; );
				return;
			}
		}
		dynamicMFD = distance &lt; scannerRange ? MFD_NEARBY			// clear all as all are reset here
											 : MFD_FARAWAY;
		if( scanClass &lt; 0 ) scanClass = ent.scanClass;
		if( scanClass === &#39;CLASS_CARGO&#39; ) {							// scannerRange exception for cargo
			if( check_notable ) {
				if( is_cargo === true )
					dynamicMFD = MFD_NEARBY;
			} else {
				if( is_ignored_ship( ent ) ) {
					_delete_Sighting( (index &gt;= 0 ? index : ent), &#39;update_one_Sighting&#39; + &#39; is_ignored_ship&#39; );
					return;
				}
				if( shipClassName &lt; 0 ) shipClassName = ent.shipClassName;
				if( shipClassName !== &#39;Splinter&#39;
						 &amp;&amp; shipClassName !== &#39;Boulder&#39;
						 &amp;&amp; shipClassName !== &#39;Metal fragment&#39; )
					dynamicMFD = MFD_NEARBY;						// cargo, escape pods detectable until deleted
			}
		}
		if( gravScanProgress &gt; 0 ) { // once gs stops running, this degrades over time (ie. not checking gs_state)
			if( gs_curr &lt; 0 ) gs_curr = grav_scan_dist( ent, true, map );
			map.gs_curr_dist = gs_curr;
		}
		let have_scanned = map.have_scanned;
		if( rank &lt; 0 )	rank = map.rank;
		else 			map.rank = rank;							// may have been altered in notable_ent
		if( ve_colour &lt; 0 ) ve_colour = map.ve_colour;
		if( rank === &#39;ukn&#39; ) {
			ve_colour = &#39;gray&#39;;										// becomes &#39;gray&#39; if ent departs our equipment&#39;s range
			if( map.ve_colour !== &#39;gray&#39; ) {						// just became &#39;ukn&#39;, remove masslock ring so a gray one will be created
				let masslock = map.masslock;
				if( masslock &amp;&amp; !profiling ) {
					masslock.remove();
					map.masslock = null;
				}
			}
			isHostile = false;
			dynamicMFD = MFD_FARAWAY;								// lost contact, clear all dynamic MFD bitflags but Faraway
		} else {
			let moody = scanClass !== &#39;CLASS_BUOY&#39;
					 &amp;&amp; scanClass !== &#39;CLASS_CARGO&#39;
					 &amp;&amp; scanClass !== &#39;CLASS_ROCK&#39;
					 &amp;&amp; scanClass !== &#39;CLASS_NO_DRAW&#39;
					 &amp;&amp; scanClass !== &#39;CLASS_WORMHOLE&#39;;
			isHostile = moody ? is_hostile( ent, true ) : false;	// true to set all glocals
			if( isHostile ) {
				if( have_scanned !== true &amp;&amp; have_scanned !== -1 ) {// must be explicit, as prop has multiple uses
					if( distance &lt; scannerRange ) {
						map.have_scanned = -1;						// once scanned, offender status can be remembered (FarStatus)
					}
				}
				ve_colour = &#39;red&#39;;									// FarStatus &amp; distance dealt with in is_hostile
				dynamicMFD |= MFD_UNSOCIABLE;
			} else if( moody ) {
				if( have_scanned === -1 ) {							// an offender has reformed?
					map.have_scanned = false;
				}
				dynamicMFD |= MFD_FRIENDLY;
			}
			if( has_targets )						  dynamicMFD |= MFD_ACTIVE;
			if( targeting_ps || in_ents_Targets )	  dynamicMFD |= MFD_HOSTILE;
			if( ent.withinStationAegis )			  dynamicMFD |= MFD_PROTECTED;
		}
		map.dynamicMFD = dynamicMFD;
		if( have_scanned === true || have_scanned &gt; 0 ) {			// hidden ent or cargo
			if( proc_stealthy( map, ent, have_scanned ) ) {			// gets deleted if no longer detectable
				if( check_notable ) using_common_vars = false;		// premature exit, reset when necessary
				return;
			}
		}
		if( index &gt;= 0 ) {											// when called by grow_new_list, has not been added to
			update_ml_ring( map );									//	 mapping, so wait for next update (index is req&#39;d
			update_lt_ball( map, index );							//	 for update_lt_ball)
		}
		map.ve_colour = ve_colour;									// may have been altered
		if( check_notable ) using_common_vars = false;				// reset when necessary
	}

	var systemEclipsers = null;										// cache of system&#39;s orbs &amp; stations
ws._eclipsed = eclipsed; // for debug
	function eclipsed( ent, map, dist ) {							// determine if it&#39;s behind orb or station (notable_ent only caller)
		var that = eclipsed;
		var eclipsed_ent = (that.eclipsed_ent = that.eclipsed_ent || []),// vector to ent we&#39;re checking
			orb_vector = (that.orb_vector = that.orb_vector || []);// vector to candidate eclipser

		eclipsed_ent.length = 0;									// reset array
		orb_vector.length = 0;										// reset array
		if( !systemEclipsers || systemEclipsers.length === 0 )		// cache not initialized
			return false;
		if( grav_eq_ok )
			return false;											// gravity scanner overcomes line of sight
		let eclipsing_dist = 0;										// its distance
		if( map )													// map optional, as is called by grow_list sequence
			eclipsing_dist = distance = map.ent_dist;
		else if( dist )												// dist optional, to save on call to _detect_distanceTo
			eclipsing_dist = distance = dist;
		else {
			if( distance &lt; 0 ) distance = _detect_distanceTo( ent );
			eclipsing_dist = distance;
		}

		var threshold, tangentAngle, ecl_ent, ecl_map, dist,
			edge, opp, adj, msize, isOrb,
			len = systemEclipsers.length;
		if( !len ) return false;
		for( var idx = 0; idx &lt; len; idx++ ) {
			ecl_ent = systemEclipsers[ idx ];
			if( ecl_ent === ent ) continue;
			if( ecl_ent &amp;&amp; !ecl_ent.isValid ) continue;
			if( ecl_ent &amp;&amp; !ecl_ent.position ) {
/// trap for dybal&#39;s bug where _detect_distanceTo call mks call to subtract_vectors w/ null 2nd parm
/// (may have fixed via fetchSun when building systemEclipsers)
if( debug ) {
	log( ws.name, &#39;eclipsed, stale systemEclipser w/o a position, idx = &#39; + idx );
	var tmp = _Sighting_index( ecl_ent );
	if( tmp &lt; 0 ) {
		log( ws.name, &#39;eclipsed, NOT in _Sightings!!!&#39; );
	} else {
		log( ws.name, &#39;eclipsed, _Sighting_index = &#39; + tmp );
		if( cd )
			cd._showProps( mapping[tmp], &#39;systemEclipser&#39; );
	}
}
				continue;
			}
			let index = _Sighting_index( ecl_ent );
//			  if( index &lt; 0 ) continue;								// not in map, cannot eclipse (ok, 1st create in system will thrash, a bit)
			if( index &lt; 0 ) {
				ecl_map = null;
				let save_radius = radius,
					save_collRad = collisionRadius;					// preserve current ent&#39;s property gets
				radius = collisionRadius = -1;
try {
				dist = _detect_distanceTo( ecl_ent );				// sets radius, maybe collisionRadius
} catch( err ) {
	log( ws.name, &#39;ATTN: Dybal&#39; );
	log( ws.name, &#39;eclipsed, failed to calculate distance to un-mapped ent: &#39; + ecl_ent );
	log( ws._reportError( err, eclipsed, [ent, map, dist], 2, true ) );
	if( !that.DybalMsg || that.DybalMsg &lt; 3 ) {
		consoleMessage( &#39;!! check log for error !!&#39;, ConsoleMsgDurn );
		that.DybalMsg = !that.DybalMsg ? 1 : that.DybalMsg + 1;
	}
	continue;
}
				edge = radius;
				radius = save_radius;								// restore current ent&#39;s property gets
				collisionRadius = save_collRad;
			} else {
				ecl_map = mapping[ index ];
				dist = ecl_map.ent_dist;
				edge = ecl_ent.radius;
			}
			if( eclipsing_dist &lt; dist ) continue;					// is in front of ecl_map
			// calc dist from center to rim/outer hull
			isOrb = edge &gt; 0;										// only they have a .radius property
			if( isOrb ) {
				opp = edge + (ecl_ent.hasAtmosphere === true ? 500 : 0);// 500 is default height of atmosphere
			} else if( ecl_ent.isStation || (SpicyHermits &amp;&amp; ecl_ent.isRock &amp;&amp; !ecl_ent.isFrangible) ) {
				if( dist &gt; scannerRange_X_4 ) continue;				// don&#39;t bother with distant stations
				edge = ecl_ent.collisionRadius;
				opp = edge;
			} else continue;										// should never happen but, well, you know, bugs
			adj = dist + edge;										// is subtracted in _detect_distanceTo
			if( adj &lt;= 0 ) continue;								// should never happen
			tangentAngle = asin( opp / adj ) * RADIANS_TO_DEGREES;	// angle from center to limb/hull
			copy_vector( (index &lt; 0 ? ecl_ent.position
									: ecl_map.last_posn), vector );
			subtract_vectors( vector, ps_position, orb_vector );
			if( eclipsed_ent.length === 0 ) {						// 1st time here, calc ent&#39;s vector, etc., as now it&#39;s needed
				copy_vector( (map ? map.last_posn
								  : ent.position), vector );
				subtract_vectors( vector, ps_position, eclipsed_ent );
				unit_vector( eclipsed_ent, eclipsed_ent );
				if( isOrb ) {
					if( isStation &lt; 0 ) isStation = ent.isStation;
					let marker = map ? map.lb_size : null;
					msize = !marker ? (LargeLightBalls ? 500 : 200) :// no lightball/map, use median size
							marker === &#39;_largeball&#39; ? 1000 :		// sizes vary a bit across colors; these are the largest values
							marker === &#39;_ball&#39; ? 800 :
							marker === &#39;_marker&#39; ? 600 :
							marker === &#39;_smallmarker&#39; ? 400 :
							marker === &#39;_tinymarker&#39; ? 300 : 150;	// &#39;_dotmarker&#39;
					msize = msize / 533 *							// in right ballpark, if _smallmarker is ~3/4 degree
							(isStation ? (1e6 - eclipsing_dist) / 1e6 : 1); // adj for station apparent size
				} else
					msize = 0;
			}
			threshold = tangentAngle - msize;						  // lightball has constant size
			let span = angle_between_unitV( eclipsed_ent, orb_vector ) * RADIANS_TO_DEGREES;
/*
if( debug &amp;&amp; ent === curr_target )
	log(ws.name, &#39;eclipsed, &#39; + (span&lt;threshold ? &#39;HIDDEN by &#39; + ecl_ent.name : &#39;&#39;)
		+&#39;, span = &#39; + span.toFixed(2)
		+ &#39;, threshold = &#39; + threshold.toFixed(2) + &#39;, tangentAngle = &#39; + tangentAngle.toFixed(2) + &#39;, msize = &#39; + msize.toFixed(2)
	);
player.ship.removeEquipment( &#39;EQ_GRAVSCANNER&#39; )
player.ship.awardEquipment( &#39;EQ_GRAVSCANNER&#39; )
*/
			if( span &lt; threshold ) return ecl_ent;
		}
		return false;
	}

	function refresh_Sightings() {									// update existing ents a few at a time (1 update ~ 0.86 ms); use_map limits to known targets
		try {
			if( mk_maps ) return;									// have started creating new mapping, abort
			if( maplen &lt;= 0 ) return;
			var index = map_update_index;
			var count = updates_per_frame;
			var map, ent;
			for( ; count &gt; 0 &amp;&amp; index &lt; maplen; count--, index++ ) {
				if( index &gt;= mapping.length ) break;				// scooped/died/jumped during update, which shortened mapping!
				map = mapping[ index ];
				if( !map ) continue;
				ent = map.ent;
				if( !ent || !ent.isValid ) continue;
				update_one_Sighting( map, ent, index, true );		// true directs call to notable_ent
			}
			map_update_index = index;
			if( index &gt;= maplen ) {									// finished w/ list
				set_fn_pending( grow_new_list, &#39;refresh&#39; );
			} else {												// more to process in next call
				set_fn_pending( refresh_Sightings );
			}
		} catch( err ) {
			if( debug ) log(ws.name, &#39;refresh_Sightings, map = &#39;
						+ (cd ? cd._showProps( map, &#39;map&#39; ) :&#39;&#39;)
						+ &#39;\nent = &#39; + ent + &#39;\nindex = &#39; + index
						+ &#39;, count = &#39; + count + &#39;, maplen = &#39; + maplen );
			log( ws.name, ws._reportError( err, &#39;refresh_Sightings&#39;, updates_per_frame ) );
			if( debug ) throw err;
		}
	}

	var updates_per_frame = 2;										// # of ships updated in a single frame; adjusted to frame rate
	var map_update_index = 0;										// saves index across calls

	function update_Sightings( just_mapping ) {
		try {
			_update_Sightings( just_mapping );
		} catch( err ) {
			log( ws.name, ws._reportError( err, &#39;update_Sightings&#39;, just_mapping ) );
			if( debug ) throw err;
		}
	}

	function _update_Sightings( just_mapping ) {					// initiate update cycle; just_mapping limits update to known targets
		var that = _update_Sightings;
		if( that.fps === undefined ) that.fps = 0;

		if( !equip_ok ) return;
		if( !mappingReady || maplen === 0 ) return;					// mapping not yet initialized OR it&#39;s empty
		if( fns_are_pending() ) return;								// called in midst of creating a new mapping, abort!
		if( !ps || !ps.isValid || alertCondition === DOCKED ) 		//if player died or docked
			return;
		mk_maps = false;											// suppress creation of Sightings
		map_update_index = 0;
		if( just_mapping ) {										// update just known entities (ie. in mapping)
			set_fn_pending( refresh_Sightings );
			/*
			- a user setting (MaxTargets) deals with the max # of targets to consider.	At 200, processing
			  5 per frame, this completes in 40 frames but at a cost of 4.3 ms/frame (@~30 fps on my PC)

			- there is available, @ 60 fps 16.7 ms/frame,
								  @ 50	   20 ms
								  @ 40	   25 ms
								  @ 30	   33 ms
								  @ 20	   50 ms

			- so on my PC, I reduce my frame rate from 30 to 26.8 ( 1/33 -&gt; 1/37.3 )

			- if I limit to 2 per frame, 200 targets will take 10 sec @20 fps, but only 3.33 sec @ 60 fps

			I&#39;m sure the pilot @20 won&#39;t like the 10 seconds but all I can do is suggest (s)he reduce the max # of
			targets.  And the one @60 isn&#39;t thrilled either, but there I can do something:

			- start w/ a low rate until fps stats mature
			- then starting w/ an fps based target, incr # Sightings/frame
			- monitor the % diff in ms/Sighting and keep it below a threshold based on fps
			  (see init_growing; uses similar scheme &amp; will decrease MaxTargets)
			*/
			var fps, base, target;
			if( !current_fps || !long_term_fps )
				return;
			fps = current_fps();
			base = long_term_fps();									// mean of last 5 min
			if( fps &gt; 0 &amp;&amp; fps !== that.fps ) {						// more than a minute has passed &amp; got new value
				if( base &gt; 0 ) {									// in flight for at least 5 min
					target = floor( 2 + fps / 30 );					// aim for twice min of 2 @ 60 Hz
					if( fps &lt; base &amp;&amp;								// reduction in fps beyond threshold
						   percentDiffOver( fps, base, (fps / 8) ) )// 7.5% @ 60 (&gt; 55.5 fps), 3.75% @ 30 (&gt; 27.6 fps)
						target--;
					else
						target++;
				} else {
					target = floor( fps / 20 );						// start w/ a low rate
				}
				if( target &gt; 2 &amp;&amp; target !== updates_per_frame ) {	// adjust target every update based on fps stats from the last minute
					if( debug ) log(ws.name, &#39;_update_Sightings, updates_per_frame changed from &#39;
												 + updates_per_frame + &#39; to &#39; + target );
					updates_per_frame = target;
				}
				that.fps = fps;
			}
		} else {													// new entities detected
			init_growing( false );
			set_fn_pending( grow_new_list, &#39;add_orbs&#39; );
		}
	}

	function percentDiffOver( a, b, p ) {							// for comparing fps readings; reciprocals compare time
		if( a === 0 || b === 0 || p === 0 ) return false;
		var diff = a &gt; b ? (a - b) / a	// (1/b - 1/a)	=&gt; a-b/ab; * b =&gt; a-b/a
						 : (b - a) / b; // (1/a - 1/b) * a =&gt; (b - a)/ab * a =&gt; (b - a) / b
		return diff &gt; p / 100;
	}

	// Sighting effect positioning ////////////////////////////////////////////////////////////////

	var speed_adj = [];
	function apply_speed_adj( dst_posn ) {							// used in position calc for lightballs, marker
																	// prevDist is distance from last frame
		// travelling at high speed can distort positon calculations,
		// lightballs off-center or lose lock on far target marker
		//   eg. @reg. Torus of 12000 and fps &lt; 30, travel &gt; 400 m/frame
		// so we contract the range for positioning lightballs &amp; the marker
		//   at rest, marker: scannerRange - 600, placed just in front of band of far lightballs
		//    far lightballs: scannerRange - 400 - index, a ring MaxTargets deep, ending @ 25200
		//   near lightballs: scannerRange + 400 - index, ie. a buffer of +- 200 around scannerRange
/*
		var that = apply_speed_adj;
		if( that.absMaxSpeed === undefined ) that.absMaxSpeed = 0;
		var absMaxSpeed = that.absMaxSpeed;
		var absMSShip = (that.absMSShip = that.absMSShip || {});
		let chkValue  = TorusToSun ? TorusToSun.$TorusToSunBonus :
						FarPlanets ? FarPlanets.$FarPlanetsBonus :
						WarpDrive  ? WarpDrive.$scanScale : ps_maxSpeed;
		if( !absMaxSpeed || !absMSShip[ ps ] || absMSShip[ ps ] !== chkValue ) {
			if( TorusToSun ) {										// using 31, not 32, as its chkValue is 1 based, ie. 1 =&gt; no bonus
				absMaxSpeed = ps_maxSpeed * 31 * chkValue;			// his code uses (b - 1) which doesn&#39;t work here
			} else if( FarPlanets ) {
				absMaxSpeed = ps_maxSpeed * 31 * chkValue;
			} else if( WarpDrive ) {
				absMaxSpeed = WarpDrive.$basicMaxSpeed * (WarpDrive.$warpFlag ? chkValue : 1);
			} else {
				absMaxSpeed = chkValue * 32;
			}
			that.absMaxSpeed = absMaxSpeed;
			that.absMSShip[ ps ] = chkValue;
		}
 */
		var travel = ps_speed * frame_delta;						// distance expect to travel this frame
		// - frame_delta is set by call to _hud_effects() which preceeds _reposition_effects()
		var dotP = dot_product( ps_vectorForward, target_direction );
		// - more sensitive to change in frame rate for ents parallel to heading, less so when perpendicular

		var contract = 250 + (250 * ps_speed/(ps_maxSpeed * 32));	// base amt for all directions
		if( dotP &gt;= 0 ) {											// moving towards light ball
			contract += 0.5 * travel * dotP;
		} else {													// moving away from light ball
			contract += -1.5 * travel * dotP;
		}
		let adjust = -100 * ( floor(contract/100) ); 				// to hundreds to reduce jitter
		scale_vector( target_direction, adjust, speed_adj );
		add_vectors( dst_posn, speed_adj, dst_posn );
	}

	function redAlertOptimize() {
		// RedAlertDist: show lollipops in red alert within this distance only
		return RedAlertDist &gt; 0 &amp;&amp; distance &gt; RedAlertDist &amp;&amp; alertCondition &gt; YELLOW_ALERT &amp;&amp; weaponsOnline;
	}

	var view_vector = [],
		rotated_orient = [];	// working quaternion
		// &quot;The Gravity scanner works only when you turn off your weapons with underscore (&quot;_&quot;) button,
		//	otherwise only visible targets are displayed.&quot; (from readme)

	function orientToFace( ent, direction ) {
		// &#39;direction&#39; is a vector pointing at &#39;ent&#39;
		// orient entity so it faces &#39;direction&#39;, ie. its vectorForward is the negative of &#39;direction&#39;

		copy_vector( ent.vectorForward, vector );					// &#39;vector&#39; is a common working array
		cross_product( vector, direction, cross ); 					// axis of rotation (&#39;cross&#39; is the other working vector)
		unit_vector( cross, cross ); 								// must be normalized for rotation
		let angle = -angle_between_two_unitV( vector, direction );	// angle is negated to close the gap
		if( equal_value( angle, 0 ) ) 								// don&#39;t bother if w/i PRECISION, ie. close enough
			return;
		copy_quaternion( ent.orientation, quaternion );				// &#39;quaternion&#39; is a common working array
		rotate_about_axis( quaternion, cross, angle, rotated_orient );
		ent.orientation = rotated_orient;							// &#39;rotated_orient&#39; is another common working array
	}

	function _reposition_effects() {								// quick fcb that just updates effects
		try {
			if( !equip_ok ) return;
			if( !mappingReady || maplen === 0 ) return;				// mapping not yet initialized OR it&#39;s empty
			var index = maplen;
			var map, ent, distTo, lightball, masslock, redAlertOpt,
				showingMLRings = show_ml_ring();
			while( index-- ) {
				map = mapping[ index ];
				ent = map.ent;
				if( !ent || !ent.isValid ) continue;
				reset_common_vars();								// ensure no data carries over from last frame
				ve_colour = map.ve_colour;
				rank = map.rank;
				if( rank !== &#39;ukn&#39; ) {								// if lost detection, position data goes stale (not updated)
					copy_vector( ent.position, map.last_posn );
				}
				copy_vector( map.last_posn, position );
				subtract_vectors( position, ps_position, ent_vector );
				unit_vector( ent_vector, target_direction );
			/// brought in from _detect_distanceTo for efficiency (share vector calc&#39;s)
				distTo = vector_magnitude( ent_vector );
				distTo -= hullOffset( ent );						// distance to near surface
				map.ent_dist = distance = distTo;
			/// end of _detect_distanceTo dup&#39;d code
				redAlertOpt = redAlertOptimize();					// a fn of distance
				if( !redAlertOpt &amp;&amp; viewIsStandard ) {
					map.headingTo = angle_between_two_unitV( view_vector, target_direction ) * RADIANS_TO_DEGREES;
				}
				lightball = map.lightball;
				lb_size = map.lb_size;
				let showingEffect = true;
				if( lightball )
					showingEffect = showing_lightball( ent );
				if( lightball &amp;&amp; lb_size !== &#39;_flag&#39;
						&amp;&amp; ( redAlertOpt || !showingEffect ) ) {
					lightball.remove();
					map.lightball = null;
				} else if( lightball ) {
					lightball.scannerDisplayColor1 = lb_showing_colour( ent, showingEffect );
					lb_position( map, index, true );				// reposition existing effect, sets lightball_posn
						// uses distance, rank, position, ps_position, ent_vector, speed_adj
					lightball.position = lightball_posn;
				}
				masslock = map.masslock;
				if( masslock
						&amp;&amp; ( redAlertOpt || !showingMLRings )) {
					masslock.remove();
					map.masslock = null;
				} else if( masslock ) {
					masslock.position = position;					//move masslock ring
					if(	distance &lt; scannerRange_X_2 || (radius		// set orientation of near ones for easier navigation
						&amp;&amp; distance &lt; 2 * (scannerRange + radius)) ) {// including planets/moons (calc so masslock spheres don&#39;t touch)
						// setting to ps_orientation allows player to approach ring and steer
						// just outside masslock range
						masslock.orientation = ps_orientation;
					} else {										// orient ring to be perpendicular, face player.ship
						orientToFace( masslock, target_direction );
					}
				}
			}
			using_common_vars = false;
		} catch( err ) {
			log( ws.name, ws._reportError( err, &#39;_reposition_effects&#39; ) );
			if( debug ) throw err;
		}
	}

	// new Sightings //////////////////////////////////////////////////////////////////////////////

	var new_targets = [];											// list of new target entities for Combat_MFD

	function process_new_targets() {
		var index;
		if( new_targets &amp;&amp; new_targets.length &gt; 0 ) {
			var ent, idx, len;
			init_headingView();										// prep for showTargetName
			len = new_targets.length;
			for( idx = 0; idx &lt; len; idx++ ) {						//search new target
				ent = new_targets[ idx ];
				if( ent.radius )
					continue;										// on launch, all targets are &#39;new&#39; and system.planets may not be ready!
				index = _Sighting_index( ent, &#39;process_new_targets&#39; );
				if( index &lt; 0 )
					continue;										// should always be there but ...
				showTargetName( mapping[ index ] );					//but do not jump out of the cycle, keep to print all new name
			}
			new_targets.length = 0; 								// mk sure array ready for re-use
		} else {
			checkCombatMFD();										// update existing data
		}
	}

	function checkCombatMFD() {										// check health of target listed in Combat_MFD
		var index, map, ent;
		if( Combat_MFD ) {											//Combat_MFD support
			index = index_in_list( prevMFDTarget, mapping );
			if( index &gt;= 0 ) {
				map = mapping[ index ];
				ent = map.ent;
				if( ent &amp;&amp; ent.isValid ) {							// prev target is still ok
					showTargetName( map, true );					//update the direction (true suppresses console msg as this call 1/sec)
					return;											//	init_headingView called in _auto_updates
				}
			}
			prevMFDTarget = null;
			Combat_MFD.$TelescopeLine = &#39;&#39;;							//clear the line in MFD
		}
	}

///////////////////////////////////////////////////////////////////////////////////////////////////
// mapping functions //////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

	function newList( keep_deferred ) {
		try {
			_newList( keep_deferred );
		} catch( err ) {
			log( ws.name, ws._reportError( err, &#39;newList&#39;, keep_deferred ) );
			if( debug ) throw err;
		}
	}

	function _newList( keep_deferred ) {							// clears all Sightings &amp; removes effects prior to docking/witchspace
		if( selected_Sightings )
			selected_Sightings.length = 0;							// remove any previous results
		clear_all_pending( keep_deferred );							// true will preserve deferred tasks queue
		if( !keep_deferred ) {										// are shutting down
			halt_steering();
		}
		while( maplen-- )
			free_Sighting( mapping[ maplen ] );
		mapping.length = maplen = 0;								// used to test when mapping not ready (launching, witchspace) - system var.s need re-init&#39;g
		mappingReady = false;
		ws.$TelescopeList.length = 0;
		ws.$TelescopeListi = 0;										// $TelescopeListi = 0 =&gt; not in $TelescopeList
	}

	function map_sort_heading( a, b ) {								// sort by headingTo
		var a_heading = a.headingTo;								//  - to conform w/ find_most_central&#39;s logic, if 2 ships
		var b_heading = b.headingTo;								//    are within half a degree, choose the closer
		var diff = a_heading &lt; b_heading ? b_heading - a_heading
										 : a_heading - b_heading;
		if( diff &lt; 0.5 ) {											// w/i HALF_a_DEGREE of crosshairs,
			return a.ent_dist - b.ent_dist;							//	sort by distance
		} else {
			return a_heading - b_heading;							//	sort by heading
		}
	}

	function create_Sightings() {
		try {
			_create_Sightings();
		} catch( err ) {
			log( ws.name, ws._reportError( err, &#39;create_Sightings&#39; ) );
			if( debug ) throw err;
		}
	}

	function _create_Sightings() {
		clear_all_pending();										// started in midst of _update_Sightings() or deferred tasks; shut that down!
		if( maplen === 0 )											// only needed when launching or exiting witchspace
			_init_player_vars();
		if( !equip_ok )
			return;
		grow_hidden_scanned.length = 0;
		var idx = maplen;
		while( idx-- ) {											// preserve list of &#39;hidden&#39; entities that have been w/i scannerRange
			let map = mapping[ idx ];
			if( map.have_scanned !== false )						// for specials (hidden, cargo, FarStatus), should not be present otherwise
				grow_hidden_scanned.push( map.ent );				// preserve scan of specials (scriptInfo: telescope = 0), ie. once detected,
		}
		init_growing( true );
		set_fn_pending( grow_new_list, &#39;add_orbs&#39; );
		// adj_update_MFDs.count = 0;									//	 &quot;
	}

	var grow_maps = [];												// list of Sightings built to replace current mapping
	var grow_hidden_scanned = [];									// info carried over to new mapping; support for scriptInfo: telescope=0
	var max_sightings;												// counter during grow so don&#39;t exceed MaxTargets
	var mk_maps = true;												// flag as to whether (true) or not (false) we&#39;re creating a mapping

	var grow_list_index = 0;										// save index across calls
	var grow_start_count = 0;										// # of current iteration of &#39;start&#39; step
	var grow_step_num = 12;											// arbitrary @start; scale it w/ fps_monitor
	var grow_target = 0;											// target step_num based on fps

	function init_growing( creating ) {
		var that = init_growing;
		if( that.fps === undefined ) that.fps = 0;
		if( that.base === undefined ) that.base = 0;
		mk_maps = creating;

		if( creating &amp;&amp; current_fps &amp;&amp; long_term_fps ) {			// adjust MaxTargets to prevent create cycle using too many frames
			var fps, base, limit;
			fps = current_fps();
			base = long_term_fps();									// mean of last 5 min
			if( fps &gt; 0 &amp;&amp; fps !== that.fps ) {						// more than a minute has passed/got new value
				that.fps = fps;
				if( base &gt; 0 &amp;&amp; base !== that.base ) {				// in flight for at least 5 min/got new 5 min baseline
					that.base = base;
					grow_target = floor( 6 + base / 5 );			// aim for 3 x&#39;s the minimum of 6 @ 60 Hz
					limit = grow_step_num;
					if( fps &lt; base &amp;&amp;								// reduction in fps beyond threshold
						   percentDiffOver( fps, base, (fps / 8) ) )// 7.5% @ 60 (&gt; 55.5 fps), 3.75% @ 30 (&gt; 27.6 fps)
						limit--;
					else
						limit++;
					if( abs( grow_target - limit ) &gt; 2 )			// it&#39;s a trend (occurs in 3/5)
						grow_target = limit;
/*
					let max_frames = floor( base / 5 );				// cycle must finish in 1/5 sec to allow time for others
					let total = grow_target * max_frames;
					if( debug &amp;&amp; total !== MaxTargets ) {
						log(ws.name, &#39;init_growing, MaxTargets changed to &#39; + total
										 + &#39; due to frame rate of &#39; + base + &#39; fps&#39; );
						MaxTargets = total;							// max # to finish in (arbitrary) 1/5  sec
						// Milo reports miss important new sightings; w/ various hardware/oxp config&#39;s, can creep too low
						// ? grow only, shrink to min of MaxTargets vs KISS
					}
 */
				} else {
					limit = floor( fps / 5 );						// initial rate, 12 per frame @ 60 fps, 6 @ 30
				}
				if( limit &gt; 6 &amp;&amp; limit !== grow_step_num ) {		// adjust limit every update based on fps stats from the last minute
																	//	 min of 6 is triple min in update because not all entities are kept,
																	//	 efficiency gains from immed. update (re-uses property get values)
																	//	 and 1st 4 frames limited to 1/2 limit (more are kept)
					if( debug ) log(ws.name, &#39;init_growing, grow_step_num changed from &#39;
									+ grow_step_num + &#39; to &#39; + limit );
					grow_step_num = limit;
				}
			}
		}

		max_sightings = MaxTargets;									// orbs no longer counted in MaxTargets
		grow_list_index = grow_start_count = 0;
		allShips = system.allShips;									// array of all ships in system, sorted by distance
		past_range = 0;
		found_new = beacons_only = false;							// reset flag if full update of mapping started
	}

	function include_ent( ent, using_past_range, restoring ) {		// dual use: restoring is for adding from grow_hidden_scanned after create
		if( notable_ent( ent, using_past_range, null, restoring ) ) {
			var index = mk_maps &amp;&amp; !restoring ? -1 : _Sighting_index( ent, &#39;include_ent&#39; );
			var map = index &lt; 0 ? mkSighting( ent ) : mapping[ index ];
			if( !map ) return false;
			if( mk_maps &amp;&amp; !restoring ) {
				grow_maps.push( map );
			} else if( index &lt; 0 ) {								// found new target or restoring
				mapping.push( map );
				maplen++;
				index = maplen - 1;
				if( !restoring ) {
					new_targets.push( ent );
				}
			}
			if( !restoring &amp;&amp; map.swapable ) {						// orbs &amp; beacons no longer counted in MaxTargets
				max_sightings--;
			}
			update_one_Sighting( map, ent, index );					// index can be -1, for those yet to be added into mapping
			return map;
		}
		return false;
	}

	var allShips, beacons_only;

	function fetchSun() {
		var ent = system_sun;
		if( isInterstellarSpace || !ent	|| !ent.isValid
				|| ent.hasGoneNova || ent.isGoingNova )	{			// sun is present and not nova
			ent = system_sun = null;
		}
		return ent;
	}

	function grow_new_list( step, testing ) {						// grow list over several frames
		if( testing !== undefined ) mk_maps = testing;
		var list, len, ent, map, idx;
		if( step === &#39;add_orbs&#39; ) {									// add sun, planets &amp; moons
			ent = fetchSun();
			len = system_planets.length;
			idx = 0;
			do {													// 1st loop adds sun, then ith loop add planet idx-1
				if( ent ) {
					reset_common_vars();							// sets using_common_vars true
					include_ent( ent );
				}
				if( idx &gt;= len ) break;
				ent = system_planets[ idx++ ];
			} while( true );
			using_common_vars = false;
			set_fn_pending( grow_new_list, &#39;start&#39; );
		} else if( step === &#39;start&#39; ) {								// create or update cycle
			var stop, alllen = allShips.length;
			stop = grow_list_index + grow_step_num &gt; alllen
				   ? alllen - grow_list_index : grow_step_num;
			if( grow_start_count &lt;= 3 )								// to counter clusters near player, where high % are
				stop = stop &gt;&gt; 1;									//	 notable, 1st 4 loops are 1/2 grow_step_num
			grow_start_count++;
			// let psUnderAttack = ps.AIPrimaryAggressor;
			// psUnderAttack = psUnderAttack ? psUnderAttack.length !== 0 : false;
			let now = clock.absoluteSeconds;
			while( stop-- ) {
				ent = allShips[ grow_list_index++ ];
				if( !ent ) break;									// a ship died since start of loop, shortening list
				if( ent === ps ) continue;
				// newly spawned ships have .isVisible == true regardless of their distance
				let spawned = ent.spawnTime;
				if( spawned &gt; 0 &amp;&amp; now - spawned &lt; SPAWN_DELAY ) 	// too new; will be picked up as a new target
					continue;
				reset_common_vars();								// clears distance
				if( beacons_only ) {								// once past AutoScanMaxRange, can only detect beacons
					isBeacon = is_beacon( ent );
					isStation = ent.isStation;
					if( !isBeacon ) continue;
				}
				include_ent( ent, true );							// sets distance
				if( !beacons_only &amp;&amp; distance &gt; scannerRange_X_2
						&amp;&amp; alertCondition &gt; YELLOW_ALERT &amp;&amp; weaponsOnline ) {
					beacons_only = true;
				}
				if( !beacons_only &amp;&amp; distance &gt; AutoScanMaxRange ) {
					beacons_only = true;
				}
				if( max_sightings === 0 ) {							// decr&#39;d by include_ent
					beacons_only = true;
				}
			}
			using_common_vars = false;
			if( stop &lt;= 0											// exit loop before finished this iteration
				&amp;&amp; grow_list_index &lt; alllen - 1 )					// not at end of allShips
				set_fn_pending( grow_new_list, &#39;start&#39; );			// still have work to do
			else if( mk_maps )										// new mapping created
				set_fn_pending( grow_new_list, &#39;create&#39; );
			else													// list finished update cycle
				set_fn_pending( grow_new_list, &#39;update&#39; );
		} else if( step === &#39;create&#39; ) {							// creating new mapping finished
if( debug ) log(ws.name, &#39;grow_new_list, create, grow_maps.length = &#39; + grow_maps.length );
			for( idx = 0, len = grow_maps.length; idx &lt; len; idx++ ) {	// transfer effects
				let new_map = grow_maps[ idx ];
				let index = _Sighting_index( new_map.ent );
				if( index &lt; 0 ) continue;
				let curr_map = mapping[ index ];
				if( curr_map.ve_colour !== new_map.ve_colour )		// colour change =&gt; new effects needed
					continue;
				if( curr_map.lightball ) {
					new_map.lb_size = curr_map.lb_size;
					new_map.lightball = curr_map.lightball;
					curr_map.lightball = null;						// prevent removal in free_Sighting via _newList
				}
				if( curr_map.masslock ) {
					new_map.ml_size = curr_map.ml_size;
					new_map.masslock = curr_map.masslock;
					curr_map.masslock = null;						// prevent removal in free_Sighting via _newList
				}
			}
			_newList( true );										// true =&gt; don&#39;t clear deferred tasks
			for( idx = 0, len = grow_maps.length; idx &lt; len; idx++ ) {	// to maintain external references, copy array
				mapping[ idx ] = grow_maps[ idx ];
			}
			maplen = mapping.length;
			mappingReady = true;
			grow_maps.length = 0;
			if( curr_S.ent )										// refresh current target
				_set_curr_Sighting( curr_S.ent, &#39;grow_new_list create&#39; );
			list = grow_hidden_scanned;
			idx = list.length;
			while( idx-- ) {										// preserve list of &#39;hidden&#39; entities that have been w/idx scannerRange
				ent = list[ idx ];
				reset_common_vars();
				map = include_ent( ent, false, true );				// true =&gt; checks it&#39;s still notable, update_one_Sighting (sets )
				if( !map ) continue;
				// when mkSighting, read_scriptInfo called, .script_mass is set set
				if( map.script_mass === 0 ) {						// ent hidden using scriptInfo {telescope = 0;}
					map.have_scanned = true;
				} else if( ent.scanClass === &#39;CLASS_CARGO&#39; ) {		// cargo pod (restore its RFID range)
					map.have_scanned = scannerRange + (map.entityPersonality &gt;&gt; 1);
				} else {											// an offender, preserve detection for FarStatus
					map.have_scanned = -1;							//	 not using true, as offender status knowledge can
				}													//	 survive a scan whereas hidden does not
			}
			using_common_vars = false;
			set_fn_pending( grow_new_list, &#39;finish&#39; );
		} else if( step === &#39;update&#39; ) {							// update cycle finished
// if( debug ) log(ws.name, &#39;grow_new_list, update, mapping.length = &#39; + mapping.length );
			if( curr_target === null ) {
				ent = curr_S.ent || null;
				if( !ent || !ent.isValid || ent.radius )
					if( !testing &amp;&amp; !profiling )					// sometimes doesn&#39;t return when profiling
						_clear_HUD_Effects();						//cleanup needed in some cases
			}
			set_fn_pending( grow_new_list, &#39;finish&#39; );
		} else if( step === &#39;refresh&#39; ) {							// finished updating existing mapping&#39;s ents
			mapping.sort( map_sort_heading );
		} else if( step === &#39;finish&#39; ) {							// follow-up common to both create &amp; update cycle
			process_new_targets();
			mapping.sort( map_sort_heading );
if( debug &amp;&amp; mk_maps ) log( ws.name, &#39;grow_new_list, finished w/ &#39; + maplen + &#39; Sightings&#39; );
			if( mk_maps ) {											// once mapping creation is done, update its ents
				grow_maps.length = 0;								// is now held in $SightingsMap (aka mapping)
				grow_hidden_scanned.length = 0;						// free up for garbage collection
			}														// - really only apparent on create cycle
		}
	}

	var past_range = 0;												// # of scannerRange&#39;s, to save calc&#39;s, as lists sorted by distance

	function set_range( ent, divide, using_past_range, dist ) {		// eliminate distance calc&#39;s where class is limited to
		if( using_past_range ) {									//	 a multiple of scannerRange
			if( past_range &lt; divide &amp;&amp; distance &lt; 0 ) {				// have not reached divide, so must calc distance
				distance = _detect_distanceTo( ent );
			}
		} else {													// calc distance if not passed
			if( distance &lt; 0 ) {
				distance = dist ? dist
								: _detect_distanceTo( ent );
			}
		}
		if( distance &gt;= 0 ) {										 // have calc&#39;d distance; never decrease past_range!
			if( past_range &lt; divide &amp;&amp; distance &gt; scannerRange * divide ) {
				past_range = divide;
			}
		}
		return past_range &gt;= divide;
	}

	// bitflags for static MFD filtering
	const MFD_SALVAGE = 1,		// cargo, escape pods, derelicts
		  MFD_MINING = 2,		// asteroids, boulders, splinters &amp; metal fragments
		  MFD_WEAPONS = 4,		// mines &amp; missiles
//		  	MFD_INANIMATE = 7,	// those of 1st 3 flags excluded from dynamic filtering
		  MFD_TRADERS = 8,		// ships .isTrader &amp; escorts
		  MFD_POLICE = 16,		// scanClass === &#39;CLASS_POLICE&#39;
		  MFD_PIRATES = 32,		// .isPirate &amp; .isPirateVictim
		  MFD_MILITARY = 64,	// scanClass === &#39;CLASS_MILITARY&#39;
		  MFD_ALIENS = 128,		// scanClass === &#39;CLASS_THARGOID&#39;
		  MFD_NEUTRAL = 256,	// scanClass === &#39;CLASS_NEUTRAL&#39; and not in any above category (e.g., miners, hunters, etc.)
//		  	MFD_ALLSHIPS = 504,	// all of the previous 6
		  MFD_STATION = 512,	// .isStation
		  MFD_NAVIGATION = 1024,// some stations &amp; beacons (may include a ship if emitting a beacon)
		  MFD_CELESTIAL = 2048;	// sun, planets, moons
//		  	MFD_ORIENT = 3584;	// all of the previous 3
		  // if add more flags, be sure to update line 89: this.$MFD_STATIC_ALLSET = 4095;

	function classify_ship( ent, dist ) {							// police, military &amp; alien flags set in notable_ent
		var markOffender = dist &lt;= scannerRange;
		if( dist &gt; scannerRange &amp;&amp; FarStatus ) {
			// with FarStatus, once of an offender is seen w/i scannerRange, it&#39;s status is remembered when it leaves
			let idx, have_scanned = false;
			if( grow_hidden_scanned.length &gt; 0 ) {
				idx = index_in_list( ent, grow_hidden_scanned );
				if( idx &gt;= 0 )
					have_scanned = grow_hidden_scanned[ idx ].have_scanned;
			} else {
				idx = _Sighting_index( ent, &#39;classify_ship&#39; );
				if( idx &gt;= 0 )
					have_scanned = mapping[ idx ].have_scanned;
			}
			if( have_scanned === true || have_scanned === -1 ) {	// has been seen inside scannerRange
				markOffender = true;
			}
		}
		if( markOffender &amp;&amp; ent.isPirate ) {
			staticMFD |= MFD_PIRATES;
		}
		if( markOffender &amp;&amp; ent.isPirateVictim ) {					// include in pirate filter if under attack by pirates
			let defenseTargets = ent.defenseTargets;
			for( let idx = 0, len = defenseTargets.length; idx &lt; len; idx ++ ) {
				if( defenseTargets[ idx ].isPirate ) {
					staticMFD |= MFD_PIRATES;
					break;
				}
			}
		}
		if( ent.isTrader ) {
			staticMFD |= MFD_TRADERS;
		}
		var group = ent.group,
			areTraders = false;
		if( group ) {
			let leader = group.leader;
			if( leader &amp;&amp; leader.isTrader ) {
				staticMFD |= MFD_TRADERS;
				areTraders = true;									// having found group are traders, don&#39;t need to check escorts
			}
		}
		group = ent.escortGroup;
		if( group &amp;&amp; !areTraders ) {
			let leader = group.leader;
			if( leader &amp;&amp; leader.isTrader ) {
				staticMFD |= MFD_TRADERS;
			}
		}
		if( (staticMFD &amp; MFD_TRADERS) || (staticMFD &amp; MFD_POLICE)
				|| (staticMFD &amp; MFD_PIRATES)
				|| (staticMFD &amp; MFD_MILITARY)
				|| (staticMFD &amp; MFD_ALIENS) ) {						// not NEUTRAL
			return;
		}
		staticMFD |= MFD_NEUTRAL; 									// all other ships that are not pirates or traders (e.g., miners, hunters, etc.)
	}

	function isGalactic_Navy( ent ) {
		var roles = ent.roles;
		for( let idx = 0, len = roles.length; idx &lt; len; idx++ ) {
			let role = roles[ idx ];
			if( role === &#39;SeccomLocator&#39; || role === &#39;seccom-medship&#39;
					|| role === &#39;GN_sortie_target&#39; || role ===  &#39;navyradar&#39;
					|| role === &#39;kurtz-pod&#39; || role === &#39;nelly_crew&#39; ) {
				return true;
			}
			let dash = role.indexOf( &#39;-&#39; );
			if( dash !== -1 ) {
				let pref = role.slice( 0, dash );
				if( pref === &#39;intercept&#39; || pref === &#39;reserve&#39;
						|| pref === &#39;picket&#39; || pref ===  &#39;patrol&#39;
						|| pref === &#39;hofd&#39; || pref === &#39;galNavy&#39; ) {
					return true;
				} else if( pref === &#39;navy&#39; ) {
					if( dataKey &lt; 0 ) dataKey = ent.dataKey;
					if( dataKey === &#39;FA_Titan&#39;
							|| dataKey === &#39;FA_Sunracer_N&#39; ) { // Montana&#39;s Far_Arm_Ships.OXZ
						return false;
					}
					return true;
				}
			} else {
				let pref = role.slice( 0, 5 );
				if( pref === &#39;navyS&#39; || pref === &#39;navys&#39; ) {
					return true;
				}
			}
		}
	}

///
	function notable_ent( ent, using_past_range, dist, restoring ) {// ALL calls must be preceeded by reset_common_vars
																	//	- not done here as there may be some vars set before call
																	// &#39;using_past_range&#39; only true in call from grow_new_list, to save distance
																	//	 calculations when batch processing ents sorted by distance
																	// &#39;restoring&#39; is only used for ents in grow_hidden_scanned
		var is_past_range;
		if( !using_past_range ) past_range = 0;						// also being called from _add_Sighting, check_Sightings, update_one_Sighting
		if( scanClass &lt; 0 ) scanClass = ent.scanClass;
		if( scanClass === &#39;CLASS_VISUAL_EFFECT&#39;
				|| scanClass === &#39;CLASS_PLAYER&#39; ) {
			return false;
		}
		if( status &lt; 0 ) status = ent.status;
		if( _has_bad_status( ent, status ) )
			return false;
		switch( scanClass ) {
			case &#39;CLASS_BUOY&#39;:
				ve_colour = &#39;green&#39;;
				isBuoy = true;
				is_past_range = set_range( ent, 1, using_past_range, dist );
				isBeacon = is_beacon( ent );						// can&#39;t assume all buoys are beacons // fn tests isBeacon &lt; 0
				if( isBeacon ) staticMFD |= MFD_NAVIGATION;
				if( !isBeacon &amp;&amp; is_past_range ) return false;
				if( !isBeacon &amp;&amp; eclipsed( ent, null, (distance &lt; 0 ? dist : distance) ) )
					return false;
				rank = is_past_range ? &#39;nsr&#39; : &#39;loc&#39;;
				break;
			case &#39;CLASS_CARGO&#39;:										// cargo, pods &amp; scoopable minables; all have distance &lt; scannerRange_X_2
				ve_colour = &#39;white&#39;;
				is_past_range = set_range( ent, 1, using_past_range, dist );
				if( !ext_ok &amp;&amp; is_past_range ) return false;
				shipClassName = ent.shipClassName;
				if( shipClassName === &#39;Splinter&#39; || shipClassName === &#39;Boulder&#39;
						|| shipClassName === &#39;Metal fragment&#39; ) {
					if( is_past_range ) return false;				// discard rocks past scannerRange
					if( eclipsed( ent, null, (distance &lt; 0 ? dist : distance) ) )
						return false;
					rank = &#39;mng&#39;;
					is_minable = true;
					staticMFD |= MFD_MINING;
					return true;
				} else if( shipClassName === &#39;Thargoid Robot Fighter&#39; ) {
					if( is_past_range ) return false;
					if( eclipsed( ent, null, (distance &lt; 0 ? dist : distance) ) )
						return false;
					rank = &#39;loc&#39;;									//will be like cargo when inactive, ve_colour stays white
					staticMFD |= MFD_ALIENS;
					return true;
				}
				isBeacon = is_beacon( ent );						// some (escape?) pods may have a beacon // fn tests isBeacon &lt; 0
				if( isBeacon ) staticMFD |= MFD_NAVIGATION;
				if( mk_maps &amp;&amp; !restoring							// unkown cargo must enter scannerRange in order to obtain its
						&amp;&amp; is_past_range &amp;&amp; !isBeacon )				//	 RFID frequency; existing preserved in grow_hidden_scanned
					return false;
				is_past_range = set_range( ent, 2, using_past_range, dist );// can &#39;see&#39; cargo beyond scannerRange (RFID tags?)
				let isCargo = ent.isCargo;
				if( is_past_range ) {								// exclude all beyond 2 * scannerRange
					if( !isBeacon ) return false;
					if( isCargo ) return false;						// escortdeck ships are &#39;CLASS_CARGO&#39; but !isCargo, have beacons
					if( isVisible &lt; 1 ) isVisible = ent.isVisible;
					if( !isVisible ) return false;
				}
				if( !isBeacon &amp;&amp; eclipsed( ent, null, (distance &lt; 0 ? dist : distance) ) )
					return false;
				if( !getDetected( ent, restoring ) ) return false;
				if( !is_past_range &amp;&amp; isBeacon &amp;&amp; is_ignored_ship( ent ) )
// - cargo w/ beacons, mainly EscortDeckShip&#39;s
// - for escorts: beaconCode = &quot;E&quot;+pad+&quot; &quot;+ship.name;
// - for towed ships: beaconCode = &quot;D&quot;; //Derelict
					return false;									// limit is_ignored_ship calls (expensive) by doing them last
				is_cargo = isCargo;									// escortdeck ships are &#39;CLASS_CARGO&#39; but !isCargo
				rank = &#39;loc&#39;;										// &#39;loc&#39; rank, as distance &lt; scannerRange_X_2
				staticMFD |= MFD_SALVAGE;
				break;
			case &#39;CLASS_MINE&#39;:
			case &#39;CLASS_MISSILE&#39;:
				is_past_range = set_range( ent, 1, using_past_range, dist );
				if( is_past_range ) return false;
				if( eclipsed( ent, null, (distance &lt; 0 ? dist : distance) ) )
					return false;
				ve_colour = &#39;cyan&#39;;
				rank = &#39;isr&#39;;										// as distance &lt; scannerRange
				staticMFD |= MFD_WEAPONS;
				break;
			case &#39;CLASS_THARGOID&#39;:
			case &#39;CLASS_POLICE&#39;:
			case &#39;CLASS_MILITARY&#39;:
			case &#39;CLASS_NEUTRAL&#39;:
				if( scanClass === &#39;CLASS_THARGOID&#39; ) {
					dataKey = ent.dataKey;
					if( dataKey !== &#39;tharglet&#39; )
						ve_colour = &#39;red&#39;;							//warship is red but tharglet is pink or white
					else
						ve_colour = &#39;pink&#39;;
					isHostile = true;
					staticMFD |= MFD_ALIENS;
				} else if( scanClass === &#39;CLASS_POLICE&#39; ) {
					if( isGalactic_Navy( ent ) ) {
						staticMFD |= MFD_MILITARY;
					} else {
						staticMFD |= MFD_POLICE;
					}
					ve_colour = &#39;purple&#39;;
				} else if( scanClass === &#39;CLASS_MILITARY&#39; ) {
					staticMFD |= MFD_MILITARY;
				}
				// pre-filtered by equipment: !ext_ok: &lt; scannerRange, !grav_eq_ok: .isVisible
				if( is_cloaked( ent ) )
					return false;
				// jamming ents are still notable (can be seen, not locked); map.hasJammer gets set using isJamming in mkSighting
				// is_jamming( ent );									// sets isJamming, returns true if effective (ie. scanFilter_ok)
				if( isVisible &lt; 0 ) isVisible = ent.isVisible;
				isBeacon = is_beacon( ent );						// fn tests isBeacon &lt; 0
				if( isBeacon ) staticMFD |= MFD_NAVIGATION;
				if( !isBeacon &amp;&amp; eclipsed( ent, null, (distance &lt; 0 ? dist : distance) ) )
					return false;
				if( !getDetected( ent, restoring ) ) return false;
				if( dataKey &lt; 0 ) dataKey = ent.dataKey;
				if( is_drone &lt; 0 &amp;&amp; dataKey )
					is_drone = dataKey.indexOf( &#39;drone&#39; ) &gt;= 0;		// allow drones from HardShips OXP
				if( is_drone ) {									// core &#39;sees&#39; then over scannerRange, even when !isVisible
					if( distance &lt; 0 ) distance = _detect_distanceTo( ent );
					if( distance &gt; scannerRange ) {					//	 so are treated as special case (incompatable w/ code below)
if( debug ) log(ws.name, &#39;notable_ent, is_drone &amp;&amp; distance &gt; scannerRange, discarding &#39; + ent );
						return false;
					}
					if( isHostile &lt; 0 ) isHostile = is_hostile( ent );// is_hostile accounts for distance &amp; FarStatus
					ve_colour = isHostile ? &#39;red&#39; : ve_colour &lt; 0 ? &#39;yellow&#39; : ve_colour;
if( debug &amp;&amp; ve_colour === &#39;red&#39; ) log(ws.name, &#39;notable_ent, ve_colour = &#39; + ve_colour + &#39;, scanClass = &#39; + scanClass );
					rank = isHostile ? &#39;bad&#39; : &#39;isr&#39;;				// undetectible beyond scannerRange
					if( scanClass === &#39;CLASS_NEUTRAL&#39; ) {
						classify_ship( ent, distance );				// set MFD_&#39;s for traders, pirates
					}
					return true;
				}
				is_past_range = set_range( ent, 1, using_past_range, dist );
				if( is_past_range &amp;&amp; !ext_ok &amp;&amp; !isBeacon ) return false;
				if( distance &lt; 0 ) distance = _detect_distanceTo( ent );
				let in_mapping = -1, dist_visible = scannerRange, lost_target = false;
				if( !isBeacon &amp;&amp; is_past_range &amp;&amp; ext_ok ) {		// visible detection
					is_past_range = !isVisible;
					if( is_past_range &amp;&amp; !grav_eq_ok ) {			// w/o gs, &#39;Lost target&#39;s hang around until beyond 10% of
						in_mapping = mk_maps ? false				//	 visible distance (or next scan)
											 : _Sighting_index( ent, &#39;notable_ent&#39; ) &gt;= 0;
						if( in_mapping ) {							// only ents in mapping get is_past_range extended, so only they can
							is_past_range = distance &gt; dist_visible * 1.10;//	get assigned a rank of &#39;ukn&#39; below, ie. become lost target
							lost_target = true;
						}
					}
				}
				if( !isBeacon &amp;&amp; !isVisible &amp;&amp; is_past_range &amp;&amp; !grav_eq_ok )	   // discard unseen ships
					return false;
				if( !isBeacon &amp;&amp; is_past_range &amp;&amp; gravScanProgress &gt; 0 ) {// gravity scanner detection
					gs_curr = grav_scan_dist( ent, true );			// true gets current range else max detection range
					isVisible = distance &lt; gs_curr;
					is_past_range = !isVisible;
					if( is_past_range ) {
						if( in_mapping &lt; 0 )
							in_mapping = mk_maps ? false
												 : _Sighting_index( ent, &#39;notable_ent #2&#39; ) &gt;= 0;
						if( in_mapping ) {							// only ents in mapping get is_past_range extended, so only they can
							gs_max = !stationNearby ? gs_curr * 1.10//	 get assigned a rank of &#39;ukn&#39; below, ie. become lost target
													: grav_scan_dist( ent );
							is_past_range = distance &gt; gs_max;		// w/ gs, &#39;Lost target&#39;s hang around until beyond detectable range,
							lost_target = distance &lt; gs_max;
						}
					}
				}
				if( !isBeacon &amp;&amp; !isVisible &amp;&amp; is_past_range )		// discard undetectible ships
					return false;
				if( isHostile &lt; 0 ) isHostile = is_hostile( ent );	// is_hostile accounts for distance &amp; FarStatus
				if( isHostile )						rank = &#39;bad&#39;;
				else if( distance &lt; scannerRange )	rank = &#39;isr&#39;;
				else if( isVisible || isBeacon )	rank = &#39;nsr&#39;;
				else if( lost_target )				rank = &#39;ukn&#39;;
				else return false;
				ve_colour = isHostile	  ? &#39;red&#39; :					// colour police too if hostile
							ve_colour &lt; 0 ? &#39;yellow&#39; : ve_colour;	// preserve previously assigned colour
				if( ent.isDerelict ) {
					ve_colour = &#39;blue&#39;;
					staticMFD |= MFD_SALVAGE;
				} else if( scanClass === &#39;CLASS_NEUTRAL&#39; ) {
					classify_ship( ent, distance );					// set MFD_&#39;s for traders, pirates
				}
				if( !isVisible ) {
					if( rank === &#39;ukn&#39; ) {
						ve_colour = &#39;gray&#39;;							// overrides all other colours
					} else {
						if( mass &lt; 0 )								// mass set this way to catch any scriptInfo
							script_mass = read_scriptInfo( ent );	// sets mass
						ve_colour = mass &lt; 130000 ? &#39;brown&#39; : &#39;orange&#39;;
					}
				}
				break;
			case &#39;CLASS_ROCK&#39;:										// rocks are either minables or Rock Hermits
				if( dataKey &lt; 0 ) dataKey = ent.dataKey;
				if( dataKey === &#39;telescopemarker&#39; ) return false;
				is_past_range = set_range( ent, 1, using_past_range, dist );
				if( isFrangible &lt; 0 ) isFrangible = ent.isFrangible;
				if( is_past_range &amp;&amp; isFrangible ) return false;	// discard rocks beyond scannerRange; isFrangible works for asteroids
																	//	 and boulders, the smaller rocks (eg. splinters) are CLASS_CARGO
				if( isStation &lt; 0 ) isStation = ent.isStation;		// abandoned rock hermits are !isStation
				isBeacon = is_beacon( ent );						// fn tests isBeacon &lt; 0
				if( isBeacon ) staticMFD |= MFD_NAVIGATION;
				let hidden = -1;
				if( is_past_range ) {								// rock hermits
					if( !ext_ok ) return false;
					if( !isStation &amp;&amp;								// discard abandoned Rock Hermits beyond scannerRange
							!(grav_eq_ok &amp;&amp; (small_ok || large_ok)))//	unless has a working dish
						return false;

					if( isVisible &lt; 0 ) isVisible = ent.isVisible
					if( !isBeacon &amp;&amp; !isVisible ) return false;
					hidden = !isBeacon &amp;&amp; eclipsed( ent, null, (distance &lt; 0 ? dist : distance) );
					if( hidden ) return false;
					if( isStation &amp;&amp; !getDetected( ent, restoring ) ) {// rock hermit; abandoned ones are !isStation
						return false;
					}
				} // else isFrangible
				if( !isStation &amp;&amp; !getDetected( ent, restoring ) )	// stealth mines are rocks
					return false;
				is_past_range = set_range( ent, 4, using_past_range, dist );
				if( hidden === -1 )
					hidden = !isBeacon &amp;&amp; eclipsed( ent, null, (distance &lt; 0 ? dist : distance) );
				if( hidden ) return false;
				isPiloted = ent.isPiloted;
				if( isFrangible &amp;&amp; !isPiloted ) {					// only those &lt; scannerRange or !isFrangible get here
					ve_colour = &#39;white&#39;;							//	 so distance calc not required
					rank = &#39;mng&#39;;
					is_minable = true;
					staticMFD |= MFD_MINING;
				} else if( isStation ) {							// abandoned Rock Hermits are !isStation but are isMinable
					staticMFD |= MFD_STATION;
					ve_colour = &#39;green&#39;;
					rank = is_past_range ? &#39;nsr&#39; : &#39;loc&#39;;
				} else { // isFrangible
					if( isPiloted ) {								// lave.oxp has piloted rocks!
						ve_colour = &#39;white&#39;;						// since isFrangible, must be in scannerRange
						rank = &#39;loc&#39;;								// grouped w/ cargo
					} else if( grav_eq_ok &amp;&amp; (small_ok || large_ok) &amp;&amp;
								ent.isMinable ) {					// allows &#39;Abandoned Rock Hermit&#39; for working dishes
						staticMFD |= MFD_STATION;
						staticMFD |= MFD_MINING;
						rank = distance &lt; scannerRange_X_4 ? &#39;loc&#39; : &#39;nsr&#39;;
						ve_colour = &#39;pink&#39;;
					} else
						return false;								// fallback -&gt; discard
				}
				break;
			case &#39;CLASS_STATION&#39;:
				ve_colour = &#39;green&#39;;
				isStation = true;
				staticMFD |= MFD_STATION;
				isBeacon = is_beacon( ent );						// fn tests isBeacon &lt; 0
				if( isBeacon ) staticMFD |= MFD_NAVIGATION;
				if( isVisible &lt; 0 ) isVisible = ent.isVisible;
				is_past_range = ext_ok ? !isVisible
									   : set_range( ent, 1, using_past_range, dist );
				// jamming ents are still notable (can be seen, not locked); map.hasJammer gets set using isJamming in mkSighting
				// is_jamming( ent );									// sets isJamming, returns true if effective (ie. scanFilter_ok)
				if( !isBeacon ) {
					if( is_past_range )
						return false;
					if( eclipsed( ent, null, (distance &lt; 0 ? dist : distance) ) )
						return false;
					if( !getDetected( ent, restoring ) )
						return false;
				}
				if( distance &lt;= scannerRange ) {
					rank = &#39;isr&#39;;
				} else {
					rank = &#39;nsr&#39;;
					if( is_past_range &amp;&amp; !isBeacon
							&amp;&amp; _Sighting_index( ent, &#39;notable_ent&#39; ) &gt;= 0 ) {// only known (ie. existing) ents can become lost
						rank = &#39;ukn&#39;;
					}
				}
				break;
			case &#39;CLASS_NO_DRAW&#39;:
				if( radius &lt; 0 ) radius = ent.radius || false;
				if( !radius ) return false;							// not an orb, probably wreckage
				if( ext_ok ) {
					if( isVisible &lt; 0 ) isVisible = ent.isVisible;
					is_past_range = isVisible;						// sun, planets &amp; moons always visible?
				} else
					is_past_range = set_range( ent, 1, using_past_range, dist );
				ve_colour = &#39;lightgray&#39;;
				rank = is_past_range ? &#39;orb&#39; : &#39;loc&#39;;
				isSun = ent.isSun;
				isPlanet = !isSun;
				staticMFD |= MFD_CELESTIAL;
				break;
			case &#39;CLASS_WORMHOLE&#39;:
				is_past_range = set_range( ent, ext_ok ? 4 : 1, using_past_range, dist ); // scannerRange_X_4 = 102400, an arbitrary choice
				if( is_past_range ) return false;
				if( collisionRadius &lt; 0 ) collisionRadius = ent.collisionRadius;
				if( collisionRadius === 0 ) return false;			// wormhole has evaporated
				if( eclipsed( ent, null, (distance &lt; 0 ? dist : distance) ) )
					return false;
				ve_colour = &#39;blue&#39;;
				rank = distance &lt; scannerRange ? &#39;loc&#39; : &#39;nsr&#39;;
				isWormhole = true;
				staticMFD |= MFD_NAVIGATION;
				break;
			default:												// what slips thru
if( debug &amp;&amp; scanClass !== undefined &amp;&amp; scanClass !== &#39;CLASS_VISUAL_EFFECT&#39; &amp;&amp; scanClass !== &#39;CLASS_PLAYER&#39; )
	log(ws.name, &#39;notable_ent, MISSING case for scanClass &#39; + scanClass );
				return false;
		}
		// no code here unless repl. &#39;return true&#39; cases above
		return true;
	}
///

// profiling functions ////////////////////////////////////////////////////////////////////////////

var profiling = false;
/*	//!cagiife
function profile_create() {	 _profile_growing( true, false, false ); }
function profile_update() {	 _profile_growing( false, true, false ); }
function profile_refresh() { _profile_growing( false, false, true ); }

function _profile_growing( create, update, refresh ) {
	function profiled_code() { _call_pending( 1 ); }
	function profile_run( fn, result_array ) {
		var profile, fname, title, total, jstime, start, end, saved;
		set_fn_pending( fn );
		while( tasks_pending.length ) {
			title = fname = tasks_pending[0].fn.name;
			if( fname.length &gt; 12 )
				fname = fname.substr( 0, 13 );
			else
				fname += &#39;		  &#39;.slice( fname.length - 13 );
			console.writeJSMemoryStats();
			profile = console.profile( profiled_code, worldScripts.telescope._Sightings_closure );
			start = profile.indexOf( &#39;:&#39; ) + 2; // &#39;: &#39;
			end = saved = profile.indexOf( &#39; ms&#39;);
			total = parseFloat( profile.slice( start, end ) );
			start = profile.indexOf( &#39;:&#39;, end ) + 2; // &#39;: &#39;
			end = profile.indexOf( &#39; ms&#39;, start );
			jstime = parseFloat( profile.slice( start, end ) );
			result_array.push([ fname, total, jstime ]);
			log(ws.name, &#39;\n\nprofiling &#39; + title +&#39;():	 Total time: &#39;	+ total
						   + &#39; ms\n			 ==&#39; + &#39;========================&#39;.substr( 0, title.length )
						   + &#39;				 =====&#39; + (total &lt; 10 ?	 &#39;\n&#39;: &#39;=\n&#39;  ) + profile.substr( saved + 4 ) );
		}
	}
	clear_all_pending();
	let saved_debug = debug;
	debug = false;
	profiling = true;
	console.clearConsole();

	var creating = null, updating = null, refreshing = null;
	console.garbageCollect();
	if( create ) {
		creating = [];
		profile_run( _create_Sightings, creating );
		console.writeJSMemoryStats();
	}
	if( update ) {
		updating = [];
		profile_run( _update_Sightings, updating );
		console.writeJSMemoryStats();
	}
	if( refresh ) {
		refreshing = [];
		profile_run( refresh_Sightings, refreshing );
		console.writeJSMemoryStats();
	}
	report_timings( creating, updating, refreshing );
	profiling = false;
	debug = saved_debug;
}
*/	//!cagiife

/*
ws.time_create()
ws.profile_create()

JavaScript heap: 5.11 MiB (limit 32.00 MiB, 106 collections to date)
JavaScript heap: 5.11 MiB (limit 32.00 MiB, 106 collections to date)
JavaScript heap: 5.11 MiB (limit 32.00 MiB, 106 collections to date) =&gt; no garbage!
_create_Sightings (12)		_update_Sightings (12)		updating is:
======================		======================		============
_create_Sight = 0.9050		_update_Sight = 0.3110		65.6% faster (diff:	 0.5940, js:  0.5830)
grow_new_list = 1.8510		grow_new_list = 1.3360		27.8% faster (diff:	 0.5150, js:  0.4940)
grow_new_list = 2.0140		grow_new_list = 1.9240		 4.5% faster (diff:	 0.0900, js:  0.0740)
grow_new_list = 1.5700		grow_new_list = 1.7830	   -13.6% slower (diff: -0.2130, js: -0.1470)
grow_new_list = 1.3030		grow_new_list = 1.2590		 3.4% faster (diff:	 0.0440, js:  0.0530)
grow_new_list = 0.9010		grow_new_list = 0.8300		 7.9% faster (diff:	 0.0710, js:  0.0370)
grow_new_list = 2.2960		grow_new_list = 1.8980		17.3% faster (diff:	 0.3980, js:  0.3700)
grow_new_list = 2.7040		grow_new_list = 2.5930		 4.1% faster (diff:	 0.1110, js:  0.1280)
grow_new_list = 1.3190		grow_new_list = 1.0830		17.9% faster (diff:	 0.2360, js:  0.1510)
grow_new_list = 0.6150		grow_new_list = 0.4360		29.1% faster (diff:	 0.1790, js:  0.1510)
grow_new_list = 1.2130		grow_new_list = 0.1310		89.2% faster (diff:	 1.0820, js:  1.0860)
grow_new_list = 0.3260		grow_new_list = 0.2070		36.5% faster (diff:	 0.1190, js:  0.1190)
			   =======					   =======		======
	creating:  17.0170			 updating: 13.7910		updating is 18.96% faster

*/

/*	//!cagiife
function set_profiling() { profiling = true; } // debug access to glocal
function clear_profiling() { profiling = false; } // debug access to glocal

function time_create( solo ) { _time_growing( true, solo ? false : true, false ); }
function time_update( solo ) { _time_growing( false, true, solo ? false : true ); }
function time_refresh() { _time_growing( false, false, true ); }

function _time_growing( create, update, refresh ) {
	function profiled_code() { _call_pending( 1 ); }
	function profile_run( fn, result_array ) {
		var profile, fname, total, jstime, parm;
		set_fn_pending( fn );
		while( tasks_pending.length ) {
			fname = tasks_pending[0].fn.name;
			parm = tasks_pending[0].parm;
			profile = console.getProfile( profiled_code, worldScripts.telescope._Sightings_closure );
			total = ( profile.totalTime * 1000 );
			jstime = ( profile.javaScriptTime * 1000 );
			if( fname.length &gt; 12 )
				fname = fname.substr( 0, 13 );
			else
				fname += &#39;		  &#39;.slice( fname.length - 13 );
			result_array.push([ fname, total, jstime, parm ]);
		}
	}

	try {
		clear_all_pending();
		let saved_debug = debug;
		debug = false;
		profiling = true;
		console.garbageCollect();
		console.writeJSMemoryStats();
		var creating = null, updating = null, refreshing = null;
		if( create &amp;&amp; update &amp;&amp; refresh ) {
			log(ws.name, &#39;_time_growing, support for all 3 simultaneously NOT supported&#39; );
			return;
		}
		if( !create &amp;&amp; !update &amp;&amp; !refresh ) create = update = true;
		if( create ) {
			creating = [];
			profile_run( _create_Sightings, creating );
			console.writeJSMemoryStats();
		}
		if( update ) {
			updating = [];
			profile_run( _update_Sightings, updating );
			console.writeJSMemoryStats();
		}
		if( refresh ) {
			refreshing = [];
			profile_run( refresh_Sightings, refreshing );
			console.writeJSMemoryStats();
		}
		report_timings( creating, updating, refreshing );
		profiling = false;
		debug = saved_debug;
	} catch( err ) {
		log( ws.name, ws._reportError( err, &#39;time_create&#39; ) );
		if( debug ) throw err;
	}
}
function report_timings( creating, updating, refreshing ) {
	var first_col = null, second_col = null;
	if( creating ) {
		first_col = creating;
		if( updating ) second_col = updating;
		else if( refreshing ) second_col = refreshing;
	} else if( updating ) {
		first_col = updating;
		if( refreshing ) second_col = refreshing;
	} else if( refreshing ) {
		first_col = refreshing;
	}
	var ctotal, utotal, cstep, ustep, cjs, ujs, diff, last_c = false, last_u = false;
	var csum = 0, usum = 0, cjsum = 0, ujsum = 0, out_c = true, out_u = true;
	var out, ci, ui, jspercent, last_cr, last_up, parm, spacer = &#39;		&#39;;
	var cr_len = first_col ? first_col.length : 0;
	var up_len = second_col ? second_col.length : 0;
	var both = first_col &amp;&amp; second_col;
//	out = &#39;_create_Sightings (&#39;+cr_len+&#39;)	   _update_Sightings (&#39;+up_len+&#39;)	   updating is:&#39;
	out = &#39;\n&#39; + (creating ? &#39;_create&#39; : updating ? &#39;_update&#39; : &#39;refresh&#39;);
	//if( first_col )
		out += &#39;_Sightings (&#39;+cr_len+&#39;)&#39;;
	if( both ) out += spacer;
	if( second_col ) out += (creating ? (updating ? &#39;_update&#39; : &#39;refresh&#39;) : &#39;refresh&#39;) + &#39;_Sightings (&#39;+up_len+&#39;)&#39;;
	if( both ) out += spacer + (creating ? (updating ? &#39;updat&#39; : &#39;refresh&#39;) : &#39;refresh&#39;) + &#39;ing is:&#39;;
//			 +&#39;\n======================		 ======================		 ============&#39;;
	out += &#39;\n&#39;;
	if( first_col ) out += &#39;======================&#39;;
	if( both ) out += spacer;
	if( second_col ) out += &#39;======================&#39;;
	if( both ) out += spacer + &#39;============&#39;;
var count = 0;
	for( ci = 0, ui = 0; ci &lt; cr_len || ui &lt; up_len;  ) { // cr_len !== up_len
		out += &#39;\n&#39;;
		if( out_c &amp;&amp; ci &lt; cr_len ) [ cstep, ctotal, cjs, parm ] = first_col[ ci ];
		if( out_u &amp;&amp; ui &lt; up_len ) [ ustep, utotal, ujs, parm ] = second_col[ ui ];
		if( both ) {
			out_c = last_c || ci &lt; cr_len
								&amp;&amp; ( ci === 0 || cstep === ustep	// 1st row is always diff
									 || cstep === last_cr );		// complete run of same steps
			out_u = last_u || ui &lt; up_len
								&amp;&amp; ( ui === 0 || ustep === cstep	// 1st row is always diff
									 || ustep === last_up );		// complete run of same steps
		} else {
			out_c = true;
			out_u = false;
		}
		if( !out_c &amp;&amp; !out_u )
				 if( ci &lt; cr_len &amp;&amp; ci &lt; ui ) out_c = true;			// allow shorter to catch up
			else if( ui &lt; up_len &amp;&amp; ui &lt; ci ) out_u = true;
			else if( ci === ui ) {
				if( cr_len &lt; up_len ) out_u = true;
				else				  out_c = true;
			} else if( ci &lt; cr_len ) out_c = true;					// go w/ unfinished one
			else   if( ui &lt; up_len ) out_u = true;
if( !out_c &amp;&amp; !out_u ) { log(ws.name, &#39;time_create, stalled w/ cstep = &#39; + first_col[ ci ][0] + &#39;, ustep = &#39; + second_col[ ui ][0] ); break; }
		if( !out_c &amp;&amp; !out_u ) out_c = true;						// create has extra grow_new_list entries
		if( out_c &amp;&amp; !last_c ) {
			ci++;
			csum += ctotal;
			cjsum += cjs;
			last_cr = cstep;
			let txt = cstep + &#39; = &#39; + ctotal.toFixed( 4 );
			if( both &amp;&amp; ci === cr_len ) {
				last_c = txt;
				if( ui &lt; up_len - 1 ) out += &#39;						&#39;;
			} else out += txt;
		} else if( both &amp;&amp; !last_c &amp;&amp; !last_u ) {
			out += &#39;					  &#39;;
		}
		if( out_u &amp;&amp; !last_u ) {
			ui++;
			usum += utotal;
			ujsum += ujs;
			last_up = ustep;
			let txt = (first_col ? spacer : &#39;&#39;) + ustep + &#39; = &#39; + utotal.toFixed( 4 );
			if( both &amp;&amp; ui === up_len ) {
				last_u = txt;
				if( ci &lt; cr_len ) out += &#39;							  &#39;;
			} else out += txt;
		} else if( both &amp;&amp; !last_c ) {
			out += &#39;							&#39;;
		}
		if( out_c &amp;&amp; out_u &amp;&amp; !last_c &amp;&amp; !last_u || (last_c &amp;&amp; last_u)) {
			if( last_c &amp;&amp; last_u ) out += last_c + last_u;
			diff = ((ctotal - utotal) / ctotal * 100).toFixed( 1 );
			diff = &#39;		 &#39;.slice( diff.length-8 ) + diff;
			let totdiff = (ctotal - utotal).toFixed(4);
			let jsdiff = (cjs - ujs).toFixed(4);
			out += &#39;  &#39; +  diff + &#39;% &#39;+( diff &lt; 0 ? &#39;slower&#39; :&#39;faster&#39; )
				+&#39; (diff: &#39;+(totdiff &gt; 0 ? &#39; &#39;+totdiff : totdiff)
				+&#39;, js: &#39;+(jsdiff &gt; 0 ? &#39; &#39;+jsdiff : jsdiff)+&#39;)&#39;;
		} else if( out_u &amp;&amp; !last_c ) {
			jspercent = (ujs / utotal * 100).toFixed( 1 );
			out += spacer + &#39;native: &#39;+ (utotal - ujs).toFixed(4) +&#39;, js: &#39;+ ujs.toFixed(4)+&#39; (&#39;+jspercent+&#39;%)&#39;;
		} else if( out_c &amp;&amp; !last_u ) {
			jspercent = (cjs / ctotal * 100).toFixed( 1 );
			out += spacer + &#39;native: &#39;+ (ctotal - cjs).toFixed(4) +&#39;, js: &#39;+ cjs.toFixed(4)+&#39; (&#39;+jspercent+&#39;%)&#39;;
		}
		if( parm ) out += &#39;	   parm: &#39; + parm;
		if( last_c &amp;&amp; (!both || last_u )) break;
if( ++count &gt; 25 ) break;
	}
	if( both ) diff = ((csum - usum) / csum * 100).toFixed( 2 );
//	out += &#39;\n				 =======					 =======	  ======&#39;;
	out += &#39;\n&#39;;
	if( first_col ) out += &#39;			   =======&#39;;
	if( both ) out += spacer;
	if( second_col ) out += &#39;				=======&#39;;
	if( both ) out += spacer + &#39;======&#39;;
//	out += &#39;\n	  creating:	 &#39; +csum.toFixed( 4 )+ &#39;		   updating: &#39; +usum.toFixed( 4 )+ &#39;	  updating is &#39;
//		+ diff + &#39;% &#39;+( diff &lt; 0 ? &#39;slower&#39; :&#39;faster&#39; );
	out += &#39;\n&#39;;
	if( first_col ) out += (creating ? &#39;	creating:  &#39; : updating ? &#39;		updating: &#39; : &#39;	  refreshing: &#39;) +csum.toFixed( 4 );
	if( both ) out += spacer;
	if( second_col ) out += (updating ? &#39;	  updating: &#39; : &#39;	refreshing: &#39;) +usum.toFixed( 4 );
	if( both ) out += spacer + (updating ? &#39;updating&#39; : &#39;refreshing&#39;) + &#39; is &#39;+ diff + &#39;% &#39;+( diff &lt; 0 ? &#39;slower&#39; :&#39;faster&#39; );
	log(ws.name, out );
	profiling = false;
}
*/	//!cagiife

///////////////////////////////////////////////////////////////////////////////////////////////////
// _target_marker_closure /////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

	function _update_target_marker() {								// FCB to make and update shadow and vmarkship
		try {
			if( have_shutdown )
				return;
			var map = curr_S.map;
			if( !equip_ok ) {										// 1st FCB fn called, so responsible for orderly shutdown if equipment damaged
				if( map )
					_set_curr_Sighting( null, &#39;_update_target_marker&#39; );// no parms resets
				_newList();
				have_shutdown = true;
				return;
			}
			if( !map )
				return;
			var marker = curr_S.marker;
			if( marker &amp;&amp; !marker.isValid ) {
				marker = removeMarker();							// convenience return of null
			}
			var ent = curr_S.ent;
			if( !ent || _has_bad_status( ent ) ) {
				_set_curr_Sighting( null, &#39;_update_target_marker&#39; );// no parms resets
				return;
			}

			reset_common_vars();
			// ensure target&#39;s distance is up to date so setting ps.target will always succeed
			// - when crossing boundary, must be exact if switching from far to near as cannot
			//   set ps.target to an ent that is scannerRange + 0.000000001 distant!
			distance = map.ent_dist = _detect_distanceTo( ent );
			radius = ent.radius || false;
			if( !marker
				|| crossing_boundary( map, distance + ent.collisionRadius,
									  curr_S.marker_type, radius, &#39;_update_target_marker&#39; ) ) {
				_manage_marker( map, false, &#39;_update_target_marker (IdentKeyPress = &#39;
											+ identKeyPress + &#39;)&#39; );
				if( !marker ) {
					marker = curr_S.marker;
					if( !marker ) {
						using_common_vars = false;
						return;
					}
				}
			} else {
				calc_marker_posn( map, distance, radius );
				marker.position = marker_posn;
				marker.velocity = ps_velocity;						//keep target over Torus speeds in FarPlanets OXP
			}
			if( curr_S.marker_type === &#39;marker&#39; ) {  				// update km
				let displayName = set_displayName( map );
				let distAndUnits = distWithUnits( distance );
				marker.displayName = distAndUnits + &#39; &#39; + displayName;
			}
			using_common_vars = false;
		} catch( err ) {
			log( ws.name, ws._reportError( err, &#39;_update_target_marker&#39; ) );
			if( debug ) throw err;
		}
	}

	var marker_posn = [];
	var target_posn = [];

	function calc_marker_posn( map, map_ent_dist, is_an_orb ) {
		copy_vector( map.last_posn, position );
		copy_vector( position, target_posn );
		subtract_vectors( position, ps_position, target_vector );
		unit_vector( target_vector, target_direction );				// unit vector to target (or to last known pos)
		let marker_dist = scannerRange - 600;
		// - the shadow lollipop lies in front of the lightballs (sR - 400 in lb_position) to reduce flickering
		//do not set closer to scannerRange so won&#39;t leave behind aft markers during torus travel
		if( map_ent_dist &lt; scannerRange &amp;&amp; is_an_orb ) {			// close to a planet, moon or suns
			if( (map_ent_dist - 300) &lt; marker_dist ) {
				marker_dist = map_ent_dist - 300;					// min( marker_dist, map_ent_dist - 299.6 ) from old code
			}
			if( marker_dist &lt; ps_collisionRadius )					// so we don&#39;t collide with marker
				marker_dist = ps_collisionRadius;
		}
		scale_vector( target_direction, marker_dist, vector )
		add_vectors( ps_position, vector, marker_posn );
		if( moving_fast )
			apply_speed_adj( marker_posn );
	}

	function removeMarker() {
		if( curr_S.marker ) {
/*
			if( curr_S.marker_type === &#39;marker&#39; ) {
				curr_S.marker.removeCollisionException(ps);
			} // not really necessary
 */
			curr_S.marker.$TelescopeTarget = null;
			curr_S.marker.remove();
		}
		curr_S.marker = null;
		curr_S.marker_type = &#39;&#39;;
		return null;												// convenience return
	}

	function manage_marker( new_map, showName, caller ) {
		try {
			_manage_marker( new_map, showName, caller );
		} catch( err ) {
			log( ws.name, ws._reportError( err, &#39;manage_marker&#39;, [showName, caller] ) );
			if( debug ) throw err;
		}
	}

	function _manage_marker( new_map, showName, caller ) {
		if( !mappingReady || have_shutdown ) return;				// not yet built OR empty
/*
if( debug ) {
	log(ws.name, &#39;\n_manage_marker, new_map&#39;
		+ (new_map &amp;&amp; new_map.ent ? &#39; (&#39; + new_map.ent.entityPersonality + &#39;): &#39; + new_map.ent.displayName : &#39;: &#39; + new_map)
		+ &#39;, showName: &#39; + showName + &#39;, caller: &#39; + caller );
}
 */
		var ent, new_marker, map = null;
		var index = new_map === null ? -1 : _Sighting_index( new_map, &#39;_manage_marker&#39; );
		var actual = curr_S.map || false;							// ? may have died, docked, jumped, out of range, etc., ?must remove telescopemarker
		// check we have a valid target (current or new)
		var still_alive = actual &amp;&amp; actual.ent &amp;&amp; actual.ent.isValid;// if he&#39;s ok, may have to just update marker position
		if( index &lt; 0 &amp;&amp; still_alive ) {							// no new target, fetch existing one
			map = actual;
		} else {													// get ready to switch targets
			map = index &gt;= 0 &amp;&amp; index &lt; maplen ? mapping[ index ] : null;
		}
/*
if( debug ) {
	log(ws.name, &#39;  index: &#39; + index + &#39;, actual&#39;
		+ (actual &amp;&amp; actual.ent ? &#39; (&#39; + actual.ent.entityPersonality + &#39;): &#39; + actual.ent.displayName : &#39;: &#39; + actual)
		+ &#39;, still_alive: &#39; + still_alive + &#39;, map&#39;
		+ (map &amp;&amp; map.ent ? &#39; (&#39; + map.ent.entityPersonality + &#39;): &#39; + map.ent.displayName : &#39;: &#39; + map) );
}
 */
		if( !map ) {												// nothing to do
			return;
		}
		ent = map.ent;
		if( _has_bad_status( ent ) ) {								// target died, jumped or docked, clean up
			if( actual &amp;&amp; new_map === actual ) {					// ent is not a new target, reset curr_S
				_set_curr_Sighting( null, &#39;_manage_marker, _has_bad_status, via &#39; + caller );
			} // else we just don&#39;t switch to new ent (ie. stay w/ curr_S.map)
			return;
		}
		if( is_jamming( ent ) ) {									// ent just started jamming
			if( actual &amp;&amp; new_map === actual ) {					// jammer is current target, reset curr_S
				_set_curr_Sighting( null, &#39;_manage_marker, is_jamming, via &#39; + caller );
			} // else we just don&#39;t switch to new ent (ie. stay w/ curr_S.map)
			return;
		}
 		if( is_cloaked( ent ) ) {									// ent cloaked before we got here!
			if( actual &amp;&amp; new_map === actual ) {					// current target just cloaked, reset curr_S
				_set_curr_Sighting( null, &#39;_manage_marker, is_cloaked, via &#39; + caller );
			} // else we just don&#39;t switch to new ent (ie. stay w/ curr_S.map)
			_delete_Sighting( map, &#39;_manage_marker, via &#39; + caller );// telescope cannot &#39;see&#39; cloaked ships
			return;
		}
		if( radius &lt; 0 || !using_common_vars )
			radius = ent.radius || false;							// only orbs have .radius
		if( map !== actual ) {										// update curr_S.name
			set_displayName( map );
		}
		// determine if we keep current marker (reposition) or must create new one
		var marker = curr_S.marker || null;
		if( marker &amp;&amp; !marker.isValid ) {
			marker = removeMarker();								// convenience return of null
		}
		if( ent.isWormhole ) {
			// core requires user to manually target wormhole (player hits &#39;u&#39;, &#39;r&#39;) for the wormhole scanner to work
			// we cannot target a wormhole, only the user can; setting ps.target = wormhole generates exception
			//	 &quot;Exception: Error: Cannot set property target of instance of PlayerShip to invalid value&quot;
			_handle_wormhole( ent );								// mimic core wormhole scanner
			if( (!curr_S || curr_S.ent !== ent) &amp;&amp; ent.$TelescopeScanStart !== undefined ) {
				_set_curr_Sighting( ent, &#39;_manage_marker wormhole, via &#39; + caller  );
			}
			return;
		}

		var mark_type = curr_S.marker_type || &#39;&#39;;
		// edge for near/far targets is .distanceTo === scannerRange, regardless of any radius (core tries for 25k)
		// =&gt; marker should read _detect_distanceTo, ie. position.distanceTo - ent.collisionRadius
		let map_ent_dist = map.ent_dist;							// now updated every frame in reposition_effects
		new_marker = true;
		do {														// determine if we may need a new marker
			if( !marker || mark_type === &#39;&#39; ) break;				//	- launching or leaving witchspace
			if( curr_target === null ) break;						//	- had no target
			if( crossing_boundary( map, map_ent_dist, mark_type,	//	- ent has crossed scannerRange
						radius, &#39;_manage_marker, via &#39; + caller ) )	//		will switch marker type
				break;
			new_marker = false;										// marker checks out ok, we can just move it
		} while( false );
		let ent_dist = map_ent_dist + hullOffset( ent );			// reverse adj from _detect_distanceTo, so it&#39;s .distanceTo
																	//	 collisionRadius &lt;&lt; scannerRange
/*
if( debug ) {
	log(ws.name, &#39;  for new_marker: &#39; + new_marker + &#39;, mark_type: &#39; + mark_type
		+ &#39;, ent_dist: &#39; + ent_dist.toFixed(2)
		+ &#39; (map_ent_dist: &#39; + map_ent_dist.toFixed(2) + &#39; + hullOffset( ent ): &#39; + hullOffset( ent ).toFixed(2)
		+ &#39; vs distanceTo: &#39; + ps.position.distanceTo( ent ).toFixed(2)
		+ &#39;\n    marker: &#39; + marker + &#39;\n    curr_target: &#39; + curr_target  );
}
 */
		mark_type = ent_dist &lt; scannerRange &amp;&amp; !radius				// sun/planet/moon must remain far targets as core does not
					? &#39;-shadow&#39; : &#39;marker&#39;;							//	 allow ship to target them; esp a prob w/ small moons with
																	//	 collisionRadius &lt;&lt; scannerRange
		// do the actual updating of target &amp; marker
		calc_marker_posn( map, map_ent_dist, radius );
		if( markerInsideOrb( map ) ) {
			_set_curr_Sighting( null, &#39;_manage_marker, markerInsideOrb, via &#39; + caller );
			return;
		}
/*
if( debug ) {
	log(ws.name, &#39;  new_marker: &#39; + new_marker + &#39;, mark_type: &#39; + mark_type
		+ &#39;, identKeyPress: &#39; + identKeyPress + &#39; (ws$: &#39; + ws.$IdentKeyPress
		+&#39;), \n  curr_target&#39; + (curr_target ? &#39; (&#39; + curr_target.entityPersonality + &#39;): &#39; + curr_target.displayName : &#39;: &#39; + curr_target) );
}
 */
		if( !new_marker ) {											// just move the existing telescopemarker, so marker &amp; marker_type stay the same
			marker.position = marker_posn;
			marker.velocity = ps_velocity;							//keep target over Torus speeds in FarPlanets OXP
			if( mark_type === &#39;-shadow&#39; ) {
				if( curr_target !== ent ) {							// switch from one near target to another near one
					switch_PS_target( ent, map, showName, &#39;1_manage_marker, !new_marker, via &#39; + caller );
				} else if( identKeyPress === IDENT_LOCKED &amp;&amp; !ps.target ) {
					switch_PS_target( ent, map, showName, &#39;2_manage_marker, !ps.target but known marker, via &#39; + caller );
				}
			} else if( mark_type === &#39;marker&#39; ) {					// have switched from a far target to a different far one, where
				if( curr_S.map !== map ) {							//	 _switch_PS_target is not called for far targets (it&#39;s always the target marker)
					if( !curr_S.ent.radius ) {						// not an orb
						marker.removeCollisionException( curr_S.ent ); // remove previous target
					}
					if( !radius ) {									// not an orb
						marker.addCollisionException( ent );		// avoid impacting target
					}
					marker.displayName = set_displayName( map );
					_set_curr_Sighting( map, &#39;_manage_marker, !new_marker, via &#39; + caller );
					if( showName ) {
						init_headingView();
						showTargetName( map );
					}
					_showVShip( ent.dataKey );
				}
				if( !ps.target ) {	// added to support ident sequence (restore after target lost)
				// } else if( identKeyPress === IDENT_LOCKED &amp;&amp; !ps.target ) {	// added to support ident sequence (restore after target lost)
					switch_PS_target( marker, map, showName, &#39;3_manage_marker, !ps.target but known marker, via &#39; + caller );
				}
			}
// since re-using marker (&amp; not chg&#39;g ps.target), get no new &#39;ID locked&#39; verbal msg
//	- no msg if browsing (!weaponsOnline) otherwise must hit ident key to chg far target, so do get verbal msg
		} else {													// create a new one (it gets remove()&#39;d there)
			if( marker ) removeMarker();							// remove any existing marker/shadow
			curr_S.marker_type = mark_type;
			if( mark_type === &#39;marker&#39; ) {							// addShips(role, count, position, radius);
				marker = addShips( &#39;telescopemarker&#39;, 1, marker_posn, 1 )[ 0 ];
				marker.addCollisionException( ps );					// avoid limiting Torus speed (Milo &amp; dybal)
				if( !radius ) {										// not an orb
					marker.addCollisionException( ent );			// avoid impacting target
				}
			} else {												//replace the markership with visuall effect shadow lollipop
				marker = addVisualEffect( &#39;telescope-shadow&#39;, marker_posn );
			}
			if( marker ) {
				marker.velocity = ps_velocity;						//keep target over Torus speeds in FarPlanets OXP
				curr_S.marker = marker;
				if( mark_type === &#39;marker&#39; ) {
					switch_PS_target( marker, map, showName, &#39;4_manage_marker, new marker, via &#39; + caller );
				} else if( mark_type === &#39;-shadow&#39; ) {
					switch_PS_target( ent, map, showName, &#39;5_manage_marker, new -shadow, via &#39; + caller );
				}
			} else {
				log(ws.name, &#39;_manage_marker, unable to create marker; shutting down telescope operations!&#39; );
				_shutdown_Sightings();
			}
		}
	}

/* when a user manually targets a wormhole, the wormhole scanner, if present, begins &amp; after about 7 sec.s reports
   its findings. when user targets it, we add property $TelescopeScanStart to emulate the scanner and update its displayName
*/

	function _handle_wormhole( ent ) {								// mimic behavior of core game wormhole scanner
		if( !ent || !ent.isValid || ent.collisionRadius === 0 ) {	// expired wormholes eventually (!) become invalid
			_delete_Sighting( ent, &#39;_handle_wormhole&#39; );
			return;
		}
		if( ps.equipmentStatus( &#39;EQ_WORMHOLE_SCANNER&#39; ) !== &#39;EQUIPMENT_OK&#39; )
			return;
		if( !curr_target || curr_target !== ent )					// wait for it to be targetted before starting countdown
			return;
		if( ent.$TelescopeScanStart === undefined )	{				// save time acquired, to display destination after wormhole scanner (using 7 sec)
			ent.$TelescopeScanStart = clock.seconds;
			if( !ent.displayName ) {								// if not named by someone else
				ent.displayName = ent.$TelescopeName = &#39;Wormhole&#39;;	// name is &#39;wormhole&#39; when Sighting created
			}
		} else if( clock.seconds - ent.$TelescopeScanStart &gt;= 7 ) {	// once 7 seconds have expired, we&#39;ll update the displayName w/ the destination
			if( ent.$TelescopeName )								// if we named it
				ent.displayName = &#39;Wormhole to &#39; + System.systemNameForID( ent.destination );
		}
	}

// : &#39; +  + &#39;
	function switch_PS_target( ent, map, showName, caller ) {
// if( debug ) log(ws.name, &#39;switch_PS_target, ent: &#39; + (ent ? ent.displayName : ent) + &#39;, map: &#39; + (map &amp;&amp; map.ent ? map.ent.displayName : map)
// 				+ &#39;, showName: &#39; + showName + &#39;, caller: &#39; + caller);
		if( ent === null ) {										// explicitly null target
			ws.$TelescopeTargetSet = true;							// prevent shipTargetAcquired and shipTargetLost treating
			ps.target = null;										//   this assignment as a new target
			ws.$TelescopeTargetSet = false;
			_set_curr_Sighting( null, &#39;_switch_PS_target, ent is null, via &#39; + caller );
			return;
		}

		if( ps.target === ent ) {									// prevent double ident system verbal message on near targets
			_set_curr_Sighting( map, &#39;_switch_PS_target #3-aborted, via &#39; + caller );
			_showVShip( map.ent.dataKey );
			return;
		}
		if( curr_S.marker_type === &#39;marker&#39; ) {						//remove km from ident message
			ent.displayName = set_displayName( map );				// set displayName of telescopemarker
		}
		ws.$TelescopeTargetSet = true;								// prevent shipTargetAcquired and shipTargetLost treating
		ps.target = ent;											//   this assignment as a new target
		ws.$TelescopeTargetSet = false;
		if( ps.target !== ent ) {									// unlockable!
			let cloaked = is_cloaked( ent ),
				bad_status = _has_bad_status( ent );
log(ws.name, &#39;switch_PS_target, target lock FAILED, &#39; + caller + &#39;, _has_bad_status: &#39; + bad_status
				+ &#39;, is_cloaked: &#39; + cloaked + &#39;, ps.target = &#39; + ps.target
				+ &#39;\n    ship ent_dist = &#39; + map.ent_dist + &#39;, .distanceTo( ent ): &#39; + ps.position.distanceTo( ent ) +&#39;: &#39; + ent );
			if( !bad_status &amp;&amp; !cloaked ) {// can take time to register
log(ws.name, &#39;  * UNABLE to lock * &#39; +  cd._showProps( map, &#39;map&#39;, 1,1,1 ) );
			}
		} else {
			_set_curr_Sighting( map, &#39;_switch_PS_target #4, via &#39; + caller );// make sure in sync w/ ps.target, in case fn called from other than _manage_marker
			if( showName ) {
				init_headingView();
				showTargetName( map );
			}
			_showVShip( map.ent.dataKey );
		}
	}

	function crossing_boundary( map, dist, mark_type, targetRadius/*, caller*/ ) {// crossing the scannerRange threshold will generate a
																	// shipTargetLost event, we need to change marker type
		if( !map ) return false;
		let ent = map.ent;
		if( !ent || !ent.isValid ) return false;
		var marker_type = mark_type || curr_S.marker_type;
		let isanOrb = targetRadius === null ? ent.radius : targetRadius;// radius can be false
		if( isanOrb ) return marker_type === &#39;-shadow&#39;;				// sun/planet/moon can never use shadow marker
		var targetDist = dist;
		if( dist === null ) {										// null dist forces distance update calc
			targetDist = map.ent_dist = _detect_distanceTo( ent );	// distance to hull/surface
		}
		targetDist += hullOffset( ent );							// reverse adj from _detect_distanceTo, so it&#39;s .distanceTo
		if( (marker_type === &#39;marker&#39; &amp;&amp; targetDist &lt;= scannerRange)		// just came into scannerRange
			|| (marker_type === &#39;-shadow&#39; &amp;&amp; targetDist &gt; scannerRange) ) { // just left scannerRange
			return true;
		}
		return false;
	}

	function mostCentered( mode, chg_by_ident ) {
		try {
			_mostCentered( mode, chg_by_ident );
		} catch( err ) {
			log( ws.name, ws._reportError( err, &#39;mostCentered&#39;, [mode, chg_by_ident] ) );
			if( debug ) throw err;
		}
	}

// : &#39; +  + &#39;
	function _mostCentered( mode, chg_by_ident ) {					// chg_by_ident is false (explicit in 2 calls), may be true in call from shipTargetLost
																	//	 where target lock lost but ship not destroyed, then ident key press is assumed
																	// called from _auto_updates only when not Steering and IdentKeyPress is IDENT_READY
		if( have_shutdown )
			return;
		var orig = curr_S.map,
			map = orig;
		reset_common_vars();										// ensure no data carries over to new ent
		using_common_vars = false; 									// not using glocals as code path complex &amp; not in fcb
		// when called w/ null for distance, crossing_boundary will update map.ent_dist
		let crossed = crossing_boundary( map, null, null, null, &#39;_mostCentered&#39; );
		if( map &amp;&amp; crossed ) {										// keep same target
			_manage_marker( map, false, &#39;_mostCentered (scannerRange)&#39; );
			return;
		}
		var ident_was_pressed = mode === &#39;ident&#39; &amp;&amp; chg_by_ident;	// called from shipTargetLost and target still alive
/*
if( debug &amp;&amp; mode === &#39;ident&#39; ) {
	log(&#39;\n_mostCentered, ident_was_pressed: &#39; + ident_was_pressed
		+ &#39; ==&gt; mode (&#39; + mode + &#39;) === ident: &#39; + (mode === &#39;ident&#39;)
		+ &#39; &amp;&amp; chg_by_ident: &#39; + (chg_by_ident || false) );
	log(&#39;\t\t  identKeyPress: &#39; + identKeyPress + &#39;, orig&#39;
		+ (orig &amp;&amp; orig.ent ? &#39; (&#39; + orig.ent.entityPersonality + &#39;): &#39; + orig.ent.displayName : &#39;: &#39; + orig) );
}
 */

		find_most_central( mode );									// sets found_map to a Sighting or null if it fails
		if( !ident_was_pressed || !map ) {
			if( !found_map ) {
// if( debug &amp;&amp; mode === &#39;ident&#39; ) log(&#39;  !found_map, bailing&#39;);
				return;
			}
			map = found_map;
		}
		if( !map ) {												// may have jumped/died
			_set_curr_Sighting( null, &#39;_mostCentered (!map)&#39; );		// sets identKeyPress to IDENT_READY
// if( debug &amp;&amp; mode === &#39;ident&#39; ) log(&#39;  !map, reset curr_S, bailing&#39;);
			return;
		}
		isWormhole = map.ent.isWormhole;
		if( orig !== map ) {										// changing to a new target
			ws.$IdentKeyPress = identKeyPress = IDENT_READY;		// reset lock
			if( !isWormhole ) {
				_manage_marker( map, false, &#39;_mostCentered (new target)&#39; );
// if( debug &amp;&amp; mode === &#39;ident&#39; ) log(&#39;\n_mostCentered, back from _manage_marker&#39;);
			}
/*
if( debug &amp;&amp; mode === &#39;ident&#39; ) {
	log(&#39;_mostCentered, orig !== map, ident found new target, identKeyPress := IDENT_READY&#39;);
	log(&#39;               bailing, new map&#39;
		+ (map &amp;&amp; map.ent ? &#39; (&#39; + map.ent.entityPersonality + &#39;): &#39; + map.ent.displayName : &#39;: &#39; + map) );
}
 */
			return;
		}
		if( !ident_was_pressed ) {									// the rest of function is for ident only
			return;
		}

		if( identKeyPress !== IDENT_READY &amp;&amp; found_map != orig ) {	// new most centered ship
/*
if( debug &amp;&amp; mode === &#39;ident&#39; ) {
	log(&#39;_mostCentered, identKeyPress := IDENT_READY because found_map: &#39;
		+ (found_map &amp;&amp; found_map.ent ? &#39; (&#39; + found_map.ent.entityPersonality + &#39;): &#39; + found_map.ent.displayName : &#39;: &#39; + found_map)
		+ &#39; is != orig: &#39;
		+ (orig &amp;&amp; orig.ent ? &#39; (&#39; + orig.ent.entityPersonality + &#39;): &#39; + orig.ent.displayName : &#39;: &#39; + orig) );
}
 */
			ws.$IdentKeyPress = identKeyPress = IDENT_READY;
			map = found_map;
		}


		if( identKeyPress === IDENT_READY ) {
			if( !isWormhole &amp;&amp; orig &amp;&amp; orig === found_map ) {		// wormhole need extra ident from player
			// if( !isWormhole || (orig &amp;&amp; orig !== map) ) {			// wormhole need extra ident from player
				ws.$IdentKeyPress = identKeyPress = IDENT_LOCKED;	// really lock the target
/*
if( debug &amp;&amp; mode === &#39;ident&#39; ) {
	log(&#39;_mostCentered, lock the target, identKeyPress := IDENT_LOCKED, curr_target: &#39;
		+ (curr_target ? &#39; (&#39; + curr_target.entityPersonality + &#39;): &#39; + curr_target.displayName : curr_target));
}
 */
				if( IdentMessages )
					consoleMessage( &#39;Telescope locked: &#39; + curr_S.name, ConsoleMsgDurn );
			}
			_manage_marker( map, false, &#39;_mostCentered (IdentKeyPress = &#39; + (identKeyPress === 1 ? &#39;IDENT_LOCKED&#39; : &#39;IDENT_READY&#39;) + &#39;)&#39; );
// if( debug &amp;&amp; mode === &#39;ident&#39; ) log(&#39;\n_mostCentered, back from _manage_marker2&#39;);
		} else {
			if( identKeyPress === IDENT_LOCKED ) {
				ws.$IdentKeyPress = identKeyPress = IDENT_STEERING;	//next time will do unlock
				_manage_marker( map, false, &#39;_mostCentered2 (IdentKeyPress = IDENT_STEERING)&#39; );
// if( debug &amp;&amp; mode === &#39;ident&#39; ) log(&#39;\n_mostCentered, back from _manage_marker3&#39;);
				if( Steering &gt; 0 ) {
					if( ps_speed &lt; ps_maxSpeed * 1.1 ) {			//prevent unwanted steer when lost marker at high speeds
						if( IdentMessages )
							consoleMessage( &#39;Telescope lock, auto-steering&#39;, ConsoleMsgDurn );
						start_Steering();							//turn to the target
/*
if( debug &amp;&amp; mode === &#39;ident&#39; ) {
	log(&#39;_mostCentered, steering, next time will do unlock, identKeyPress := IDENT_STEERING&#39;);
}
 */
						return;										// exit to allow steering to complete
					}
/*
} else {
if( debug &amp;&amp; mode === &#39;ident&#39; ) {
	log(&#39;_mostCentered, not steering, fall thru to unlock, identKeyPress := IDENT_STEERING&#39;);
}
 */
				}													// steering is turned off, so proceed to unlock now
			}
			// since not steering, proceed to unlock stage
			if( identKeyPress === IDENT_STEERING )  {				// manual unlock, as steering is off or failed to reach target
				ws.$IdentKeyPress = identKeyPress = IDENT_UNLOCK;	// need a delay, else relock immediately; see _auto_updates()
/*
if( debug &amp;&amp; mode === &#39;ident&#39; ) {
	log(&#39;_mostCentered, &#39; + (Steering &gt; 0 ? &#39;finished&#39; : &#39;not&#39;)  + &#39; steering, proceed to unlock stage, identKeyPress := IDENT_UNLOCK&#39;);
}
 */
				if( IdentMessages )
					consoleMessage( &#39;Telescope lock released&#39;, ConsoleMsgDurn );
			}
		}
	}

	var entHeading = [];											// working vector
	var vectorToOrb = [];											// working vector
	var vectorToPerp = [];											// working vector
	
	function markerInsideOrb( map ) {								// PlanetFall support: cannot mark distant target if marker
																	//   will be inside planet!
		// at rest, marker: scannerRange - 600, placed just in front of band of far lightballs
		var neededDist = scannerRange - 600;						// for head-on approach
		entHeading.length = 0;
		for( let mi = 0; mi &lt; maplen; mi++ ) {
			let orb = mapping[ mi ];
			if( orb.rank !== &#39;orb&#39; ) continue;
			let orbDist = orb.ent_dist;								 // distance to surface
			if( orbDist &gt; neededDist ) continue;
			// the rest only executes if an orb is within scannerRange
			if( entHeading.length === 0 ) {							// delay as may not be needed
				subtract_vectors( map.last_posn, ps_position, entHeading );
				unit_vector( entHeading, entHeading );
			}
			let orbRadius = orb.ent.radius;
			subtract_vectors( orb.last_posn, ps_position, vectorToOrb );
			let distToOrb = vector_magnitude( vectorToOrb ) - orbRadius; // distance to surface
			unit_vector( vectorToOrb, vector );
			let angleCos = dot_product( entHeading, vector );		// only if both are unit vectors is dot_product the cosine
			if( angleCos &lt; 0 ) continue;							// orb is &gt; 90 from heading
			// projecting orb &#39;vector&#39; onto entHeading is a quick way to catch most cases (unless quite near an orb)
			if( angleCos * distToOrb &gt; neededDist ) 
				continue;
			// now check if entHeading intersects orb surface
			let distToPerp = dot_product( entHeading, vectorToOrb );// projecting entire vector to center onto unit vector gives
			scale_vector( entHeading, distToPerp, vectorToPerp );	//   portion of entHeading up to perpendicular from orb&#39;s center
			// find point along vector to target that meets the perpendicular
			add_vectors( ps_position, vectorToPerp, vector );
			subtract_vectors( orb.ent.position, vector, vector );
			if( vector_magnitude( vector ) &lt; orbRadius ) {			// perpendicular clears the limb
				return true;
			}
		}
		return false;
	}
// : &#39; +  + &#39;

	function closest_to() {
		var len = find_list.length;
		var min_a = find_radius;
		var best = null;											// ie. not init&#39;d
		var best_d = MaxRange;
		var angle, diff, distance, map, ent, idx;
		var was_using_common_vars = using_common_vars;
		using_common_vars = false;
		find_list.sort( map_sort_heading );
		for( idx = 0; idx &lt; len; idx++ ) {							//search target near the center
			map = find_list[ idx ];
			ent = map.ent;
			if( !ent || !ent.isValid ) continue;
			if( weaponsOnline
					&amp;&amp; !ent.isVisible								// cannot target !isVisible w/ grav. scanner off-line (see reposition_effects)
					&amp;&amp; ent.scanClass !== &#39;CLASS_CARGO&#39;				// are deleted when go beyond RFID range
					&amp;&amp; !is_beacon( ent ) )							// radio always detectable
				continue;
			let ent_rank = ent.rank;
			if( ent_rank === &#39;ukn&#39; ) continue;						// is lost (but recoverable) target
			if( find_rank &gt;= 0 &amp;&amp; find_rank !== ent_rank )			// wrong rank in limited rank search
				continue;
			if( is_cloaked( ent ) ) continue;
			if( weaponsOnline &amp;&amp; alertCondition &gt; YELLOW_ALERT
					&amp;&amp; ent.isDerelict )								// ignore when fighting
				continue;
			if( ent.isWormhole ) {
				if( find_mode !== &#39;ident&#39; ) continue;				// wormholes must be targeted by player (&#39;r&#39;)
				if( weaponsOnline &amp;&amp; alertCondition &gt; YELLOW_ALERT )// ignore when fighting
					continue;
				if( ent.collisionRadius === 0 ) continue;			// has closed
				if( ent.$TelescopeScanStart === undefined )
					continue;										// hasn&#39;t been manually (&#39;ident&#39; mode) targetted yet
			}
			if( redAlertOptimize() ) continue;						// headingTo is NOT being updated (see _reposition_effects)
			if( markerInsideOrb( map ) ) continue;
			angle = map.headingTo;
			if( find_mode !== &#39;ident&#39; &amp;&amp; angle &gt; find_radius )		// halt search as remainings ents are outside specified cone
				break;
			diff = abs( angle - min_a );							// angle always &gt;= 0, so abs(abs(angle) - abs(min_a)) not necessary
			if( best &amp;&amp; diff &gt; 0.5 )  // HALF_a_DEGREE				// found at least one and are beyond pt for distance chk
				break;												// now sorted by headingTo, so only need check 1st few ents
			if( angle &gt; min_a )
				break;												// now sorted by headingTo, so only need check 1st few ents
			// if( angle &gt; min_a ) continue;
			distance = map.ent_dist;
			if( distance &lt;= scannerRange &amp;&amp; is_jamming( ent ) ) 	// cannot target inside scannerRange
				continue;
			if( !best ) {											// 1st target found
				best_d = distance;
				min_a = angle;
				best = map;
				continue;
			}
			if( diff &lt; 0.5 ) {// HALF_a_DEGREE						// for ships within a half degree, pick the closer one
				if( distance &gt; best_d ) continue;
			}
			best_d = distance;
			min_a = angle;
			best = map;
		}
		using_common_vars = was_using_common_vars;
// if(find_mode === &#39;ident&#39;)
	// log(&#39;closest_to, returning best: &#39; + (best ? best.ent : best) + &#39;\n&#39;);
		return best;
	}

	var find_mode, find_list, find_radius, find_rank, found_map;

	function find_most_central( mode ) {
		if( !mappingReady || maplen === 0 ) return;					// wait for mapping to be created OR it&#39;s empty
		if( !viewIsStandard )
			return;
		find_mode = mode;
		find_list = mapping;
		found_map = null;
		if( ILS &amp;&amp; ILS.$L === ps ) { 								// suspend all autoscans while in ILS
			return;													// found_map being set to null should signal upstream
		}
		find_rank = -1;
		find_radius = IdentLock;
		var result = -1;
		// just in case you target something before it gets entered into the mapping
		if( curr_target &amp;&amp; _Sighting_index( curr_target, &#39;_find_most_central&#39; ) === -1 ) {
			if( !_has_bad_status( curr_target ) 					// need check for when scooping target!
					&amp;&amp; !is_cloaked( curr_target )) {
				let index = _add_Sighting( curr_target, false, false, &#39;_find_most_central&#39; );
				if( index &gt;= 0 ) {
					found_map = mapping[ index ];
					return;
				}
			}
		}
		if( alertCondition &gt; YELLOW_ALERT &amp;&amp; weaponsOnline ) {		//in red alert find most centered hostile if not supressed with off-line weapons
																	// in ident, &quot;In Red Alert it will not narrow the locking to the attackers; it can lock any target.&quot;
			find_radius = 180;										//in Red Alert lock from the whole sphere who target you
			find_list = select_Sightings( 0, 0,						// 0 =&gt; all, 0 =&gt; any rank
										  targeting_player );		// first target those targeting you
			if( !find_list || find_list.length === 0 ) {			// no attackers identified
				find_list = mapping;
				find_rank = &#39;bad&#39;;									// limit to bad guys; if none in list yet, search it all
			}														//do not target asteroids before ships in red alert
			result = closest_to();									// try targeting bad guys 1st
			if( result &amp;&amp; (mode !== &#39;ident&#39; 						// ident mode switches from existing target
							|| result !== curr_S.map) ) {
				found_map = result;									//found, target it
				return;												//priority to targets in crosshairs for fighting/asteroid hunting
			}
			find_rank = -1;											// open up search to all targets, as none are targeting &amp; none ranked &#39;bad&#39;
			find_list = mapping;
			find_radius = AutoLock &gt; 0 ? AutoLock : IdentLock;
		}															//if no bad guy in crosshairs then do normal ident to a ship in telescope list
		if( mode === &quot;ident&quot; ) {									//button &quot;r&quot; pressed or target lost
			find_radius = IdentLock;
		} else	if( mode === &quot;auto&quot; ) {								//lock in the crosshairs only; not called if AutoLock &lt;= 0
			find_radius = AutoLock;
		} else	if( mode === &quot;grav&quot; ) {								//panorama targeting or lock in the crosshairs
			find_radius = GravLock;
		}
		result = closest_to();
		if( result ) {												//found, target it
			found_map = result;
			return;
		}
		return;
	}

///////////////////////////////////////////////////////////////////////////////////////////////////
// naming functions ///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

	sunName.sun_names = {};		//cache of names
	function sunName( ent ) {										// allow for multiple suns
		if( !system || !ent || !ent.isValid )
			return null;
		var name, key = ent.position.toString();
		if( sunName.sun_names.hasOwnProperty( key ) )				// use cached
			return sunName.sun_names[ key ];

		do {
			name = system.info.sun_name;
			if( name &amp;&amp; name.length &gt; 0 )
				break;
			name = system_sun.displayName;
			if( name &amp;&amp; name.length &gt; 0 )
				break;
			name = system.info.name;
			if( name &amp;&amp; name.length &gt; 0 ) {
				if( name === system_name )
					name += &#39; (Star)&#39;;
				break;
			}
			name = system_name + &#39; (Star)&#39;;
		} while( false );
		sunName.sun_names[ key ] = name;							// add to cache
		return name;
	}

	function entityIsNamed( ent ) {									// return name if someone else has named it
		var name;
		// copied property priority from GalacticAlmanac
		name = ent.displayName;
		if( name &amp;&amp; name.length &gt; 0 ) {
			return name;
		}
		name = ent.beaconLabel;
		if( name &amp;&amp; name.length &gt; 0 ) {
			return name;
		}
		name = ent.beacon;
		if( name &amp;&amp; name.length &gt; 0 ) {
			return name;
		}
		name = ent.beaconCode;
		if( name &amp;&amp; name.length &gt; 0 ) {
			return name;
		}
	}

	function planetIsNamed( ent ) {									// return planet name if named by another oxp_name
		var name, ent_name = entityIsNamed( ent );
		if( ent_name &amp;&amp; ent_name.length &gt; 0 ) {
			return( ent_name );
		}
		// farplanets oxz
		if( PlanetNames ) {		//	worldScripts.planetnames.$PlanetNames_GetPlanetName( cs.ent )
			name = PlanetNames.$PlanetNames_GetPlanetName( ent );
			if( name &amp;&amp; name.length &gt; 0 ) {
				return name;
			}
		}
		if( PlanetaryCompass ) {	//	worldScripts[ &#39;planetaryCompass_worldScript.js&#39; ]
			// set beaconCode &amp; beaconLabel (latter has type in parentheses)
			// - for mainPlanet, instead sets name &amp; displayName (latter has type in parentheses)
			//   which is caught by entityIsNamed
			let pce = entitiesWithScanClass( &quot;CLASS_VISUAL_EFFECT&quot;, ent, 10 );
			for( let idx = 0, len = pce.length; idx &lt; len; idx++ ) {
				let first = pce[ idx ];
				if( !first || !first.isValid )
					continue;
				if( first.dataKey.indexOf( &#39;planetaryCompass&#39; ) &lt; 0 )
					continue;
				if( first.beaconLabel ) {
					name = first.beaconLabel;					// others
					break;
				}
			}
			free_array( pce );
			return name;
		}
	}

	orbName.planet_names = [];	//cache of names
	function orbName( ent ) {
		if( !ent ) return null;
		if( isSun &lt; 0 ) isSun = ent.isSun;
		if( isPlanet &lt; 0 ) isPlanet = ent.isPlanet;
		if( !isPlanet &amp;&amp; !isSun ) return null;
		if( !system_planets || system_planets.length === 0 ) {
log(ws.name, &#39;orbName, SYSTEM_PLANETS INVALID: &#39; + system_planets );
			return null;
		}

		var name = &#39;&#39;;
		if( isSun ) {
			return sunName( ent );
		} else {
			var idx = index_in_list( ent, system_planets );
			if( idx &lt; 0 )
				return null;
			name = orbName.planet_names[ idx ];
			if( !name || name.length === 0 ) {
				name = planetNameString( ent );
				orbName.planet_names[ idx ] = name;
			}
		}
		return name;
	}

	planetNameString.orbList = null; // inventory of system&#39;s planets &amp; moons generated when none exist
	planetNameString.ROMAN = [ &#39;I&#39;, &#39;II&#39;, &#39;III&#39;, &#39;IV&#39;, &#39;V&#39;, &#39;VI&#39;, &#39;VII&#39;, &#39;VIII&#39;, &#39;IX&#39;, &#39;X&#39;,
							   &#39;XI&#39;, &#39;XII&#39;, &#39;XIII&#39;, &#39;XIV&#39;, &#39;XV&#39;, &#39;XVI&#39;, &#39;XVII&#39;, &#39;XVIII&#39;, &#39;XIX&#39;, &#39;XX&#39; ];
	planetNameString.GREEK = [ &#39;Alpha&#39;, &#39;Beta&#39;, &#39;Gamma&#39;, &#39;Delta&#39;, &#39;Epsilon&#39;, &#39;Zeta&#39;, &#39;Eta&#39;,
							   &#39;Theta&#39;, &#39;Iota&#39;, &#39;Kappa&#39;, &#39;Lambda&#39;, &#39;Mu&#39;, &#39;Nu&#39;, &#39;Xi&#39;, &#39;Omicron&#39;, &#39;Pi&#39;,
							   &#39;Rho&#39;, &#39;Sigma&#39;, &#39;Tau&#39;, &#39;Upsilon&#39;, &#39;Phi&#39;, &#39;Chi&#39;, &#39;Psi&#39;, &#39;Omega&#39; ];
	function planetNameString( ent ) {
		if( !system || !ent || !ent.isValid )
			return &#39;nada&#39;;
		if( !isPlanet )
			return( &#39;Non-Planet&#39; );

		var name = planetIsNamed( ent );
		if( name &amp;&amp; name.length &gt; 0 ) {							// someone else has named it
			return name;
		}
		name = ent.name;
		if( name !== system_name ) {							// someone else has named it
			return name;
		}
		// create dictionary of default names, done once/system, taking 2.37 ms @ 32 fps
		let orbList = planetNameString.orbList;
		if( orbList === null ) {								// generate planet names
			planetNameString.orbList = orbList = {};
			let orbs = entitiesWithScanClass( &quot;CLASS_NO_DRAW&quot;, system_sun );
				// all planets, moons ordered by distance from sun
			let pnum = 0, pstr, mnum = 0, mstr,
				ROMAN = planetNameString.ROMAN, romans = ROMAN.length,
				GREEK = planetNameString.GREEK, greeks = GREEK.length;
			for( let pl = 0, plen = orbs.length; pl &lt; plen; pl++ ) {
				let orb = orbs[ pl ];
				if( !orb.hasOwnProperty( &#39;radius&#39; ) ) continue;
				if( orb.hasAtmosphere ) {					// it&#39;s a planet
					pstr = pnum &lt; romans ? ROMAN[ pnum ] : pnum;
					name = system_name + (orb.isMainPlanet ? &#39; Prime (Planet)&#39;
														   : &#39; &#39; + pstr + &#39; (Planet)&#39;);
					orbList[ orb.position.toString() ] = name;
					pnum++;
					let moons = entitiesWithScanClass( &quot;CLASS_NO_DRAW&quot;, orb, orb.collisionRadius * 10 );
						// all moons ordered by distance from orb
					for( let mn = 0, mlen = moons.length; mn &lt; mlen; mn++ ) {
						let moon = moons[ mn ];
						if( moon.hasAtmosphere ) break;		// it&#39;s a planet, we&#39;re done (and have double counted!)
						mstr = mnum &lt; greeks ? GREEK[ mnum ] : mnum;
						name = mnum &lt; greeks ? mstr + &#39; Moon&#39; : &#39;Moon &#39; + mstr;
						name += &#39; (&#39; + pstr + &#39;)&#39;;
						orbList[ moon.position.toString() ] = name;
						mnum++;
					}
					free_array( moons );
				}
			}
			free_array( orbs );
		}
		name = orbList[ ent.position.toString() ];
		return name;
	}

	function entityName( map ) {
		var ent = map.ent, name = &#39;&#39;, ent_script = -1,
			ent_name = ent.name;
		do {
			if( map.rank === &#39;ukn&#39; ) {
				name = lost_target_name;
				break;
			}
			if( ent_name &amp;&amp; ( ent_name === &#39;Railgun Projectile&#39;			//do not show launched bullets
							|| ent_name === &#39;Debris&#39;
							|| ent_name.indexOf( &#39;customshields&#39; ) &gt;= 0 ) ) {
				return null;											//nor customshields parts
			}
			if( ent_name &amp;&amp; ent_name.indexOf(&#39;Exhibition]&#39; ) &gt;= 0 ) {
				return null;											//do not show ships in exhibition of Gallery OXP
			}
			ent_script = ent.script;
			if( ent_script &amp;&amp; ent_script.$Detectors_Origname ) {		// shipversion oxp
				name = ent_script.$Detectors_Origname;
				break;
			}
			name = entityIsNamed( ent );
			if( name &amp;&amp; name.length &gt; 0 ) {
				break;
			}
			if( ent_name &amp;&amp; ent_name.length &gt; 0 ) {
				name = ent_name;
				let unique = ent.shipUniqueName;
				if( unique &amp;&amp; unique.length &gt; 0 )
					name =+ &#39;: &#39; + unique;
				break;
			}
			name = unknown_ship_name;
		} while( false );
		return name;
	}

	// had to remove cache for ship names for other oxp name changes
	// eg. cargoscanner sets .shipUniqueName, someone else applies it to .displayName
	//     and thus &quot;Splinter&quot; -&gt; &quot;Splinter: Minerals&quot;
	function clearNameCaches() {									// reset name caches for each system
		var cache = sunName.sun_names;
		for( let prop in cache ) {
			if( cache.hasOwnProperty( prop ) ) {
				delete cache[ prop ];
			}
		}
		orbName.planet_names.length = 0;
		planetNameString.orbList = null;							// deliberate object -&gt; garbage heap (once/system)
	}

	// const isoPrefix = [&#39;&#39;, &#39;K&#39;, &#39;M&#39;, &#39;G&#39;, &#39;T&#39;, &#39;P&#39;];
	function distWithUnits( distance ) {
/* 	telescope 1.15
		var range = floor( ent_dist / 1000 );
		if( range &lt; 0 ) range = 0;
		if( range &gt;= 1e6 ) range = floor( range / 1e6 ) + &#39;M&#39;;
		// ...
		let km = distance / 1000;
		if( km &lt; 100 )
			name_with_dist = km.toFixed( 3 ) + &#39; km &#39; + displayName;
		else if( km &lt; 1e6 )
			name_with_dist = floor( km ) + &#39; km &#39; + displayName;
		else
			name_with_dist = floor( km / 1e6 ) + &#39; Mkm &#39; + displayName;
*/
/*
		var displayDist = distance / baseDistance;
		var milles = floor( log10( displayDist ) / 3 ); // # of 1000&#39;s
		if( milles &gt;= isoPrefix.length ) {
			return &#39;really far&#39;;
		}
		var prefix = 0;
		do {
			displayDist /= 1000;
			prefix++;
		} while( --milles &gt;= 0 );
		var units = isoPrefix[ prefix ] + distanceUnits;
		if( displayDist &gt;= 1000 ) {
			displayDist = displayDist.toFixed( 0 );
		} else if( displayDist &gt;= 100 ) {
			displayDist = displayDist.toFixed( 1 );
		} else if( displayDist &gt;= 10 ) {
			displayDist = displayDist.toFixed( 2 );
		} else {
			displayDist = displayDist.toFixed( 3 );
		}
// oxp&#39;s needing update:
//  Combat_MFD: has unit Mkm for 1000000 km, chg to Gm
//   - he does use Mm/s for speed
//  VimanaHUD: searches for &#39;km &#39; in telescopemarker&#39;s .displayName, ch to re /^(?:\d+[.]?\d*|[.]\d+)[kKMGTP]?m(.*)$/
//   - also fix for telescope v2 support; optimize distanceTo, repl filteredEntities w/ entitiesWithScanClass
 */

		// canon has Mkm as 1e9, not Gm; nothing defined for 1e6 (and Kkm is wierd)
		let units = [&#39;m &#39;, &#39;km &#39;, &#39;Kkm &#39;, &#39;Mkm &#39;, &#39;Gkm &#39;, &#39;Tkm &#39;, &#39;Pkm &#39;];
		let withUnits,
			fixed = floor( log10( distance ) / 3 ); // # of 1000&#39;s
		if( fixed &gt;= units.length ) {
			withUnits = &#39;really far&#39;;
		} else {
			let signif = (distance / pow(1000, fixed) );
			if( fixed === 0 ) {
				// withUnits =	signif.toFixed( 3 - floor(log10( distance )) );
				// VimanaHUD searches for &#39;km &#39; to remove distance from displayName
				withUnits =	(distance / 1000).toFixed( 3 );
				withUnits += &#39; &#39; + units[ 1 ];
			} else if( fixed === 2 ) {						// skip Kkm (can&#39;t use Mm due to VimanaHUD)
				withUnits =	floor(distance / 1000);//.toFixed( 0 );
				withUnits += &#39; &#39; + units[ 1 ];
			} else {
				withUnits =	signif.toPrecision( 4 );
				withUnits += &#39; &#39; + units[ fixed ];
			}
		}
		return withUnits;
	}

// : &#39; +  + &#39;
	function set_displayName( map ) {								// update curr_S.name and return new value (for marker.displayName)
		var that = set_displayName;
		var lastDisplayed = (that.lastDisplayed = that.lastDisplayed || null);

		// called by _update_target_marker, _manage_marker &amp; switch_PS_target ie. target only
		var displayName = curr_S.name,								//remove km from ident message
			ent = map.ent;
		if( lastDisplayed !== ent ) {								// avoid repeating name construction as we cannot cache
			that.lastDisplayed = ent;								//  because some oxp&#39;s alter displayName dynamically (eg. cargoscanner)
			displayName = null;
		}
		if( map.rank === &#39;ukn&#39; ) {
			displayName = lost_target_name;
		} else if( !displayName 									// save unaltered name for ident message
					|| displayName === lost_target_name ) {
			if( radius &lt; 0 ) radius = ent.radius;
			if( radius ) {											// only orbs have .radius
				displayName = orbName( ent );
			} else if( is_jamming( ent ) ) {						// sets isJamming, returns true if effective (ie. scanFilter_ok)
				displayName = unknown_ship_name;					// can see jamming ships but not identify (thanks Milo)
			} else {
				displayName = entityName( map );
			}
		}
		if( !displayName ) {
			// Error: Cannot set property displayName of instance of Ship to invalid value null
			displayName = &#39;&#39;;
		}
		curr_S.name = displayName;
		return displayName;
	}

	function showTargetName( map, combatMFDonly ) {
		if( !equip_ok ) return;
		if( _Sighting_index( map, &#39;showTargetName&#39; ) &lt; 0 ) return;
		reset_common_vars();										// required as done in groups of 3
		var msg = showShipReport( map );
		if( !msg || msg.length &lt;= 0 ) return;
		if( Combat_MFD &amp;&amp; index_in_list( &#39;combat_MFD&#39;, ps.multiFunctionDisplayList ) !== -1) {											//show in Combat MFD instead of console
			prevMFDTarget = map;									//store for Combat MFD
			Combat_MFD.$TelescopeLine = msg;
		} else if( !combatMFDonly ) {
			consoleMessage( msg, ConsoleMsgDurn );					//fallback to console
		}
		using_common_vars = false;
	}

	function showShipReport( map ) {								// format ship name/dist for format_line (MFD) &amp; showTargetName
		if( !map ) return;
		var ent = map.ent;
		var name = &#39;&#39;, cached = false,
			ent_script = -1,
			jamming = is_jamming( ent );							// sets isJamming, returns true if effective (ie. scanFilter_ok)

		copy_vector( map.last_posn, position ); 					// if &#39;ukn&#39;, can only report what was known
		while( name.length === 0 ) {
			if( radius &lt; 0 ) radius = ent.radius;
			if( ent.radius ) {
				name = orbName( ent );
				if( name === null ) {
log(ws.name, &#39;showShipReport, orbName FAILED for ent: &#39; + ent );
					return;
				}
				break;
			}
			if( jamming ) {											// can see jamming ships but not identify (thanks Milo)
				name = unknown_ship_name;
				break;
			}
			name = entityName( map );
			if( name === null ) {
log(ws.name, &#39;showShipReport, entityName FAILED for ent: &#39; + ent );
				return;
			}
			break;
		}
		var ent_dist = map.ent_dist;
		var range = distWithUnits( ent_dist ) + &#39; &#39;;
		var prefix = &#39;&#39;;
		if( !ent.isWormhole ) {
			if( ent.isDerelict ) {
				if( ent_script &lt; 0 ) ent_script = ent.script;
				if( Towbar &amp;&amp; ent_script) { 						//Towbar status
					if( ent_script.$TowbarUsableShip ) 		prefix = &#39;Usable &#39;;
					else if( ent_script.$TowbarMinedShip ) 	prefix = &#39;Mined &#39;;
					else if( ent_script.$TowbarEmptyShip ) 	prefix = &#39;Empty &#39;;
					else 									prefix = &#39;Derelict &#39;;
				} else {
					prefix = &#39;Derelict &#39;;
				}
			} else if( (FarStatus || ent_dist &lt; scannerRange) &amp;&amp; ent.target === ps ) {
				range = &#39;! &#39; + range; 								//hostile
			} else if( map &amp;&amp; map.rank === &#39;bad&#39; ) {
				range = &#39;* &#39; + range; 								//pirate
			}
		}
		_relative_direction( position, map );

// log(ws.name, &#39;showShipReport, &#39; + name+&#39;, d:&#39;+relative_dirn+&#39; p:&#39;+position[0].toFixed(2)+&#39;, &#39;
		// +position[1].toFixed(2)+&#39;, &#39;+position[2].toFixed(2)); //debug

		var colon = name.indexOf( &#39;: &#39; );
		if( !cached ) {												// it has a name
		// if( !cached &amp;&amp; (colon = name.indexOf( &#39;: &#39; )) &gt;= 0 ) {		// it has a name
			let staticLen = strFontLen( range + prefix + &#39; &#39; + relative_dirn ),
				openLen = 18 - staticLen,
				nameLen = strFontLen( name );
			if( nameLen &gt; openLen ) {								// replace &#39;Navigation Buoy&#39; w/ &#39;Nav. Buoy&#39;
				[ name, nameLen ] = subLongest( name, openLen,
						&#39;Navigation Buoy&#39;,  [&#39;Nav. Buoy&#39;, &#39;Buoy&#39;]);
			}
			if( nameLen &gt; openLen ) {								// replace &#39;Station Buoy&#39; w/ &#39;Stn. Buoy&#39;
				[ name, nameLen ] = subLongest( name, openLen,
						&#39;Station Buoy&#39;,  [&#39;Stn. Buoy&#39;, &#39;Buoy&#39;]);
			}
			if( nameLen &gt; openLen ) {								// replace &#39;Station&#39; w/ &#39;Stn&#39;
				[ name, nameLen ] = subLongest( name, openLen,
						&#39;Station&#39;, [&#39;Stn.&#39;]);
			}
			if( nameLen &gt; openLen ) {
				name = shortenShipName( name, colon, nameLen, openLen );
			}
		}
		return range + prefix + name + &#39; &#39; + relative_dirn;
	}

	function subLongest( string, maxLen, target, candidates ) {
		// pass candidates in descending length
		var startLen = strFontLen( string ),
			newStr = string,
			len = candidates.length;
		if( len === 0 || !maxLen | startLen &lt;= maxLen
				|| string.indexOf( target ) &lt; 0 ) {
			return [ string, startLen ];
		}
		for( let idx = 0; idx &lt; len; idx++ ) {
			newStr = string.replace( target, candidates[ idx ] );
			let fontLen = strFontLen( newStr );
			if( fontLen &lt;= maxLen )
				return [ newStr, fontLen ];
		}
		return [ string, startLen ];
	}

	function shortenShipName( name, colon, startLen, targetLen ) {
		var that = shortenShipName;
		var name_breaks = that.name_breaks;							// const. props defined at end of function
		var name_suffix = that.name_suffix;							//	 &quot;
		var name_shorten = (that.name_shorten = that.name_shorten || []);
		name_shorten.length = 0;									// prep to re-use array

		var idx, len, space, nameLen = startLen,
				diff, start, brk = -1;

		for( idx = 0, len = name.length; idx &lt; len; idx++ )
			name_shorten[ idx ] = name[ idx ];
		space = name_shorten.lastIndexOf( &#39; &#39;, colon );
		if( space &gt;= 0 ) {											// try replacing superfluous tag
			let ship_tags = that.ship_tags,
				tags = ship_tags.length;
			for( idx = 0; idx &lt; tags; idx++ ) {
				brk = findListInArray( ship_tags[ idx ], name_shorten, 0, colon );
				if( brk &gt;= 0 ) break;
			}
			if( brk &gt;= 0 ) {
				let shrink = colon - space;
				for( idx = colon, len = name_shorten.length; idx &lt; len; idx++ )
					name_shorten[ idx - shrink ] = name_shorten[ idx ];
				name_shorten.length -= shrink;
				nameLen = strFontLen( name_shorten )				// strFontLen assumes spaces between elements
						  - (len - shrink - 1) * SpaceLen;			//	 so we subtract # commas * SpaceLen
			}
		}
		if( nameLen &gt; targetLen ) {									// still too long, break on logical words
			diff = startLen - targetLen + colon * SpaceLen;			// &#39;colon * SpaceLen&#39; =&gt; start earlier for long ship types
			start = floor(colon + (name.length - colon) / (1 + diff / 2));
			brk = -1; idx = 0; len = name_breaks.length;
			for( ; idx &lt; len; idx++ ) {
				brk = findListInArray( name_breaks[ idx ], name_shorten, start );
				if( brk &gt;= 0 ) break;
			}
			if( brk &gt;= 0 ) {
				idx = brk;
				len = name_suffix.length;
				for( let nsi = 0; nsi &lt; len; nsi++ )
					name_shorten[ idx++ ] = name_suffix[ nsi ];
				name_shorten.length = brk + len;
				nameLen = strFontLen( name_shorten ) - ( name_shorten.length - 1 ) * SpaceLen;
			}
		}
		if( nameLen &gt; targetLen ){									// still too long, break on a space
			brk = name_shorten.indexOf( &#39; &#39;, start );
			if( brk &gt;= 0 ) {
				idx = brk;
				len = name_suffix.length;
				for( let nsi = 0; nsi &lt; len; nsi++ )
					name_shorten[ idx++ ] = name_suffix[ nsi ];
				name_shorten.length = brk + len;
				nameLen = strFontLen( name_shorten ) - ( name_shorten.length - 1 ) * SpaceLen;
			}
		}
if( debug ) {
	let msg = &#39;name: &quot;&#39; + name + &#39;&quot;, name_shorten: &quot;&#39; + name_shorten.join(&#39;&#39;) + &#39;&quot;&#39;;
	if( sShipNameRpt.indexOf &lt; 0 ) {
		log(ws.name, &#39;shortenShipName, &#39; + msg );
		sShipNameRpt.push( msg );
	}
}
		return name_shorten.join(&#39;&#39;);
	}
	shortenShipName.ship_tags = [ [&#39;S&#39;,&#39;h&#39;,&#39;i&#39;,&#39;p&#39;], [&#39;B&#39;,&#39;o&#39;,&#39;a&#39;,&#39;t&#39;], [&#39;S&#39;,&#39;h&#39;,&#39;u&#39;,&#39;t&#39;,&#39;t&#39;,&#39;l&#39;,&#39;e&#39;] ];
	shortenShipName.name_suffix = [&#39; &#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;];
	shortenShipName.name_breaks = [ [&#39; &#39;,&#39;a&#39;,&#39;n&#39;,&#39;d&#39;,&#39; &#39;], [&#39; &#39;,&#39;o&#39;,&#39;f&#39;,&#39; &#39;],	// must be lower case, will test upper
									[&#39; &#39;,&#39;t&#39;,&#39;h&#39;,&#39;e&#39;,&#39; &#39;], [&#39; &#39;,&#39;o&#39;,&#39;r&#39;,&#39; &#39;],
									[&#39; &#39;,&#39;o&#39;,&#39;n&#39;,&#39; &#39;],	   [&#39; &#39;,&#39;i&#39;,&#39;n&#39;,&#39; &#39;] ];
var sShipNameRpt = []; /// tmp4debug

	function findListInArray( list, array, start, end ) {			// return index of list in array
		var ar = start || 0,										//	 list is assumed lower case
			arLen = end || array.length,
			li, liLen = list.length;
		if( arLen &lt; liLen ) return -1;
		for( ; ar &lt; arLen; ar++ ) {
			for( li = 0; li &lt; liLen; li++ ) {
				let achr = array[ ar + li ],
					lchar = list[ li ];
				if( achr === lchar ) continue;
				if( lchar === &#39; &#39; ) break;
				if( achr === lchar.toUpperCase() ) continue;
				break;
			}
			if( li &gt;= liLen ) return ar;
			if( ar + liLen &gt;= arLen ) return -1;
		}
	}

	function relativeDirection( position, map ) {					// stub for external call from telescope_debug._dump_map
		try {
			init_headingView();
			_relative_direction( position, map );
			return relative_dirn;
		} catch( err ) {
			log( ws.name, ws._reportError( err, &#39;relativeDirection&#39;, [position, map], 1 ) );
			if( debug ) throw err;
		}
	}

	var relative_dirn;												// external store for relative_direction&#39;s return

	function _relative_direction( position, map ) {					// init_headingView is called by calling fn(s) to reduce #
		if( !position || !map ) return;
		if( !viewIsStandard ) return;
		relative_dirn = &#39;&#39;;
		if( !ps_position || ps_position.length === 0 ) {			// this fn can get called before FCB starts
			if( !ps_position ) ps_position = alloc_array();
			copy_vector( ps.position, ps_position );
		}
		subtract_vectors( position, ps_position, ent_vector );
		unit_vector( ent_vector, ent_vector );
		let right_v = angle_between_two_unitV( headingView, ent_vector );
		let delta_right = abs( QUARTER_ARC - right_v );
		let up_v = angle_between_two_unitV( ps_vectorUp, ent_vector );
		let delta_up = abs( QUARTER_ARC - up_v );
		let dirn_marks = &#39;&#39;;
		if( right_v &gt; REL_DIR_HALF_PLUS )
			dirn_marks += delta_right &gt; (REL_DIR_STRESS * delta_up)
							? &#39;&lt;&lt;&#39; : &#39;&lt;&#39;;							// extra chr when heading is mostly in that direction
		if( right_v &lt; REL_DIR_HALF_MINUS )
			dirn_marks += (delta_right &gt; REL_DIR_STRESS * delta_up)
							? &#39;&gt;&gt;&#39; : &#39;&gt;&#39;;
		if( up_v &lt; REL_DIR_HALF_MINUS )
			dirn_marks += (delta_up &gt; REL_DIR_STRESS * delta_right)
							? &#39;^^&#39; : &#39;^&#39;;
		if( up_v &gt; REL_DIR_HALF_PLUS )
			dirn_marks += (delta_up &gt; REL_DIR_STRESS * delta_right)
							? &#39;vv&#39; : &#39;v&#39;;
		if( dirn_marks.length === 2 &amp;&amp; dirn_marks[ 0 ] === dirn_marks[ 1 ] )
			dirn_marks = dirn_marks[ 0 ];							// remove doubled when near axis
		relative_dirn = round( map.headingTo ) + &quot; &quot; + dirn_marks;
	}

	function init_headingView() {									// relativeDirection needs view vector
		if( viewDirection === &quot;VIEW_FORWARD&quot; ) {
			copy_vector( ps_vectorRight, headingView );				// right is right of fwd
		} else if( viewDirection === &quot;VIEW_AFT&quot; ) {
			scale_vector( ps_vectorRight, -1, headingView );		// -right is right of aft
		} else if( viewDirection === &quot;VIEW_STARBOARD&quot; ) {
			scale_vector( ps_vectorForward, -1, headingView );		// -fwd is right of starboard
		} else if( viewDirection === &quot;VIEW_PORT&quot; ) {
			copy_vector( ps_vectorForward, headingView );			// fwd is right of port
		}
	}

///////////////////////////////////////////////////////////////////////////////////////////////////
// _auto_update_closure ///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

	// &#39;constant&#39; variables unique to _auto_update_closure
	var PlanetNames, PlanetaryCompass,
		lost_target_name = &#39;(lost target)&#39;,
		unknown_ship_name = &#39;(unknown ship)&#39;;

	// local variables unique to _auto_update_closure
	var quarter_sec_counter = 0,									//counter to make colour of the visual marks, used to do once in a second within a 0.25s timer
		report_status = false,										// flag to restrict over-reporting of msgs
		gravScanMsg = false,										// flag to show messgage less frequently
		found_new = false,											// flag for triggering action required when a new target is detected
		delay_counter = -1;											// countdown for IdentDelay (see also _chg_curr_Sighting)

	function _report_autovars() {
		let tmp = &#39;_report_autovars ,stationNearby = &#39; + stationNearby + &#39;, gravScanProgress = &#39; + gravScanProgress
			 + &#39;, gs_state = &#39; + gs_state + &#39;, gs_progress_report = &#39; + gs_progress_report
			 + &#39;\nfound_new = &#39; + found_new + &#39;, delay_counter = &#39; + delay_counter
			 + &#39;, identKeyPress = &#39; + identKeyPress + &#39;\n&#39;;
		var idx, len = selected_Sightings.length;
		tmp += &#39;selected_Sightings has &#39; + len + &#39; items\n&#39;
		if( len &gt; 0 ) {
			for( idx = 0, len = selected_Sightings.length; idx &lt; len; idx++ ) {
				if( idx &gt; 0 ) tmp += &#39;\n&#39;
				tmp += &#39;selected_Sightings[&#39;+idx+&#39;] = \n&#39;;
				if( cd ) tmp += cd._showProps( selected_Sightings[idx], &#39;selected_S[&#39;+idx+&#39;]&#39; );
			}
		}
		log( ws.name, tmp );
		debug = ws.$DebugMessages;
	}

	function _set_GS_state() {										//in the range of the Gravity Scanner if installed
		var available = stationNearby &amp;&amp; !weaponsOnline 			//near a station or baseship &amp; weaps off-line
			&amp;&amp; ext_ok &amp;&amp; grav_eq_ok &amp;&amp; gravScanProgress &lt;= 1;		// scan underway or done( == 1 )
																	//grav scan without weapons only to need force it
		if( gravScanProgress === 1 ) {
			gs_state = GS_COMPLETE;
		} else if( gravScanProgress === 0 ) {
			gs_state = available ? GS_STOPPED : GS_NONE;
		} else {
			gs_state = available ? GS_RUNNING : GS_DEGRADING;
		}
	}

	function check_equip_ok() {
		if( eq_status === &#39;EQUIPMENT_DAMAGED&#39; ) {
			if( ws.$DamageMsg ) {
				consoleMessage( &#39;Telescope damaged&#39;, ConsoleMsgDurn );
				ws.$DamageMsg = false;
			}
			return false;
		} else if( eq_status !== &#39;EQUIPMENT_OK&#39; ) {
			if( BuyMsg ) {
				consoleMessage( &#39;Buy Telescope! (x)&#39;, ConsoleMsgDurn );
				BuyMsg = false;
			}
			ws.$DamageMsg = false;
			return false;
		}
		return true;
	}

	function chk_energy_gs_status( on_demand ) {					// on_demand = true for user directed scans (toggle weapons, Rescan, step thru end of list)
		if( ps.energy &lt; 64 ) {
			if( on_demand )
				consoleMessage( &#39;Not enough energy for Telescope&#39;, ConsoleMsgDurn );
			return false;
		}
		if( on_demand ) {
			_create_Sightings();									// create list from scratch
			report_status = true;
		}
		var scanning = fns_are_pending();							// true =&gt; mapping creation/update is running
		if( !AutoScan &amp;&amp; !on_demand &amp;&amp; !scanning
			&amp;&amp; gs_state &lt;= GS_STOPPED )
			return false;											// AutoScan turned off by user
		if( found_new || on_demand || scanning ) {
			ps.energy -= 2;											//use a little energy to scan the whole sky
		}
		if( gs_state === GS_RUNNING									// no energy drain during degradation
			&amp;&amp; alertCondition &lt; RED_ALERT ) { 						// suspended during Red Alert
			ps.energy -= 6;											//need 4x energy with Gravity Scanner
		}
		return true;
	}

	function is_station_near( map ) {
		var ent = map.ent;
		if( !ent.isStation )			return false;				// not abandoned rock hermit, as has no power for its part of grav. scanner
		if( ent.mass &lt;= 1e7 )			return false;				//skip ships with docking port (except baseships), rock hermit with 53508t must fit in
		if( ent.target === ps )			return false;				//target is hostile if targeting back
		var d = map.ent_dist;
		if( d &gt; 5000 )					return false;				// not within 5 km
		if( index_in_list( ps, ent.defenseTargets ) &gt;= 0 )
			return false;											// hostile
		return true;
	}

	function report_scan_progress( forced, set_gs_progress ) {
		if( forced ) report_status = true;							// record now in case fns_are_pending
		if( set_gs_progress === undefined &amp;&amp; fns_are_pending() )
				return;												// report status when update is complete
		if( !forced &amp;&amp; !report_status &amp;&amp; !gravScanMsg ) return;		// already reported
		var msg, progress;
		if( ext_ok &amp;&amp; grav_eq_ok ) {
			if( gravScanProgress === 1 ) {							// scan complete
				msg = &#39;Gravity scan found &#39;;
				gravScanMsg = false;
			} else if( gravScanProgress &lt;= 0 ) {					// scan totally degraded
				msg = &#39;Gravity scan off-line&#39;;
				gravScanMsg = false;
				consoleMessage( msg, ConsoleMsgDurn );
				report_status = false;
				return;
			} else {												// scan still active
				if( set_gs_progress !== undefined )					// ensure msg always an even amount
					gs_progress_report = progress = set_gs_progress;
				else
					progress = floor( gravScanProgress * 100 );
				if( !weaponsOnline ) {
					msg = &#39;Gravity scan &#39; + (stationNearby ? &#39;up to &#39; : &#39;down to &#39;) + progress + &#39;%, &#39; + (stationNearby ? &#39;found &#39; : &#39;has &#39;);
					gravScanMsg = false;
				} else
					return;											// no progress msg when weaponsOnline
			}
		} else {													//send message about telescope scan
			msg = &#39;Telescope found &#39;;
		}
		if(		 maplen === 0 ) msg += &#39;no targets&#39;;
		else if( maplen === 1 ) msg += &#39;1 target&#39;;
		else					msg += maplen + &#39; targets&#39;;
		consoleMessage( msg, ConsoleMsgDurn );
		report_status = false;
	}

	const GSR_PROGRESS_ENDPTS = 1,									// gravity scan reporting frequency
		  GSR_PROGRESS_QUARTERS = 2,
		  GSR_PROGRESS_TENTHS = 4,
		  GSR_DEGRADE_ENDPTS = 8,
		  GSR_DEGRADE_QUARTERS = 16,
		  GSR_DEGRADE_TENTHS = 32;

	var gs_progress_report = 0;										// remember progress of last report

	function update_grav_scan() {
		// reporting is triggered in _hud_effects(): sets report_status = true when you turn weapons off-line
		if( !equip_ok || !ext_ok || !grav_eq_ok ) {					// check equipment ok
			gravScanMsg = false;									// suppress any reporting
			gravScanProgress = 0;
			return;
		}
		if( ps_mass &gt;= 1e8 ) {
			stationNearby = true;									//baseships can perform gravity scan anywhere
		} else if( quarter_sec_counter &lt;= 0 ) {						//check a station is nearby for gravity scanner every 4. call, ie. 1/sec
			var list = select_Sightings( 1, &#39;isr&#39;, is_station_near );
			if( list &amp;&amp; list.length &gt; 0 ) {
				if( !stationNearby &amp;&amp; weaponsOnline )				//show when arrived near a station
					consoleMessage( &#39;Gravity scan needs weapons off-line&#39;, ConsoleMsgDurn );
				stationNearby = true;
			} else {												//too far or become hostile
				if( stationNearby )									// show when leave 5km radius or you pissed them off
					consoleMessage( &#39;Gravity scan needs a friendly station in 5km&#39;, ConsoleMsgDurn );
				stationNearby = false;
			}
		}
		if( stationNearby ) {										// incr gravity scan progress counter
			if( gravScanProgress === 0 )
				ws.$SoundScan.play();								//GS scan sound
			if( gravScanProgress &lt; 1 ) {
				let halted = false;
				if( gravScanProgress &gt; 0 &amp;&amp; numberSwapable() &gt;= MaxTargets ) {// orbs &amp; beacons excluded from MaxTargets
					gravScanProgress = 1.1;							// terminate gravity scan, nothing to gains
					halted = true;									// suppress further reports
					consoleMessage( &#39;Gravity scan halted, memory full; &#39;
									+ maplen + &#39; targets&#39;, ConsoleMsgDurn );
				} else {
					let gsm = 1;									//gravity scanner multiplyer
					if( ps_speed === 0 ) gsm = 4;					//4 times faster if stopped
					if( grav_eq2_ok )
						gsm *= 2;									//half time with 2 working grav.scanner
					gravScanProgress += gsm * QUARTER_SECS_OF_4MIN;	//normal gravity scan need 4 minutes
				}
				if( gravScanProgress &gt; 1 ) {
					gravScanProgress = 1;
					gs_progress_report = 100;
					++ws.$GravScanCount;							//Gravity Scan counter to bring aliens
					if( GravScanMsgFreq &amp; GSR_PROGRESS_ENDPTS ) {	// not turn off by user
						gravScanMsg = true;							// enable reporting
						if( weaponsOnline ) {
							consoleMessage( &#39;Gravity scan done, turn off weapons to see results&#39;, ConsoleMsgDurn );
						} else if( !halted ) {
							report_scan_progress();
						}
					}
					let p = ws.$FixedGS === 1 ? 100 : 200;			// every 100 scans if cheap fix, else every 200
					if( ws.$GravScanCount &gt;= p ) {
						let num = ceil(pow( player.score, 0.5 ) / 10 ); //with 0 score do not get any
						if( num &gt; 0 ) {
							consoleMessage( &#39;Aliens detected your Gravity Scan!&#39;, 10 );
							addShips( &#39;thargoid&#39;, num, ps_position, 50000 );
						}
						ws.$GravScanCount = 0;
					}
				} else if( GravScanMsgFreq &gt; 0 ) {					// issue progress report
					let progress = floor(gravScanProgress * 100);
					let frequency = GravScanMsgFreq &amp; GSR_PROGRESS_TENTHS	? 10 :
									GravScanMsgFreq &amp; GSR_PROGRESS_QUARTERS ? 25 : 0;
					if( frequency &gt; 0 ) {
						let div = floor(progress / frequency);
						let mark = progress % frequency;
						if( mark &lt; 2 &amp;&amp; div * frequency &gt; gs_progress_report ) {
							report_scan_progress( true, div * frequency );
						}
					}
				}
			}
		} else if( gravScanProgress &gt; 0 ) {							//degrading from 100% to 0% in 2 minute if away from stations
			gravScanProgress -= QUARTER_SECS_OF_2MIN *
								( 1 + ps_speed / ps_maxSpeed );		// faster if moving
			if( gravScanProgress &lt; 0
					&amp;&amp; GravScanMsgFreq &amp; GSR_DEGRADE_ENDPTS ) {
				report_scan_progress( true, 0 );
				gravScanProgress = 0;
			} else if( GravScanMsgFreq &gt;= GSR_DEGRADE_ENDPTS ) { 	// issue progress report
				let frequency = GravScanMsgFreq &amp; GSR_DEGRADE_TENTHS   ? 10 :
								GravScanMsgFreq &amp; GSR_DEGRADE_QUARTERS ? 25 : 0;
				if( frequency &gt; 0 ) {
					let progress = floor(gravScanProgress * 100);
					let rpt = floor(progress / frequency) * frequency;
					let mark = progress % frequency;
					if( mark &lt; 2 &amp;&amp; rpt &lt; gs_progress_report ) {	// mark &lt; 2 to ensure reported on slow machines
						report_scan_progress( true, rpt );
						if( rpt === frequency )						// last report, suppress report @ 0
							gs_progress_report = 0;
					}
				}
			}
		}
	}

// : &#39; +  + &#39;

	function randomInt( min, max ) { return floor( random() * (max - min) ) + min; }

	doClear_MFD.orig_msg =	[ &#39;T&#39;,&#39;e&#39;,&#39;l&#39;,&#39;e&#39;,&#39;s&#39;,&#39;c&#39;,&#39;o&#39;,&#39;p&#39;,&#39;e&#39;,&#39;:&#39;,&#39; &#39;,&#39;N&#39;,&#39;o&#39;,&#39; &#39;,&#39;T&#39;,&#39;a&#39;,&#39;r&#39;,&#39;g&#39;,&#39;e&#39;,&#39;t&#39;,&#39;s&#39; ];
	doClear_MFD.aux_msg =	[ &#39;T&#39;,&#39;e&#39;,&#39;l&#39;,&#39;e&#39;,&#39;s&#39;,&#39;c&#39;,&#39;o&#39;,&#39;p&#39;,&#39;e&#39;,&#39; &#39;,&#39;A&#39;,&#39;u&#39;,&#39;x&#39;,&#39;.&#39;,&#39;:&#39;,&#39; &#39;,&#39;N&#39;,&#39;o&#39;,&#39; &#39;,&#39;T&#39;,&#39;a&#39;,&#39;r&#39;,&#39;g&#39;,&#39;e&#39;,&#39;t&#39;,&#39;s&#39; ];
	doClear_MFD.aux_not =	[ &#39;T&#39;,&#39;e&#39;,&#39;l&#39;,&#39;e&#39;,&#39;s&#39;,&#39;c&#39;,&#39;o&#39;,&#39;p&#39;,&#39;e&#39;,&#39; &#39;,&#39;A&#39;,&#39;u&#39;,&#39;x&#39;,&#39;.&#39;,&#39;:&#39;,&#39; &#39;,&#39;D&#39;,&#39;i&#39;,&#39;s&#39;,&#39;a&#39;,&#39;b&#39;,&#39;l&#39;,&#39;e&#39;,&#39;d&#39; ];
	function doClear_MFD( MFDname, fully ) {						// ?completely empty MFD&#39;s vanish
		var that = doClear_MFD;
		var clear_msg = (that.clear_msg = that.clear_msg || []);

		var msg = MFDname === PrimaryMFD_name ? that.orig_msg :
				  SeparateMFDs ? that.aux_msg : that.aux_not;
		if( fully ) {
			ps.setMultiFunctionText( MFDname, &#39;&#39;, false );
		} else if( equip_ok ) {
			ps.setMultiFunctionText( MFDname, msg.join(&#39;&#39;), false );
		} else {
			let idx, msg_len;
			idx = msg_len = msg.length;
			clear_msg.length = 0;									// clear array
			while( idx-- ) clear_msg[ idx ] = msg[ idx ];			// set up working array
			let min, max, rand = randomInt( 4, 6 );					// distort msg by swapping a few, chg&#39;g case
			while( rand ) {
				min = randomInt( 0, msg_len );
				max = randomInt( 0, msg_len );
				if( min === max ) continue;							// need diff #&#39;s
				if( clear_msg[ min ] ===  clear_msg[ max ] )
					continue;										// want diff char&#39;s
				rand--;
				if( min &gt; max ) {
					[ max, min ] = [ min, max ];
				}
				if( min % 2 === 0 || max - min &gt; msg_len &gt;&gt; 2 ) {	// swap chars
					// let tmp = clear_msg[ min ];
					// clear_msg[ min ] = clear_msg[ max ];
					// clear_msg[ max ] = tmp;
					[ clear_msg[ min ], clear_msg[ max ] ] = [ clear_msg[ max ], clear_msg[ min ] ];
				} else {
					for( idx = min; idx &lt; max; idx++ )
						clear_msg[ idx ] = clear_msg[ idx ].toUpperCase();
				}
			}
			ps.setMultiFunctionText( MFDname, clear_msg.join(&#39;&#39;), false ); // &#39;\n\n\n\n&#39; +
		}
	}

	function format_line( map, list ) {
		let ent = map.ent;
		if( !ent || !ent.isValid ) return false;
		if( MFD_ents[ ent ] ) {
			return false;
		}
		reset_common_vars();										// required as done in groups of 3
		let rpt = showShipReport( map );
		using_common_vars = false;
		if( !rpt || rpt.length === 0 || rpt.indexOf( &#39;(Lost &#39; ) === 0 )
			return false;
		if( curr_target ) {
			if( curr_target === ent || ent === curr_S.ent )
				rpt = &#39;[ &#39; + rpt + &#39; ]&#39;;							//mark the current target
		}
		list.push( rpt );
		MFD_ents[ ent ] = true;
		return true;
	}

/*	&quot;The Target list contains hostiles first, if any, then all ships in normal scanner (25.6km),
	 followed by Cargo and Escape Pods, then ending with ships which are not in the normal scanner.&quot;

	function map_sort_rank_dist( a, b ) {							// same as used in _chg_curr_Sighting
		let a_rank = a.rank, b_rank = b.rank;
		if( a_rank === b_rank )
			return a.ent_dist - b.ent_dist;
		else
			return a_rank &gt; b_rank;
	}
*/

	function map_sort_dist( a, b ) {
		return  a.ent_dist - b.ent_dist;
	}

	function MFD_is_visible( name ) {
		var mfds = ps.multiFunctionDisplayList;
		if( !mfds || mfds.length ===0 )
			return false;											// ship damaged
		return index_in_list( name, mfds ) !== -1;
	}

	function qualifyMFD( map, staticFilter, dynamicFilter ) {
		var passStatic = staticFilter === 0 						// none specified OR matches static filter
							|| (map.staticMFD &amp; staticFilter) &gt; 0;
		var passAttitude = (dynamicFilter &amp; MFD_ATTITUDE) === 0		// none specified OR matches attitude
							|| (map.dynamicMFD &amp; dynamicFilter &amp; MFD_ATTITUDE) &gt; 0;
		var passRange = (dynamicFilter &amp; MFD_RANGED) === 0 			// none specified OR matches range limit
							|| (map.dynamicMFD &amp; dynamicFilter &amp; MFD_RANGED) &gt; 0;

		return passStatic &amp;&amp; passAttitude &amp;&amp; passRange;
	}

// : &#39; +  + &#39;
	function bitsSet( map, stat, dyn ) {							// return # bits set for map in both stat &amp; dyn
		var count = 0, 												//  - used as a crude determination of which list is better fit
			bits = map.staticMFD &amp; stat;
		while( bits &gt; 0 ) {
			if( bits &amp; 1 )
				count++;
			bits &gt;&gt;&gt;= 1;
		}
		bits = map.dynamicMFD &amp; dyn;
		while( bits &gt; 0 ) {
			if( bits &amp; 1 )
				count++;
			bits &gt;&gt;&gt;= 1;
		}
		return count;
	}

	var MFD_lines = [];												// formated lines for MFD
	var Aux_lines = [];
	var depthMFD, depthAUX;
	var MFD_ents = {};												// ents in MFD_lines, so don&#39;t repeat
	function update_MFDs( started, testing ) {
		var that = update_MFDs;
		var maps2rpt = (that.maps2rpt = that.maps2rpt || []);
		if( that.adjusted === undefined ) that.adjusted = 0;
		var adjusted = that.adjusted;

		var map, ent, rptlen, newLines, idx, primaryUp, auxiliaryUp;
		if( !mappingReady || maplen === 0 ) 						// not yet built OR empty
			return;
		primaryUp = MFD_is_visible( PrimaryMFD_name );
		auxiliaryUp = MFD_is_visible( AuxilaryMFD_name );
		if( !primaryUp &amp;&amp; !auxiliaryUp ) {							// only update if being used (it&#39;s expensive)
			doClear_MFD( PrimaryMFD_name, true );
			doClear_MFD( AuxilaryMFD_name, true )
			return;
		}
		if( !started || testing ) {
			if( tasks_queued( update_MFDs ) ) 						// on a slow PC, _auto_updates may call before update cycle complete
				return;
			MFD_lines.length = 0;									// re-use arrays
			Aux_lines.length = 0;
			for( let ent in MFD_ents ) 								// re-use dictionaries
				if( MFD_ents.hasOwnProperty( ent ) )
					delete MFD_ents[ ent ];
			maps2rpt.length = 0;
			depthMFD = depthAUX = newLines = 0;
			mapping.sort( map_sort_dist );
			for( idx = 0; idx &lt; maplen; idx++ ) {					// store maps to report so don&#39;t sort next frame
				maps2rpt[ idx ] = mapping[ idx ];
			}
			idx = 0;
		} else {													// continue from last frame
			depthMFD = MFD_lines.length;
			depthAUX = Aux_lines.length;
			newLines = 0;
			idx = started;
		}
		var continueMFD = SeparateMFDs								// aux is a continuation of primary when
						  &amp;&amp; ( !MFDFiltering						// aux is active w/ no filter or same filter
							   || (MFDPrimaryDynamic === MFDAuxDynamic
								   &amp;&amp; MFDPrimaryStatic === MFDAuxStatic) );
		rptlen = maps2rpt.length;
		for( ; idx &lt; rptlen &amp;&amp; ( (SeparateMFDs &amp;&amp; (depthMFD &lt; 10 || depthAUX &lt; 10))
							|| (!SeparateMFDs &amp;&amp; depthMFD &lt; 10) ); idx++ ) {
			map = maps2rpt[ idx ];
			ent = map &amp;&amp; map.ent;
			if( !map || !ent ) 										// was just deleted?
				continue;
			if( (newLines &gt; 3 + adjusted) &amp;&amp; !testing ) {			// split across frames as formatting takes time
				set_fn_pending( update_MFDs, idx, true );			// true is for tasks_deferred list
				return;
			}
			let qualifies, mfdBits = 0, auxBits = 0;
			if( !continueMFD &amp;&amp; SeparateMFDs ) {					// decide which one gets it
				mfdBits = bitsSet( map, MFDPrimaryStatic, MFDPrimaryDynamic );
				auxBits = bitsSet( map, MFDAuxStatic, MFDAuxDynamic );
			}
			if( depthMFD &lt; 10 ) {									// not full
				if( !MFDFiltering ) {								// just list the first 10
					qualifies = true;
				} else if( continueMFD								// just list the first qualified 10
							|| !SeparateMFDs						// no fit to worry about
							|| mfdBits &gt;= auxBits ) {				// mfd list is a better fit (&gt;= favours primary)
					qualifies = qualifyMFD( map, MFDPrimaryStatic,
												 MFDPrimaryDynamic );
				} else {											// - check that it passes filters
					qualifies = false;
				}
				if( qualifies ) {
					if( !primaryUp ) { 								// incr counter to keep aux aligned
						depthMFD++;
						if( !MFD_ents[ ent ] )						// add to reported ents dictionary
							MFD_ents[ ent ] = true;					//   so it won&#39;t appear in aux (should filters overlap)
					} else if( format_line( map, MFD_lines ) ) {	// only do expensive call when necessary
						newLines++;									// format_line adds to dictionary if map used
						depthMFD++;
					}
					continue;										// an ent cannot be in both MFDs, so move on to next
				}
			}
			if( depthAUX &lt; 10 ) {									// not full
				if( !MFDFiltering ) {								// just list the first 10
					qualifies = true;
				} else if( continueMFD								// just list the first qualified 10
							|| !SeparateMFDs						// no fit to worry about
							|| auxBits &gt; mfdBits					// aux list is a better fit (&gt; excludes primary)
							|| (auxBits === mfdBits					// qualifies for both but didn&#39;t fit in primary
								&amp;&amp; !MFD_ents[ ent ]) ) {
							// || auxBits &gt; mfdBits ) {				// aux list is a better fit (&gt; excludes primary)
					qualifies = qualifyMFD( map, MFDAuxStatic,
												 MFDAuxDynamic );
				} else {											// - check that it passes filters
					qualifies = false;
				}
				if( qualifies ) {
					if( !auxiliaryUp ) { 							// incr counter to keep aux aligned
						depthAUX++;
						if( !MFD_ents[ ent ] )						// add to reported ents dictionary
							MFD_ents[ ent ] = true;					//   so it won&#39;t appear in main (should filters overlap)
					} else if( format_line( map, Aux_lines ) ) {	// only do expensive call when necessary
						newLines++;									// format_line adds to dictionary if map used
						depthAUX++;
					}
				}
			}
		}
		if( ps.setMultiFunctionText ) {
			if( depthMFD &gt; 0 &amp;&amp; primaryUp ) {
				ps.setMultiFunctionText( PrimaryMFD_name, MFD_lines.join( &#39;\n&#39; ), false );
			} else {
				doClear_MFD( PrimaryMFD_name, !primaryUp );
			}
			if( depthAUX &gt; 0 &amp;&amp; auxiliaryUp ) {
				ps.setMultiFunctionText( AuxilaryMFD_name, Aux_lines.join( &#39;\n&#39; ), false );
			} else {
				doClear_MFD( AuxilaryMFD_name, !auxiliaryUp );
			}
		}
	}

/*	&quot;Telescope checks for new targets every second and performs an autoscan if it finds one: simple light sensors can see new dots
	 in the whole sky without using energy but must zoom with the main scope to determine the ship type which needs 2 energy points.&quot;
*/

	function check_if_new_targets() {								// detect when there are new target to consider
		if( found_new ) return;										// no need to check
		// &quot;There are no passive gravity sensors so AutoScan will happen only if a new target arrives into the visible range.&quot;
		var ent, map, dist = -1, pastScannerRange = 0,
			isStn, stnsOnly = false, index = 0,
			allShips = system.allShips,								// array of all ships in system, sorted by distance
			alllen = allShips.length;								// - use this to suppress calc of distance, as exact value irrelevant

var numEnts = alllen - system_planets.length - 1;		// - 1 for sun
var breakEarly = MaxTargets &lt;= 50 &amp;&amp; numEnts &gt; MaxTargets;// player has slow PC, so limit _create_Sightings() calls

		while( index &lt; alllen ) {
			ent = allShips[ index++ ];
			if( ent === ps ) continue;
			let mapi = _Sighting_index( ent, &#39;check_if_new_targets&#39; );
			if( mapi &gt;= 0 ) {										// a known entity
				map = mapping[ mapi ];
				if( map.rank !== &#39;ukn&#39; )							// ?is it an existing one that re-entered detection range
					 continue;
			} else {
				map = null;
			}
if( breakEarly &amp;&amp; weaponsOnline &amp;&amp; alertCondition === RED_ALERT ) {
	isBeacon = -1;									// force entity property get
	if( is_beacon( ent ) ) break;					// limit scanning while in battle
}

			if( pastScannerRange === 0 ) {
				dist = _detect_distanceTo( ent );
				if( dist &gt; scannerRange ) {
					pastScannerRange = index - 1;					// last time in this if block
					if( !ext_ok ) break;
					if( !ent.isVisible	) continue;					// above all, it must be visible
				}
			} else {												// we use distance to know when to quit
				if( !stnsOnly &amp;&amp; index &gt; pastScannerRange
						&amp;&amp; (index - pastScannerRange) % 10 === 0 ) {// calc distance on every 10th ent
					dist = _detect_distanceTo( ent );
					if( dist &gt; AutoScanMaxRange ) break;
					if( dist &gt; scannerRange_X_10 )					// hard limit enough for largest ship?
						stnsOnly = true;
				} else {											// don&#39;t need to calc distance at all
					dist = -1;
				}
				if( !ent.isVisible ) continue;						// above all, it must be visible
				isStn = !stnsOnly ? false : ent.isStation;			// only check property once we&#39;re beyond limit
			}
if( breakEarly &amp;&amp; weaponsOnline ) {
	if( alertCondition === YELLOW_ALERT &amp;&amp; dist &gt; scannerRange_X_2 ) {
		isBeacon = -1;								// force entity property get
		if( is_beacon( ent ) ) break;				// limit scanning of distant ents
	}
	if( alertCondition === GREEN_ALERT &amp;&amp; dist &gt; scannerRange_X_4 ) {
		isBeacon = -1;								// force entity property get
		if( is_beacon( ent ) ) break;				// limit scanning of distant ents
	}
}
			reset_common_vars();
			distance = dist &gt; 0 ? dist : -1;						// restore known values if known
			isStation = stnsOnly ? isStn : -1;
			if( notable_ent( ent, false, (dist &gt; 0 ? dist : null) ) ) {// found one missing or may need updating
				if( mapi &lt; 0 ) {									// not in mapping
					let enti = _add_Sighting( ent, true, false, &#39;check_if_new_targets&#39; );
					if( debug &amp;&amp; (enti &lt; -2 &amp;&amp; enti &gt; -8) ) {
						let reason = add_Sighting_errors[ enti ];
						log(ws.name, &#39;check_if_new_targets, _add_Sighting returned &quot;&#39; + reason
							+ &#39;&quot;, distance: &#39; + distance + &#39;: &#39; + ent );
					}
					new_targets.push( ent );
					///moved from below 2Cif--# repeat msgs
				} else {
					update_one_Sighting( map, ent, mapi, false );	// false suppresses call to notable_ent
				}
				///new_targets.push( ent );
				break;
			}
		}
		using_common_vars = false;
	}

	function auto_updates( forced_scan ) {
		try {
			_auto_updates( forced_scan );
		} catch( err ) {
			log( ws.name, ws._reportError( err, &#39;auto_updates&#39;, forced_scan ) );
			if( debug ) throw err;
		}
	}

	function _auto_updates( forced_scan ) { //check for most centered 4 times/second; new targets, update MFD once/second
		// forced_scan is true for user directed actions: weapons off-line, a Rescan or stepping past list boundary
		ps = player &amp;&amp; player.ship;
		if( !ps || !ps.isValid || alertCondition === DOCKED )		//player died or docked
			return;
		if( !check_equip_ok() ) return;
		found_new = found_new
					|| ( new_targets &amp;&amp; new_targets.length &gt; 0 );	// check if any found in last scan
		if( forced_scan ) {
			if( report_status &amp;&amp; chk_energy_gs_status( true ) ) 	// true will cause chk_energy_gs_status() to create new mapping
				consoleMessage( &#39;Starting new scan ...&#39;, ConsoleMsgDurn );
			return;													// must not incr. counter or select target
		}
		if( alertCondition &lt; RED_ALERT )							// gravity scanner suspended during Red Alert
			update_grav_scan();										// invoked on ea. 1/4 sec; handles gravScanProgress
		if( AutoScan &amp;&amp; quarter_sec_counter === 0
				&amp;&amp; !fns_are_pending() ) {							// create/update takes 20+ frames
			if( chk_energy_gs_status( false ) ) {					// false to suppress msgs; they only occur on user demand scans
				if( found_new )	{									// only when there are newly found
					_update_Sightings();							//	 (routine update calc&#39;s are in reposition_effects())
				} else {
					_update_Sightings( gravScanProgress === 0		// _update_Sightings( just_mapping )
									|| gravScanProgress === 1 );	// update only those ents in mapping, unless grav scan in flux
				}
			}
		} else if( quarter_sec_counter === 1 ) {
			check_Sightings( true );								// true -&gt; &#39;quickly&#39;; this just checks the health of ents in mapping
			 if( AutoScan ) {
				 check_if_new_targets();
			 }
		} else if( quarter_sec_counter === 2 ) {
			init_headingView();
			checkCombatMFD();
			update_MFDs();
		} else { // quarter_sec_counter === 3
			check_Sightings( false );								// update should be finished, so do proper check
		}
		if( !ws.$are_Steering ) {									//no retarget during autosteering
			if( identKeyPress &gt;= IDENT_UNLOCK ) {					// just did an Ident unlock, manage delay counter, if any
				if( IdentDelay &gt; 0 &amp;&amp; delay_counter &lt; 0 ) {			// initiate delay counter
					delay_counter = IdentDelay;						// it&#39;s specified in quarter seconds, so ...
				} else if( delay_counter &gt; 0 ) {					// counter is running
					delay_counter--;								// ...decr on each call here
				}
				if( delay_counter === 0 ) {							// counter is finished
					_resetIdentDelay();
					if( identKeyPress === IDENT_STEER_DELAY )		// successful auto steer
						_manage_marker( curr_S.map, false, &#39;_mostCentered (IdentKeyPress = IDENT_STEER_DELAY)&#39; );
					ws.$IdentKeyPress = identKeyPress = IDENT_READY;// ...resume targeting
// if( debug ) log(&#39;_auto_updates, delay_counter === 0, identKeyPress := IDENT_READY&#39;);
				}
			} else if( identKeyPress === IDENT_READY ) {
				if( weaponsOnline ) {								//in auto mode
					if( curr_target === null &amp;&amp; AutoLock !== 0 ) {	//no target and autolock not disabled
						_mostCentered( &#39;auto&#39; );
					}
				} else if( GravLock !== 0 )	{						//in grav mode and not disabled
					_mostCentered( &#39;grav&#39; );
				}
			}
		}
		quarter_sec_counter--;
		if( quarter_sec_counter &lt; 0 )								// update counter for per sec tasks
			quarter_sec_counter = 3;								//do once in a second when reach 0
	}

	function _resetIdentDelay() {									// called from mode()
		delay_counter = -1;
	}

///////////////////////////////////////////////////////////////////////////////////////////////////
// steering ///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

	// local variable unique to steering
	var steer_map, steer_ent, ps_maxPitch, towbarShip, towShipmass;

	function halt_steering( angle_to_target ) {						// stop steering
		ws.$are_Steering = false;
		ws.$TelescopeSteerFCB = null;								// used by Towbar oxp
		if( SniperLock ) {											// improve compatibity (thanks Milo)
			SniperLock.deactivate = &quot;FALSE&quot;;
		}
		if( SniperLockPlus ) {										// improve compatibity
			SniperLockPlus.$enabled = true;
		}
		steer_ent = steer_map = null;
		if( angle_to_target === undefined ) {
// if( debug ) log(&#39;halt_steering, angle_to_target === undefined&#39; );
			return;
		}
		if( angle_to_target &lt;= ONE_DEGREE * 1.01
				&amp;&amp; identKeyPress === IDENT_STEERING ) {				// auto steer reached target
			ws.$IdentKeyPress = identKeyPress = IDENT_STEER_DELAY;	// get ident delay but no clearing of target
// if( debug ) log(&#39;halt_steering, identKeyPress := IDENT_STEER_DELAY&#39;);
			consoleMessage( &#39;Telescope steering ended, lock released&#39;, ConsoleMsgDurn );
		}
	}

	function start_Steering() {										//turn to the target
		steer_map = curr_S.map;
		if( !steer_map ){
// if( debug ) log(&#39;start_Steering, !steer_map, bailing&#39;);
			return;
		}
		steer_ent = steer_map.ent;
		if( !steer_ent || !steer_ent.isValid ) {
// if( debug ) log(&#39;start_Steering, &#39; + (!steer_ent ? &#39;!steer_ent&#39; : &#39;!steer_ent.isValid&#39;) + &#39;, bailing&#39;);
			return;
		}
		if( viewDirection !== &#39;VIEW_FORWARD&#39; ) { 					//working in forward view only
// if( debug ) log(&#39;start_Steering, viewDirection !== VIEW_FORWARD, bailing&#39;);
			return;
		}
		ps_maxPitch = ps.maxPitch;									// not set in _init_player_vars as only used for steering
		towbarShip = null;
/*
if( debug &amp;&amp; (ws.$FixedTel === 1 || ws.$are_Steering) ) {
	log(&#39;start_Steering, cannot start as &#39; + (ws.$FixedTel === 1 ? &#39;ws.$FixedTel === &#39; + ws.$FixedTel : &#39;ws.$are_Steering is &#39; + ws.$are_Steering));
}
 */
		if( ws.$FixedTel !== 1 &amp;&amp; !ws.$are_Steering ) {				// fully repaired &amp; not already steering
			copy_vector( ps_vectorForward, prevHeading );
			if( Towbar ) {
				towbarShip = Towbar.$TowbarShip;
				towShipmass = towbarShip ? towbarShip.mass : 0;
			}
			if( SniperLock ) {										// improve compatibity (thanks Milo)
				SniperLock.deactivate = &quot;TRUE&quot;;
			}
			if( SniperLockPlus ) {									// improve compatibity
				SniperLockPlus.$enabled = false;
			}
			ws.$are_Steering = true;
			ws.$TelescopeSteerFCB = ws.$Sighting_events_FCB;		// Towbar oxp checks isValidFrameCallback
		}
	}

	function _steerFCB( delta ) {
		try {
			var angle_to_target, angle_traversed;
			if( !steer_ent || _has_bad_status( steer_ent ) || !steer_map 	// _has_bad_status checks isValid
					|| !steer_map.last_posn || steer_map.last_posn.length === 0 ) {
/*
if( debug ) {
	if( !steer_ent )
		log(&#39;_steerFCB, !steer_ent, bailing&#39;);
	else if( _has_bad_status( steer_ent ) )
		log(&#39;_steerFCB, _has_bad_status( steer_ent ), bailing&#39;);
	else if( !steer_map )
		log(&#39;_steerFCB, !steer_map, bailing&#39;);
	else if( !steer_map.last_posn )
		log(&#39;_steerFCB, !steer_map.last_posn, bailing&#39;);
	else if( steer_map.last_posn.length === 0 )
		log(&#39;_steerFCB, steer_map.last_posn.length === 0, bailing&#39;);
	else
		log(&#39;_steerFCB, Yikes, do not know why, bailing&#39;);
}
 */
				if( steer_ent ) {
					halt_steering();								//end of steering (aborted)
				}
				return;
			}	// target still alive!
			copy_vector( steer_map.last_posn, position );			// if &#39;ukn&#39;, steer to last known position
			subtract_vectors( position, ps_position, vector );
			unit_vector( vector, vector );
			angle_to_target = angle_between_two_unitV( ps_vectorForward, vector );
			angle_traversed = angle_between_two_unitV( ps_vectorForward, prevHeading );
			if( angle_traversed &lt; 0.005 &amp;&amp; angle_to_target &gt; ONE_DEGREE ) { //steer if no manual steering and not in 1 degree
				//if the above angle_traversed value lower then can not start steering in my intel atom netbook
				let opt1 = ps_maxPitch * delta;
				let opt2 = angle_to_target / 12;
				let angle = opt1 &lt; opt2 ? opt1 : opt2;				//half max turn/step and not too accutate
				if( towbarShip &amp;&amp; towbarShip.isValid ) {
					let tow_opt = ps_mass / towShipmass;
					let ma = tow_opt &lt; 2 ? tow_opt : 2;				///small ship max. 2x
					angle = angle * ma / 3;							// 1/3 of the original rate with same mass, min. 1/5 max. 2/3
//					player.consoleMessage(&#39;Telescope slow steering with towed ship &#39;+angle_traversed);//debug
				}
//log(ws.name, &#39;_steerFCB, angle_to_target=&#39; +angle_to_target*180 / Math.PI
//	+&#39;, angle_traversed=&#39; +angle_traversed*180 / Math.PI +&#39;, a=&#39;+a*180 / Math.PI);
				cross_product( ps_vectorForward, vector, cross ); 	//set the plane where we should rotate in
				unit_vector( cross, cross );
				rotate_about_axis( ps_orientation, cross, -angle, quaternion );
				ps.orientation = quaternion;
				vector_forward_from_quaternion( quaternion );
				copy_vector( ps_vectorForward, prevHeading );
			} else {												//end of steering (normal)
				halt_steering( angle_to_target );
			}
		} catch( err ) {
			log( ws.name, ws._reportError( err, &#39;_steerFCB&#39;, delta ) );
			if( debug ) throw err;
		}
	}

///////////////////////////////////////////////////////////////////////////////////////////////////
// _hud_effects_closure ///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

	// local variables unique to _HUD_effects_closure
	var prevHeading = [],		//heading vector of the player ship in the previous frame to detect manual steering
		viewPosition  = [0,0,0],//base position of the visual effect
		haveViewPosn = false,	// flag for view positioning calculations
		vShipShift = [],		// HUD specific shift of visual target
		haveHUDShift = false,	// flag for HUD shift calculations
		effect_start = [],		//starting point for all effects (50m in front of view position)
		effect_viewposn = [],	//initially calc&#39;d posn common to both virtual ship &amp; sniper ring
		vShip_posn = [],		//position of the virtual ship model (adjusted from viewPosition for scale, ring)
		weaps = false,			//the previous state of the player weapons
		vRing = null,			//a ring around the visual effect target
		vShip = null,			//visual effect to show the selected target
		vDataKey = null,		//key of the visual effect
		vDKsubst = null,		//key of the visual effect substituted for missing effectdata
		weaponPosition = [],	//sniper ring adjusts for offset to enhance accuracy
		weaponZOffset = null,	// - used to calculate sniper ring offsets
		sRingCorrection = [],	// - used to calculate sniper ring offsets
		haveWeaponPosn = false,	// flag for view positioning calculations
		sniper = null,			//if this ring guided around the crosshair then the far target is lined up correctly
		sRing_posn = [],		//position of the sniper ring (adjusted from viewPosition for scale, ring)
		vShipScale = 0,			// scaling factor to fit vShip effect into vRing
		vsize = !weaponsOnline ? VisualTargetNormalSize / 10 	// these options can range from 0-8
							   : VisualTargetCombatSize / 10,
		vsizechanged, wide;

	function _clear_HUD_Effects() {									//Clear Visual Effect Ship Model and Visual Marker also
		clear_SnipeRing();
		clearVShip();
	}

	function clear_SnipeRing() {									//Clear small sniper ring
		if( sniper ) {
			sniper.remove();
			sniper = null;
ws.$sniper = null; // debug
		}
	}

	function clearVShip() {											//Clear Visual Effect Ship Model and large visual ring
		if( vShip ) {
			vShip.remove();
			vShip = null;
			vDataKey = null;										//need to show again when reident
			vDKsubst = null;
		}
		if( vRing ) {
			vRing.remove();
			vRing = null;
		}
	}

/*
var fmt_position = function fmt_position(posn) {
	if( !posn || !Array.isArray(posn))
		return &#39;not a vector (&#39; + posn + &#39;)&#39;;
	var out = &#39;(&#39;;
	for( let idx=0, len=posn.length; idx &lt;len; idx++) {
		out += idx &gt; 0 ? &#39;, &#39; : &#39;&#39;;
		out +=  posn[idx].toFixed(5);
	}
	return out + &#39;)&#39;;
}
 */

	function _set_vShip_posn( viewposFwd, vShift ) {				// called from shipWillLaunchFromStation
													// 	ws._set_vShip_posn( ps.viewPositionForward, ws.$VTarget_HUD_shift );
		ps = player &amp;&amp; player.ship;
		if( !ps ) return;
		haveViewPosn = haveWeaponPosn = haveHUDShift = false;

		var weaponPosnFwd = ps.weaponPositionForward;	// array of Vector3D
		var wPosnX = 0, wPosnY = 0, wPosnZ = 0;
		var idx = 0, len = weaponPosnFwd.length;
		for( ; idx &lt; len; idx++ ) {
			wPosnX += weaponPosnFwd[idx][0];
			wPosnY += weaponPosnFwd[idx][1];
			wPosnZ += weaponPosnFwd[idx][2];
		} // average the positions of weapons (in some oxps, can be multiple)
		weaponPosnFwd[0] = wPosnX / len;
		weaponPosnFwd[1] = wPosnY / len;
		weaponPosnFwd[2] = wPosnZ / len;
		copy_vector( weaponPosnFwd, weaponPosition );
		haveWeaponPosn = !same_vectors( weaponPosition, VECTOR_ALL_ZEROS );
		if( weaponZOffset === null ) {
			weaponZOffset = weaponPosnFwd;							// reuse array
			weaponZOffset[0] = 0;
			weaponZOffset[1] = 0;
		} else {
			free_array(weaponPosnFwd);
		}

		if( !viewposFwd ) return;
		copy_vector( viewposFwd, viewPosition );					// save supplied position
		haveViewPosn = !same_vectors( viewPosition, VECTOR_ALL_ZEROS );

		if( !vShift ) return;
		copy_vector( vShift, vShipShift );							// save supplied HUD shift for 3D model
		haveHUDShift = !same_vectors( vShipShift, VECTOR_ALL_ZEROS );
	}

	var HUD_vars_init = false;	// flag to prevent duplicate calculations

	var grayLevels = [	[ 0.05, 0.05, 0.05, 1],
						[ 0.1, 0.1, 0.1, 1],
						[ 0.15, 0.15, 0.15, 1],
						[ 0.2, 0.2, 0.2, 1],
						[ 0.25, 0.25, 0.25, 1],
						[ 0.3, 0.3, 0.3, 1],
						[ 0.35, 0.35, 0.35, 1],						// ~darkGrayColor
						[ 0.4, 0.4, 0.4, 1],
					  //[ 0.5, 0.5, 0.5, 1]							// grayColor
					 ];
	var brightnessLevel = 0;										// level increased using clock.absoluteSeconds
	var lastGrayLevelTime = 0;

	function makeItBrighter( obj ) {

// log(ws.name, &#39;makeItBrighter, entry, parm obj: &#39; + obj);
// if(debug &amp;&amp; obj.constructor !== VisualEffect) {
	// log(ws.name, &#39;makeItBrighter,  *** !VisualEffect ***,  parm obj: &#39; + obj);
	// if( obj &amp;&amp; cd &amp;&amp; !obj.position )
		// log(ws.name, cd._showProps( obj, &#39;obj&#39; ));
// }

		var mats = obj.getMaterials();
		for( var prop in mats ) {
			if( mats.hasOwnProperty( prop ) ) {
				if( mats[ prop ].hasOwnProperty( &#39;illumination_map&#39; )
						&amp;&amp; mats[ prop ].illumination_map !== &#39;telescope-illumination.png&#39; )
					continue;										// it has its own, we didn&#39;t modify in collect_effectdata
				if( mats[ prop ].hasOwnProperty( &#39;illumination_modulate_color&#39; ) ) {
					mats[ prop ].illumination_modulate_color = grayLevels[ brightnessLevel ];
					obj.setMaterials( mats );
				}
			}
		}
// log(ws.name, &#39;makeItBrighter, exit&#39;);
	}

	function illuminate() {
		var start = illuminate.start || 0;
// log(ws.name, &#39;illuminate, entry, .start = &#39; + start );
		if( !vShip ) {	/// thanks to Dybal
		   log(ws.name, &#39;illuminate, invalid vShip: &#39; + vShip + &#39;, start: &#39; + start
				+ &#39;, brightnessLevel: &#39; + brightnessLevel + &#39;, lastGrayLevelTime: &#39; + lastGrayLevelTime );
// log(ws.name, &#39;illuminate, exit (false), .start = &#39; + illuminate.start );
		   return false;
		}
		makeItBrighter( vShip );
		var idx, list = vShip.subEntities,
			len = list &amp;&amp; list.length || 0;
		for( idx = start; idx &lt; len; idx++ ) {
			if( idx &gt; start &amp;&amp; idx % 3 === 0 ) {					// setMaterials calls in makeItBrighter are expensive
				illuminate.start = idx;								//	 so spread over several frames
// log(ws.name, &#39;illuminate, exit (false), .start = &#39; + illuminate.start );
				return false;
			}
			makeItBrighter( list[ idx ] );
		}
		illuminate.start = 0;
// log(ws.name, &#39;illuminate, exit (true), .start = &#39; + illuminate.start );
		return true;
	}

	function mk_vship( key, noset ) {								// by not setting vDataKey, prevent trashing
		if( dataKey || key ) {
			let add_key = key ? key : dataKey;
			vShip = addVisualEffect( add_key, ps_position );
			if( vShip ) {
				// cannot use effect&#39;s collisionRadius as it may lack subEntities! eg. ddtmanta&#39;s wings, fighter swarm group
				let vsCR = curr_target.collisionRadius;
				if( vsCR === 0 || !vShip.isValid ) {				// dataKey not in effecdata.plist
					vShip.remove();
					vShip = null;
					log(ws.name, &#39;mk_vship, removed &#39; +add_key+ &#39; as &#39;
						+ (!vShip.isValid ? &#39;!vShip.isValid&#39; : &#39;vShip.collisionRadius === 0&#39;) );
					return false;
				}
ws.$vship = vShip; // debug

				lastGrayLevelTime = clock.absoluteSeconds;
				brightnessLevel = 0;
				if( noset ) {										// using a substitute model
					vDKsubst = add_key;
					vDataKey = dataKey;
				} else {
					vDataKey = vDKsubst = add_key;					// only set if using target&#39;s dataKey
				}
				if( vDKsubst === &#39;oolite-unknown-ship&#39; ) {			// question mark size independent of target
					vsizechanged = true;							// signal for update of scaling, position
					return true;
				}
				vShip.scannerDisplayColor1 = null; 					//hide from the scanner
				vShip.scannerDisplayColor2 = null; 					//  &quot;
				let bbox = curr_target.boundingBox;					// effects have no boundingBox &lt;sigh&gt;
				let bbRadius = sqrt( bbox[0]*bbox[0] + bbox[1]*bbox[1] + bbox[2]*bbox[2] ) / 2;
				// let z = bbRadius / 6; 							// all models scaled as a 6th for constant apparent size
				// - this assumes that the target &amp; vship are close in size, not always true!	thanks Dybal &amp; Milo

				// from the &#39;telescope-sniper.dat&#39; file, model has an outer radius of 42, inner is 40
				// historically, it&#39;s placed @ 50 meters and scaled by 1/6
				// multiply by vsize in [0.1 .. 0.8] (a tenth of VisualTargetNormalSize or VisualTargetCombatSize)
				// yields its collisionRadius in [0.6667 .. 5.333]
				// =&gt; ensure vship is as large as possible while not exceeding ring&#39;s inner radius (whether shown or not)
				let ringRadius = (40/6) * vsize;

				let vShipBBRad;
				if( curr_target.isStation || (SpicyHermits &amp;&amp; curr_target.isRock &amp;&amp; !curr_target.isFrangible)) {
					// station effects have different collisionRadius than actual station
					vShipBBRad = bbRadius;
				} else {										
					vShipBBRad = bbRadius &lt; vsCR ? vsCR : bbRadius; // use larger so subEntities will be enclosed by model&#39;s ring
				}
				let scaling = ringRadius / vShipBBRad;
				if( scaling &gt; 0 ) {									// factor out vsize, as user can change on the fly
					vShipScale = scaling / vsize;					// - in position_and_orient, vShip.scale( vShipScale * vsize );
					vsizechanged = true;							// signal for update of scaling, position
					// return true;
					return false;
					// - delay illumination sequence until next frame
				} else {
					log(ws.name, &#39;mk_vship, unable to scale effect ... removing: &#39; + add_key );
				}
			}
		}
		return false;
	}

	var basic_models = [ &quot;adder&quot;, &quot;anaconda&quot;, &quot;asp&quot;, &quot;boa&quot;, &quot;boa-mk2&quot;, &#39;buoy&#39;, &quot;cobra&quot;, &quot;cobra3&quot;, &quot;cobramk1&quot;,
						 &quot;ferdelance&quot;, &quot;moray&quot;, &quot;morayMED&quot;, &quot;python&quot;, //original player ships
						 &quot;base&quot;, &quot;corvette&quot;, &quot;cruiser&quot;, &quot;drone&quot;, &quot;freighter&quot;, &quot;frigate&quot;,
						 &quot;fighter&quot;, &quot;gunship&quot;, &quot;miner&quot;, &quot;runner&quot; ]; //custom ships

	function _showVShip( dkey ) {									//Show Visual Effect
		if( _showVShip.maxGrayLevel === undefined )					// store length so not checked every frame
			_showVShip.maxGrayLevel = grayLevels.length;			//	 (it&#39;s static)
		var maxGrayLevel = _showVShip.maxGrayLevel;

		HUD_vars_init = false;
		let clear_it = true;
		do {
			if( ShowVisualTarget === 0 ) break;						// turned off by user
			if( !weaponsOnline
				&amp;&amp; ( ShowVisualTarget &lt; 1 || VisualTargetNormalSize === 0 ) )
				break;												// turned off by user
			if( weaponsOnline
				&amp;&amp; ( ShowVisualTarget &lt; 2 || VisualTargetCombatSize === 0 ) )
				break;												// turned off by user
			if( moving_fast ) {
				vShipSuspended = ps_torusEngaged;					// turn off model until torus ends (too jittery)
				if( vShipSuspended )
					break;
			} else {
				vShipSuspended = false;
			}
			if( viewDirection !== &#39;VIEW_FORWARD&#39; ) break;			// not facing forward
			if( ws.$FixedTel !== 0 ) break;							// cheap repair
			if( !curr_target ) break;
			if( !ShowVisualStation &amp;&amp; curr_target.isStation ) break;  // don&#39;t show stations
			if( _has_bad_status( curr_target ) ) break;
			if( curr_S &amp;&amp; curr_S.map &amp;&amp; curr_S.map.rank === &#39;ukn&#39; )
				break;												// lost target
			clear_it = false;										// thru gauntlet, ok to show!
		} while( false );
		if( clear_it ) {
			clearVShip();
			return;
		}
		dataKey = dkey ? dkey : curr_target &amp;&amp; curr_target.dataKey;
		if( !dataKey || curr_target.radius							  // planet, moon or sun
					 || !curr_target.isValid ) {					  // nothing to show
			clearVShip();
			return;
		}
		if( !vShip || !vShip.isValid								 // no model or gone bad
				|| (vDataKey !== dataKey &amp;&amp; vDKsubst !== dataKey )) {// OR different target
			if( vShip ) vShip.remove();
			vShip = null;
		}
		var made_ship = false;
//if( debug &amp;&amp; !vShip ) log(ws.name, &quot;_showVShip, dataKey = &quot;+dataKey+&quot;, vShip &quot;+vShip+&quot;, isStation &quot;+curr_target.isStation+&quot;, ShowVisualStation &quot;+ShowVisualStation);//debug
		if( !vShip ) {
			made_ship = mk_vship();									// 1st try ship&#39;s dataKey
		}
		let find_dk = &#39;&#39;;
		if( !vShip ) {												// next, try basic model
			let idx = basic_models.length;
			while( idx-- ) {										// in reverse so longer names match 1st
				let model = basic_models[ idx ];
				if( dataKey.indexOf( model ) &gt;= 0 ) {
					find_dk = model;
					break;
				}
			}
			if( find_dk !== &#39;&#39; ) {
				made_ship = mk_vship( find_dk, true );
			}
		}
		if( !vShip &amp;&amp; ShowVisualQuestionMark ) {					 //fallback
			made_ship = mk_vship( &#39;oolite-unknown-ship&#39;, true );
		}
		if( !vShip ) {
			clearVShip(); //silent fallback
			return;
		}

		if( vDKsubst !== &#39;oolite-unknown-ship&#39; &amp;&amp; !curr_target.isRock &amp;&amp; // do not illuminate the question mark/rocks
			!made_ship &amp;&amp; brightnessLevel &lt; maxGrayLevel ) {		// do not illuminate on same call as made_ship (both are expensive)
																	//	 as illuminate	doubles _showVShip execution time
			let call_it = illuminate.start !== 0;					// is current level done?
			if( !call_it ) {										// if it is, check if time for next
				let absSeconds = clock.absoluteSeconds;
				if( absSeconds - lastGrayLevelTime &gt; 0.1 ) {		// time to do next level
					call_it = true;
					lastGrayLevelTime = absSeconds;
				}
			}
			if( call_it ) {
				if( illuminate() &amp;&amp; realtime_fps ) {				// only incr when current level complete
					if( realtime_fps() &gt; 50 ) {						// relatively fast PC
						brightnessLevel++;							// gradually increase brightness as telescope gathers light
					} else {										// PC is slow
						brightnessLevel = maxGrayLevel;				// display at maxGrayLevel immediately
					}
				}
			}
		}
		
		position_and_orient();
	}

	function calc_effects_vars( forSniper ) {						// 1st apply shift for viewPosition, then shift for vShip
																	// NB: sRing_posn is used as an intermediary; when we need to
																	//	   show sniper ring, calculations are ready (ie. cost nothing
		var shift;													//	   as were needed by _showVShip anyway)
		if( haveViewPosn ) {
			copy_vector( ps_position, effect_start );
			shift = viewPosition[0];
			if( shift ) {
				scale_vector( ps_vectorRight, shift, vector );
				add_vectors( vector, effect_start, effect_start );
			}
			shift = viewPosition[1];
			if( shift ) {
				scale_vector( ps_vectorUp, shift, vector );
				add_vectors( vector, effect_start, effect_start );
			}
			shift = viewPosition[2];
			shift = shift ? shift + 50 : 50;						// all effects are forward +50 from viewPosition
			scale_vector( ps_vectorForward, shift, vector );
			add_vectors( vector, effect_start, effect_start );
		} else {
			scale_vector( ps_vectorForward, 50, vector );			// all effects are forward +50 from viewPosition
			add_vectors( vector, ps_position, effect_start );
		}
		copy_vector( effect_start, sRing_posn );
		if( !forSniper ) {											// called for vShip (so calc&#39;s for sniper are free)
			copy_vector( effect_start, effect_viewposn );			// apply any vShipShift
			if( haveHUDShift ) {
				shift = vShipShift[0];
				if( shift ) {
					scale_vector( ps_vectorRight, shift, vector );
					add_vectors( vector, effect_viewposn, effect_viewposn );
				}
				shift = vShipShift[1];
				if( shift ) {
					scale_vector( ps_vectorUp, shift, vector );
					add_vectors( vector, effect_viewposn, effect_viewposn );
				}
				shift = vShipShift[2];
				if( shift ) {
					scale_vector( ps_vectorForward, shift, vector );
					add_vectors( vector, effect_viewposn, effect_viewposn );
				}
			}
		}
		if( target_vector.length === 0 ) {							// not initialized by _update_target_marker
			copy_vector( target_posn, vector );
			subtract_vectors( vector, ps_position, target_vector );
			unit_vector( target_vector, target_direction );
		}
		HUD_vars_init = true;										// prevents unnecessary call from sniper_ring()
	}

	var ring_color = [];											// working vector for position_and_orient, sniper_ring
	var vShipSuspended = false;										// stop showing vShip when speed gets too high, ie. Torus drive

	function position_and_orient() {								//orient vship model
		var that = position_and_orient;
		var model_orientation = (that.model_orientation = that.model_orientation || []);

		if( !vShip || !vShip.isValid || vShip.radius ) return;
		calc_effects_vars();

		// update model&#39;s position
		if( vsizechanged ) {
			if( vShip.dataKey === &#39;oolite-unknown-ship&#39; ) {			// custom sized
				vShip.scale( 10*vsize - 2 );
			} else {
				let z = vShipScale * vsize;
				if( z &gt; 0 ) {
					vShip.scale( z ); //shrink
// log(&#39;position_and_orient, scaling vShip by &#39; + (vShipScale * vsize).toFixed(4)+ &#39;, not z: &#39; + z.toFixed(4));
				}
			}
		}

		var up = 18;	// arbitrarily chosen height; user can alter w/ viewPosition
		// calc alignment so top is constant: vsize*6 is radius of model/ring; 24*( 0.75 - wide ) carry over - needed for HUDs???
		copy_vector( effect_viewposn, vShip_posn );
		// wide &lt; 1, === gameWindow.height / gameWindow.width; ///widescreen correction
		// is 0.75 for std screen, 0.625, 0.546875, etc. for wide screens
		scale_vector( ps_vectorUp, ( up - vsize*6 - 24*( 0.75 - wide ) ), vector );
		add_vectors( vector, vShip_posn, vShip_posn );
		vShip.position = vShip_posn;

/*
		// - frame_delta is set by call to _hud_effects() which preceeds _reposition_effects()
		var dotP = dot_product( ps_vectorForward, target_direction );
		// - more sensitive to change in frame rate for ents parallel to heading, less so when perpendicular

		var contract = 250 + (250 * ps_speed/(ps_maxSpeed * 32));	// base amt for all directions
		if( dotP &gt;= 0 ) {											// moving towards light ball
			contract += 0.5 * travel * dotP;
		} else {													// moving away from light ball
			contract += -1.5 * travel * dotP;
		}
		let adjust = -100 * ( floor(contract/100) ); 				// to hundreds to reduce jitter
		scale_vector( target_direction, adjust, speed_adj );
		add_vectors( dst_posn, speed_adj, dst_posn );
 */

///

/*
if( debug &amp;&amp; vsizechanged ) log(ws.name, &#39;position_and_orient, vShip.scaleX = &#39; + vShip.scaleX.toFixed(2)
	+ &#39;, vShip.position = [ &#39; + vShip_posn[0].toFixed() + &#39;, &#39; + vShip_posn[1].toFixed() + &#39;, &#39; + vShip_posn[2].toFixed() + &#39; ]&#39;
	+ &#39;, dist from ps = &#39; + ps.position.distanceTo(vShip).toFixed(2)
	+ &#39;, angled from Fwd, Up &amp; Right: &#39; + (ps.vectorForward.angleTo(vShip) * 180/Math.PI).toFixed(1) + &#39;, &#39;
										+ (ps.vectorUp.angleTo(vShip) * 180/Math.PI).toFixed(1) + &#39;, &#39;
										+ (ps.vectorRight.angleTo(vShip) * 180/Math.PI).toFixed(1) );
 */

		// orientate 3D model
		if( curr_target.isVisible									//orientation is known only if visible (Grav.Scanner can give position only)
				|| curr_S.map.ent_dist &lt;= scannerRange ) {			//	or in scannerRange (spec.case for small: missiles, drones, cargo, etc.)
																	//  which may be !isVisible well inside scannerRange
			let angle = angle_between_two_unitV( ps_vectorForward, target_direction );
			cross_product( ps_vectorForward, target_direction, cross );
			unit_vector( cross, cross );							// cross product of unit vectors not guaranteed to yield a unit vector
			copy_quaternion( curr_target.orientation, model_orientation );
			rotate_about_axis( model_orientation, cross, -angle, quaternion );
		} else {													//nonvisible, fixed view only
			let fixed = vShip.isStation ? PI + 0.22					//stations facing
										: QUARTER_ARC + 0.22;		///ships viewed from top (90 degree plus a bit)
			if( vShip.isMainStation ) {								//rotate to horizontal dock position
				rotate_about_axis( ps_orientation, ps_vectorRight, fixed, model_orientation );
				copy_vector( vShip.vectorForward, vector );
				rotate_about_axis( model_orientation, vector, QUARTER_ARC, quaternion );
			} else {
				rotate_about_axis( ps_orientation, ps_vectorRight, fixed, quaternion );
			}
		}
		vShip.orientation = quaternion;

		// model&#39;s ring
		let ring_scale = (vsize * 1.05)/ 6;	 ///shrink
		if( VisualTargetRing &amp;&amp; ring_scale &gt; 0 ) {					//large visual target ring
			if( !vRing ) {
				vRing = addVisualEffect( &quot;telescope-sniper&quot;, vShip_posn );
				if( exact_same_vectors( ModelRingColor, VECTOR_ALL_ZEROS ) ) {		// special directives to match reticle color
					copy_vector( ps.reticleColorTarget, ring_color, true );			// cannot cache reticleColors, as hud could change
				} else if( exact_same_vectors( ModelRingColor, VECTOR_ALL_ONES ) ) {// special directives to match locking reticle color
					copy_vector( ps.reticleColorTargetSensitive, ring_color, true );
				} else {
					copy_vector( ModelRingColor, ring_color, true );
				}	// 3rd parm to copy_vector prevents parm validation
				vRing.setMaterials( { &quot;telescope-ring.png&quot;: { emission_color: ring_color } } );
					// from effecdata: materials = { &quot;telescope-ring.png&quot; = { emission_color = darkGrayColor;};}
				vRing.scale( ring_scale );
			} else {
				vRing.position = vShip_posn;
				if( vsizechanged ) {								//if weapons switched on/off set new size (small/large)
					vRing.scale( ring_scale ); ///shrink
				}
			}

			vRing.orientation = ps_orientation;
ws.$vring = vRing;//debug
		} else if( vRing ) {
			vRing.remove();
			vRing = null;
		}
		vsizechanged = false;
	}

	function sniper_ring() {										//Visual FrameCallBack for the small sniper ring
		if( !curr_target 											// lost target
// 			|| SniperRange &lt;= SniperMinRange						// turned off by user
// simplified options by having single toggle
			|| SniperRingSize === 0									// turned off by user
			|| (_getShowState() &amp; _currSniperRingFlags()) === 0		// turned off by user in this state
			|| ws.$FixedTel !== 0 ) {								// no target or cheap repairs
			if( sniper )
				clear_SnipeRing();
			return;
		}
/*
		if( sniper &amp;&amp; sniper.$TelescopeSniperTarget !== curr_target ) {
			clear_SnipeRing();
		}
 */
		var snipertarget = false;
		if( !HUD_vars_init ) calc_effects_vars( true );				// true limits calcs to those for sniper ring only
		distance = vector_magnitude( target_vector );
		let ctCR = curr_target.collisionRadius;
		if( distance - ctCR &lt; SniperRange &amp;&amp; distance - ctCR &gt; SniperMinRange ) {
/*
			if( angle_between_two_unitV( ps_vectorForward, target_vector ) &lt; QUARTER_ARC ) { //to exclude aft line-up
				let dratio = -2 * distance / ctCR;                   //distant and smaller target tracked with larger ring movement
				let ax = dratio * ( angle_between_two_unitV( ps_vectorRight, target_vector ) - QUARTER_ARC );
				let ay = dratio * ( angle_between_two_unitV( ps_vectorUp, target_vector ) - QUARTER_ARC );
				if( abs_v( ax ) &lt; 5 &amp;&amp;  abs_v( ay ) &lt; 6 * wide ) {  //ay&lt;4 if 4:3, &lt;3.4 if 16:9
 */			// new method yields same magnitude for ax, ay

			if( dot_product( target_direction, ps_vectorForward ) &gt; 0 ) { //to exclude aft line-up
				/* core code shoots from weapon position, sets reticle using view position
				   w/o adjustment, separation of view &amp; weapon will mk sniper ring innaccurate
					eg. DTT PE has viewPosition.y of 4.9 &amp; weaponPosition.y of 13.5 (laser is almost 9m above view)
						which places sniper ring too low  */
				let dratio = 0;
				if( SniperLock &amp;&amp; SniperLock.deactivate === &quot;FALSE&quot; &amp;&amp; SniperLock.sniperlockchangeflag === &quot;ON&quot; ) {
					let slsTargetPosn = SniperLock.sniperlocktargetlastposition3;
					copy_vector( slsTargetPosn, vector );
					subtract_vectors( vector, ps_position, vector );// make new target_vector
					distance = vector_magnitude( vector );
					dratio = -distance / ctCR;
					unit_vector( vector, vector );					// make new target_direction
				} else if( SniperLockPlus &amp;&amp; SniperLockPlus.$enabled &amp;&amp; SniperLockPlus.$slpState === &quot;ON&quot; ) {
					let slpsTargetPosn = SniperLockPlus.$slpTargetPosition_3;
					copy_vector( slpsTargetPosn, vector );
					subtract_vectors( vector, ps_position, vector );// make new target_vector
					distance = vector_magnitude( vector );
					dratio = -distance / ctCR;
					unit_vector( vector, vector );					// make new target_direction
				} else if( haveWeaponPosn ) {						// correct for weapon position offset wrt viewPositionForward
					// dybal&#39;s solution from sniperlock_plus
					subtract_vectors( weaponZOffset, weaponPosition, sRingCorrection );
					rotate_vector( sRingCorrection, ps_orientation )
					add_vectors( target_posn, sRingCorrection, vector )// shift target position by sRingCorrection
					subtract_vectors( vector, ps_position, vector );// make new target_vector
					distance = vector_magnitude( vector );			// ok to clobber distance here as not used again
					dratio = -distance / ctCR;
					unit_vector( vector, vector );					// make new target_direction
				} else {
					dratio = -distance / ctCR;						//distant and smaller target tracked with larger ring movement
					copy_vector( target_direction, vector );
				}
				let ax = dratio * dot_product( vector, ps_vectorRight ),
					ay = dratio * dot_product( vector, ps_vectorUp );
				if( abs( ax ) &lt; 5 &amp;&amp; abs( ay ) &lt; 6 * wide  ) {	//ay&lt;4 if 4:3, &lt;3.4 if 16:9
				// - restored original&#39;s criteria
				// if( abs( ax ) &lt; 4 &amp;&amp; abs( ay ) &lt; 4  ) {	//ay&lt;4 if 4:3, &lt;3.4 if 16:9
					scale_vector( ps_vectorRight, ax, vector );	//show misalignment
					add_vectors( vector, sRing_posn, sRing_posn );
					scale_vector( ps_vectorUp, ay, vector );
					add_vectors( vector, sRing_posn, sRing_posn );
					if( sniper ) {
						sniper.position = sRing_posn;
					} else {
						sniper = addVisualEffect( &quot;telescope-ring&quot;, sRing_posn);
						// sniper.$TelescopeSniperTarget = curr_target;
ws.$sniper = sniper; // debug
						sniper.scale( 0.01 * SniperRingSize );		//shrink
						if( exact_same_vectors( SniperRingColor, VECTOR_ALL_ZEROS ) ) {		// special directives to match reticle color
							copy_vector( ps.reticleColorTarget, ring_color, true );			// cannot cache reticleColors, as hud could change
						} else if( exact_same_vectors( SniperRingColor, VECTOR_ALL_ONES ) ) {// special directives to match locking reticle color
							copy_vector( ps.reticleColorTargetSensitive, ring_color, true );
						} else {
							copy_vector( SniperRingColor, ring_color, true );
						}	// 3rd parm to copy_vector prevents parm validation
						sniper.setMaterials( { &quot;telescope-ring.png&quot;: { emission_color: ring_color, diffuse_color: ring_color } } );
					}
					sniper.orientation = ps_orientation;
					snipertarget = true;
				}
			}
		}

		if( sniper &amp;&amp; !snipertarget ) {
			clear_SnipeRing();
		}

	}

	var frame_delta = 0;											// store this frame&#39;s delta; see apply_speed_adj
	var scanner_cooldown = 0;										// cool down period between consecutive scans
	function _hud_effects( delta ) {								//Visual FrameCallBack
		try {
			if( !ps_vectorRight || !curr_S.ent ) return;			// in case not set (eg. console load)
			// &quot;If you turn off the weapons with the underscore button (&quot;_&quot;) then a scan happens and you enter
			//	into &quot;Navigation Mode&quot;, where autolock helps you see through targets (called Panorama targeting):
			//	continually relocks to the most centered target.&quot; (from readme)
			frame_delta = delta;
			scanner_cooldown = scanner_cooldown &gt; delta ? scanner_cooldown - delta : 0;
			if( weaponsOnline ) {									//gravity scan if weapons turned off
				if( !weaps ) {										//state changed to on
					if( curr_S.marker_type === &#39;marker&#39; ) {			// clear far target
						switch_PS_target( null );
					}
					weaps = true;									//save state
					let new_size = VisualTargetCombatSize / 10;
					vsizechanged = vsize !== new_size;
					vsize = new_size;
					_resetIdentDelay();								// reset counter for IdentDelay
					if( gs_state === GS_NONE ) {
						scanner_cooldown = 5;						// (sec.) delay to start next scan
					} else if( gs_state === GS_COMPLETE ) {
						scanner_cooldown = 10;						// (sec.) delay to start next gravity scan
					}
				}
			} else if( weaps ) {									//state changed to off
				weaps = false;										//save state
				let new_size = VisualTargetNormalSize / 10;
				vsizechanged = vsize !== new_size;
				vsize = new_size;
				_resetIdentDelay();									// reset counter for IdentDelay
				var scanning = fns_are_pending();					// true =&gt; mapping creation/update is running
				if( !scanning &amp;&amp; scanner_cooldown === 0 )
					_auto_updates( gs_state &lt;= GS_STOPPED );		// user starts a &#39;rescan&#39; unless scan in progress
				report_status = true;
			}
			if( !mappingReady || maplen === 0 ) {					// wait for mapping to be built OR it&#39;s empty
				return;
			}
			if( viewDirection !== &#39;VIEW_FORWARD&#39; ) {				//working in forward view only
				_clear_HUD_Effects();
				return;
			}
			dataKey = curr_target &amp;&amp; curr_target.dataKey;
			var valid_target = dataKey &amp;&amp; curr_target.isValid;		// check dataKey to exclude wormholes &amp; orbs (have no dataKey)
			if( !valid_target || (vShip &amp;&amp; !vShip.isValid) ) {		// no ship to update
				_clear_HUD_Effects();
				return;
			}
			if( curr_target.isStation ) {							// turn off hud effect when docking
				distance = _detect_distanceTo( curr_target );
				if( distance &lt; 500 ) {
					copy_vector( curr_target.position, vector );
					subtract_vectors( vector, ps_position, vector );
					unit_vector( vector, vector );
					let dockDot = dot_product( vector, curr_target.vectorForward );
					let headingDot = dot_product( ps_vectorForward, curr_target.vectorForward );
					if( dockDot &lt; -0.95 &amp;&amp; headingDot &lt; -0.95 ) {	// in front of dock, pointing in its direction
						_clear_HUD_Effects();
						return;
					}
				}
			}
			_showVShip( dataKey );
			sniper_ring();
		} catch( err ) {
			log( ws.name, &#39;vsize = &#39; + vsize + &#39;, vShipScale = &#39; + vShipScale
					+ &#39;, dataKey: &#39; + dataKey + &#39;, valid_target: &#39; + valid_target + &#39;, curr_target: &#39; + curr_target
					+ &#39;\n\t vShip.isValid is &#39; + (vShip === null ? &#39;not available&#39; : vShip.isValid)
					+ &#39;, vRing.isValid is &#39; + (vRing === null ? &#39;not available&#39; : vRing.isValid)
					+ &#39;, sniper.isValid is &#39; + (sniper === null ? &#39;not available&#39; : sniper.isValid) );
			log( ws.name, ws._reportError( err, &#39;hud_effects&#39;, delta ) );
			if( debug ) throw err;
		}
	}

	// All functions called from outside closure are wrapped in try..catch blocks.
	// In the key: value pairs below, values that do not start with &#39;_&#39; are
	// entry stubs containing try..catch blocks that call the underscored value, (so they&#39;re not nested)

	return {
					 _initOxpVars: _initOxpVars,
				_init_player_vars: init_player_vars,			// entry stub
				   _reload_config: _reload_config,
				   _adjustMLFlags: _adjustMLFlags,
					_getShowState: _getShowState,
				_getShowStateText: _getShowStateText,
					 _currMLFlags: _currMLFlags,
			  _shutdown_Sightings: shutdown_Sightings,			// entry stub
		  _restart_after_shutdown: _restart_after_shutdown,
				  _has_bad_status: has_bad_status,				// entry stub
				  _Sighting_index: Sighting_index,				// entry stub
			   _set_curr_Sighting: set_curr_Sighting,			// entry stub
					_add_Sighting: add_Sighting,				// entry stub
				 _delete_Sighting: delete_Sighting,				// entry stub
			   _chg_curr_Sighting: chg_curr_Sighting,			// entry stub
				_nearest_Sighting: nearest_Sighting,			// entry stub
			  _reposition_effects: _reposition_effects,
				_update_Sightings: update_Sightings,			// entry stub
						 _newList: newList,						// entry stub
					_call_pending: _call_pending,
				_create_Sightings: create_Sightings,			// entry stub
			_update_target_marker: _update_target_marker,
				   _manage_marker: manage_marker,				// entry stub
					_mostCentered: mostCentered,				// entry stub
					_auto_updates: auto_updates,				// entry stub
				 _resetIdentDelay: _resetIdentDelay,
						_steerFCB: _steerFCB,
			   _clear_HUD_Effects: _clear_HUD_Effects,
					   _showVShip: _showVShip,
				  _set_vShip_posn: _set_vShip_posn,
					 _hud_effects: _hud_effects,
			   _relativeDirection: relativeDirection,			// entry stub
				   _report_config: report_config,				// entry stub
				 _report_autovars: _report_autovars,

		// for debugging
				reset_common_vars: reset_common_vars,
					index_in_list: index_in_list,
					  getDetected: getDetected,
					   is_hostile: is_hostile,
				   grav_scan_dist: grav_scan_dist,
				  check_Sightings: check_Sightings,
				 select_Sightings: select_Sightings,
					  add_lt_ball: add_lt_ball,
				   lb_effect_size: lb_effect_size,
				   update_lt_ball: update_lt_ball,
					  add_ml_ring: add_ml_ring,
				   ml_effect_size: ml_effect_size,
				   update_ml_ring: update_ml_ring,
					proc_stealthy: proc_stealthy,
			  update_one_Sighting: update_one_Sighting,
					  update_some: refresh_Sightings,
					classify_ship: classify_ship,
				  is_ignored_ship: is_ignored_ship,
			  process_new_targets: process_new_targets,
				  fns_are_pending: fns_are_pending,
				   set_fn_pending: set_fn_pending,
				clear_all_pending: clear_all_pending,
					 show_pending: show_pending,
					grow_new_list: grow_new_list,
					  notable_ent: notable_ent,
			 check_if_new_targets: check_if_new_targets,
					  update_MFDs: update_MFDs,
					   qualifyMFD: qualifyMFD,
				  set_displayName: set_displayName,
				   showTargetName: showTargetName,
				   showShipReport: showShipReport,
					entityIsNamed: entityIsNamed,
					planetIsNamed: planetIsNamed,
						  sunName: sunName,
						  orbName: orbName,
				 planetNameString: planetNameString,
			 report_scan_progress: report_scan_progress,

/* for profiling (see also debug loading iife
			time_create: time_create,		 //cagiife
			time_update: time_update,		 //cagiife
			time_refresh: time_refresh,		   //cagiife
			profile_create: profile_create,		   //cagiife
			profile_update: profile_update,		   //cagiife
			profile_refresh: profile_refresh,		 //cagiife
			set_profiling:	set_profiling,		  //cagiife
			clear_profiling: clear_profiling,		 //cagiife
*/
	}



// };				// end of closure
}.bind(this); // get [native code] in debugger rather than entire function



}).call(this);	// end of strict function call
// }).call(worldScripts.telescope);

// run  ws._shutdown_Sightings()  BEFORE reloading entire script!
// run  ws.startUp() afterwards
// run  ws.startUpComplete() afterwards












</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/telescope_debug.js</td>
                    <td><pre>this.name		 = &quot;telescope_debug&quot;;
this.author		 = &quot;cag&quot;;
this.copyright	 = &quot;2017 cag&quot;;
this.licence	 = &quot;CC BY-NC-SA 3.0&quot;;
this.description = &quot;debugging helper fns&quot;;
this.version	 = &quot;1.0&quot;;

/* jshint elision:true, shadow:false, esnext: true, curly: false, maxerr: 1000, asi: true, laxbreak: true, undef: true, unused:true
*/
/* global log, worldScripts, Script, Vector3D, Quaternion
*/

(function(){
/* validthis: true
*/
&quot;use strict&quot;;

// false prevents output, though functions are still tracked
// - except with start&#39;s header, if it&#39;s forced by a child fn&#39;s msg or by its stop&#39;s msg.
// So putting text in a stop will force output of start&#39;s header when there&#39;s no regular
// output from add, begin or end
// - useful for exceptional situations, where a fn quits early: put a stop w/ msg before the return
//	 and output start&#39;s header as well; only see the fn output when something interesting happens
this.$fns_watched = {
&#39;shipSpawned&#39;:				false,
&#39;shipScoopedOther&#39;:			false,
&#39;update_one_Sighting&#39;:		true,
&#39;_update_some_Sighting&#39;:	true,
&#39;_update_Sightings&#39;:		false,
&#39;_delete_Sighting&#39;:			true,
&#39;_add_Sighting&#39;:			true
};

// worldScripts.telescope.$cag.init();

this.$project_name = &#39;telescope&#39;;

this.$DEBUG_CONSOLE_WIDTH = 200;
this.$DEBUG_OFF = true;
//this.$DEBUG_OFF = false;

this._display_map = function _display_map( map ) {
	var that = _display_map;
	var _showProps = ( that._showProps = that._showProps || worldScripts.telescope_debug._showProps );
	
	if( map.hasOwnProperty( &#39;map&#39; ) ) {
		map = map.map;
	}
	var tmp = _showProps( map, &#39;map&#39;, false, true, true );
	const MFD_FRIENDLY = 1,		// bounty === 0 &amp;&amp; !markedForFines
		  MFD_UNSOCIABLE = 2,	// bounty || markedForFines
		  MFD_ACTIVE = 4,		// has .target || defenseTargets.length &gt; 0
		  MFD_HOSTILE = 8,		// in_ents_Targets || targeting_ps
		  	MFD_ATTITUDE = 15,	// those of 1st 4 flags used to choose targets
		  MFD_NEARBY = 16,		// distance &lt; scannerRange
		  MFD_PROTECTED = 32,	// .withinStationAegis
		  MFD_FARAWAY = 64,		// distance &gt; scannerRange
		  	MFD_RANGED = 112;	// those of prev. 3 flags used to limit those chosen
	const MFD_SALVAGE = 1,		// cargo, escape pods, derelicts
		  MFD_MINING = 2,		// asteroids, boulders, splinters &amp; metal fragments
		  MFD_WEAPONS = 4,		// mines &amp; missiles
//		  	MFD_INANIMATE = 7,	// those of 1st 3 flags excluded from dynamic filtering
		  MFD_TRADERS = 8,		// ships .isTrader &amp; escorts
		  MFD_POLICE = 16,		// scanClass === &#39;CLASS_POLICE&#39;
		  MFD_PIRATES = 32,		// .isPirate &amp; .isPirateVictim
		  MFD_MILITARY = 64,	// scanClass === &#39;CLASS_MILITARY&#39;
		  MFD_ALIENS = 128,		// scanClass === &#39;CLASS_THARGOID&#39;
		  MFD_NEUTRAL = 256,	// scanClass === &#39;CLASS_NEUTRAL&#39; and not in any above category (e.g., miners, hunters, etc.)
//		  	MFD_ALLSHIPS = 504,	// all of the previous 6
		  MFD_STATION = 512,	// .isStation
		  MFD_NAVIGATION = 1024,// some stations &amp; beacons (may include a ship if emitting a beacon)
		  MFD_CELESTIAL = 2048;	// sun, planets, moons
//		  	MFD_ORIENT = 3584;	// all of the previous 3

	tmp += &#39;\ndynamic flags&#39;;
	var flags = map.dynamicMFD;
	if( flags ) {
		if( flags &amp; MFD_FRIENDLY ) tmp += &#39;:  FRIENDLY&#39;;
		if( flags &amp; MFD_UNSOCIABLE ) tmp += &#39;:	UNSOCIABLE&#39;;
		if( flags &amp; MFD_ACTIVE ) tmp += &#39;:	ACTIVE&#39;;
		if( flags &amp; MFD_HOSTILE ) tmp += &#39;:	 HOSTILE&#39;;
		if( flags &amp; MFD_NEARBY ) tmp += &#39;:	NEARBY&#39;;
		if( flags &amp; MFD_FARAWAY ) tmp += &#39;:	 FARAWAY&#39;;
		if( flags &amp; MFD_PROTECTED ) tmp += &#39;:  PROTECTED&#39;;
	}
	tmp += &#39;\nstatic flags&#39;;
	flags = map.staticMFD;
	if( flags ) {
		if( flags &amp; MFD_SALVAGE ) tmp += &#39;:	 SALVAGE&#39;;
		if( flags &amp; MFD_MINING ) tmp += &#39;:	MINING&#39;;
		if( flags &amp; MFD_WEAPONS ) tmp += &#39;:	 WEAPONS&#39;;
		if( flags &amp; MFD_TRADERS ) tmp += &#39;:	 TRADERS&#39;;
		if( flags &amp; MFD_POLICE ) tmp += &#39;:	POLICE&#39;;
		if( flags &amp; MFD_PIRATES ) tmp += &#39;:	 PIRATES&#39;;
		if( flags &amp; MFD_MILITARY ) tmp += &#39;:  MILITARY&#39;;
		if( flags &amp; MFD_ALIENS ) tmp += &#39;:	ALIENS&#39;;
		if( flags &amp; MFD_STATION ) tmp += &#39;:	 STATION&#39;;
		if( flags &amp; MFD_NAVIGATION ) tmp += &#39;:	NAVIGATION&#39;;
		if( flags &amp; MFD_CELESTIAL ) tmp += &#39;:  CELESTIAL&#39;;
	}
	log( tmp );
}

this._dump_map = function _dump_map() {		// dump Sightings list for telescope
	var that = _dump_map;
	var cd = ( that.cd = that.cd || worldScripts.telescope_debug );
	var ws = ( that.ws = that.ws || worldScripts.telescope );
	var curr_S = ( that.curr_S = that.curr_S || ws.$curr_Sighting );
	
	var pst = curr_S.ent || null;
	var mapping = ws.$SightingsMap, maplen = mapping.length;
	var map, ent, target, thargoids = &#39;&#39;;
	var out = &#39;____ent_dist.rank   index	 rel. dir.n		 person	   [entity description minus position, scanClass &amp; status labels ...]	 [ve_colour,  lb_size,	ml_size]\n&#39;;
	// var out = &#39;____ent_dist.rank   index	 rel. dir.n	   curr.grav.D	 person	   [entity description minus position, scanClass &amp; status labels ...]	 [ve_colour,  lb_size,	ml_size]\n&#39;;
	var i, padding = &#39;________________&#39;;
	var	 ent_dist, rank, index, rel_dir, gs_curr, entID, descrn, gs_maxed;
	for( i = 0; i &lt; maplen; i++ ) {
		map = mapping[i]; ent = map.ent;
		gs_curr = map.gs_curr_dist;
		gs_maxed = gs_curr &gt; 0 &amp;&amp; gs_curr === map.gs_max_dist;
		target = pst &amp;&amp; pst === ent;
		if(ent.isThargoid) { out += ent+&#39;\n&#39;;
			thargoids += &#39;.	   dataKey = &#39;+map.dataKey+&#39;, last_posn = &#39;+map.last_posn+&#39; roles = &#39;+map.roles+&#39;\n&#39;;
		}
		ent_dist = map.ent_dist;
		if( ent_dist &gt;= 1e15 )
			ent_dist = cd._number_str( ent_dist / 1e15 ) + &#39; e15&#39;;
		else if( ent_dist &gt;= 1e12 )
			ent_dist = cd._number_str( ent_dist / 1e12, 1 ) + &#39; e12&#39;;
		else if( ent_dist &gt;= 1e9 )
			ent_dist = cd._number_str( ent_dist / 1e9, 2 ) + &#39; e9&#39;;
		else if( ent_dist &gt;= 1e6 )
			ent_dist = cd._number_str( ent_dist / 1e6, 3 ) + &#39; e6&#39;;
		else
			ent_dist = cd._number_str( ent_dist );
		ent_dist = padding.slice( ent_dist.length - 11 ) + ent_dist; // max column width is 10 (&#39;123.456 e6&#39;) + 5 (&#39;_ISR_&#39;)
		if( target ) {
			// ent_dist = ent_dist.replace(/^_*/, &#39;==&gt;&#39;);
			ent_dist = ent_dist[1] == &#39;_&#39; ? &#39;=&gt;&#39; + ent_dist.substring(2) :
					   ent_dist[0] == &#39;_&#39; ? &#39;|&gt;&#39; + ent_dist.substring(1) :
					   &#39;&gt;&#39; + ent_dist;
		}
		rank = map.rank.toUpperCase();
		index = i &lt; 10 ? &#39;__&#39; + i : i &gt; 99 ? i : &#39;_&#39; + i;
		rel_dir = ws._relativeDirection( ent.position, map );		
		rel_dir = rel_dir ? padding.slice( rel_dir.length-9 ) + rel_dir : &#39;???&#39;;
		// gs_curr = cd._number_str( gs_curr );							
		// gs_curr = padding.slice( gs_curr.length-(gs_maxed ? 10 : 11) ) + gs_curr;
		entID = ent.entityPersonality;
		entID = entID === undefined ? &#39;xxxxx&#39; : entID.toString();	
		entID = padding.slice( entID.length-6 ) + entID;
		descrn = ent.toString();
		descrn = descrn.replace(/position\: /, &#39;&#39; );
		descrn = descrn.replace(/scanClass\: /, &#39;__&#39; );
		descrn = descrn.replace(/CLASS_/, &#39;&#39; );
		descrn = descrn.replace(/status\: /, &#39;__&#39; );
		descrn = descrn.replace(/STATUS_/, &#39;&#39; );
		out += ent_dist+&#39;_&#39;+rank
		out += map.swapable ? &#39;%&#39; : &#39;_&#39;;
		out += &#39;	[&#39;+index+&#39;]&#39;+(target ? &#39;|&gt;&#39; : &#39;  &#39;)+&#39;[&#39;+rel_dir+&#39;]&#39;
			+(target ? &#39;|&gt;&#39; : &#39;  &#39;)
			// +&#39;[&#39;+gs_curr+(gs_maxed ? &#39; M&#39; : &#39;]&#39;)
			+&#39; #&#39;+entID+&#39;  &#39;
			+descrn+&#39;	[&#39;+map.ve_colour+&#39;, &#39;+map.lb_size+&#39;, &#39;+map.ml_size+&#39;]&#39;+(target ? &#39;&lt;==&#39; : &#39;&#39;)
//			  +&#39; Ms: &#39;+ map.staticMFD.toString(2)+&#39; Md: &#39;+map.dynamicMFD.toString(2)
			+&#39; stat: &#39;+ cd._number_str( map.staticMFD, 0, 2 ) + &#39; dyn: &#39;+ cd._number_str( map.dynamicMFD, 0, 2)
			+ (map.have_scanned ? &#39; h_s: &#39; + map.have_scanned :&#39;&#39;)
			+&#39;\n&#39;;
	}
	out += &#39;ws.$SightingsMap.length = &#39; + mapping.length;
	log(out);
	if( thargoids ) log( &#39;Thargoids:\n&#39; + thargoids );
}

this._rel2PS = function rel2PS( name, position, distance ) {
	var cd = worldScripts.telescope_debug;
	var ps = player &amp;&amp; player.ship;
	var ps_position = ps.position;
	let posn =	position.constructor === Vector3D ? position :
				Array.isArray(position) ? new Vector3D( position ) :
				position.position || null;
	if( !posn ) {
		return &#39;missing position for &#39; + name;
	}
	let dist = distance || posn.distanceTo( ps_position );
	let padding = &#39;________________&#39;;
	let pname = padding.slice( name.length - 16 ) + name;
	if( name === &#39;lightball&#39; ) pname = &#39;__&#39; + pname;
	let vector = posn.subtract( ps_position );
	let fwd, right, up, rpt = &#39;&#39;;
	fwd =	( ps.vectorForward.angleTo( vector ) *180/3.1415927 ).toFixed();
	right =	( ps.vectorRight.angleTo( vector ) *180/3.1415927 ).toFixed();
	up =	( ps.vectorUp.angleTo( vector ) *180/3.1415927 ).toFixed();
	rpt += pname + &#39; is &#39; + ( fwd &lt;= 90 ? &#39;forward &#39; + fwd : &#39;astern &#39; + (fwd - 90) ) + &#39;, &#39;
							+ ( right &lt;= 90 ? &#39;	 starboard &#39; + right : &#39;		port &#39; + (right - 90)) + &#39;, &#39;
							+ ( up &lt;= 90 ? &#39;	above &#39;+ up : &#39;	   below &#39; + (up - 90)) 
							+ &#39; at &#39; + cd._number_str( dist ) + &#39; m&#39;;
	// vector = vector.direction();
	// fwd =	ps.vectorForward.dot( vector ).toFixed(5);
	// right =	ps.vectorRight.dot( vector ).toFixed(5);
	// up =	ps.vectorUp.dot( vector ).toFixed(5);
	// rpt += &#39;\n\t&#39; + pname + &#39; is &#39; + ( fwd &gt;= 0 ? &#39;forward &#39; : &#39;astern &#39; ) + ( Math.acos(fwd) *180/3.1415927 ).toFixed() + &#39;, &#39;
							// + ( right &gt;= 0 ? &#39;  starboard &#39; : &#39;		  port &#39;) + ( Math.acos(right) *180/3.1415927 ).toFixed() + &#39;, &#39;
							// + ( up &gt;= 0 ? &#39;	  above &#39; : &#39;	 below &#39;) +	 ( Math.acos(up) *180/3.1415927 ).toFixed()
							// + &#39; at &#39; + cd._number_str( dist ) + &#39; m&#39;;
	return rpt;
}

this._curr_S_report = function _curr_S_report() {
	var cd = worldScripts.telescope_debug;
	var cs = worldScripts.telescope.$curr_Sighting;
	var ps = player &amp;&amp; player.ship;
	var scannerRange = ps.scannerRange;

	let map = cs.map;
	if( !map ) {
		log(&#39;telescope&#39;, &#39;_curr_S_report, $curr_Sighting.map is &#39; + map );
		return;
	}
	let ent = cs.ent;
	let map_ent_dist = cs.map.ent_dist;
	let marker = cs.marker;
	let lightball = cs.map.lightball;
	let tmp = &#39;ps.speed = &#39; + ps.speed + &#39;,	   viewDirection = &#39; + ps.viewDirection + &#39;,  for &#39; + ent;
	tmp += &#39;\n &#39; + cd._rel2PS( &#39;ent&#39;, ent, map.ent_dist );
	if( marker )
		tmp += &#39;\n &#39; + cd._rel2PS( &#39;marker&#39;, marker	 );
	if( lightball )
		tmp += &#39;\n &#39; + cd._rel2PS( &#39;lightball&#39;, lightball );
//	let ent_posn = map.rank === &#39;ukn&#39;  ? map.last_posn : ent.position;

	let marker_dist = scannerRange - 499.6;
	if( map_ent_dist &lt; scannerRange ) {
		if( map_ent_dist &lt; marker_dist )
			marker_dist = map_ent_dist;
	}
//	let targ_dir = ent_posn.subtract( ps_position ).direction();
//	let targ_posn = ps_position.add( targ_dir.multiply( marker_dist ) );//.add( speed_adj );
//	tmp += &#39;\n &#39; + cd._rel2PS( &#39;new marker&#39;, targ_posn, marker_dist );

	log(&#39;telescope&#39;, tmp );
}

// debugger ///////////////////////////////////////////////////////////////////////////////////////

/*	(function () {
WS.telescope.$cag = worldScripts.telescope_debug._debug_msgs();
WS.telescope.$cag.init();
})()	// */

this._debug_msgs = function _debug_msgs() {
	function break_line( str, limit ) {			// break str into lines, avoiding splitting on an &#39;=&#39; if poss.
		function trim( x ) {											// return index of 1st non-whitespace char.
			var space;
			var index = x;											// never modify arguments
			do {
				space = str[ index ];
				if( space !== &#39; &#39; &amp;&amp; space !== &#39;\t&#39; ) break;
				index++;
			} while( index &lt; str.length );
			return index;
		}
		function output( x ) {										// push indices for next line; return true if finished w/ str
			var index = x;											// never modify arguments
			strptr = trim( strptr );
			lines.push( [ strptr, index ] );
			index = trim( index );
			if( index + limit &gt;= str.length ) {						// just tail end remains
				lines.push( [ index, -1 ] );
				return true;										// finished w/ str
			}
			strptr = index;		i = index + limit;		first = -1;		newline = -1;
			return false;											// still more to output
		}
		function _seek( dir ) {										// walk str in direction dir across whitespace; return presence of an &#39;=&#39;
			var equals = false;
			do {													// scan in direction dir for end of whitespace or an &#39;=&#39;
				if( i + dir &lt; 0 || i + dir &gt;= str.length ) break;	// protect limits
				i += dir;
				letter = str[ i ];
				if( letter === &#39;=&#39; ) equals = true;
			} while( letter === &#39; &#39; || letter === &#39;\t&#39; || letter === &#39;=&#39; );
			i -= dir;
			return equals;											// return presence of an &#39;=&#39;
		}
		var first = -1;		var letter, i;		var newline = -1;
		var lines = [];		var strptr = 0;
		for( i = strptr + limit; i &gt; strptr; i-- ) {
			if( newline === -1 ) {
				newline = str.indexOf( &#39;\n&#39;, strptr );
				if( newline &gt;= strptr &amp;&amp; newline &lt;= i )				// respect imbedded newlines
					if( output( newline + 1 ) ) break;
			} else
				newline = 0;										// only check once per output()
			letter = str[ i ];
			if( letter === &#39; &#39; || letter === &#39;\t&#39; ) {
				if( _seek( 1 ) || _seek( -1 ) ) {					// look fwd &amp; back for &#39;=&#39;s; found a bad break, ie. has &#39;=&#39;
					if( first &lt; 0 ) first = i;						// save the first, just in case
				} else {
					if( output( i ) ) break;						// i pts to 1st letter in break
					continue;
				}
			}
			if( i - strptr &lt;= 20 ) {								// no good break bound; reasonable lower limit on line length
				if( first &gt; -1 ) {									// use previously found (bad) break
					if( output( first ) ) break;
				} else {											// no break found, arbitrary cut using limit
					if( output( strptr + limit ) ) break;
				}
			}
		}
		return lines;
	}

	function insert( str, frame ) {				// insert str into frame&#39;s msg buffer
		var msg_len = frame.msg.length;
		var pad_len = frame.pad.length;
		var str_len = str.length;
		if( msg_len === 0 ) {										// pad the 1st line
			frame.len = pad_len;									// will be added on output but need to account for its length now
		}
		if( str_len + frame.len	 &gt; DEBUG_CONSOLE_WIDTH ) {			// begin a new line
			var lines = break_line( str, DEBUG_CONSOLE_WIDTH - pad_len );
			var start, end, i;
			for( i = 0; i &lt; lines.length; i ++ ) {
				[start, end] = lines[ i ];
				frame.msg += str.substring( start, ( end === -1 ? str_len : end ) ) + &#39;\n&#39;;
			}
		} else {
			frame.msg += ( msg_len &gt; 0 ? &#39;	&#39; : &#39;&#39; ) + str;
		}
		var nl_index = frame.msg.lastIndexOf( &#39;\n&#39;, msg_len );
		if( nl_index &gt; -1 ) {										// calc length of last line in msg
			frame.len = msg_len - nl_index;							// &#39;\n&#39; has length of 1
		} else {
			frame.len = msg_len;
		}
	}

	function is_watched_fn( dbgfn, str ) {		// check user supplied $fns_watched to determine if msg should proceed
		var caller = frame.caller;
		if( fns_watched.length === 0 ) return true;					// fn limiting not used
		if( frame === null ) {
			log( project_name, &#39;ERR: _debug, null frame: debug cmd outside start...stop sequence.  is_watched_fn:  &#39;+dbgfn+&#39;:  str = &#39;+str+&#39;\n############&#39;);
			return true; // allow in hopes of locating errant cmd
		}
		if( !fns_watched.hasOwnProperty( caller ) ) return false;	// fn limiting is in play but fn missing -&gt; deny by default
		if( fns_watched[ caller ] !== true )						// its in use, fn found but turned off
			return false;
		return true;												// fn in list &amp; set true!
	}

	function trim_space( str ) {				// trim white space at start &amp; end of line; -can&#39;t use .trim() as it removes line breaks!
		return str.replace(/^[ \t\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]+|[ \t\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]+$/g, &#39;&#39;);
	}

	function change_breaks( line ) {			// collapse &amp; convert all line breaks
		return line.replace(/[\n\r\f\v\u00a0\u2028\u2029]+/g, &#39;&lt;BR&gt;&#39;);
	}

	function output() {							// called by stop to output or start to flush pre-existing msg
		if( DEBUG_OFF ) return;
		var incl_hd = frame.incl_hd;
		var msg = frame.msg;
		if( !incl_hd &amp;&amp; !msg )										// unless directed to output hd, only log if there&#39;s a msg
			return;													// excl. header when no msg
		if( incl_hd &amp;&amp; frame.out_len &gt; 0 )							// a force_hd not necess, as frame already has output
			return;
		var head = frame.head;
		var out = curr_pad + &#39;	&#39; + frame.caller + &#39;:: &#39;;			// 1st line of output always starts w/ the caller (.len incr&#39;d in .add)
		if( head ) out += head;										// .head contains a newline char
		out += msg;
		out = trim_space( out );
		out = change_breaks( out );
		out = out.replace( /(&lt;BR&gt;)+$/g, &#39;&#39; );						// trim any trailing line break
		out = out.replace( /(&lt;BR&gt;)+/g, &#39;\n&#39; + curr_pad + &#39;	&#39; );	// add padding to start of each line
		if( out.slice( - curr_pad.length ) === curr_pad )			// out ends w/ just a pad
			out = out.slice( 0, - curr_pad.length );
		if( frame.logging ) log( project_name, out );				// writes to console and log file
		else				log( out );								// writes only to console
		frame.out_len += out.length;
		frame.head = &#39;&#39;;	msg = &#39;&#39;;	frame.len = 0;
		frame.incl_hd = false;										// reset for next time
	}

	function add_msg( via, str, format ) {		// insert format str into msg buffer
		if( !is_watched_fn( via, str ) ) return;
		if( !str ) return;
		if( stack.length === 0 )
			log( project_name, &#39;ERR: debug, no debug frame: check for premature &quot;.stop()&quot; or add a &quot;.start()&quot; statement. .&#39; + via + &#39;:	str = &#39; + str +&#39;\n############&#39;);
		insert( format, frame );
	}

	// add( str ) - append str to output msg
	function add( str ) {						// user fn to append str to msg
		if( DEBUG_OFF ) return;
		add_msg( &#39;add&#39;, str, str );
	}

	// begin( str ) - output str at start of a new line (prepends a newline)
	function begin( str ) {						// user fn to begin a new line w/ str
		if( DEBUG_OFF ) return;
		add_msg( &#39;begin&#39;, str, (frame.len &gt; 0 ? &#39;\n&#39; + str : str) );
	}

	// end( str ) - output str at end of curr. line (appends a newline)
	function end( str ) {						// user fn to end the current line w/ str
		if( DEBUG_OFF ) return;
		add_msg( &#39;end&#39;, str, str +&#39;\n&#39; );
	}

	// log_file( str, [con_log], [caller] )	 - stand-alone user fn to add output to log file
	//										 - it ignores $DEBUG_OFF flag but terminates any further action if true
	//										 - con_log flag can be used to output to console as well, in curr. frame
	//										 - caller may be from any previous frame; if not found &amp; con_log is true, output added to current frame
	function log_file( str, con_log, caller ) {	// output data to log file independent of the current frame
		log( project_name, caller + &#39;, &#39; + str );					// writes to log file
		if( DEBUG_OFF ) return;										// debugger if off, so just log msg
		if( stack.length === 0 )	return;							// no active frame
		if( con_log === undefined ) return;
		if( caller === undefined ) {								// add str to curr. frame
			add( str );
			return;
		}
		var prev;
		var len = stack.length;
		for( var i = 0; i &lt; len; i ++ ) {
			prev = stack[ i ].caller;
			if( prev === caller ) {
				insert( str, prev )									// add str to caller&#39;s frame
				return;
			}
		}
		add( str );													// failed to locate caller, add to curr. frame
	}

	function Frame( c ) {	this.caller = c;		this.head = &#39;&#39;;			this.msg = &#39;&#39;;
							this.pad = &#39;&#39;;			this.out_len = 0;		this.len = 0;
							this.incl_hd = false;	this.force_hd = 1;		this.logging = false;		}
	var used_frames = [];
	var used_frame_num = 0;
	function free_frame( frame ) {
//log(&#39;telescope&#39;, &#39;free_frame, for caller = &#39; + frame.caller + &#39;, pool totals &#39; + (used_frame_num + 1)+ &#39;, on stack: &#39; + (stack.length - 1) );
		frame.caller = null;	frame.head = &#39;&#39;;		frame.msg = &#39;&#39;;
		frame.pad = &#39;&#39;;			frame.out_len = 0;		frame.len = 0;
		frame.incl_hd = false;	frame.force_hd = 1;		frame.logging = false;
		used_frames.push( frame );
		used_frame_num++;
	}
	function alloc_frame( caller ) {
		var frame;
		if( used_frame_num &gt; 0 ) {
			frame = used_frames.pop();
			used_frame_num--
			frame.caller = caller;
//log(&#39;telescope&#39;, &#39;alloc_frame for caller = &#39; + caller + &#39;, allocating recycled frame, pool totals &#39; + used_frame_num + &#39;, on stack: &#39; + (stack.length + 1) );
		} else {
			frame = new Frame( caller );
log(&#39;telescope&#39;, &#39;alloc_frame, for caller = &#39; + caller + &#39;, allocating NEW frame, pool totals &#39; + used_frame_num + &#39;, on stack: &#39; + (stack.length + 1) );
		}
		stack.push( frame );
		return frame;
	}

	// start( caller, [hd], [force_hd], [logging] )	 - open new debug level; caller is function&#39;s name (output toggled in $fns_watched)
	//												 - hd is str (heading) that is output only if more str&#39;s comes in
	//												 - force_hd, an int, over-rules this (default = 1; see Frame object).
	//												   this give some context when a normally silent fn outputs a msg,
	//												   by showing who called it. The higher the number, the farther up the frame stack
	//												   headers are forced to output
	//												 - logging is a boolean to also write to log file (vs. debug console only)
	function start( caller, hd,					// user fn to init a msg frame, start&#39;s hd string is not counted in len, so if
					force_hd, logging ) {		// no fn msg&#39;s between start &amp; stop, no output
		if( DEBUG_OFF ) return;
		var len = stack.length;
		if( len &gt; 0 ) {												// not the root frame
			output();												// flush any pending output
			var fn_name = caller !== undefined ? caller
											   : &#39;Anonomous&#39; + stack.length;
			var prev;
			for( var i = len -1; i &gt;= 0; i-- ) {					// check not already on stack (fix for GDERM bug)
				prev = stack[ i ].caller;
				if( prev === fn_name ) {
					free_frame( stack.splice( i, 1 )[0] );
					curr_pad = curr_pad.slice( 0, -PAD_LEN );		// just remove that one entry, as we know we&#39;re not recursing
				}
			}
		}
		frame = alloc_frame( caller );
		var tmp_pad;
		if( stack.length % 2 === 0 ) tmp_pad = &#39;=========&#39;;			// alternate padding char&#39;s
		else						 tmp_pad = &#39;+++++++++&#39;;
		frame.pad = tmp_pad.substr( 0, PAD_LEN );
		curr_pad += frame.pad;
		if( caller !== undefined ) {
			frame.caller = caller;
			frame.len += frame.caller.length;
		} else {
			log( project_name, &#39;ERR: _debug, invalid caller: function name needed for output to be formatted correctly. .start: str = &#39; + hd +&#39;\n############&#39;);
		}
		if( frame === null ) {
			log( project_name, &#39;ERR: _debug, internal error: unable to create frame; stack len = &#39; + len + &#39;, .start:  caller: &#39;+caller+&#39;(),  str = &#39; + hd +&#39;\n############&#39;);
		}
		if( logging !== undefined )	 frame.logging = logging;
		if( force_hd !== undefined ) frame.force_hd = force_hd;
		if( hd !== undefined ) {
			tmp_pad = curr_pad;										// save current padding str and clear curr_pad
			curr_pad = &#39;&#39;;											//	 so we don&#39;t put any padding on the header
			insert( hd + &#39;\n&#39;, frame );								// a start header always ends its output line
			curr_pad = tmp_pad;										// restore current padding
		}
		frame.head = trim_space( frame.msg );						// move to head
		frame.msg = &#39;&#39;;
		frame.len = 0;												// reset len as header doesn&#39;t count
	}

	// _stop( caller, [str], [nolog] ) - close curr. level or regress to it if events interruped sequence; nolog suppresses log file output,
	//									 over-ruling logging flag in start
	function stop( caller, str, nolog ) {		// user fn to terminate a frame, ouputting any pending messages
		if( DEBUG_OFF ) return;
var have_str = str &amp;&amp; str.length &gt; 0; // debug
		if( caller === undefined )
			log( project_name, &#39;ERR: _debug, missing caller: function name needed for output to be formatted correctly. .stop:	str = &#39; + str +&#39;\n############&#39;);
		if( frame === null )
			log( project_name, &#39;ERR: _debug, no debug frame: add a &quot;start()&quot; statement. .stop:	caller: &#39;+caller+&#39;(), str = &#39; + str +&#39;\n############&#39;);
		if( str &amp;&amp; caller === frame.caller ) {
			insert( &#39;\n&#39; + str, frame );
have_str = false;
		}
		if( nolog !== undefined ) frame.logging = !nolog;			// nolog over-rules frame.logging
		if( stack.length &gt; 0 ) {
			var msg_len = frame.msg.length;
			output();												// flush any pending output
			if( stack.length &gt; 1 ) {								// not the root frame
				var force_hd = ( msg_len &gt; 0 ? frame.force_hd : 0 );
				if( force_hd &gt; 0 ) {								// set higher frame(s) to output
					var i = stack.length;
					while( i-- &amp;&amp; force_hd &gt; 0 ) {
						stack[ i ].incl_hd = true;
						force_hd--;
					}
				}
			}
			free_frame( frame );
			frame = stack.pop();
			if( str &amp;&amp; caller === frame.caller ) {				// for when a .stop is skipped
				log( project_name, &#39;ERR: _debug, missed .stop(): &#39; + frame.caller + &#39;() stopped while &#39; + caller + &#39;() still active. .stop:	 str = &#39; + str +&#39;\n############&#39;);
				insert( &#39;\n&#39; + str, frame );					// still output msg
have_str = false;
			}
			curr_pad = curr_pad.slice( 0, -PAD_LEN );
		} else {
			frame = alloc_frame( caller );							// re-init safely after having lost track!
		}
if( have_str ) log(&#39;telescope&#39;, &#39;debug.stop, failed to output: &#39; + str );
	}

	function reset() {							// reset msg stack; meant for debug console but is also a user fn
		var len;
		len = stack.length;
		while( len-- ) {
			free_frame( stack[ len ] );
		}
		stack.length = 0;						// this will clear all ref&#39;s to frame objects
		frame = null;
		PAD_LEN = 3;
		curr_pad = &#39;&#39;;
	}
	function init( project ) {					// import local var&#39;s at runtime by calling this fn
		var wc = worldScripts.telescope_debug;
		if( project ) {
			project_name = wc.$project_name = project;
		} else {
			project_name = wc.$project_name;
		}
		fns_watched = wc.$fns_watched;
		DEBUG_CONSOLE_WIDTH = wc.$DEBUG_CONSOLE_WIDTH;
		DEBUG_OFF = wc.$DEBUG_OFF;
	}

	var frame = null;
	var stack = [];		// stack built of Frame&#39;s when debugging fns are nested
	var PAD_LEN = 3;	// max 9 unless you enlarge 2 padding str&#39;s in start
	var curr_pad = &#39;&#39;;
	var project_name, fns_watched, DEBUG_CONSOLE_WIDTH, DEBUG_OFF;

	return {	 init:	init,
				  add:	add,
				begin:	begin,
				  end:	end,
			 log_file:	log_file,
				reset:	reset,
				start:	start,
				 stop:	stop
	};
}

// debugger ends //////////////////////////////////////////////////////////////////////////////////

this._reportError = function _reportError( err, func, parms, depth, goDeep ) {
	// constants - adjust as needed
	var FILE_LEN = 100;		// cut-off len for file spec.
	var FNAME_LEN = 40;		// cut-off len for function name
	var ARGS_LEN = 60;		// cut-off len for arguments string
	var STRING_LEN = 80;	// cut-off for long strings
	var IPAD = &#39; &#39;;			// inside padding, eg. after array open bracket, before close bracket
/*	
	err		(required) value passed in the catch statement
	
	func	(required) function that caught the error
			- can also be a string with the function&#39;s name if the
			  function is not named
			  eg. this.startUp = function() { ...			-&gt; pass &#39;startUp&#39;
			      this.startUp = function startUp() { ...	-&gt; pass startUp
			- using a named function has the advantage of reporting 
			  any function properties  
				
	parms	(optional) parameters passed to func
			- if there are multiple parms, pass them in an array
			- can also include function variables if you want more 
			  information dumped
			  eg. this.shipSpawned = function shipSpawned( ship ) { 
					var dist = player.ship.position.distanceTo( ship ); ...
			      -&gt; pass as parms: [ship, dist] to have both displayed
				  
	depth	(optional) # levels to expose contents of parameters/properties
			- default is 1, use 0 to suppress overly long output
			  eg. if a parm is an array of 3 items, 0 will print &quot;&lt;array of 3&gt;&quot;,
				  1 will print &quot;[ item1, item2, item3 ]&quot;
				  - if item3 is an object: &quot;[ item1, item2, &lt;object of ..&gt; ]&quot;
				  2 will print the contents of each item, in this case, 
				    expanding the object
				  3 will expand the object&#39;s properties, etc
				  (ditto for nested arrays)
			- NB: depth &gt; 2 will likely produce large output, eg. ships
			- will accept a 2 item array if you want different depths for 
			  parameters vs. properties, ie. [ parm depth, prop depth ]
			  eg. [ 2, 1 ]
			
	goDeep	(optional) boolean indicating whether or not to test hasOwnProperty
			when exposing properties
			- default is false meaning inherited properties won&#39;t be shown
			- eg. if you dump player.ship, false shows 63 properties, while true 
				  shows 226! (player properties + ship properties + entity properties)
			- inherited properties are prefixed by a caret &#39;^&#39;
				
	example usage:
	=============
	
	this.relativeDirection = function relativeDirection( position, map ) {
		var that = relativeDirection;
		var ws = ( that.ws = that.ws || worldScripts.telescope );
		var ps = player &amp;&amp; player.ship;
		
		try {
			var dist = map.ent.positon.distanceTo( ps );			&lt;== position mis-spelled
			...
			return relative_dirn;
		} catch( err ) {
			log( &#39;telescope&#39;, ws._reportError( err, relativeDirection, [position, map], 1 ) );
			if( debug ) 
				throw err;									
		}
	}

	Latest.log output:
	=================
		
	18:48:27.293 [LogEvents]: Asteroid 28897 spawned at 413 km
	18:48:27.898 [telescope]:
	function relativeDirection() 	 caught: 	TypeError: map.ent.positon is undefined
		parameters: [ (70839.2, -96302.7, 664477), &lt;object of 6&gt; ]
		properties: { ws: &lt;object of 169&gt; }
		file: ../AddOns/Norby.cag.Telescope.oxp/Scripts/telescope.js
			line: 6204,	relativeDirection( [object Vector3D], [object Object] )
		file: ../AddOns/Norby.cag.Telescope.oxp/Scripts/telescope_debug.js
			line:   47,	_display_map( [object Object] )
	18:48:27.899 [script.javaScript.exception.unexpectedType]: ***** JavaScript exception (oolite-debug-console 1.89): TypeError: map.ent.positon is undefined
	18:48:27.899 [script.javaScript.exception.unexpectedType]:       ../AddOns/Basic-debug.oxp/Scripts/oolite-debug-console.js, line 1117.
*/
		
	function trim_str( str ) {
		var result, len = str.length;
		if( len === 0 ) 
			return &#39;&lt;empty string&gt;&#39;;
		result = str.replace( /[\u180e\u2000-\u200a\u202f\u205f\u3000]+/g, &#39; &#39; );
		result = result.replace( /[\n]+/g, &#39;\\n&#39; ).replace( /[\t]+/g, &#39;\\t&#39; )
		result = &#39;&quot;&#39; + (len &gt; STRING_LEN ? result.substr(0, STRING_LEN) + &#39; ...&#39; : result) + &#39;&quot;&#39;;
		return result
	}

	var padding = [];
	function mkSpacePad( count ) {
		if( typeof count === &#39;number&#39; ) {
			padding.length = count + 1;
			return padding.join(&#39; &#39;);
		}
		return &#39; &#39;;
	}
 
	function countObjKeys( obj, deep ) {	// Object.keys( obj ).length only counts hasOwnProperty ones
		var count = 0;						// deep overrides goDeep
		if( goDeep || deep ) {
			for( let prop in obj ) 
				if( prop )					// this is just to silence JSLint
					count++;
		} else {
			count = Object.keys( obj ).length;
		}
		return count;
	}
	
	function rptType( obj ) {
		if( Array.isArray( obj ) ) {
			let len = obj.length;
			return len &gt; 0 ? &#39;&lt;array of &#39; + len + &#39;&gt;&#39; : &#39;[]&#39;;
		} else if( obj instanceof Script ) {
			return &#39;[Script &quot;&#39; + obj.name + &#39;&quot; version &#39; + obj.version + &#39;]&#39;;
		} else if( typeof obj === &#39;object&#39; ) {
			let len = countObjKeys( obj, true );	// ignore goDeep when counting
			return len &gt; 0 ? &#39;&lt;object of &#39; + len + &#39;&gt;&#39; : &#39;{}&#39;;
		} else {
			return obj;
		} 
	}
	
	function hasComplex( obj ) {
		for( let prop in obj ) {
			if( goDeep || obj.hasOwnProperty( prop ) ) {
				let item = obj[ prop ];
				if( Array.isArray( item ) || (typeof item === &#39;object&#39; &amp;&amp; item !== null) )
					return true;
			}
		}
		return false;
	}

	function showComplex( obj, recurse ) {		
		var isArray = Array.isArray( obj );
		var len = isArray ? obj.length : countObjKeys( obj );
		if( len === 0 ) return isArray ? &#39;[]&#39; : &#39;{}&#39;;
		var index = 0, 
			str = (isArray ? &#39;[&#39; : &#39;{&#39;) + IPAD, 
			strLen = str.length;
		var recursable = recurse &gt; 0 &amp;&amp; hasComplex( obj );
		for( let prop in obj ) {
			if( goDeep || obj.hasOwnProperty( prop ) ) {
				let item = obj[ prop ];
				let propStr = isArray ? &#39;&#39; : 
							(goDeep &amp;&amp; !obj.hasOwnProperty( prop ) ? &#39;^&#39; : &#39;&#39;) + prop + &#39;: &#39;;
				let propLen = propStr.length;
				str += propStr;
				if( recursable ) {
					if( index === 0 ) {
						outStarts.push( (outStarts.length &gt; 0 
										? outStarts[outStarts.length-1] + propLen + strLen
										: strLen + propLen + strLen) );
					}
					str += fmt_parm( item, recurse );
					if( index &lt; len - 1 ) {		// not the last one
						let inset = outStarts.length &gt; 1 ? outStarts[outStarts.length-2] : strLen;
						str += &#39;,\n&#39; + mkSpacePad( indentLen + inset );
					} else {
						str += IPAD;
					}
				} else {
					str += hasComplex( item ) ? rptType( item ) : fmt_parm( item, 0 );
					str += index &lt; len - 1 ? &#39;, &#39; : IPAD;
				}
				index++;
			}
		}
		if( recursable &amp;&amp; index ) outStarts.pop();
		return str + (isArray ? &#39;]&#39; : &#39;}&#39;);
	}
	
	var outStarts = [];	// stack of running total of recursed insets
	var parents = [];	// check parm not in parents to avoid endless recursion
	function fmt_parm( parm, recurse ) {
		if( parents.indexOf( parm ) &lt; 0 ) {
			parents.push( parm );
		} else  {
			return parm;
		} 
		var type = typeof parm;
		var str = &#39;&#39;;
		if( parm === null ) {
			str += &#39;null&#39;;
		} else if( type === &#39;undefined&#39; ) {
			str += &#39;undefined&#39;;
		} else if( type === &#39;string&#39; ) {
			str += trim_str( parm );
		} else if( type === &#39;boolean&#39; ) {
			str += (parm ? &#39;true&#39; : &#39;false&#39;);
		} else if( type === &#39;function&#39; ) {
			str += &#39;function &#39; + parm.name + &#39;()&#39;;
		} else if( parm instanceof Script ) {
			str += &#39;[Script &quot;&#39; + parm.name + &#39;&quot; version &#39; + parm.version + &#39;]&#39;;
		} else if( parm instanceof Vector3D ) {
			str += &#39;Vector3D: (&#39; + parm.x.toFixed() + &#39;, &#39; 
					+ parm.y.toFixed() + &#39;, &#39; + parm.z.toFixed() + &#39;)&#39;;
		} else if( parm instanceof Quaternion ) {
			str += &#39;Quaternion: (&#39; + parm.w.toFixed() + &#39; + &#39; + parm.x.toFixed() + &#39;i + &#39; 
					+ parm.y.toFixed() + &#39;j + &#39; + parm.z.toFixed() + &#39;k)&#39;;
		} else if( Array.isArray( parm ) ) {
			str += showComplex( parm, recurse &lt;= 1 ? 0 : recurse - 1 );
		} else if( type === &#39;object&#39; &amp;&amp; parm ) {
			str += showComplex( parm, recurse &lt;= 1 ? 0 : recurse - 1 );
		} else {
			str += rptType( parm );
		}
		parents.pop();
		return str;
	}

	var funcProps = {};
	function propsNotName( obj ) {
		if( typeof obj !== &#39;function&#39; ) return 0;	// backwards compatibity
		for( let key in funcProps ) {				// reset object
			if( funcProps.hasOwnProperty( key ) )
				delete funcProps[ key ];
		}
		for( let key in obj ) {
			if( key !== &#39;name&#39; )
				funcProps[ key ] = obj[ key ];
		}
		return Object.keys( funcProps ).length;
	}
	
	var parmsLabel = &#39;\n    parameters: &#39;;
	var indentLen = parmsLabel.length - 1;	// -1 for \n
	var fnName = typeof func === &#39;function&#39; ? func.name : func; // backwards compatibity
	var rpt, parmMax, propMax,
		bonus = Array.isArray( parms ) ? 1 : 0;			// don&#39;t count parms being an array as recursion (+ 1)
	if( Array.isArray( depth ) ) {
		parmMax = (depth.length &gt; 0 &amp;&amp; typeof depth[ 0 ] === &#39;number&#39; ? ~~(depth[ 0 ]) : 1) + bonus;
		propMax = (depth.length &gt; 1 &amp;&amp; typeof depth[ 1 ] === &#39;number&#39; ? ~~(depth[ 1 ]) : 1) + bonus;
	} else {
		parmMax = propMax = (typeof depth === &#39;number&#39; ? ~~(depth) : 1) + bonus;
	}
	if( err instanceof Error ) {
		rpt = &#39;\nfunction &#39; + fnName + &#39;() \t caught: \t&#39; + err.name + &#39;: &#39; + err.message;
	} else {		// for thrown strings (user defined errors)
		rpt = &#39;\nfunction &#39; + fnName + &#39;() \t caught: \t&#39; + err;
	}
	if( parms ) {
		rpt += parmsLabel + fmt_parm( parms, parmMax );
	}
	if( propsNotName( func ) ) {
		parmsLabel = &#39;\n    properties: &#39;;
		indentLen = parmsLabel.length - 1;	// -1 for \n
		rpt += parmsLabel + fmt_parm( funcProps, propMax + 1 );	// + 1 as funcProps is an object
	}
	
	// err is the stack object with properties: message, fileName, lineNumber, stack, name
	//  - stack is a long string containing &lt;function call&gt;@&lt;filename&gt;:&lt;line #&gt; separated by
	//    &#39;\n&#39; for each call in the stack
	if( err &amp;&amp; err.stack ) {
		var lastFile, parsed, frame, fnCall, args, file, line, pad;
		var stk = err.stack.split( /[\n\r]+/ ); // split on line breaks
		for( let i = 0, len = stk.length; i &lt; len; i ++ ) {
			// stack line format: fn(parms)@../AddOns/.../script.js:123
			parsed = stk[ i ].match( /^\s*(\w+)\((.*?)\)@(.*?):(.*?)$/ );
			if( !parsed || parsed.length &lt; 5 ) break;
			[frame, fnCall, args, file, line] = parsed;
			if( file &amp;&amp; file !== lastFile ) {	// suppress repeat of same filename
				if( file.length &gt; FILE_LEN ) 
					file = file.substring( file.length - FILE_LEN ) + &#39;...&#39;;
				rpt += &#39;\n    file: &#39; + file;
				lastFile = file;
			}
			pad = line &lt; 10 ? &#39;   &#39; : line &lt; 100 ? &#39;  &#39; : line &lt; 1000 ? &#39; &#39; : &#39;&#39; ;
			rpt += &#39;\n        line: &#39; + pad + line + &#39;,	&#39;; 
			if( fnCall.length &gt; FNAME_LEN ) fnCall = fnCall.substring(0, FNAME_LEN) + &#39;...&#39;;
			if( args.length &gt; ARGS_LEN ) args = args.substring(0, ARGS_LEN) + &#39;...&#39;;
			if( args.length ) 					// add spaces inside function&#39;s parenthices
				args = &#39; &#39; + args.replace( /,/g, &#39;, &#39; ) + &#39; &#39;;
			rpt += fnCall + &#39;(&#39; + args + &#39;)&#39;;	
		}
	}
	return rpt;
}
	
this._number_str = function _number_str( n, fixed, base ) {
	var that = _number_str;
	var round = ( that.round = that.round || Math.round );
	var working = ( that.working = that.working || [] );

	var comma, index, wk, len, str;
	str = typeof n === &#39;string&#39; ? parseFloat( n ) : n;
	if( !isFinite( str ) ) return n.toString();
	str = fixed &gt; 0 ? str.toFixed( fixed ).toString( base || 10 )
					: round( str ).toString( base || 10 );
	len = str.length;
	working.length = wk = 0;
	for( index = 0; index &lt; len; index++ ) working[ index ] = str[ index ];
	index = str.indexOf( &#39;.&#39; );
	comma = index &gt;=0 ? (index &gt; 0 ? index - 1 : 0) : len - 1;
	for( ; comma &gt; 0 ; comma -= 3 ) {
		index = comma - 2;
		if( (n &lt; 0 ? index-1 : index) &lt;= 0 ) break;
		for( wk = len - 1; wk &gt;= index; wk-- )
			working[ wk + 1 ] = working[ wk ];
		working[ index ] = &#39;,&#39;;
		len = working.length;
	}
	return working.join( &#39;&#39; );
}

//	worldScripts.telescope_debug
//	worldScripts.telescope_debug._showProps( cs.map, &#39;map&#39; )
//	worldScripts.telescope_debug._showProps( cs.map, &#39;map&#39;, false,	false,	true )
//	worldScripts.telescope_debug._showProps( cs.map, &#39;map&#39;, true )
//	worldScripts.telescope_debug._showProps( cs.map, &#39;map&#39;, true,		false,	true )
//	worldScripts.telescope_debug._showProps( cs.map, &#39;map&#39;, false,	true )
//	worldScripts.telescope_debug._showProps( cs.map, &#39;map&#39;, false,	true,	true )
//	worldScripts.telescope_debug._showProps( cs.map, &#39;map&#39;, true,		true,	true )
//	worldScripts.telescope_debug._showProps( cs.map, &#39;map&#39;, false,	2,		true )

//	worldScripts.telescope_debug._showProps =

this._showProps =	function _showProps( obj, objName, newLine, show_deep, expand_arrays, show_type ) {
	//										default:	true	true (1)		true			false
	function trim_str( str ) {
		var result, len = str.length;
		if( len === 0 ) 
			return &#39;&lt;empty string&gt;&#39;;
		result = str.replace( /[\u180e\u2000-\u200a\u202f\u205f\u3000]+/g, &#39; &#39; );
		result = result.replace( /[ ]{3:}/g, &#39;  &#39; );
		result = result.replace( /[\n]+/g, &#39;\\n&#39; ).replace( /[\t]+/g, &#39;\\t&#39; )
		// result = str.replace( /[\s]+/g, &#39; . &#39; );
		result = &#39;&quot;&#39; + (len &gt; 90 ? result.substr(0, 90) + &#39; ...&#39; : result) + &#39;&quot;&#39;;
		return result
	}

	function mkPad( i, suppress ) {
		if( i &lt;= 0 || suppress ) return &#39;&#39;;
		padding.length = newLine ? i : 1;
		return (newLine ? &#39;.&#39; :&#39;&#39;) + padding.join( &#39;    &#39; ); // &#39;.&#39; needed for console, as leading space trimmed
	}
	 
	function rptType( obj, showIt ) {
		if( Array.isArray( obj ) )
			return show_type || showIt ? &#39; &lt;array: &#39; + obj.length + &#39; elements&gt; &#39; : &#39;&#39;; 
		else if( typeof obj === &#39;object&#39; )
			return show_type || showIt ? &#39; &lt;object: &#39; + Object.keys( obj ).length + &#39; keys&gt; &#39; : &#39;&#39;; 
		else
			return &#39; &lt;&#39; + typeof obj + &#39;&gt; &#39;;
	}
 
	function show_array( array, recurse ) {
		if( array.length === 0 ) return &#39;[ ]&#39;;
		ilevel++;
		var str = &#39;[ &#39;;
		var pad = mkPad( ilevel, !expand_arrays );
		var len = array.length;
		for( var index = 0; index &lt; len; index ++ ) {
			str += !expand_arrays || !newLine ? (index &gt; 0 ? &#39;, &#39; : &#39;&#39;) : &#39;\n&#39;;
			str += pad;
			if( expand_arrays )
				str += index + &#39;: &#39; + fmt_prop( array[ index ], recurse );
			else
				str += fmt_prop( array[ index ], (recurse &lt;= 1 ? 0 : recurse - 1) );
		}
		ilevel--;
		if( len &gt; 0 &amp;&amp; expand_arrays &amp;&amp; newLine ) str += &#39;\n&#39;;
		str += mkPad( ilevel, !len || !expand_arrays ) + &#39; ]&#39; + rptType( array );
		return str;
	}

	function show_obj( obj, recurse ) {
		ilevel++;
		var str = &#39;{ &#39;;
		var pad = mkPad( ilevel );
		var len = Object.keys( obj ).length;
		for( var item in obj ) {
			str += newLine ? &#39;\n&#39; : &#39;    &#39;;
			str += pad;
			if( Array.isArray( obj ) ) {
				str += show_array( obj[ item ], recurse );
			} else {
				str += (obj.hasOwnProperty( item ) ? &#39;&#39; : &#39;^&#39;) + item + &#39;: &#39;;
				str += fmt_prop( obj[ item ], recurse );
			}
			str += &#39;;&#39;;
		}
		ilevel--;
		if( len &gt; 0 &amp;&amp; newLine ) str += &#39;\n&#39;;
		str += mkPad( ilevel, !len ) + &#39; }&#39; + rptType( obj );
		return str;
	}
	
	function fmt_prop( prop, recurse ) {
		if( parents.indexOf( prop ) &lt; 0 )
			parents.push( prop );
		else 
			return prop;
		var type = typeof prop;
		var str = &#39;&#39;;
		if( prop === null ) {
			str += &#39;null&#39;;
		} else if( type === &#39;undefined&#39; ) {
			str += &#39;undefined&#39;;
		} else if( type === &#39;string&#39; ) {
			str += trim_str( prop ) + (show_type ? &#39; &lt;string: &#39; + prop.length + &#39; char.s&gt;&#39; : &#39;&#39;);
		} else if( type === &#39;number&#39; ) {
			str +=	cd._number_str( prop, prop % 1 === 0 ? 0 : expand_arrays ? 3 : 1 )
					+ (show_type ? &#39; &lt;number&gt;&#39; : &#39;&#39;);
		} else if( type === &#39;boolean&#39; ) {
			str += prop + (show_type ? &#39; &lt;boolean&gt;&#39; : &#39;&#39;);
		} else if( type === &#39;function&#39; ) {
			str += &#39; function &#39; + prop.name + &#39;()&#39;;
		} else if( Array.isArray( prop ) ) {
			if( expand_arrays ) {
				str += show_array( prop, (recurse &lt;= 1 ? 0 : recurse - 1) );
			} else {
				str += rptType( prop, true );
			}
		} else if( type === &#39;object&#39; &amp;&amp; prop ) {
			if( recurse &gt; 0 ) {
				str += show_obj( prop, (recurse &lt;= 1 ? 0 : recurse - 1) );
			} else {
				str += rptType( prop, true );
			}
		} else {
			str += prop + (show_type ? &#39; &lt;&#39;+type+&#39;&gt;&#39; : &#39;&#39;);
		}
		parents.pop();
		return str;
	}
	
	var that = _showProps;
	var cd = ( that.cd = that.cd || worldScripts.telescope_debug );
	
	var padding = [], parents = [];
	if( show_type === undefined ) 		show_type = false;
	if( expand_arrays === undefined )	expand_arrays = true;	
	if( show_deep === undefined ) 		show_deep = 1;
	if( newLine === undefined ) 		newLine = true;
	var rmax = !show_deep ? 0 : show_deep === true ? 1 : ~~(show_deep);
	var ilevel = 1;

	return (newLine ? &#39;\n&#39; : &#39; &#39;) + objName + &#39;: &#39; + fmt_prop( obj, rmax ) + (newLine ? &#39;\n&#39; : &#39;&#39;);
}

}).call(this);














</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/telescope_fps_monitor.js</td>
                    <td><pre>this.name        = &quot;telescope_fps_monitor&quot;;
this.author      = &quot;cag&quot;;
this.copyright   = &quot;2017 cag&quot;;
this.licence     = &quot;CC BY-NC-SA 4.0&quot;;
this.description = &quot;Monitor and report frames/sec, and optionally, various other stats, plus callback support.&quot;;
this.version     = &quot;1.2&quot;;

/* global addFrameCallback, isValidFrameCallback, log, player, removeFrameCallback, Uint8Array
 */
 
/// stripped down version of fps_monitor for running with Telescope 

this._fps_monitor_closure = (function _fps_monitor_closure() { 
    &quot;use strict&quot;;
	// closure is self-initiating, doing so when it loads, so there no need to call it

	var that = _fps_monitor_closure;
    
    /*  user settings  */
    
    var OXP_NAME = &#39;&lt;&lt;your oxp&gt;&gt;&#39;; // required! used as 1st parm in call to log(); can also be set 
                                   //   if you call _init_fps_monitor( &#39;&lt;&lt;your oxp&gt;&gt;&#39; )
    // reporting
    var N_MINUTES = 1;             // minutes, frequency of reporting on last minute&#39;s stats (default 1, 0 to turn off)
    var SHORT_TERM = 15;           // minutes, &gt; 1, time interval for short term report (default 15, 0 to turn off)
    var LONG_TERM = 60;            // minutes, &gt; 1, time interval for long term report (default 60, 0 to turn off)
    var FPS_ONLY = false;          // stores and reports only fps value
    var FILE_LOG = true;           // write to the log file results for 3 time periods just mentioned
    var CONSOLE_LOG = false;       // echo the reports to in-game console
    var CONSOLE_TIME = 5;          // seconds, 1-10, duration of in-game console message (default 5)

    // calculations
    var TRUNC_LOW = 10;            // seconds, &gt; 0, for discarding low outliers before calculating fps (default 10, 0 to turn off)
    var TRUNC_HIGH = 5;            // seconds, &gt; 0, for discarding high outliers before calculating fps (default 5, 0 to turn off)
    var HARMONIC_MEAN = false;     // when true, calc harmonic rather than arithmetic mean, for less sensitivity to outliers

    // these next 5 booleans turn on extra values for reports and return values for data fetch functions
    // - computed every minute together w/ fps; relative order is always:  median, mode, mean, high, low
    
    var MEDIAN = true;             // fps rate that has equal # of values before/after it in the minute
                                   // - averaged over SHORT_TERM and LONG_TERM
    var MODE = false;              // fps rate with the most hits in the minute
                                   // - averaged over SHORT_TERM and LONG_TERM
    var MEAN = false;              // arithmetic mean (simple average), not very useful, included for completeness
                                   // - averaged over SHORT_TERM and LONG_TERM
    var HIGH = true;               // highest frame count in a second in the term
    var LOW = true;                // lowest frame count in a second in the term

    /*  user functions  */
    
    function _setup_fps_report( minutes, shortterm, longterm, filelog, console, duration ) { // set reporting variables
        // set values of N_MINUTES, SHORT_TERM, LONG_TERM, FILE_LOG, CONSOLE_LOG, CONSOLE_TIME
        //               int,       int,        int,       bool,     bool,        int
		N_MINUTES = get_term( minutes, 1, 1 );
		SHORT_TERM = get_term( shortterm, 1, 15 );
		LONG_TERM = get_term( longterm, 1, 60 );
		if( filelog !== undefined ) FILE_LOG = !!filelog;
		if( console !== undefined ) CONSOLE_LOG = !!console;
		if( N_MINUTES === 0 &amp;&amp; SHORT_TERM === 0 &amp;&amp; LONG_TERM === 0 ) {
			FILE_LOG = false;
			CONSOLE_LOG = false;
		}
		if( duration ) {						// cannot be set to 0
			let dur = get_term( duration, 1, 3 );
			CONSOLE_TIME = dur &gt; 10 ? 10 : dur;	// as per the wiki
		}
	}
	function _setup_fps_calc( cut_low, cut_high, harmonic, fps_only, median, mode, mean, high, low ) { // set calculation variables
        // set values of TRUNC_LOW, TRUNC_HIGH, HARMONIC_MEAN, FPS_ONLY, MEDIAN, MODE, MEAN, HIGH, LOW
        //               int,       int,        bool,          bool,   	 bool,   bool, bool, bool, bool
		TRUNC_LOW = get_term( cut_low, 1, 5 );
		TRUNC_HIGH = get_term( cut_high, 1, 5 );
		if( harmonic !== undefined )HARMONIC_MEAN = !!harmonic;
		if( fps_only ) FPS_ONLY = !!fps_only;
		if( FPS_ONLY ) MEDIAN = MODE = MEAN = HIGH = LOW = false;
		if( median !== undefined )	MEDIAN = !!median;
		if( mode !== undefined )	MODE = !!mode;
		if( mean !== undefined )	MEAN = !!mean;
		if( high !== undefined )	HIGH = !!high;
		if( low !== undefined )		LOW = !!low;
		if( FPS_ONLY &amp;&amp; ( MEDIAN || MODE || MEAN || HIGH || LOW ) ) {
			let num = (MEDIAN ? 1 : 0 ) + (MODE ? 1 : 0 ) + (MEAN ? 1 : 0 )
						+ (HIGH ? 1 : 0 ) + (LOW ? 1 : 0 );
			let count = num;
			log(&#39;fps_monitor&#39;, &#39;_setup_fps_calc, warning: fps_only setting (true) conflicts with &#39; 
					+ (MEDIAN ? &#39;median&#39; + (num-- &gt; 1 ? &#39;, &#39; : &#39;&#39;) : &#39;&#39;) 
					+ (MODE ? &#39;mode&#39;     + (num-- &gt; 1 ? &#39;, &#39; : &#39;&#39;) : &#39;&#39;) 
					+ (MEAN ? &#39;mean&#39;     + (num-- &gt; 1 ? &#39;, &#39; : &#39;&#39;) : &#39;&#39;)
					+ (HIGH ? &#39;high&#39;     + (num-- &gt; 1 ? &#39;, &#39; : &#39;&#39;) : &#39;&#39;) 
					+ (LOW ? &#39;low&#39;       + (num-- &gt; 1 ? &#39;, &#39; : &#39;&#39;) : &#39;&#39;) 
					+ &#39;. &#39;+(count&gt;1 ? &#39;These values are&#39; : &#39;This value is&#39;) +&#39; NOT being stored.&#39; ); 
		}
		if( FPS_ONLY ) MEDIAN = MODE = MEAN = HIGH = LOW = false;
	}
	function _init_fps_monitor( oxp_name, paused, no_fcb ) {// str, [bool, bool]; one-time setup; sets &#39;oxp_name&#39; used when calling log(OXP_NAME,&quot;...&quot;)
															//  - &#39;paused&#39; prevents it from starting until you call _turn_on_fps_monitor()
															//  - &#39;no_fcb&#39; prevents it adding a frame callback, so you either call _turn_on_fps_monitor()
															//	  later or one of your fcb&#39;s calls _fps_monitor() and passes along &#39;delta&#39;
		if( oxp_name )
			OXP_NAME = typeof oxp_name === &#39;string&#39;	// or, you can just edit this file above
							? oxp_name
							: oxp_name.toString();
        else
            OXP_NAME = &#39;FPS_MONITOR&#39;;
		if( isValidFrameCallback( FCB_handle ) ) 
			removeFrameCallback(  FCB_handle );
		if( !no_fcb &amp;&amp; !isValidFrameCallback( FCB_handle ) )
			FCB_handle = addFrameCallback( _fps_monitor.bind( that ) );
			// FCB_handle = addFrameCallback( _fps_monitor.bind( this ) );
		if( paused !== undefined )
			is_running = !paused;
		else
			is_running = true;
	}
	function _turn_on_fps_monitor( no_fcb, stutter, thresh, wipe ) {// [bool[,bool[,float[,bool]]]]; resume fps monitoring; set &#39;no_fcb&#39; to true to prevent adding a frame callback (see above)
																// - set &#39;stutter&#39; to true to enable stutter checking (NB: this will force LOW to be true!)
																// - &#39;thresh&#39; is a number &gt; 0 &amp; &lt; 1 that defines what a stutter is, default 0.8.
																//   So if you encounter a frame count that&#39;s less than thresh * fps, a report is written, at the end of that minute,
																//   to your log file. (w/ default 0.8, any second w/ &lt; 80% of mean frames gets reported)
																// - &#39;wipe&#39; set true wipes all data arrays for a clean start
		if( !no_fcb &amp;&amp; !isValidFrameCallback( FCB_handle ) )
			FCB_handle = addFrameCallback( _fps_monitor.bind( that ) );
			// FCB_handle = addFrameCallback( _fps_monitor.bind( this ) );
		_reset_fps_monitor( 0, wipe );
		is_running = true; 
		if( stutter === undefined ) return;
		chk_stutter = !!stutter;
		if( chk_stutter &amp;&amp; !stutter_mon &amp;&amp; !LOW ) 
			set_calc_vars();					// need to adjust for required LOW values
		stutter_mon = chk_stutter;
		if( thresh === undefined ) return;
		if( thresh &gt; 0 &amp;&amp; thresh &lt; 1 )
			threshold = thresh;
		else
			log( OXP_NAME, &#39;fps_monitor, _turn_on_fps_monitor, invalid threshold of &#39; + thresh + &#39;, using default of &#39; + threshold );
	}
	function _turn_off_fps_monitor( remove ) {	// [bool]; suspend fps monitoring; set &#39;remove&#39; to true to remove frame callback
		if( remove &amp;&amp; isValidFrameCallback( FCB_handle ) ) {
			removeFrameCallback( FCB_handle );
			FCB_handle = null;
		}
		is_running = false; 
	}
	function _set_callback( fn, period ) {	// function, [int]; returns bool; set a callback function to be invoked every &#39;period&#39; seconds (default is 60)
											// - for performance reasons, callbacks only occur on second boundary. If you want more, search for the string
											//   &quot;per frame resolution&quot; and uncomment the line
		if( typeof fn !== &#39;function&#39; ) 	return false;
		if( period &lt;= 0 ) 				return false;
		callback = fn;
		callback_period = period &gt; 0 ? period &gt;&gt;&gt; 0 : 60;
		var max = SHORT_TERM &gt; LONG_TERM ? SHORT_TERM : LONG_TERM;
		if( N_MINUTES &gt; max ) max = N_MINUTES;
		max *= 60;
		if( callback_period &gt; max ) {
			callback_period = max;
			log( OXP_NAME, &#39;fps_monitor, _set_callback, period exceeds your largest time interval, reset to &#39; + max );
		}
		return true;
	}
	function _clear_callback() {				// clear a callback function set in _set_callback
		callback = null;
		callback_period = 0;
		return true;
	}
	function _realtime_fps() {					// returns int; result of the last second&#39;s frame count
												//  - returns -1 in the event of no data (not started)
												//  - not real useful (?), but trivial to implement
		if( frames_per_sec[ 0 ] === 0 			// has not started
			|| !is_running )					// is not running
			return -1;	
		let i = seconds - 1;					// seconds is post-incremented
		if( i &lt; 0 ) i = 59;
		return frames_per_sec[ i ];				// return last frame&#39;s count
	}
	function _current_fps( all_stats, result ) {// [bool[,array]]; returns int or array; result(s) of the last minute&#39;s measured data
												//  - returns -1 in the event of no data (not started, not running long enough)
												//  - when &#39;all_stats&#39; is true, returns an array of up to 6 values.  I deliberately left 
												//    this out of the _setup_... functions, so it would be more apparent what return to expect
												//    - array values have relative order: fps, median, mode, mean, high, low
												//  - when &#39;result&#39; is present, data is copied into the array (ie. not creating new one to return)
												//    - will append to any existing array data, so set its length = 0 if you want to empty it first
		return return_data( minute_data, all_stats, result );
	}
	function _short_term_fps( all_stats, result ) {// [bool[,array]]; returns int or array; result(s) of the last SHORT_TERM&#39;s *reported* data
												//  - if you want SHORT_TERM data from period ending when you call, use _get_fps_data()
												//  - otherwise, works the same as _current_fps()
		return return_data( short_data, all_stats, result );
	}
	function _long_term_fps( all_stats, result ) {// [bool[,array]]; returns int or array; result(s) of the last LONG_TERM&#39;s *reported* data
												//  - if you want LONG_TERM data from period ending when you call, use _get_fps_data()
												//  - otherwise, works the same as _current_fps()
		return return_data( long_data, all_stats, result );
	}
	function _get_frames( count, result ) {		// [int[,array]]; returns an array integer frame counts; &#39;count&#39; specifies # of seconds of 
												// data to return; if no count supplied, all are returned, to a max. of 60 (if it&#39;s been running 
												// less than a minute, the array&#39;s length will reflect that)
												//  - returns -1 in the event of no data (not started, not running long enough)
												//  - when &#39;result&#39; is present, data is copied into the array (ie. not creating new one to return)
												//    - will append to any existing array data, so set its length = 0 if you want to empty it first
		var len, asking, data, dst, src;
		if( !is_running 						// monitor is not running
			|| frames_per_sec[ 0 ] === 0 )	
			return -1;		
		len = frames_per_sec[ seconds ] === 0 	// buffer not full, strip unused
				? seconds : 60;
		asking = 60;							// max. # to return
		if( count !== undefined )
			asking = typeof count === &#39;number&#39; 
						? round( count )
						: parseInt( count, 10 );
		dst = asking &lt; len ? asking : len;		// index for destination
		asking = dst;
		if( result &amp;&amp; Array.isArray(result) ) { 
			data = result;						// copy data into supplied array
			dst += result.length;
		} else {
			data = new Array( dst );
		}
		src = seconds;							// index for source
		while( asking-- ) {
			if( src &lt;= 0 ) src = 60;
			data[ --dst ] = frames_per_sec[ --src ];
		}
		return data;
	}
	function _get_fps_data( all_stats, count, result ) {// [bool[,int[,array]]]; returns an array of integers of all it&#39;s collected for further processing
												//  - returns -1 in the event of no data (not started, not running long enough)
												//  - by default, returns an array of fps values
												//    - set &#39;all_stats&#39; true for data to be an array of: fps, median, ..., depending on what
												//      flags you set in _setup_fps_calc() (or by editing the script)
												//      NB: not an array of [ fps, median, ... ] entries, just a stream of int&#39;s
												//  - length of return array will be max( SHORT_TERM, LONG_TERM ) if !all_stats
												//    - if all_stats is true, each min. will have 1 - 6 int&#39;s, depending on flags set previously 
												//  - count is some # of minutes &lt;=  max( SHORT_TERM, LONG_TERM )
												//  NB: _short_term_fps() returns data from short term report, as such, only changes every SHORT_TERM minutes.
												//      If you want data from the previous SHORT_TERM minutes, call this fn w/ count = SHORT_TERM. Ditto for long term.
												//  - when &#39;result&#39; is present, data is copied into the array (ie. not creating new one to return)
												//    - will append to any existing array data, so set its length = 0 if you want to empty it first
		var len, asking, data, fps_only, maxm, dst, src;
		if( !is_running || !fps_stats			// monitor is not running
			|| fps_stats[ 0 ] === 0 )			// too soon, have not measured anything
			return -1;		
		fps_only = all_stats !== undefined
					? !all_stats : true;
		if( fps_stats[ index ] === 0 ) {		// buffer not full, strip unused
			maxm = asking = minutes;			// default for when !count
			len = index;
		} else {
			maxm = asking = max_minutes;		// default for when !count
			len = array_size;					// max. fps_stats index
		}
		if( count ) {
			asking = typeof count === &#39;number&#39; 
						? round( count )
						: parseInt( count, 10 );
		}
		if( asking &gt; maxm ) asking = maxm;
		if( fps_only ) {
			dst = asking;						// index for destination			
		} else {
			let dsize = asking * DATA_SIZE;			
			dst = dsize &lt; len ? dsize : len;	// index for destination
		}
		if( result &amp;&amp; Array.isArray(result) ) {
			data = result;						// copy data into supplied array
			dst += result.length;
		} else {
			data = new Array( dst );
		}
		src = index;							// index for source
		while( asking-- ) {
			if( src &lt;= 0 ) src = array_size;
			if( fps_only ) {
				src -= DATA_SIZE - 1;			// discard everything but fps
			} else {
				if( LOW )    data[ --dst ] = fps_stats[ --src ];
				if( HIGH )   data[ --dst ] = fps_stats[ --src ];
				if( MEAN )   data[ --dst ] = fps_stats[ --src ];
				if( MODE  )  data[ --dst ] = fps_stats[ --src ];
				if( MEDIAN ) data[ --dst ] = fps_stats[ --src ];
			}
			data[ --dst ] = fps_stats[ --src ];	// copy fps
		}
		return data;
	}

	/*  internal variables - you break it, you own it!  */

	// function references
	var round = Math.round;
	var callback = null;						// function to be called at end of each callback_period minutes
	// local variables
	var chk_stutter = false;					// user toggle for stutter monitor
	var stutter_mon = false;					// internal state for stutter monitor
	var threshold = 0.8;						// amount below average fps that defines what&#39;s a stutter (eg. &lt; 80%)
	var stutters = [];							// array (re-used) to store stutters while reporting
	var callback_period = 0;					// # of seconds between each callback
	var game_paused = false;					// flag so when games resumes, can continue accuratly
	var FCB_handle = null;						// reference for frame callback
	var is_running = false;						// on - off switch available via _turn_on_fps_monitor() &amp; _turn_off_fps_monitor()
	var frames = 0;								// # of frames
	var seconds = 0;							// # of seconds, index into frames_per_sec array
	var minutes = 0;							// # of minutes; not an index, so keeps incrementing (unles _reset_fps_monitor( .., true ))
	var start_delta = -1;						// delta value @ start of ea. sec. (can be any value, depending on when 1st fcb called)
	var running_total = 0;						// running total of delta values passed to frame callback
	var index = 0;								// index into fps_stats, max is array_size
	var frames_per_sec = new Uint8Array( 60 );	// typed array used for storing frame counts, wraps every minute
	var counted = new Uint8Array( 256 ); 		// internal working area for counting_sort; frame counts limited to 254!
	var counted_most, counted_mid;				// when sorting, save most popular -&gt; mode, middle -&gt; median

	var DIVISOR = 60 - TRUNC_HIGH - TRUNC_LOW;	// divisor for (trucated) mean or dividend for harmonic mean
	var DATA_SIZE, array_size, max_minutes, fps_stats, long_data, short_data, minute_data, mid_data, frames_sorted;
	// NB: data store relative order: fps, median, mode, mean, high, low
	//     - some may be missing due to user settings
	function set_calc_vars() {
		DIVISOR = 60 - TRUNC_HIGH - TRUNC_LOW;
		max_minutes = LONG_TERM &gt; SHORT_TERM	// the larger of the two
				   ? LONG_TERM : SHORT_TERM;
		var old_data_size = DATA_SIZE;
		if( FPS_ONLY ) {
			frames_sorted = frames_per_sec;		// sort not called, pts to frames_per_sec for code following sort
			DATA_SIZE = (stutter_mon || chk_stutter) ? 2 : 1;
		} else {
			frames_sorted = new Uint8Array( 60 );// typed array used for calc&#39;g average fps, high &amp; low values, reset every minute
			DATA_SIZE = 1 + (MEDIAN ? 1 : 0 )	// saving 1 data point + upto 5 more
						  + (MODE   ? 1 : 0 )
						  + (MEAN   ? 1 : 0 )
						  + (HIGH   ? 1 : 0 )
						  + (LOW || stutter_mon || chk_stutter ? 1 : 0 );
		}
		if( old_data_size === DATA_SIZE ) 	 	// subsequent call but size not changed
			return;	
		fps_stats = null;
		array_size = max_minutes * DATA_SIZE;
		if( array_size &gt; 0 )
			fps_stats = new Uint8Array( array_size );// a 2nd typed array of each minute&#39;s stats as an int or run of ints
		minute_data = new Uint8Array( DATA_SIZE );// if both SHORT_TERM &amp; LONG_TERM shut off, still needed for minutes
		short_data = long_data = mid_data = null;
		if( SHORT_TERM === 0 &amp;&amp; LONG_TERM === 0 ) {
			return;
		} else if( SHORT_TERM === 0 ) {
			long_data = new Uint8Array( DATA_SIZE );// save latest data for get fns
		} else if( LONG_TERM === 0 ) { 
			short_data = new Uint8Array( DATA_SIZE );
		} else {
			short_data = new Uint8Array( DATA_SIZE );
			long_data = new Uint8Array( DATA_SIZE );	// save latest data for get fns
			mid_data = new Uint8Array( DATA_SIZE );	// internal for case when long &amp; short reports coincide
		}			
	}
	
	var rpt_begin = &#39;*** FPS report ***: over the last &#39;;
	var minutes_str = [ &#39;minute&#39;, &#39;1 min&#39;];
	var short_term_str, long_term_str;
	function set_time_strs() {
		short_term_str = [ (SHORT_TERM % 15 === 0
							? (SHORT_TERM / 15) + &#39;/4 hour&#39;
								+ (SHORT_TERM &gt; 15 ? &#39;s.&#39; : &#39;.&#39;) 
							: SHORT_TERM + &#39; minutes&#39;),
							SHORT_TERM + &#39; min&#39; ];
		long_term_str = [ (LONG_TERM  % 60 === 0 
							? (LONG_TERM / 60) +&#39; hour&#39; 
								+ (LONG_TERM &gt; 60 ? &#39;s.&#39; : &#39;.&#39;) 
							: LONG_TERM + &#39; minutes&#39;),
							LONG_TERM + &#39; min&#39; ];
	}

	/*  internal functions - any modification will void you warrantee  */
	
	function get_term( term, minimum, defawlt ) {
		var num;
		if( !term ) return 0;					// no parms shuts it down
		num = typeof term === &#39;number&#39; 
				? round( term ) : parseInt( term, 10 );
		num = num &gt;= minimum ? num : defawlt;
		return num;
	}
	function return_data( data, all_stats, result ) {
		if( !data || data[ 0 ] === 0  			// too soon, have not measured 1st minute/term
				  || !is_running )				// is not running
			return -1;	
		var fps_only, rtn, len, i;
		fps_only = all_stats === undefined
						? true : !all_stats;
		if( !all_stats &amp;&amp; !result )
			return data[ 0 ];					// return fps
		
		if( result &amp;&amp; Array.isArray(result) ) {
			i = result.length;
			rtn = result;
		} else {
			i = 0;
			rtn = [];
		}					
		len = fps_only ? 1 : DATA_SIZE;
		while( len-- ) {
			rtn[i] = data[i];					// copy data into (supplied) array		
			i++;
		}
		return rtn;								// return [ fps, ... ]
	}
	function wipe_data( list ) {				// for typed Arrays, setting length = 0 doesn&#39;t clear, .fill() not supported
		if( list ) for( var i = list.length-1; i &gt;= 0; i-- ) list[i] = 0;
	}
	function _reset_fps_monitor( delta, restart ) {	// [float[,bool]]: reset the monitor; internal function, useful for limiting monitoring (eg. dockside vs in flight)
													//  - not strictly required, as invoking the closure initializes these
													//  - if using this, it&#39;s not necessary to supply &#39;delta&#39; (counting will start on next frame)
													//  - &#39;restart&#39; sets minutes to 0 &amp; wipes existing data; for calls w/o &#39;delta&#39;, use _reset_fps_monitor( 0, true )
		if( restart === true ) {
			wipe_data( minute_data );
			wipe_data( fps_stats );
			wipe_data( short_data );
			wipe_data( long_data );
			wipe_data( mid_data );
			minutes = 0;
		}
		start_delta = 	!delta ? -1 : running_total;
		running_total = !delta ? 0  : running_total + delta;
		frames =		!delta ? 0  : 1;							
		seconds = 0;							// indices must be set to 0	every minute
		index = 0;								//    &quot;                     every &#39;array_size&#39;
	}
	function rpt_to_console( fps, median, mode, mean, high, low, time_str ) {
		let msg = &#39;FPS: &#39; + fps;
		if( !FPS_ONLY )  {
			if( MEDIAN ) msg += &#39;, median: &#39; + median;
			if( MODE )   msg += &#39;, mode: &#39; + mode;
			if( MEAN )   msg += &#39;, mean: &#39; + mean;
			if( HIGH )   msg += &#39;, hi: &#39; + high;
			if( LOW )    msg += &#39;, lo: &#39; + low;
		}
		msg += &#39; (&#39; + time_str[ 1 ] + &#39;)&#39;;
		player.consoleMessage( msg, CONSOLE_TIME );
	}
	function rpt_to_log( fps, median, mode, mean, high, low, time_str ) {
		var type = &#39;&#39;;
		if( HARMONIC_MEAN ) type = &#39;harmonic&#39;;
		if( TRUNC_HIGH === 25 &amp;&amp; TRUNC_LOW === 25 ) 
			type += &#39;interquartile&#39;;
		else if( TRUNC_HIGH || TRUNC_LOW ) type = &#39;truncated&#39; + (type ? &#39; &#39; + type: &#39;&#39;);
		let report = rpt_begin + time_str[ 0 ] + &#39;, &#39;+type+&#39; mean fps was &#39;+ fps;
		if( !FPS_ONLY ) {
			if( MEDIAN ) report += &#39;, median: &#39; + median;
			if( MODE )   report += &#39;, mode: &#39; + mode;
			if( MEAN )   report += &#39;, mean: &#39; + mean;
			if( HIGH )   report += &#39;, high: &#39; + high;
			if( LOW )    report += &#39;, low: &#39; + low;
		}
		log( OXP_NAME, report );
	}
	function rpt_results( data, time_str ) {
		var fps, median, mode, mean, high, low;
		var i = 0;
		fps = data[ i++ ];
		median = mode = mean = high = low = 0;
		if( MEDIAN ) median = data[ i++ ];
		if( MODE )   mode =   data[ i++ ];
		if( MEAN )   mean =   data[ i++ ];
		if( HIGH )   high =   data[ i++ ];
		if( LOW )    low =    data[ i++ ];
		if( FILE_LOG )
			rpt_to_log( fps, median, mode, mean, high, low, time_str );
		if( CONSOLE_LOG ) 
			rpt_to_console( fps, median, mode, mean, high, low, time_str );
	}
	function check_stutter() {
		var fps = minute_data[ 0 ];
		if( !fps ) return;	// not ready
		var low = minute_data[ DATA_SIZE - 1 ];
		var thresh = fps * threshold;
		if( low &gt;= thresh ) return; // ignore any diff above threshold
		var ref = &#39;&#39;, all = &#39;[ &#39;, rpt = &#39;&#39;;
		var hic_len = 0, run = 0, slot, found = false;
		var i, frames;
		for( i = 0; i &lt; 60; i++ ) { // always called at end of a full minute
			frames = frames_per_sec[ i ];
			slot = i + 1;
			if( i &lt; 15 ) ref += slot &gt; 9 ? &#39;   &#39; + slot : &#39;    &#39; + slot;
			all += (frames &lt; 100 ? &#39; &#39; : &#39;&#39;) + frames + (i === 59 ? &#39; ]&#39; : (i &lt; 59 &amp;&amp; slot % 15 === 0) ? &#39;,\n  &#39; : &#39;, &#39;);
			if( frames &lt; thresh ) {
				stutters.push( frames );
				found = true;
				continue;
			}
			if( found ) { 
				if( run &gt; 0 ) rpt += &#39; ..[&#39; + run + &#39; s].. &#39;;
				hic_len = stutters.length;
				while( hic_len-- ) 
					rpt += stutters.shift() + (hic_len &gt; 0 ? &#39;, &#39; : &#39; &#39;);
				stutters.length = hic_len = run = 0;
				found = false;
			}
			run++;
		}
		rpt += run &gt; 0 ? &#39;..[&#39; + run + &#39; s]..&#39; : &#39;&#39;;
		if( found ) { 
			hic_len = stutters.length;
			while( hic_len-- ) 
				rpt += stutters.shift() + (hic_len &gt; 0 ? &#39;, &#39; : &#39; &#39;);
			stutters.length = 0;
		}
		ref += &#39;\n&#39;;
		rpt = &#39;check_stutter, w/ threshold = &#39; + thresh.toFixed(1) + &#39; frames:  -&gt;  &#39; + rpt;
		log( OXP_NAME, rpt + &#39;\nfps = &#39; + fps + &#39;, low = &#39; + low + &#39;, last 60 seconds:\n&#39; + ref + all );
	}
/*
*** FPS report ***: over the last minute, harmonic mean fps was 140, median: 139, high: 205, low: 130

check_stutter, w/ threshold = 133.0 frames:  -&gt;   ..[39 s].. 130  ..[7 s].. 132 ..[12 s]..
fps = 140, low = 130, last 60 seconds:
    1    2    3    4    5    6    7    8    9   10   11   12   13   14   15
[ 146, 137, 140, 134, 137, 140, 135, 137, 139, 137, 145, 139, 146, 138, 137,
  133, 135, 145, 138, 139, 139, 143, 142, 141, 141, 139, 145, 140, 138, 142,
  133, 139, 134, 138, 149, 145, 138, 139, 136, 130, 146, 136, 138, 139, 138,
  137, 144, 132, 140, 142, 137, 137, 135, 134, 133, 137, 137, 152, 205, 205 ]
*/
	function counting_sort() {
		var i, cs, max = 0, hh, ll, diff;
		cs = 255; 
		while( cs-- ) counted[ cs ] = 0;		// clear counts array
		i = 60;
		while( i-- ) {
			cs = frames_per_sec[ i ];			// record count of each value
			counted[ cs ]++;
		}
		cs = 255; i = 60;
		while( cs-- ) {
			let count = counted[ cs ];			// re-build frames_per_sec sorted by counts
			if( MODE &amp;&amp; count &gt; max ) { 
				max = count;
				counted_most = cs;
			}
			while( count-- ) {
				frames_sorted[ --i ] = cs;
				if( MEDIAN &amp;&amp; i &gt; 28 &amp;&amp; i &lt; 31 ) {
					if( i === 30 ) hh = cs;
					else if( i === 29 ) {
						ll = cs;
						diff = hh - ll;
						if( diff % 2 === 0 ) 	// ll + diff/2
							counted_mid = ll + (diff &gt;&gt;&gt; 1);
						else  					// round( ll + diff/2 )
							counted_mid = ll + ((diff + 1) &gt;&gt;&gt; 1);
					}
				}
			}
		}
	}
	function do_callback() {
		if( !callback ) return;
		if( callback_period &lt;= 0 ) return;
		var elapsed = callback_period &lt;= 60 ? seconds : minutes * 60 + seconds;
		if( elapsed % callback_period === 0 ) {
			try {
				callback();
			} catch( err ) {
				log( OXP_NAME, &#39;callback function encountered an error: &#39; + err );
				_clear_callback();
				log( OXP_NAME, &#39;callback function has been cleared.&#39; ); 
			}
		}
	}
	function _fps_monitor( delta ) {
		if( delta === 0 &amp;&amp; game_paused ) {		// game paused, subsequent frames
			return;
		} else if( delta === 0 ) {				// game paused, first frame
			game_paused = true;
			return;
		} else if( delta &gt; 0 &amp;&amp; game_paused ) {	// game resumed
			game_paused = false;
		}
		var fps, high, low, highest, lowest, short_rpt, long_rpt,
			count, sum, total, i, j, len, mid, mean, mode, median, 
			mean_sum, mode_sum, median_sum, div, data, mid_div, mid_data;
		if( !is_running ) return;
		if( !frames_sorted ) set_calc_vars();	// just-in-time init&#39;n
		if( index &gt;= array_size ) index = 0;	// must be @ top of &#39;loop&#39; due to various return statements
		if( start_delta === -1 ) {				// 1st time thru
			running_total = start_delta = delta;
			frames = 0;							// start counting next frame
			return;
		}
		running_total += delta;
		frames++;
		if( running_total - start_delta &lt; 1 ) {
///			do_callback();						// remove comment for per frame resolution
			return;
		}										// every second
		frames_per_sec[ seconds++ ] = frames &gt; 254 ? 254 : frames;
		frames = 0;
		start_delta = running_total;
		if( seconds &lt; 60 ) {
			do_callback();
			return;	
		}										// every minute	
		seconds = 0;
		minutes++;
		if( !FPS_ONLY )
			counting_sort();					// req&#39;d for truncated mean, median &amp; mode
		median = mode = mean = high = sum = total = 0;
		low = 254; i = 60;
		while( i-- ) {
			count = frames_sorted[ i ];
			total += count;
			if( i &gt;= TRUNC_LOW &amp;&amp; i &lt; (60 - TRUNC_HIGH) ) {
				if( HARMONIC_MEAN ) {
					if( count &gt; 0 )sum += 1/count;
				} else
					sum += count;
			}
			if( HIGH &amp;&amp; count &gt; high ) high = count;
			if( (LOW || stutter_mon) &amp;&amp; count &lt; low ) low = count;
		}
		fps = HARMONIC_MEAN ? round( DIVISOR / sum )
							: round( sum / DIVISOR );
		i = 0;
		minute_data[ i++ ] = fps;
		if( MEDIAN ) minute_data[ i++ ] = counted_mid;
		if( MODE )   minute_data[ i++ ] = counted_most;
		if( MEAN )   minute_data[ i++ ] = round( total/ 60 );
		if( HIGH )   minute_data[ i++ ] = high;
		if( LOW || stutter_mon ) minute_data[ i++ ] = low;
		if( N_MINUTES &gt; 0 &amp;&amp; (N_MINUTES === 1	// not turned off by user
				|| minutes % N_MINUTES === 0) ) // on Nth minute
			rpt_results( minute_data, minutes_str );
		if( stutter_mon ) check_stutter();
		if( array_size === 0 ) {
			do_callback();
			return;								// turned off by user
		}
		i = 0; // store data for short &amp; long term reports
		fps_stats[ index++ ] = minute_data[ i++ ]; // fps
		if( MEDIAN ) fps_stats[ index++ ] = minute_data[ i++ ];
		if( MODE )   fps_stats[ index++ ] = minute_data[ i++ ];
		if( MEAN )   fps_stats[ index++ ] = minute_data[ i++ ];
		if( HIGH )   fps_stats[ index++ ] = minute_data[ i++ ];
		if( LOW || stutter_mon ) fps_stats[ index++ ] = minute_data[ i++ ];
						
		short_rpt = SHORT_TERM &gt; 0 &amp;&amp; minutes &gt; 1 
						? minutes % SHORT_TERM : -1;
		long_rpt =  LONG_TERM &gt; 0 &amp;&amp; minutes &gt; 1 
						? minutes % LONG_TERM  : -1;
		if( short_rpt !== 0 &amp;&amp; long_rpt !== 0 ) {// not ready to report either benchmark
			do_callback();
			return;							
		}
		if( short_rpt === long_rpt ) {			// reporting both
			if( SHORT_TERM &lt; LONG_TERM ) {
				len = j = LONG_TERM * DATA_SIZE;
				data = long_data;
				div = LONG_TERM;
				mid = SHORT_TERM * DATA_SIZE;
				mid_data = short_data;
				mid_div = SHORT_TERM;
			} else {
				len = j = SHORT_TERM * DATA_SIZE;
				data = short_data;
				div = SHORT_TERM;
				mid = LONG_TERM * DATA_SIZE;
				mid_data = long_data;
				mid_div = LONG_TERM;
			}
		} else {								// reporting which one?
			if( long_rpt === 0  ) {
				len = j = LONG_TERM * DATA_SIZE;
				data = long_data;
				div = LONG_TERM;
			} else {
				len = j = SHORT_TERM * DATA_SIZE;
				data = short_data;
				div = SHORT_TERM;
			}
			mid = -1;							// not used for single, act as flag
		}
		lowest = low = 254; 	highest = high = 0;		i = index;
		mean_sum = mean = mode_sum = mode = median_sum = median = sum = 0;
		while( j ) {							// walk back from end gathering stats
			if( LOW || stutter_mon ) {
				low = fps_stats[ --i ];
				if( low &lt; lowest ) lowest = low;
			}
			if( HIGH ) {
				high = fps_stats[ --i ];
				if( high &gt; highest ) highest = high;
			}	
			if( MEAN )   mean_sum   += fps_stats[ --i ];
			if( MODE )   mode_sum   += fps_stats[ --i ];
			if( MEDIAN ) median_sum += fps_stats[ --i ];
			sum += fps_stats[ --i ];
			if( i &lt;= 0 ) i = array_size;
			j -= DATA_SIZE;
			if( mid &gt; 0 &amp;&amp; len - j === mid ) {
				// both are reporting, store data for shorter one
				let m = 0;
				mid_data[ m++ ] = round( sum / mid_div ); // fps
				if( MEDIAN ) mid_data[ m++ ] = round( median_sum / mid_div );
				if( MODE )   mid_data[ m++ ] = round( mode_sum   / mid_div );
				if( MEAN )   mid_data[ m++ ] = round( mean_sum   / mid_div );
				if( HIGH )   mid_data[ m++ ] = highest;
				if( LOW || stutter_mon ) mid_data[ m++ ] = lowest;
			}
		}
		data[ i++ ] = round( sum / div ); 		// fps
		i = 0;
		if( MEDIAN ) data[ i++ ] = round( median_sum / div );
		if( MODE )   data[ i++ ] = round( mode_sum   / div );
		if( MEAN )   data[ i++ ] = round( mean_sum   / div );
		if( HIGH )   data[ i++ ] = highest;
		if( LOW || stutter_mon ) data[ i++ ] = lowest;
		do_callback();
		if( !short_rpt ) set_time_strs();			// just-in-time init&#39;n
		if( short_rpt === 0 ) 
			rpt_results( short_data, short_term_str );
		if( long_rpt === 0 ) 
			rpt_results( long_data, long_term_str );
		if( index === array_size ) 
			_reset_fps_monitor( delta );			// memory full, reset counters
	}

	return {	
				  _setup_fps_calc: _setup_fps_calc,
			    _setup_fps_report: _setup_fps_report, 
				_init_fps_monitor: _init_fps_monitor,
			 _turn_on_fps_monitor: _turn_on_fps_monitor,
			_turn_off_fps_monitor: _turn_off_fps_monitor,
			   _reset_fps_monitor: _reset_fps_monitor,
					_set_callback: _set_callback,
				  _clear_callback: _clear_callback,
					_realtime_fps: _realtime_fps, 
					 _current_fps: _current_fps, 
				  _short_term_fps: _short_term_fps, 
				   _long_term_fps: _long_term_fps, 
					  _get_frames: _get_frames, 
				    _get_fps_data: _get_fps_data, 
					 _fps_monitor: _fps_monitor
			};
			
}).call(this);


</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/telescope_refundeq.js</td>
                    <td><pre>this.name        = &quot;telescope_refundeq&quot;;
this.author      = &quot;Norby&quot;;
this.copyright   = &quot;2013 Norbert Nagy&quot;;
this.licence     = &quot;CC BY-NC-SA 3.0&quot;;
this.description = &quot;Refund an equipment if undamaged and not cheaply repaired only.&quot;;
this.version     = &quot;1.0&quot;;

this.allowAwardEquipment = function( eqKey, ship, context )
{   
    &quot;use strict&quot;;
    if( context !== &quot;purchase&quot; ) 	return false;
    var ps = player &amp;&amp; player.ship;
    if( ship !== ps )            	return false;
    var actualEq = eqKey,
        endsWith = &#39;&#39;,
        parsed = eqKey.split( &#39;_&#39; );
    if( parsed.length === 3 ) {
        actualEq = parsed[ 0 ] + &#39;_&#39; + parsed[ 1 ];
        endsWith = parsed[ 2 ];
    }
    if( !endsWith ) 				return false;   // will be &#39;&#39; if there&#39;s only 1 &#39;_&#39;
    let status = ps.equipmentStatus( actualEq );
    if( status !== &#39;EQUIPMENT_OK&#39; ) return false;  // must repair before you sell 
    var ws = worldScripts.telescope;
    if(      eqKey === &quot;EQ_GRAVSCANNER2_REFUND&quot; )   return ws.$FixedGS !== 1; // these have no equipment that
    else if( eqKey === &quot;EQ_SMALLDISH_REFUND&quot; )      return ws.$FixedSD !== 1; // requires them, so we are free
    else if( eqKey === &quot;EQ_LARGEDISH_REFUND&quot; )      return ws.$FixedLD !== 1; // to sell them if fully repaired
    else if( eqKey === &quot;EQ_TELESCOPE_REFUND&quot; ) {
        if( ps.equipmentStatus( &quot;EQ_TELESCOPEEXT&quot; ) === &quot;EQUIPMENT_UNAVAILABLE&quot; ) // must sell ext first
            return ws.$FixedTel !== 1;	// can sell only if fully repaired
        return false;
    } else if( eqKey === &quot;EQ_TELESCOPEEXT_REFUND&quot; ) {
        if( ps.equipmentStatus( &quot;EQ_GRAVSCANNER&quot; ) === &quot;EQUIPMENT_UNAVAILABLE&quot; )  // must sell gravity scanner first
			return ws.$FixedTel !== 1;	// can sell only if fully repaired
        return false;
    } else if( eqKey === &quot;EQ_GRAVSCANNER_REFUND&quot; ) {							// must sell add-ons first
        if( ps.equipmentStatus( &quot;EQ_LARGEDISH&quot; )    !== &quot;EQUIPMENT_UNAVAILABLE&quot; ) return false;
        if( ps.equipmentStatus( &quot;EQ_SMALLDISH&quot; )    !== &quot;EQUIPMENT_UNAVAILABLE&quot; ) return false;
        if( ps.equipmentStatus( &quot;EQ_GRAVSCANNER2&quot; ) !== &quot;EQUIPMENT_UNAVAILABLE&quot; ) return false;
        return ws.$FixedGS !== 1;		// can sell only if fully repaired
    }
    return false;
}
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/telescope_repaireq.js</td>
                    <td><pre>this.name        = &quot;telescope_repaireq&quot;;
this.author      = &quot;Norby&quot;;
this.copyright   = &quot;2013 Norbert Nagy&quot;;
this.licence     = &quot;CC BY-NC-SA 3.0&quot;;
this.description = &quot;Repair an equipment if damaged only, full repairs if cheaply fixed.&quot;;
this.version     = &quot;1.0&quot;;

this.allowAwardEquipment = function( eqKey, ship, context )
{
    &quot;use strict&quot;;
    if( context !== &quot;purchase&quot; ) 	return false;
    var ps = player &amp;&amp; player.ship;
    if( ship !== ps )            	return false;
    var actualEq = eqKey,
        endsWith = &#39;&#39;,
        parsed = eqKey.split( &#39;_&#39; );
    if( parsed.length === 3 ) {
        actualEq = parsed[ 0 ] + &#39;_&#39; + parsed[ 1 ];
        endsWith = parsed[ 2 ];
    }
    if( !endsWith ) 				return false;					// will be &#39;&#39; if there&#39;s only 1 &#39;_&#39;
    let status = ps.equipmentStatus( actualEq );
    let isDamaged = status === &quot;EQUIPMENT_DAMAGED&quot;;
    let isWorking = status === &quot;EQUIPMENT_OK&quot;;
    if( !isWorking &amp;&amp; !isDamaged )  return false;					// EQUIPMENT_UNAVAILABLE or EQUIPMENT_UNKNOWN
    var ws = worldScripts.telescope;
    if(      eqKey === &quot;EQ_TELESCOPE_REPAIR&quot; )        return isDamaged &amp;&amp; ws.$FixedTel === 0;
    else if( eqKey === &quot;EQ_GRAVSCANNER_REPAIR&quot; )      return isDamaged &amp;&amp; ws.$FixedGS === 0;
    else if( eqKey === &quot;EQ_GRAVSCANNER2_REPAIR&quot; )     return isDamaged &amp;&amp; ws.$FixedGS === 0;
    else if( eqKey === &quot;EQ_SMALLDISH_REPAIR&quot; )        return isDamaged &amp;&amp; ws.$FixedSD === 0;
    else if( eqKey === &quot;EQ_LARGEDISH_REPAIR&quot; )        return isDamaged &amp;&amp; ws.$FixedLD === 0;
    
    else if( eqKey === &quot;EQ_TELESCOPE_FULLREPAIR&quot; )    return isWorking &amp;&amp; ws.$FixedTel === 1;
    else if( eqKey === &quot;EQ_TELESCOPEEXT_FULLREPAIR&quot; ) return isDamaged; // has no cheap repair option
    else if( eqKey === &quot;EQ_GRAVSCANNER_FULLREPAIR&quot; )  return isWorking &amp;&amp; ws.$FixedGS === 1;
    else if( eqKey === &quot;EQ_GRAVSCANNER2_FULLREPAIR&quot; ) return isWorking &amp;&amp; ws.$FixedGS === 1;                       
    else if( eqKey === &quot;EQ_SMALLDISH_FULLREPAIR&quot; )    return isWorking &amp;&amp; ws.$FixedSD === 1;
    else if( eqKey === &quot;EQ_LARGEDISH_FULLREPAIR&quot; )    return isWorking &amp;&amp; ws.$FixedLD === 1;
    
    return false;
}
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/telescopeeq.js</td>
                    <td><pre>this.name        = &quot;telescopeeq&quot;;
this.author      = &quot;Norby, cag&quot;;
this.copyright   = &quot;2013 Norbert Nagy&quot;;
this.licence     = &quot;CC BY-NC-SA 4.0&quot;;
this.description = &quot;Commands and settings, press mode to cycle, activate to accept or change.&quot;;
this.version     = &quot;2.0&quot;;

(function(){
&quot;use strict&quot;;

this.$eq_Menu = [ 
	[ &quot;Nearest target&quot; ],
	[ &quot;Rescan&quot; ],
	[ &quot;Step forward in the target list&quot; ],
	[ &quot;Step back in the target list&quot; ],
	[ &quot;Steering:&quot;, &quot;off&quot;, &quot;nearest target only&quot;, &quot;both nearest and step in the list&quot;], 
    // cutoff for RemoveInFlight; string &#39;Steering:&#39; is hard coded in mode()
	// [ &quot;Lightballs:&quot;, &quot;off&quot;, &quot;navigation only&quot;, &quot;ships&quot;, &quot;masslock rings&quot;, &quot;bright masslock rings&quot;, &quot;large&quot; ],
	[ &quot;Lightballs:&quot;, &quot;off&quot;, &quot;navigation only&quot;, &quot;include ships&quot;, &quot;large&quot; ],
	[ &quot;Masslock rings:&quot;, &quot;current alert/weapons state: off&quot;, &quot;current alert/weapons state: on&quot;, &quot;brighter&quot; ],
	[ &quot;Sniper ring km:&quot;, &quot;off&quot;, &quot;5-25.6&quot;, &quot;10-25.6&quot;, &quot;15-25.6&quot;, &quot;5-30&quot;, &quot;10-30&quot;, &quot;15-30&quot;], //off=10-10
	[ &quot;Targets:&quot;, &quot;20 and limitation in red alert&quot;, 50, 100, 200 ],
	[ &quot;Visual target:&quot;, &quot;off&quot;, &quot;weapons off&quot;, &quot;no ring&quot;, &quot;no station&quot;, &quot;no question mark&quot;, &quot;all&quot; ],
	[ &quot;Visual target size:&quot;, 1, 2, 3, 4, 5, 6, 7, 8 ] 
];
this.$eq_MenuItem = 0; //current item in the commands or settings menu

//equipment events
this.activated = function activated() {
	var that = activated;
	var ws = (that.ws = that.ws || worldScripts.telescope);
	var menu = (that.menu = that.menu || this.$eq_Menu);
	var eq_GetSubItem = (that.eq_GetSubItem = that.eq_GetSubItem || this.$eq_GetSubItem);
	var fmtMasslockMsg = (that.fmtMasslockMsg = that.fmtMasslockMsg || this.$fmtMasslockMsg);

	var item = this.$eq_MenuItem;
	if( item &lt; 4 ) { 												//commands
		switch( item ) {
			case 0: 												//Nearest target
				ws._nearest_Sighting(); 							//lock the nearest target
				break;
			case 1: 												//Rescan
                ws._auto_updates( true );
				break;
			case 2: 												//Step forward in the target list
                ws._chg_curr_Sighting( 1 );
				break;
			case 3: 												//Step back in the target list
                ws._chg_curr_Sighting( -1 );
				break;
		}
	} else { 														//settings
		var submenu = menu[ item ];
		var subitem = eq_GetSubItem( item ) + 1; 				    //step to the next subitem in the current settings
		if( subitem &gt;= submenu.length ) subitem = 1; 				//back to the first subitem (0. is the menuitem)
		switch( item ) {
			case 4: 												//Steering
				ws.$TelescopeMenuSteering = subitem;
				ws._SetSteering( subitem );
				break;
			case 5: 												//Lightballs
				ws.$TelescopeMenuLightballs = subitem;
				ws._SetLightballs( subitem );
				break;
			case 6: 												//MasslockRings
				ws.$TelescopeMenuMasslockRings = subitem;
				ws._SetMasslockRings( subitem );
				break;
			case 7: 												//Sniper ring km
				ws.$TelescopeMenuSniper = subitem;
				ws._SetSniper( subitem );
				break;
			case 8: 												//Targets
				ws.$TelescopeMenuTargets = subitem;
				ws._SetTargets( subitem );
				break;
			case 9: 												//Visual target
				ws.$TelescopeMenuVisual = subitem;
				ws._SetVisual( subitem );
				ws._clear_HUD_Effects();
				if( ws.$FixedTel === 0 )
					ws._showVShip(); 							    //repaint visual target and ring
				else 
                    player.consoleMessage(&quot;Your cheaply fixed Telescope can not show visual target, buy full repair.&quot;, ws.$ConsoleMsgDurn);
				break;
			case 10: 												//Visual target size
				ws.$TelescopeMenuVisualSize = subitem;
				if( ws.$TelescopeMenuVisual &lt; 2 ) {
					ws.$TelescopeMenuVisual = 2; 					//must at least wp off
					ws._SetVisual( 2 );
				}
				ws._SetVisualSize( subitem );
				ws._clear_HUD_Effects();
				if( ws.$FixedTel === 0 )
					ws._showVShip(); 							    //repaint visual target and ring
				else 
                    player.consoleMessage(&quot;Your cheaply fixed Telescope can not show visual target, buy full repair.&quot;, ws.$ConsoleMsgDurn);
				break;
		}
		//show subitem in settings
		// player.consoleMessage( menu[ item ][ 0 ] + &quot; &quot; + menu[ item ][ subitem ], ws.$ConsoleMsgDurn );
		let menuStr = menu[ item ][ 0 ],
			subitemStr = menu[ item ][ subitem ];
		if( item === 6 ) {
			subitemStr = fmtMasslockMsg( subitemStr );
		}
		player.consoleMessage( menuStr + &quot; &quot; + subitemStr, ws.$ConsoleMsgDurn );
	}
}

this.$fmtMasslockMsg = function fmtMasslockMsg( msg ) {
	var that = fmtMasslockMsg;
	var ws = (that.ws = that.ws || worldScripts.telescope);

	var [ alert, weapons ]  = ws._getShowStateText();
	return msg.replace( &#39;current&#39;, alert ).replace( &#39;state&#39;, weapons );
}

this.mode = function mode() {
	var that = mode;
	var ws = (that.ws = that.ws || worldScripts.telescope);
	var menu = (that.menu = that.menu || this.$eq_Menu);
	var cutoff = (that.cutoff = that.cutoff || null);
	var eq_GetSubItem = (that.eq_GetSubItem = that.eq_GetSubItem || this.$eq_GetSubItem);
	var fmtMasslockMsg = (that.fmtMasslockMsg = that.fmtMasslockMsg || this.$fmtMasslockMsg);
    
    if( cutoff === null ) {                                         // 1st invocation
        for( let i = 0, len = menu.length; i &lt; len; i++ ) {
            if( menu[ i ][ 0 ] === &#39;Steering:&#39; ) {
                cutoff = that.cutoff = i;
                break;
            }
        }
    }
    var item = this.$eq_MenuItem + 1;							    //step forward in the current menu
    if( item &gt;= menu.length || (item &gt; cutoff &amp;&amp; ws.$RemoveInFlight) ) 
        item = 0;                      	                            //back to the first menu item
    this.$eq_MenuItem = item;
	if( item &lt; 4 ) {												//no subitem with commands
		player.consoleMessage( menu[ item ][ 0 ], ws.$ConsoleMsgDurn );
		if( item &lt; 2 || item &gt; 3 ) {								// not stepping through sightings
			ws._resetIdentDelay();
		}
	} else {
		ws._resetIdentDelay();
		let menuStr = menu[ item ][ 0 ],
			subitemStr = menu[ item ][ eq_GetSubItem( item ) ];
		if( item === 6 ) {
			subitemStr = fmtMasslockMsg( subitemStr );
		}
		player.consoleMessage( menuStr + &#39; &#39; + subitemStr, ws.$ConsoleMsgDurn );		
	}
}

//Telescope primable equipment method
this.$eq_GetSubItem = function eq_GetSubItem( item ) {
	var that = eq_GetSubItem;
	var ws = (that.ws = that.ws || worldScripts.telescope);

	var m = null;
	switch( item ) {
		case 4:  													//Steering
			m = ws.$TelescopeMenuSteering;
			if( m &gt; 0 ) return( m );
			return( ws.$Steering + 1 );
		case 5: 													//Lightballs
			m = ws.$TelescopeMenuLightballs;
			if( m &gt; 0 ) return( m );
			if( !ws.$LightBalls ) 			return( 1 ); 			//off (&#39;off&#39;)
			if( !ws.$ShipLightBalls ) 		return( 2 ); 			//ship off (&#39;navigation only&#39;)
			if( !ws.$LargeLightBalls ) 		return( 3 ); 			//large off (&#39;include ships&#39;)
			return( 4 );											//large on (&#39;large&#39;)
		case 6: 													//MasslockRings
			let state = ws._getShowState(),							// on/off for current alert/weaps state
				currFlags = ws._currMLFlags();
			let menu = 1;
			if( currFlags &amp; state ) {
				menu = 2;
				if( ws.$BrightMassLockRings ) 
					menu = 3;
			}
			return menu;
		case 7:  													//Sniper ring km
			m = ws.$TelescopeMenuSniper;
			if( m &gt; 0 ) return( m );
			var max = ws.$SniperRange;
			var min = ws.$SniperMinRange;
			if( max === min ) 	return( 1 ); 						//off
			var p = 0; 												//max = 25.6km
			if( max &gt; 25600 ) p = 3; 								//add this to reach subitems with max = 30km
			if( min &lt;= 5000 ) 	return( 2 + p ); 					// &quot;5-25.6&quot; or &quot;5-30&quot;
			if( min &gt;= 15000 )	return( 4 + p ); 					// &quot;15-25.6&quot; or &quot;15-30&quot;
			return( 3 + p ); 										// &quot;10-25.6&quot; or &quot;10-30&quot;
		case 8:  													//Targets
			m = ws.$TelescopeMenuTargets;
			if( m &gt; 0 ) return( m );
			if( ws.$RedAlertLimiter )	return( 1 ); 				//20 and limitation in red alert
			if( ws.$MaxTargets &lt;= 50 )	return( 2 ); 				//50
			if( ws.$MaxTargets &gt;= 200 ) return( 4 ); 				//200
			return( 3 ); 											//100
		case 9:  													//Visual target
			m = ws.$TelescopeMenuVisual;
			if( m &gt; 0 ) return( m );
			if( ws.$VisualTargetNormalSize === 0 
                || ws.$ShowVisualTarget === 0 ) 	return( 1 ); 	//off
			if( ws.$ShowVisualTarget === 1 )	    return( 2 ); 	//weapons off
			if( !ws.$Ring ) 						return( 3 ); 	//no ring
			if( !ws.$ShowVisualStation ) 		 	return( 4 );	//no station
			if( !ws.$ShowVisualQuestionMark )		return( 5 ); 	//no &quot;?&quot;
			return( 6 ); 											//all
		case 10:  													//Visual target size (VZoomSize=0 if full off)
			m = ws.$TelescopeMenuVisualSize;
			if( m &gt; 0 ) return( m );
			return( ws.$VisualTargetNormalSize );
	}
	return( -2 ); 													//no subitem with commands
}

}).call(this);
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/xlonly.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name        = &quot;xlonly&quot;;
this.author      = &quot;Norby&quot;;
this.copyright   = &quot;2013 Norbert Nagy&quot;;
this.licence     = &quot;CC BY-NC-SA 3.0&quot;;
this.description = &quot;This equipment is usable only for ships from 400t like Anaconda or Hard Python.&quot;;
this.version     = &quot;1.0&quot;;

this.allowAwardEquipment = function(eqKey, ship, context)
{
//	player.consoleMessage( eqKey+&quot; &quot;+ship+&quot; &quot;+context );//debug
	if( ship.mass &gt;= 400000 ) return true;
	else return false;
}
</pre></td>
                </tr>
            </table>
        </a>
    </body>
</html>
