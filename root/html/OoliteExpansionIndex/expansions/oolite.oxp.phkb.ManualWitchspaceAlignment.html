<html>
    <head>
        <title>Expansion Manual Witchspace Alignment</title>
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <table border="0" width="100%">
            <tr>
                <td>Back to <a href='../index.html'>Index</a></td>
                <td align="right"><small>Page generated: Oct 11, 2023, 3:16:49 PM</small></td>
            </tr>
        </table>

        <h1>Expansion Manual Witchspace Alignment</h1>

        <h2>Content</h2>
        <ul>
          
          <li><a href="#manifest">Manifest</a></li>
          <li><a href="#documentation">Documentation</a></li>
          <li><a href="#equipment">0 Equipment</a></li>
          <li><a href="#ships">1 Ships</a></li>
          <li><a href="#models">0 Models</a></li>
          <li><a href="#scripts">2 Scripts</a></li>
        </ul>


        <a name="manifest">
        <h2>Manifest</h2>
            <table border="1">
                <tr>
                    <th></th>
                    <th>from Expansion Manager's OXP list</th>
                    <th>from Expansion Manifest</th>
                </tr>
                <tr>
                    <td>Description</td>
                    <td>Requires the player manually align their ship with the witchspace destination before jump can occur.</td>
                    <td>Requires the player manually align their ship with the witchspace destination before jump can occur.</td>
                </tr>
                <tr>
                    <td>Identifier</td>
                    <td>oolite.oxp.phkb.ManualWitchspaceAlignment</td>
                    <td>oolite.oxp.phkb.ManualWitchspaceAlignment</td>
                </tr>
                <tr>
                    <td>Title</td>
                    <td>Manual Witchspace Alignment</td>
                    <td>Manual Witchspace Alignment</td>
                </tr>
                <tr>
                    <td>Category</td>
                    <td>Mechanics</td>
                    <td>Mechanics</td>
                </tr>
                <tr>
                    <td>Author</td>
                    <td>phkb, Cmdr. Cheyd, Phantor Gorth, Svengali, Submersible, spara</td>
                    <td>phkb, Cmdr. Cheyd, Phantor Gorth, Svengali, Submersible, spara</td>
                </tr>
                <tr>
                    <td>Version</td>
                    <td>2.7</td>
                    <td>2.7</td>
                </tr>
                <tr>
                    <td>Tags</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Required Oolite Version</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Maximum Oolite Version</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Required Expansions</td>
                    <td>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>Optional Expansions</td>
                    <td>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>Conflict Expansions</td>
                    <td>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>Information URL</td>
                    <td><a target="_blank" href="https://wiki.alioth.net/index.php/Manual_Witchspace_Alignment">https://wiki.alioth.net/index.php/Manual_Witchspace_Alignment</a></td>
                    <td><a target="_blank" href="">n/a</a></td>
                </tr>
                <tr>
                    <td>Download URL</td>
                    <td><a target="_blank" href="https://wiki.alioth.net/img_auth.php/8/8b/ManualWitchspaceAlignment.oxz">https://wiki.alioth.net/img_auth.php/8/8b/ManualWitchspaceAlignment.oxz</a></td>
                    <td><a target="_blank" href="">n/a</a></td>
                </tr>
                <tr>
                    <td>License</td>
                    <td>CC BY-NC-SA 4.0</td>
                    <td>CC BY-NC-SA 4.0</td>
                </tr>
                <tr>
                    <td>File Size</td>
                    <td>n/a</td>
                </tr>
                <tr>
                    <td>Upload date</td>
                    <td>1697001273</td>
                </tr>
            </table>
                </a>

        <a name="documentation">
        <h2>Documentation</h2>
        <p>Also read <a href='http://wiki.alioth.net/index.php/Manual%20Witchspace%20Alignment'>http://wiki.alioth.net/index.php/Manual%20Witchspace%20Alignment</a></p>
        <h3>readme.txt</h3>
        <pre>Manual Witchspace Alignment
by Nick Rogers

With thanks to Cmdr. Cheyd, Phantor Gorth, spara, Svengali and Submersible for their code.

Overview
========
This OXP seeks to add some interactivity to the witchspace jumping mechanic by requiring the player to manually align their ship with a jump target. Each possible local system destination will have a different target to align with. The jump countdown will only commence once the ship is aligned (with a margin for error). Additionally, if the target is blocked (occluded) by the sun, a planet, or a station, the countdown will be stopped until the player has a clear flight path to the target.

The jump target will appear on the Advanced Space Compass to assist with alignment. If the ASC is not installed or is damaged, a console message will be displayed every 2 seconds showing alignment instructions (eg &quot;Align: left and up&quot;). These instructions will also be displayed in interstellar space, because the ASC does not function there.

You can still use the normal methods to force a mis-jump.

If the system you are in has gone nova, an emergency alignment protocol will engage, allowing you to enter witchspace without alignment, although some ship damage will likely occur when this takes place.

Jump Target Color Variation
===========================
It is possible to switch the color of the jump target on the HUD, if the Library OXP is installed. You can switch between the default blue, amber/orange, green, pink, purple and white. This can also be controlled through code.

As it is possible for 3rd party OXP&#39;s (like HUD&#39;s) to adjust the color of the jump target, if the user color preference has been set, a &quot;User Override&quot; value can be set to notify any 3rd party OXP that no color changes should take place.

Code to adjust the color of the jump target:

	if (worldScripts.ManualWitchspaceAlignment) {
		var mwa = worldScripts.ManualWitchspaceAlignment;
		if (mwa._userOverride === false) { // only do the change if the player hasn&#39;t told us not to
			mwa._color = 0; // 0 = blue, 1 = amber/orange, 2 = green, 3 = pink, 4 = purple, 5 = white
		}
	}  

Deep Horizon Advanced Navigation Computer
==========================================
The DH ANC is compatible with this OXP. If both are installed, but the ANC hasn&#39;t been purchased by the player, then the manual alignment method will be required. If the ANC has been purchased, the ANC&#39;s automatic alignment process will take place.

Acknowledgements
================
This work is quite heavily based on Cmdr. Cheyd and Phantor Gorth&#39;s &quot;Deep Horizon Advanced Navigation Computer&quot;, and they have generously allowed me to include some of that code here. spara also helped by providing some code for checking if a point is behind a stellar body.

License
=======
This work is licensed under the Creative Commons Attribution-Noncommercial-Share Alike 3.0 Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/

Part of this OXP uses code and models from the Deep Horizon Advanced Navigation Computer:
- Navigation frame
- Star textures and shaders
- Code to spawn the navigation frame and star textures, as well as to realign them as the player ship moves.

The DH ANC has has the following licence amendments:

The files that make up &quot;Deep Horizon - Advance Navigation Computer.oxp&quot; shall be referred to in the rest of these terms as the &quot;Work&quot;. The Authors are the authors of the Work. Any derivatives from this version of the Work will be referred to as a Derived Work. Historic Authors are all the authors (including the Original Authors unless this is the first version of the Work) that made ancestral versions of the code that go back to the original Work. The Original Authors are those that made the first version of this Work (i.e. Blake Deakins (Cmd. Cheyd), Phantor Gorth (Paul Cooper))

license: Creative Commons Attribution-Noncommercial-ShareAlike 3.0 Unported license (Modified)
This is the Creative Commons Attribution-Noncommercial-ShareAlike 3.0 Unported license as detailed at http://creativecommons.org/licenses/by-nc-sa/3.0/ with the following additional terms and conditions:

1. These terms superseded any conflicting terms as found in the Creative Commons Attribution-Noncommercial-ShareAlike 3.0 Unported license.
2. The Work is provided on an &quot;as is&quot; basis and you possess and or use the Work entirely at your own risk. The Authors or Historic Authors are not liable for any damages or other consequences that arise from possession, use, or misuse of the Work.
3. You will not request support of any of the Historic Authors for issues with the Work. Any support is at the discretion of the Authors.
4. You will not criticise Historic Authors for issues with this Work if this Work is a derived work.
5. Derived Works must use a compatible license and contain these additional license terms and term descriptions that apply to the Release Version. The term Work will then refer to the Derived Work and any derived works of that new Work will become the Derived Work.
6. You will adhere to this license&#39;s terms and conditions fully up to the maximum allowed in your legal jurisdiction. Invalidation of any terms or conditions does not invalidate any or all of the remaining terms and conditions.

Version History
===============
2.7
- Better handling of situation where jump countdown is stopped before our start function has run.

2.6
- Making sure jump markers do not have pilots attached.

2.5
- Better integration with sound OXP&#39;s (like Halsis).

2.4
- Alignment is now not required if a system has gone nova.

2.3
- Fixed issue when escape pod is activated while visual effects are being displayed.

2.2
- Tweaks to prevent JS code time-out conditions when cancelling the jump countdown due to misalignment.
- Improved integration with BGS, particularly when starting a jump countdown when the ship is already aligned with the destination.
- Improved integration with Countdown to Zero, to prevent timer garbage collection.
- Code cleanup.

2.1
- Added Purple and White color options, and tweaked the colors of the green and pink options (thanks to gsagostinho).
- Added protection from out of bounds errors if color property is incorrectly set.

2.0
- Added Amber/Orange, Green and Pink nav beacon variations, plus code to allow the color of the nav frame to be either selected by the user, or configured via script.
- Fixed issue where selecting another ASC target would leave nav frame and star on the screen.
- Code refactoring.

1.7
- Starting docking computers will now correctly disengage the hyperspace countdown.

1.6
- Jump is now cancelled if player starts a jump and then changes the destination system on the F6 chart before aligning with nav beacon.

1.5
- Bug fixes.

1.4
- Fixed issue where variable was not being set correctly when player ship is replaced.
- Bug fixes.

1.3
- Fixed JS error if Advanced Navigation Computer OXP is not installed.

1.2
- Corrections to manifest.plist file.

1.1
- Fixed issues in interstellar space where visual effects were not being removed if the hyperspace countdown was cancelled.
- Fixed issues in normal space where quickly turning the hyperspace countdown on and off could lead to the visual effects not being removed.

1.0
- Initial release
</pre>
        </a>

        <a name="equipment">          
        <h2>Equipment</h2>
            This expansion declares no equipment. 
        </a>

        <a name="ships">    
        <h2>Ships</h2>
            <table>
                <tr>
                    <th>Name</th>
                </tr>
                <tr>
                    <td><a href="../ships/jumpbeacon_marker.html">Jump Marker</a></td>
                </tr>
            </table>
        </a>

        <a name="models">    
        <h2>Models</h2>
            This expansion declares no models. 
        </a>

        <a name="scripts">    
        <h2>Scripts</h2>
            <table>
                <tr>
                    <th>Path</th>
                </tr>
                <tr>
                    <td valign="top">Scripts/mwa_conditions.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name        = &quot;ManualWitchspaceAlignment_Conditions&quot;;
this.author      = &quot;phkb&quot;;
this.copyright   = &quot;2017 phkb&quot;;
this.description = &quot;Condition script for equipment.&quot;;
this.licence     = &quot;CC BY-NC-SA 3.0&quot;;

//-------------------------------------------------------------------------------------------------------------
this.allowAwardEquipment = function(equipment, ship, context) {
	if (context === &quot;scripted&quot;) return true;
    return false;
}</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/mwa_main.js</td>
                    <td><pre>&quot;use strict&quot;;
this.name = &quot;ManualWitchspaceAlignment&quot;;
this.author = &quot;phkb&quot;;
this.copyright = &quot;2017 phkb&quot;;
this.description = &quot;Reimplements the DHI AHC but with a manual alignment procedure&quot;;
this.licence = &quot;CC BY-NC-SA 3.0&quot;;

/*
	TODO:
		work out better occlusion calc for stations
*/

this._markers = []; // array of markers representing jump points to all local systems
this._running = false; // used to work out when the spawn routine is running
this._alignAccuracy = 0.18; // used to control how accurately the player needs to align their ship to the nav beacon
// higher number means less accuracy
this._heldTarget = null;
this._colorList = [&quot;blue&quot;, &quot;amber&quot;, &quot;green&quot;, &quot;pink&quot;, &quot;purple&quot;, &quot;white&quot;];
this._color = 0;
this._userOverride = false;
this._nova = false;
this._cancelled = false;
this._fcb;

this._libSettings = {
	Name: this.name,
	Display: &quot;UI Settings&quot;,
	Alias: &quot;Manual Witchspace Alignment&quot;,
	Alive: &quot;_libSettings&quot;,
	Bool: {
		B0: {
			Name: &quot;_userOverride&quot;,
			Def: false,
			Desc: &quot;User Override&quot;
		},
		Info: &quot;Setting User override to true will prevent other OXP&#39;s from changing the UI color.&quot;
	},
	SInt: {
		S0: {
			Name: &quot;_color&quot;,
			Def: 0,
			Min: 0,
			Max: 5,
			Desc: &quot;Nav Frame Color&quot;
		},
		Info: &quot;0 = Blue, 1 = Amber/Orange, 2 = Green, 3 = Pink, 4 = Purple, 5 = White&quot;
	},
};

this._trueValues = [&quot;yes&quot;, &quot;1&quot;, 1, &quot;true&quot;, true];

//-------------------------------------------------------------------------------------------------------------
this.startUp = function () {
	if (worldScripts.Lib_Config) {
		if (missionVariables.MWA_UserOverride) this._userOverride = (this._trueValues.indexOf(missionVariables.MWA_UserOverride) &gt;= 0 ? true : false);
		if (missionVariables.MWA_Color) this._color = parseInt(missionVariables.MWA_Color);
	}
	// make sure we don&#39;t get in the way of the ANC
	if (worldScripts.Deep_Horizon_Adv_Nav_Comp) {
		// turn off ws events in ANC and control them from here
		var anc = worldScripts.Deep_Horizon_Adv_Nav_Comp;
		anc.shipWillEnterWitchspace_hold = anc.shipWillEnterWitchspace;
		delete anc.shipWillEnterWitchspace;
		anc.shipWillExitWitchspace_hold = anc.shipWillExitWitchspace;
		delete anc.shipWillExitWitchspace;
		anc.playerStartedJumpCountdown_hold = anc.playerStartedJumpCountdown;
		delete anc.playerStartedJumpCountdown;
	}
	if (worldScripts.BGS) {
		player.ship.script._BGS = true;
		// we&#39;re taking charge of BGS&#39;s playerStartedJumpCountdown routine so we can make sure
		// it&#39;s only called when we actually start the countdown (ie when aligned);
		worldScripts.BGS.$mwa_playerStartedJumpCountdown = worldScripts.BGS.playerStartedJumpCountdown;
		delete worldScripts.BGS.playerStartedJumpCountdown;
	}
}

//-------------------------------------------------------------------------------------------------------------
this.startUpComplete = function () {
	if (worldScripts.Lib_Config) worldScripts.Lib_Config._registerSet(this._libSettings);
	this.$systemSetup();

	// bug fix to prevent countdown to zero from having its timer garbage collected if the jump starts/stops frequently
	if (worldScripts.countdown_to_zero) {
		worldScripts.countdown_to_zero.playerStartedJumpCountdown = function(type, seconds) {
			if (this.$hyperTimer &amp;&amp; this.$hyperTimer.isRunning === true) {
				this.$hyperTimer.stop();
			}
			if (type === &quot;standard&quot;) {
				missionVariables[&quot;countdown_to_zero&quot;] = seconds;
				this.$hyperTimer = new Timer(this,this._hyperDriveCountdown,0,1);
			}
			else if (type === &quot;galactic&quot;) {
				missionVariables[&quot;countdown_to_zero&quot;] = seconds - 1;
				this.$hyperTimer = new Timer(this,this._hyperDriveCountdown,1,1);
			}
		}
	}
}

//-------------------------------------------------------------------------------------------------------------
this.shipWillDockWithStation = function (station) {
	this.$stopNavFrameCallback(true);
}

//-------------------------------------------------------------------------------------------------------------
this.shipWillLaunchFromStation = function () {
	this._running = false;
	var ps = player.ship.script;
	ps.$checkForAlignment = this.$checkForAlignment;
	ps.$shipIsAligned = this.$shipIsAligned;
	ps.$jumpIsOccluded = this.$jumpIsOccluded;
	ps.$entityType = this.$entityType;
	ps.$reorientVEToPlayer = this.$reorientVEToPlayer;
	ps.$vectoredPositionToTarget = this.$vectoredPositionToTarget;
	ps.$lookAtRotate = this.$lookAtRotate;
	ps.$orthoNormalise = this.$orthoNormalise;
	ps.$lookAtRotateEuler = this.$lookAtRotateEuler;
	ps.$displayBasicPointerMessage = this.$displayBasicPointerMessage;
	ps.$positionNavVisualEffects = this.$positionNavVisualEffects;
	ps.$performCancel = this.$performCancel;

	//ps._useCheckCourseFunction = player.ship.hasOwnProperty(&quot;checkCourseToPosition&quot;) === true ? true : false; //oolite.compareVersion(&quot;1.87&quot;) &lt;= 0 ? true : false;
	ps._checkingAlignment = false;
	ps._jumpStarted = false;
	ps._BGSStarted = false;
	ps._jumpMarker = null;
	ps._alignCount = 0;
	ps._occludedCount = 0;
	ps._alignWarning = false;
	ps._occludedWarning = false;
	ps._override = false;
	ps._navFrameVE = null;
	ps._navStarVE = null;
	ps._basicCompassFrameCount = 0;
	ps._alignAccuracy = this._alignAccuracy;
	this._cancelled = false;

	var anc = worldScripts.Deep_Horizon_Adv_Nav_Comp;
	ps._usingANC = false;
	if (anc) {
		if (player.ship.equipmentStatus(&quot;EQ_ADV_NAV_COMP&quot;) === &quot;EQUIPMENT_OK&quot;) {
			// turn on anc, turn off mwa
			anc.shipWillEnterWitchspace = anc.shipWillEnterWitchspace_hold;
			anc.shipWillExitWitchspace = anc.shipWillExitWitchspace_hold;
			anc.playerStartedJumpCountdown = anc.playerStartedJumpCountdown_hold;
			ps._usingANC = true;
		} else {
			delete anc.shipWillEnterWitchspace;
			delete anc.shipWillExitWitchspace;
			delete anc.playerStartedJumpCountdown;
		}
	}
}

//-------------------------------------------------------------------------------------------------------------
this.shipDied = function(whom, why) {
	this.$alternateStopNavFrameCallback(false);
}

//-------------------------------------------------------------------------------------------------------------
this.playerWillSaveGame = function () {
	missionVariables.MWA_UserOverride = this._userOverride;
	missionVariables.MWA_Color = this._color;
}

//-------------------------------------------------------------------------------------------------------------
this.guiScreenChanged = function (to, from) {
	var p = player.ship;
	if (p.isInSpace === false) return;
	if ((to === &quot;GUI_SCREEN_LONG_RANGE_CHART&quot; || to === &quot;GUI_SCREEN_SHORT_RANGE_CHART&quot;) &amp;&amp; this._heldTarget == null) this._heldTarget = p.nextSystem;
	if ((from === &quot;GUI_SCREEN_LONG_RANGE_CHART&quot; || from === &quot;GUI_SCREEN_SHORT_RANGE_CHART&quot;) &amp;&amp;
		(to != &quot;GUI_SCREEN_LONG_RANGE_CHART&quot; &amp;&amp; to != &quot;GUI_SCREEN_SHORT_RANGE_CHART&quot;) &amp;&amp; this._heldTarget != p.nextSystem) {
		// player changed destination system
		if (p.script._navFrameCallbackID &amp;&amp; isValidFrameCallback(p.script._navFrameCallbackID)) {
			player.consoleMessage(&quot;Hyperspace destination changed - jump cancelled&quot;, 5);
			p.cancelHyperspaceCountdown();
			this.$stopNavFrameCallback(false);
		}
	}
}

//-------------------------------------------------------------------------------------------------------------
this.shipLaunchedEscapePod = function(escapePod) {
	this.$alternateStopNavFrameCallback(false);
}

//-------------------------------------------------------------------------------------------------------------
this.shipExitedWitchspace = function () {
	this.$systemSetup();
	player.ship.script._checkingAlignment = false;
	if (this._nova === true) {
		player.ship.takeInternalDamage();
		this._nova = false;
	}
}

//-------------------------------------------------------------------------------------------------------------
this.shipWillEnterWitchspace = function (cause, destination) {
	this._heldTarget = null;
	delete this.compassTargetChanged;
	delete this.playerStartedAutoPilot;
	//delete this.playerCancelledJumpCountdown;
	this._cancelled = false;
	this.$stopNavFrameCallback(false);
}

//-------------------------------------------------------------------------------------------------------------
this.playerStartedJumpCountdown = function (type, seconds) {
	if (this._cancelled == true) {
		// jump was cancelled during a playerStartedJumpCountdown worldscript
		this._cancelled = false;
		return;
	}
	var ps = player.ship.script;
	// check for galactic jump or if the anc is in play, or the system is going nova - don&#39;t do anything for these
	if (type === &quot;galactic&quot; || ps._usingANC === true || (system.sun &amp;&amp; system.sun.hasGoneNova)) {
		if (ps._BGS) worldScripts.BGS.$mwa_playerStartedJumpCountdown(type, seconds);
		if (system.sun &amp;&amp; system.sun.hasGoneNova) {
			this._nova = true;
			player.consoleMessage(&quot;System going nova - Emergency alignment engaged&quot;);
		}
		return;
	}

	if (!ps._navFrameCallbackID) {
		ps._basicCompass = false;
		if (system.isInterstellarSpace === true || player.ship.hasEquipmentProviding(&quot;EQ_ADVANCED_COMPASS&quot;) === false) {
			ps._basicCompass = true;
		}
		this.$spawnJBNavVEs();
	} else if (ps._override === false) {
		player.ship.cancelHyperspaceCountdown();
		//this.$stopNavFrameCallback(true);
		player.consoleMessage(expandDescription(&quot;[witch-user-abort]&quot;));
	}
}

//-------------------------------------------------------------------------------------------------------------
this.playerStartedAutoPilot_hide = function () {
	player.consoleMessage(expandDescription(&quot;[witch-user-abort]&quot;));
	player.ship.cancelHyperspaceCountdown();
	this.$stopNavFrameCallback(true);
}

//-------------------------------------------------------------------------------------------------------------
this.compassTargetChanged_hide = function (whom, mode) {
	player.consoleMessage(expandDescription(&quot;[witch-user-abort]&quot;));
	delete player.ship.script._oldTarget;
	this.$stopNavFrameCallback(true);
	player.ship.cancelHyperspaceCountdown();
}

//-------------------------------------------------------------------------------------------------------------
this.playerCancelledJumpCountdown = function () {
	var ps = player.ship.script;
	ps._BGSStarted = false;
	if (ps._override === true) return;
	if (ps._usingANC === true) return;
	// set cancelled = true if we got here before the playerStartedJumpCountdown function was executed
	// usually because some other OXP cancelled the jump in it&#39;s own playerStartedJumpCountdown function.
	if (ps._jumpStarted == false) this._cancelled = true;
	this.$stopNavFrameCallback(true);
}

//-------------------------------------------------------------------------------------------------------------
this.playerJumpFailed = function (reason) {
	this.$stopNavFrameCallback(true);
}

//-------------------------------------------------------------------------------------------------------------
this.$spawnJBNavVEs = function $spawnJBNavVEs() {
	if (this._running === true) return;
	this._running = true;
	var p = player.ship;
	var ps = p.script;
	// Select marker that matches the destination system.
	var playerTarget = p.nextSystem;
	for (var i = 0; i &lt; this._markers.length; i++) {
		if (playerTarget === this._markers[i].systemID) {
			ps._jumpMarker = this._markers[i];
			break;
		}
	}
	if (ps._jumpMarker == null) {
		log(this.name, &quot;!!ERROR: marker not found for &quot; + System.systemNameForID(playerTarget) + &quot;!&quot;);
		this._running = false;
		return;
	}
	player.consoleMessage(System.systemNameForID(playerTarget) + &quot; system beacon acquired.&quot;);
	ps._jumpMarker.beaconCode = &quot;witch-destination-icon&quot;;
	ps._jumpMarker.beaconLabel = &quot;Hyperspace destination: &quot; + ps._jumpMarker.name;

	ps._jumpStarted = true;
	// start the framecount at its recycle point so an alignment check will happen next frame
	ps._frameCount = 0.4;

	// Spawn Visual Effect and store reference to it
	if (this._color &gt; 5 || this._color &lt; 0) this._color = 0; // default to blue if incorrectly set
	ps._navFrameVE = system.addVisualEffect(&quot;jumpbeacon_navframe_&quot; + this._colorList[this._color], ps.$vectoredPositionToTarget(ps._jumpMarker.position, p.collisionRadius + 5000));
	ps._navStarVE = system.addVisualEffect(&quot;jumpbeacon_navstar&quot;, ps.$vectoredPositionToTarget(ps._jumpMarker.position, p.collisionRadius + 50000));
	// Orient the VE toward the player ship
	ps._navFrameVE.scale(0.66);
	ps._navStarVE.scale(3.30 - ps._jumpMarker.distanceToSystem * 0.27);
	var tex = ps._jumpMarker.systemID % 4;
	switch (tex) {
		case 1:
			ps._navStarVE.setMaterials({
				&quot;jumpbeacon_navstar.png&quot;: {
					&quot;textures&quot;: [&quot;jumpbeacon_navstar2.png&quot;],
					&quot;fragment_shader&quot;: &quot;jumpbeacon_jumpstar.fragment&quot;,
					&quot;emission_map&quot;: &quot;jumpbeacon_navstar2.png&quot;,
					&quot;uniforms&quot;: {
						&quot;uColorMap&quot;: {
							&quot;type&quot;: &quot;texture&quot;,
							&quot;value&quot;: &quot;0&quot;
						},
						&quot;uSpecIntensity&quot;: &quot;shaderFloat1&quot;,
						&quot;uSpecColor&quot;: &quot;shaderVector1&quot;
					},
					&quot;vertex_shader&quot;: &quot;jumpbeacon_jumpstar.vertex&quot;
				}
			});
			break;
		case 2:
			ps._navStarVE.setMaterials({
				&quot;jumpbeacon_navstar.png&quot;: {
					&quot;textures&quot;: [&quot;jumpbeacon_navstar3.png&quot;],
					&quot;fragment_shader&quot;: &quot;jumpbeacon_jumpstar.fragment&quot;,
					&quot;emission_map&quot;: &quot;jumpbeacon_navstar3.png&quot;,
					&quot;uniforms&quot;: {
						&quot;uColorMap&quot;: {
							&quot;type&quot;: &quot;texture&quot;,
							&quot;value&quot;: &quot;0&quot;
						},
						&quot;uSpecIntensity&quot;: &quot;shaderFloat1&quot;,
						&quot;uSpecColor&quot;: &quot;shaderVector1&quot;
					},
					&quot;vertex_shader&quot;: &quot;jumpbeacon_jumpstar.vertex&quot;
				}
			});
			break;
		case 3:
			ps._navStarVE.setMaterials({
				&quot;jumpbeacon_navstar.png&quot;: {
					&quot;textures&quot;: [&quot;jumpbeacon_navstar4.png&quot;],
					&quot;fragment_shader&quot;: &quot;jumpbeacon_jumpstar.fragment&quot;,
					&quot;emission_map&quot;: &quot;jumpbeacon_navstar4.png&quot;,
					&quot;uniforms&quot;: {
						&quot;uColorMap&quot;: {
							&quot;type&quot;: &quot;texture&quot;,
							&quot;value&quot;: &quot;0&quot;
						},
						&quot;uSpecIntensity&quot;: &quot;shaderFloat1&quot;,
						&quot;uSpecColor&quot;: &quot;shaderVector1&quot;
					},
					&quot;vertex_shader&quot;: &quot;jumpbeacon_jumpstar.vertex&quot;
				}
			});
			break;
	}
	ps._navFrameCallbackID = addFrameCallback(ps.$positionNavVisualEffects.bind(ps));
	worldScripts.ManualWitchspaceAlignment._fcb = ps._navFrameCallbackID;
	this._running = false;
}

//-------------------------------------------------------------------------------------------------------------
this.$stopNavFrameCallback = function $stopNavFrameCallback(cancelled) {
	var p = player.ship;
	var ps = p.script;
	if (ps._navFrameCallbackID &amp;&amp; isValidFrameCallback(ps._navFrameCallbackID)) {
		removeFrameCallback(ps._navFrameCallbackID);
	}
	delete ps._navFrameCallbackID;
	delete this.compassTargetChanged;
	delete this.playerStartedAutoPilot;
	//delete this.playerCancelledJumpCountdown;
	if (ps._jumpMarker) {
		ps._jumpMarker.beaconCode = &quot;&quot;;
		ps._jumpMarker.beaconLabel = &quot;&quot;;
		ps._jumpMarker = null;
		if (ps._oldTarget &amp;&amp; ps._oldTarget.isValid) {
			p.compassTarget = ps._oldTarget;
		}
		delete ps._oldTarget;
	}
	if (ps._navFrameVE != null) {
		ps._navFrameVE.remove();
		ps._navFrameVE = null;
	}
	if (ps._navStarVE != null) {
		ps._navStarVE.remove();
		ps._navStarVE = null;
	}
	ps._jumpStarted = false;
	ps._occludedCount = 0;
	ps._occludedWarning = false;
	ps._alignWarning = false;
	ps._alignCount = 0;
	ps._override = false;
	ps._lastHeading = null;
	if (ps._BGS &amp;&amp; ps._usingANC === false &amp;&amp; cancelled === true) {
		ps._BGSStarted = false;
		worldScripts.BGS.playerCancelledJumpCountdown();
		worldScripts.BGS._clrTimer(1);
	}
	this._running = false;
}

//-------------------------------------------------------------------------------------------------------------
this.$alternateStopNavFrameCallback = function $alternateStopNavFrameCallback() {
	if (this.fcb &amp;&amp; isValidFrameCallback(this._fcb)) {
		removeFrameCallback(this._fcb);
	}
	var ve = system.allVisualEffects;
	for (var i = ve.count; i &gt;= 0; i--) {
		if (ve[i].dataKey.indexOf(&quot;jumpbeacon&quot;) &gt;= 0) {
			ve[i].remove();
		}
	}
}

//-------------------------------------------------------------------------------------------------------------
this.$systemSetup = function $systemSetup() {
	this._markers.length = 0;
	// Determine how many farpoint markers are needed
	this._localSystems = System.infoForSystem(galaxyNumber, system.ID).systemsInRange(7);
	this._spawnCount = this._localSystems.length;
	// For each in-range system spawn a farpoint marker
	this._markers = system.addShips(&quot;jump_marker&quot;, this._spawnCount, player.ship.position, 5000000);
	//Assign a matching system.ID as an additional value to each buoy
	for (var i = 0; i &lt; this._markers.length; i++) {
		var mkr = this._markers[i];
		mkr.systemID = this._localSystems[i].systemID;
		mkr.galCoordinates = this._localSystems[i].coordinates;
		mkr.name = this._localSystems[i].name;
		mkr.distanceToSystem = System.infoForSystem(galaxyNumber, system.ID).distanceToSystem(this._localSystems[i]);
		mkr.uSpecColor = this.$selectColor(this._localSystems[i].systemID, i);
		mkr.uSpecIntensity = 0.5;
		mkr.position = this.$positionJumpBeaconMarker(mkr, 100000000);
	}
}

//-------------------------------------------------------------------------------------------------------------
this.$positionJumpBeaconMarker = function $positionJumpBeaconMarker(marker, distance) {
	if (marker.galCoordinates == null) return null;
	var t = marker.galCoordinates;
	var s = System.infoForSystem(galaxyNumber, system.ID).coordinates;

	var tV = t.subtract(s);

	var u = system.scrambledPseudoRandomNumber(34567346);
	var v = system.scrambledPseudoRandomNumber(431976567);
	var w = system.scrambledPseudoRandomNumber(9834674);

	var theta = Math.acos(2 * u - 1);
	var phi = 2 * Math.PI * v;
	var psi = 2 * Math.PI * w;

	var v1 = new Vector3D(Math.sin(theta) * Math.sin(phi), Math.sin(theta) * Math.cos(phi), Math.cos(theta));
	var v2 = new Vector3D(0, 0, 1); //straight up
	var v3 = v2.cross(v1);
	v3 = v3.direction(); // normalize (should be normalized anyway)

	var q1 = new Quaternion(1, 0, 0, 0);
	q1 = q1.rotate(v3, theta).normalize();
	var v4 = tV.rotateBy(q1).direction(); // rotate target vector tV so that the coordinate space has pole moved from straight up to v1 (theta, phi) (spherical coords)
	var q2 = new Quaternion(1, 0, 0, 0);
	q2 = q2.rotate(v1, psi).normalize();
	v4 = v4.rotateBy(q2).direction(); // rotate about the new pole v1 by psi

	return v4.multiply(distance).add(player.ship.position);
}

//-------------------------------------------------------------------------------------------------------------
this.$selectColor = function $selectColor(sysID, i) {
	var color = System.infoForSystem(galaxyNumber, sysID).sun_color;
	if (typeof (color) === &#39;undefined&#39;) {
		var c = Math.floor(system.scrambledPseudoRandomNumber(785331 - i) * 7);
		switch (c) {
			case 0:
				color = &quot;magentaColor&quot;;
				break;
			case 1:
				color = &quot;redColor&quot;;
				break;
			case 2:
				color = &quot;orangeColor&quot;;
				break;
			case 3:
				color = &quot;yellowColor&quot;;
				break;
			case 4:
				color = &quot;whiteColor&quot;;
				break;
			case 5:
				color = &quot;cyanColor&quot;;
				break;
			default:
				color = &quot;blueColor&quot;;
				break;
		}
	}
	switch (color) {
		case &quot;magentaColor&quot;:
			var colorVec = [1, 0, 1];
			break;
		case &quot;redColor&quot;:
			var colorVec = [1, 0, 0];
			break;
		case &quot;orangeColor&quot;:
			var colorVec = [1, 0.5, 0];
			break;
		case &quot;yellowColor&quot;:
			var colorVec = [1, 1, 0];
			break;
		case &quot;whiteColor&quot;:
			var colorVec = [1, 1, 1];
			break;
		case &quot;cyanColor&quot;:
			var colorVec = [0, 1, 1];
			break;
		case &quot;blueColor&quot;:
			var colorVec = [0, 0, 1];
			break;
		default:
			var colorVec = [1, 1, 1];
	}
	return colorVec;
}

//-------------------------------------------------------------------------------------------------------------
// all the following functions are attached to player.ship.script to improve performance

//-------------------------------------------------------------------------------------------------------------
// main frame callback routine
this.$positionNavVisualEffects = function $positionNavVisualEffects(delta) {
	if (delta === 0) return;
	var p = this.ship;
	// make sure we have a valid ship to work with
	if (!p || !p.position || !p.vectorForward) {
		worldScripts.ManualWitchspaceAlignment.$alternateStopNavFrameCallback(false);
		return;
	}
	var ps = this;
	// make sure we have valid entities to work with, otherwise cancel the fcb
	if (ps._navFrameVE.isValid === false || ps._navStarVE.isValid === false) {
		if (ps._navFrameCallbackID &amp;&amp; isValidFrameCallback(ps._navFrameCallbackID)) {
			removeFrameCallback(ps._navFrameCallbackID);
		}
		delete ps._navFrameCallbackID;
		return;
	}
	ps.$reorientVEToPlayer(ps._navFrameVE);
	ps.$reorientVEToPlayer(ps._navStarVE);
	ps._navFrameVE.position = ps.$vectoredPositionToTarget(ps._jumpMarker.position, p.collisionRadius + 5000);
	ps._navStarVE.position = ps.$vectoredPositionToTarget(ps._jumpMarker.position, p.collisionRadius + 10000);
	ps._navStarVE.shaderVector1 = ps._jumpMarker.uSpecColor;
	ps._navStarVE.shaderFloat1 = ps._jumpMarker.uSpecIntensity;
	ps._frameCount += delta;
	if (ps._frameCount &gt; 0.5) {
		ps._frameCount = 0;
		ps.$checkForAlignment();
	}
	// for non-compass directions, we need to give a console message pointer to the beacon
	if (ps._basicCompass === true) {
		ps._basicCompassFrameCount += delta;
		if (ps._basicCompassFrameCount &gt; 2) {
			ps._basicCompassFrameCount = 0;
			ps.$displayBasicPointerMessage();
		}
	}
}

//-------------------------------------------------------------------------------------------------------------
this.$checkForAlignment = function $checkForAlignment() {
	//var startDate = new Date();
	// make sure we don&#39;t run over ourselves
	var ps = this;
	if (ps._checkingAlignment === true) return;
	ps._checkingAlignment = true;
	var p = this.ship;
	if (p.maxPitch - Math.abs(p.pitch) &lt; 0.0001) {
		ps._checkingAlignment = false;
		return;
	}
	var ws = worldScripts.ManualWitchspaceAlignment;
	// set the compass to the nav jump marker, and kick in our functions to monitor when the 
	// compass target changes, and when the player cancels the jump
	if (ps._basicCompass === false &amp;&amp; ps._jumpMarker &amp;&amp; p.compassTarget != ps._jumpMarker) {
		ps._oldTarget = p.compassTarget;
		p.compassTarget = ps._jumpMarker;
		ws.compassTargetChanged = ws.compassTargetChanged_hide;
		ws.playerStartedAutoPilot = ws.playerStartedAutoPilot_hide;
		//ws.playerCancelledJumpCountdown = ws.playerCancelledJumpCountdown_hide;
	}
	if (ps.$shipIsAligned() === true) {
		ps._alignWarning = false;
		ps._lastHeading = p.heading;
		if (ps._jumpStarted === false) {
			ps._jumpStarted = true;
			if (ps._cancelTimer &amp;&amp; ps._cancelTimer.isRunning) ps._cancelTimer.stop();
			ps._override = true;
			p.beginHyperspaceCountdown(p.hyperspaceSpinTime);
			//ws.playerCancelledJumpCountdown = ws.playerCancelledJumpCountdown_hide;
			ps._override = false;
		}
		if (ps._BGS &amp;&amp; ps._BGSStarted === false) {
			ps._BGSStarted = true;
			worldScripts.BGS.$mwa_playerStartedJumpCountdown(&quot;standard&quot;, p.hyperspaceSpinTime);
		}
	} else {
		if (ps._jumpStarted === true) {
			ps._jumpStarted = false;
			//delete ws.playerCancelledJumpCountdown;
			// do the actual cancellation through a separate timer, rather than the framecallback
			// sometimes getting timeout errors when run through the fcb
			if (!ps._cancelTimer || !ps._cancelTimer.isRunning) {
				ps._cancelTimer = new Timer(ps, ps.$performCancel, 0.25, 0);
			}
			//p.cancelHyperspaceCountdown();
			/*if (ps._BGS) {
				worldScripts.BGS.playerCancelledJumpCountdown();
				worldScripts.BGS._clrTimer(1);
			}*/
		}
		ps._alignCount += 1;
		if (ps._alignCount &gt;= 15 &amp;&amp; ps._occludedWarning === false) ps._alignWarning = false;
		if (ps._alignWarning === false) {
			ps._alignWarning = true;
			ps._alignCount = 0;
			player.consoleMessage(expandDescription(&quot;[witch-unaligned]&quot;), 4);
		}
	}
	ps._checkingAlignment = false;
	//log(this.name, &quot;checkForAlignment complete in ms: &quot; + (new Date().getTime() - startDate.getTime()));
}

//-------------------------------------------------------------------------------------------------------------
this.$performCancel = function $performCancel() {
	var p = player.ship;
	p.script._override = true;
	p.cancelHyperspaceCountdown();
	p.script._override = false;
}

//-------------------------------------------------------------------------------------------------------------
this.$vectoredPositionToTarget = function $vectoredPositionToTarget(targetPosVector, distance) {
	if (!this.ship || !this.ship.position) return null;
	var v = targetPosVector.subtract(this.ship.position).direction();
	v = v.multiply(distance);
	v = v.add(this.ship.position);
	return v;
}

//-------------------------------------------------------------------------------------------------------------
this.$reorientVEToPlayer = function $reorientVEToPlayer(navVE) {
	if (!this.ship || !this.ship.position) return;
	var orient = this.$lookAtRotate(this.ship.position.subtract(navVE.position), this.ship.orientation.vectorUp());
	if (orient === null) orient = this.$lookAtRotate(this.ship.position.subtract(navVE.position), this.ship.orientation.vectorForward().multiply(-1));
	navVE.orientation = orient;
}

//-------------------------------------------------------------------------------------------------------------
this.$lookAtRotate = function $lookAtRotate(forward, up) {
	//returns an orientation quaternion given a Forward vector and an Up vector (the Forward and Up do not need to be
	//orthonormal but they can not be parallel or anti-parallel.)
	if (forward.direction().cross(up.direction()).magnitude() &lt; 0.01) return null; // Return null if Forward and Up are parallel or anti-parallel or nearly so.
	var f = forward.direction();
	var u = this.$orthoNormalise(f, up);

	var v = new Vector3D(0, 1, 0); //Uses Y axis at the basis axis for theta and the Z axis is used to measure phi from for finding the Euler angles.
	var u2 = this.$orthoNormalise(f, v);

	var sign = -u2.cross(u).dot(f);
	var sign = sign &amp;&amp; sign / Math.abs(sign);

	var psi = sign * u2.angleTo(u);

	var z = new Vector3D(0, 0, 1);
	var h = new Vector3D(f.x, 0, f.z);

	sign = -z.cross(h).y;
	sign = sign &amp;&amp; sign / Math.abs(sign);

	var phi = sign * z.angleTo(h);

	sign = f.y;
	sign = sign &amp;&amp; sign / Math.abs(sign);

	var theta = (Math.PI / 2) - (sign * h.angleTo(f));
	return this.$lookAtRotateEuler(theta, phi, psi);
}

//-------------------------------------------------------------------------------------------------------------
this.$orthoNormalise = function $orthoNormalise(a, b) {
	//Returns a normalised vector that is in the plane of &quot;ab&quot; and is at 90� to &quot;a&quot; in the same half plane as &quot;b&quot;.
	var a2 = a.direction();
	var b2 = b.direction();
	var c = a.cross(b).cross(a);
	return c.direction();
}

//-------------------------------------------------------------------------------------------------------------
this.$lookAtRotateEuler = function $lookAtRotateEuler(theta, phi, psi) {
	//Returns a Quaternion that matches a rotational transformation that is described by the Euler angles.
	//Uses Y axis at the basis axis for theta and the Z axis is used to measure phi from.
	var q = new Quaternion(1, 0, 0, 0);
	var theta2 = (Math.PI / 2) - theta;
	q = q.rotateZ(psi);
	q = q.rotateX(theta2);
	q = q.rotateY(phi);
	return q;
}

//-------------------------------------------------------------------------------------------------------------
this.$shipIsAligned = function $shipIsAligned() {
	//var startDate = new Date();
	var p = this.ship;
	var target = this._jumpMarker;
	if (!target) return false;
	var deviation = p.vectorForward.angleTo(target.position.subtract(p.position));
	if (deviation &lt; this._alignAccuracy) {
		// check for occlusion
		/*if (p.script._useCheckCourseFunction === true) {
			var ent = p.checkCourseToPosition(target.position);
			if (ent &amp;&amp; (ent.isPlanet || ent.isSun || ent.isStation)) {
				this._occludedCount += 1;
				if (this._occludedCount &gt;= 15 &amp;&amp; this._occludedWarning === true) this._occludedWarning = false;
				if (this._occludedWarning === false) {
					this._occludedCount = 0;
					player.consoleMessage(expandDescription(&quot;[witch-occluded]&quot;, {
						entity: this.$entityType(ent)
					}), 4);
					this._occludedWarning = true;
				}
				return false;
			}
		} else {*/
			var entities = [].concat(system.planets).concat(system.sun).concat(system.stations);
			var occluded = false;
			if (entities.length &gt; 0) {
				for (var i = 0; i &lt; entities.length; i++) {
					if (entities[i] &amp;&amp; this.$jumpIsOccluded(entities[i], target) === true) {
						this._occludedCount += 1;
						if (this._occludedCount &gt;= 15 &amp;&amp; this._occludedWarning === true) this._occludedWarning = false;
						if (this._occludedWarning === false) {
							this._occludedCount = 0;
							player.consoleMessage(expandDescription(&quot;[witch-occluded]&quot;, {
								entity: this.$entityType(entities[i])
							}), 4);
							this._occludedWarning = true;
						}
						//log(this.name, &quot;align check complete in ms: &quot; + (new Date().getTime() - startDate.getTime()));
						return false;
					}
				}
			}
		//}
		//log(this.name, &quot;align check complete in ms: &quot; + (new Date().getTime() - startDate.getTime()));
		return true;
	} else {
		//log(this.name, &quot;align check complete in ms: &quot; + (new Date().getTime() - startDate.getTime()));
		return false;
	}
}

//-------------------------------------------------------------------------------------------------------------
// with thanks to spara for the calculation
this.$jumpIsOccluded_alt = function $jumpIsOccluded_alt(bodyEntity, targetEntity) {
	//if (this._jumpStarted === true &amp;&amp; this._lastHeading &amp;&amp; this.ship.heading.dot(this._lastHeading) &gt; 0.99) return false;
	var vStellarBody = bodyEntity.position;
	var rStellarBody = bodyEntity.radius;
	// i&#39;m reusing this routine for stations, but it&#39;s not ideal for non-spherical entities
	if (bodyEntity.isStation) {
		var box = bodyEntity.boundingBox;
		rStellarBody = (box.x &gt; box.y &amp;&amp; box.x &gt; box.z ? box.x :
			(box.y &gt; box.x &amp;&amp; box.y &gt; box.z ? box.y : box.z)) / 2;
	}
	if (isNaN(rStellarBody) === true) return false;
	var vTarget = targetEntity.position;
	var vPlayerShip = player.ship;

	var vPlayerToStellar = vStellarBody.subtract(vPlayerShip);
	var vPlayerToTarget = vTarget.subtract(vPlayerShip);

	var dPlayerToStellar = vPlayerToStellar.magnitude();
	var dPlayerToTarget = vPlayerToTarget.magnitude();

	if (dPlayerToStellar &lt; dPlayerToTarget) {
		var aStellar = Math.asin(rStellarBody / dPlayerToStellar);
		var aTarget = vPlayerToStellar.angleTo(vPlayerToTarget);
		if (aStellar &gt; aTarget) {
			return true;
		} else {
			return false;
		}
	}
}

//-------------------------------------------------------------------------------------------------------------
// with thanks to spara for the calculation
this.$jumpIsOccluded = function $jumpIsOccluded(bodyEntity, targetEntity) {
	//if (this._jumpStarted === true &amp;&amp; this._lastHeading &amp;&amp; this.ship.heading.dot(this._lastHeading) &gt; 0.99) return false;
	//var startDate = new Date();
	//var vStellarBody = bodyEntity.position;
	var rStellarBody = bodyEntity.radius;
	// i&#39;m reusing this routine for stations, but it&#39;s not ideal for non-spherical entities (I think)
	if (bodyEntity.isStation) {
		var box = bodyEntity.boundingBox;
		rStellarBody = (box.x &gt; box.y &amp;&amp; box.x &gt; box.z ? box.x :
			(box.y &gt; box.x &amp;&amp; box.y &gt; box.z ? box.y : box.z)) / 2;
	}
	if (isNaN(rStellarBody) === true) return false;
	var vTarget = targetEntity.position;
	var vPlayerShip = this.ship.position;

	var vPlayerToTarget = vTarget.subtract(vPlayerShip);

	var dPlayerToStellar = vPlayerShip.distanceTo(bodyEntity);
	var dPlayerToTarget = vPlayerToTarget.magnitude();

	if (dPlayerToStellar &lt; dPlayerToTarget) {
		var checkVal = Math.sqrt(Math.pow(dPlayerToStellar, 2) - Math.pow(rStellarBody, 2));
		if (isNaN(checkVal) === false) {
			var vTest = vPlayerShip.add(vPlayerToTarget.direction().multiply(checkVal));
			var dTest = vTest.distanceTo(bodyEntity);
			if (rStellarBody &gt; dTest) {
				//log(this.name, &quot;occlusion check complete in ms: &quot; + (new Date().getTime() - startDate.getTime()));
				return true;
			} else {
				//log(this.name, &quot;occlusion check complete in ms: &quot; + (new Date().getTime() - startDate.getTime()));
				return false;
			}
		} else {
			return true;
		}
	} else {
		//log(this.name, &quot;occlusion check complete in ms: &quot; + (new Date().getTime() - startDate.getTime()));
		return false;
	}
}

//-------------------------------------------------------------------------------------------------------------
this.$entityType = function $entityType(entity) {
	if (entity.isPlanet) return &quot;planet&quot;;
	if (entity.isSun) return &quot;sun&quot;;
	return &quot;station&quot;;
}

//-------------------------------------------------------------------------------------------------------------
this.$displayBasicPointerMessage = function $displayBasicPointerMessage() {
	var p = this.ship;
	var target = this._jumpMarker;
	var output = &quot;&quot;;
	var f_dev = p.vectorForward.angleTo(target.position.subtract(p));
	var r_dev = p.vectorRight.angleTo(target.position.subtract(p));
	var u_dev = p.vectorUp.angleTo(target.position.subtract(p));
	var s = &quot;&quot;;
	// &gt; 1.56 means opposite side (3.12 exact opposite)
	// so, f_dev &lt; alignAccuracy -- aligned
	if (f_dev &lt; this._alignAccuracy) s = &quot;X&quot;;
	if (f_dev &gt;= this._alignAccuracy) {
		if (r_dev &gt; 1.69) s += &quot;left &quot;;
		if (u_dev &lt; 1.45) {
			s += (s === &quot;&quot; ? &quot;&quot; : &quot;and &quot;) + &quot;up &quot;;
		} else if (u_dev &gt; 1.69) {
			s += (s === &quot;&quot; ? &quot;&quot; : &quot;and &quot;) + &quot;down &quot;;
		}
		if (r_dev &lt; 1.45) s += (s === &quot;&quot; ? &quot;&quot; : &quot;and &quot;) + &quot;right &quot;;
		if (f_dev &gt; 1.57) s += &quot; (aft)&quot;;
	}
	if (s !== &quot;X&quot;) {
		output += &quot;Align: &quot; + s;
		player.consoleMessage(output, 2);
	}
}</pre></td>
                </tr>
            </table>
        </a>
    </body>
</html>
