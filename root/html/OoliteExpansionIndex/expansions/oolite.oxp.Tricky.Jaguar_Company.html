<html>
    <head>
        <title>Expansion Jaguar Company</title>
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <table border="0" width="100%">
            <tr>
                <td>Back to <a href='../index.html'>Index</a></td>
                <td align="right"><small>Page generated: Oct 11, 2023, 3:16:49 PM</small></td>
            </tr>
        </table>

        <h1>Expansion Jaguar Company</h1>

        <h2>Content</h2>
        <ul>
          
          <li><a href="#manifest">Manifest</a></li>
          <li><a href="#documentation">Documentation</a></li>
          <li><a href="#equipment">2 Equipment</a></li>
          <li><a href="#ships">31 Ships</a></li>
          <li><a href="#models">0 Models</a></li>
          <li><a href="#scripts">13 Scripts</a></li>
        </ul>


        <a name="manifest">
        <h2>Manifest</h2>
            <table border="1">
                <tr>
                    <th></th>
                    <th>from Expansion Manager's OXP list</th>
                    <th>from Expansion Manifest</th>
                </tr>
                <tr>
                    <td>Description</td>
                    <td>Adds in an Elite group of pilots to patrol the space lanes in Anarchy, Feudal and Multi-Government systems. Jaguar Company can also be found sometimes in interstellar space.</td>
                    <td>Adds in an Elite group of pilots to patrol the space lanes in Anarchy, Feudal and Multi-Government systems. Jaguar Company can also be found sometimes in interstellar space.</td>
                </tr>
                <tr>
                    <td>Identifier</td>
                    <td>oolite.oxp.Tricky.Jaguar_Company</td>
                    <td>oolite.oxp.Tricky.Jaguar_Company</td>
                </tr>
                <tr>
                    <td>Title</td>
                    <td>Jaguar Company</td>
                    <td>Jaguar Company</td>
                </tr>
                <tr>
                    <td>Category</td>
                    <td>Mechanics</td>
                    <td>Mechanics</td>
                </tr>
                <tr>
                    <td>Author</td>
                    <td>Tricky</td>
                    <td>Tricky</td>
                </tr>
                <tr>
                    <td>Version</td>
                    <td>2.5.29</td>
                    <td>2.5.29</td>
                </tr>
                <tr>
                    <td>Tags</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Required Oolite Version</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Maximum Oolite Version</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>Required Expansions</td>
                    <td>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>Optional Expansions</td>
                    <td>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>Conflict Expansions</td>
                    <td>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>Information URL</td>
                    <td><a target="_blank" href="http://wiki.alioth.net/index.php/Jaguar_Company">http://wiki.alioth.net/index.php/Jaguar_Company</a></td>
                    <td><a target="_blank" href="">n/a</a></td>
                </tr>
                <tr>
                    <td>Download URL</td>
                    <td><a target="_blank" href="https://wiki.alioth.net/img_auth.php/1/1b/Jaguar_Company_2.5.29.oxz">https://wiki.alioth.net/img_auth.php/1/1b/Jaguar_Company_2.5.29.oxz</a></td>
                    <td><a target="_blank" href="">n/a</a></td>
                </tr>
                <tr>
                    <td>License</td>
                    <td>CC BY-NC-SA 3.0</td>
                    <td>CC BY-NC-SA 3.0</td>
                </tr>
                <tr>
                    <td>File Size</td>
                    <td>n/a</td>
                </tr>
                <tr>
                    <td>Upload date</td>
                    <td>1610873242</td>
                </tr>
            </table>
                </a>

        <a name="documentation">
        <h2>Documentation</h2>
        <p>Also read <a href='http://wiki.alioth.net/index.php/Jaguar%20Company'>http://wiki.alioth.net/index.php/Jaguar%20Company</a></p>
        </a>

        <a name="equipment">          
        <h2>Equipment</h2>
            <table>
                <tr>
                    <th>Name</th>
                    <th>Visible</th>
                    <th>Cost [deci-credits]</th>
                    <th>Tech-Level</th>
                </tr>
                <tr>
                    <td><a href="../equipment/EQ_JAGUAR_COMPANY_BLACK_BOX.html">Jaguar Company Black Box</a></td>
                    <td>yes</td>
                    <td align="right">100000</td>
                    <td align="center">101+</td>
                </tr>
                <tr>
                    <td><a href="../equipment/EQ_JAGUAR_COMPANY_HARDENED_MISSILE_SMALL.html">Small ECM Hardened Missile</a></td>
                    <td>yes</td>
                    <td align="right">5000</td>
                    <td align="center">101+</td>
                </tr>
            </table>
        </a>

        <a name="ships">    
        <h2>Ships</h2>
            <table>
                <tr>
                    <th>Name</th>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_asteroid.html">jaguar_company_asteroid</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_base_bay.html">Jaguar Company Base Docking Bay</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_base_buoy_beacon.html">jaguar_company_base_buoy_beacon</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_base_buoy_no_beacon.html">jaguar_company_base_buoy_no_beacon</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_base_buoy_subent.html">jaguar_company_base_buoy_subent</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_base_buoy_template.html">Jaguar Company Base Buoy</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_base_discount.html">jaguar_company_base_discount</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_base_discount_and_docking.html">jaguar_company_base_discount_and_docking</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_base_no_discount.html">jaguar_company_base_no_discount</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_base_template.html">Jaguar Company Base</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_base_turret1.html">Jaguar Company Base Ball Turret</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_base_turret2.html">jaguar_company_base_turret2</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_base_turret3.html">jaguar_company_base_turret3</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_base_turret4.html">jaguar_company_base_turret4</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_base_turret5.html">jaguar_company_base_turret5</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_base_turret6.html">jaguar_company_base_turret6</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_base_turret7.html">jaguar_company_base_turret7</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_base_turret_holders.html">Jaguar Company Base Ball Turret Holders</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_boulder.html">jaguar_company_boulder</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_griff_ECM_Proof_missile.html">ECM Hardened Missile</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_griff_ECM_Proof_missile_small.html">Small ECM Hardened Missile</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_griff_normalmapped_cobra_mk3_front_gun.html">Jaguar Company Patrol Ship - Forward Weapon</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_griff_normalmapped_cobra_mk3_scuffed_front_gun.html">Jaguar Company Patrol Ship - Forward Weapon (Scuffed)</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_miner.html">Jaguar Company Mining Ship</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_patrol.html">jaguar_company_patrol</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_patrol_scuffed.html">jaguar_company_patrol_scuffed</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_ship_splinter.html">Jaguar Company Splinter Ship</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_template.html">Jaguar Company</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_tracker.html">Tracker: Jaguar Company Patrol</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_transporter_template.html">jaguar_company_transporter_template</a></td>
                </tr>
                <tr>
                    <td><a href="../ships/jaguar_company_tug.html">Jaguar Company Tug</a></td>
                </tr>
            </table>
        </a>

        <a name="models">    
        <h2>Models</h2>
            This expansion declares no models. 
        </a>

        <a name="scripts">    
        <h2>Scripts</h2>
            <table>
                <tr>
                    <th>Path</th>
                </tr>
                <tr>
                    <td valign="top">Scripts/jaguar_company.js</td>
                    <td><pre>/*jslint bitwise: true, es5: true, newcap: true, nomen: true, regexp: true, unparam: true, todo: true, white: true,
indent: 4, maxerr: 50, maxlen: 120 */
/*jshint boss: true, curly: true, eqeqeq: true, eqnull: true, es5: true, evil: true, forin: true, laxbreak: true,
loopfunc: true, noarg: true, noempty: true, strict: true, nonew: true, undef: true */
/*global Math, JSON, Object, System, Timer, Vector3D, expandDescription, expandMissionText, galaxyNumber, log, mission,
missionVariables, oolite, player, system, worldScripts */

/* Jaguar Company
 *
 * Copyright © 2012-2013 Richard Thomas Harrison (Tricky)
 *
 * This work is licensed under the Creative Commons
 * Attribution-Noncommercial-Share Alike 3.0 Unported License.
 *
 * To view a copy of this license, visit
 * http://creativecommons.org/licenses/by-nc-sa/3.0/ or send a letter
 * to Creative Commons, 171 Second Street, Suite 300, San Francisco,
 * California, 94105, USA.
 *
 * World script to setup Jaguar Company.
 */

(function () {
    &quot;use strict&quot;;

    /* Standard public variables for OXP scripts. */
    this.name = &quot;Jaguar Company&quot;;
    this.author = &quot;Tricky&quot;;
    this.copyright = &quot;© 2012-2013 Richard Thomas Harrison (Tricky)&quot;;
    this.license = &quot;CC BY-NC-SA 3.0&quot;;
    this.description = &quot;Script to initialise the Jaguar Company.&quot;;
    this.version = &quot;2.5&quot;;

    /* Private variables. */
    var p_main = {},
    p_const = {};

    /* This should really be defined as a const, but Notepad++ jsLint doesn&#39;t like that.
     * Set &#39;configurable&#39; so that they can be deleted by $killSelf().
     */
    Object.defineProperties(p_const, {
        &quot;shipNames&quot; : {
            value : [
                /* OU&#39;s, GOU&#39;s, LOU&#39;s and (d)ROU&#39;s. Also some names I really like. */
                &quot;Profit Margin&quot;, &quot;Trade Surplus&quot;, &quot;Limiting Factor&quot;, &quot;Gunboat Diplomat&quot;, &quot;Zealot&quot;, &quot;Xenophobe&quot;,
                &quot;God Told Me To Do It&quot;, &quot;Just Another Victim Of The Ambient Morality&quot;, &quot;Synchronize Your Dogmas&quot;,
                &quot;Thank you And Goodnight&quot;, &quot;Well I Was In The Neighbourhood&quot;, &quot;You&#39;ll Thank Me Later&quot;,
                &quot;Shoot Them Later&quot;, &quot;Attitude Adjuster&quot;, &quot;Killing Time&quot;, &quot;I Blame Your Mother&quot;, &quot;I Blame My Mother&quot;,
                &quot;Heavy Messing&quot;, &quot;Frank Exchange Of Views&quot;, &quot;Nuisance Value&quot;,
                &quot;All Through With This Niceness And Negotiation Stuff&quot;, &quot;I Said, I&#39;ve Got A Big Stick&quot;,
                &quot;Hand Me The Gun And Ask Me Again&quot;, &quot;But Who&#39;s Counting?&quot;, &quot;Germane Riposte&quot;,
                &quot;We Haven&#39;t Met But You&#39;re A Great Fan Of Mine&quot;, &quot;All The Same, I Saw It First&quot;,
                &quot;Ravished By The Sheer Implausibility Of That Last Statement&quot;, &quot;Zero Credibility&quot;,
                &quot;Charming But Irrational&quot;, &quot;Demented But Determined&quot;, &quot;You May Not Be The Coolest Person Here&quot;,
                &quot;Lucid Nonsense&quot;, &quot;Awkward Customer&quot;, &quot;Conventional Wisdom&quot;, &quot;Fine Till You Came Along&quot;,
                &quot;I Blame The Parents&quot;, &quot;Inappropriate Response&quot;, &quot;A Momentary Lapse Of Sanity&quot;, &quot;Lapsed Pacifist&quot;,
                &quot;Reformed Nice Guy&quot;, &quot;Pride Comes Before A Fall&quot;, &quot;Injury Time&quot;, &quot;Now Look What You&#39;ve Made Me Do&quot;,
                &quot;Kiss This Then&quot;, &quot;Eight Rounds Rapid&quot;, &quot;You&#39;ll Clean That Up Before You Leave&quot;, &quot;Me, I&#39;m Counting&quot;,
                &quot;The Usual But Etymologically Unsatisfactory&quot;, &quot;Falling Outside The Normal Moral Constraints&quot;,
                &quot;Hylozoist&quot;, &quot;No One Knows What The Dead Think&quot;, &quot;Flick to Kick&quot;, &quot;Your Egg&#39;s Broken But Mine Is Ok&quot;,
                &quot;Shall I Be Mummy?&quot;, &quot;Is This Galaxy Taken?&quot;, &quot;Famous Last Words&quot;, &quot;Road Rage&quot;, &quot;Live A Little&quot;,
                &quot;Not in My Back Yard&quot;, &quot;Playing A Sweeper&quot;, &quot;You&#39;re Going Home In A Fracking Ambulance&quot;, &quot;Rear Entry&quot;,
                &quot;Open Wide, Say Aaaarrgghhh&quot;, &quot;Hope You Like Explosions&quot;, &quot;I Haven&#39;t Seen One Of Those For Years&quot;,
                &quot;Are You Religious?&quot;, &quot;Not Now Dear&quot;, &quot;Something Had To Be Done&quot;,
                &quot;Hideously Indefensible Sense Of Humour&quot;, &quot;Camouflage&quot;,
                &quot;Come And Have A Go If You Think You&#39;re Hard Enough&quot;, &quot;Throwing Toys Out The Crib&quot;,
                &quot;Podex Perfectus Es&quot;, &quot;Stercorem Pro Cerebro Habes&quot;, &quot;Futue Te Ipsum Et Caballum Tuum&quot;,
                &quot;Remember To Wash Your Hands&quot;, &quot;One Out All Out&quot;, &quot;Looking At Me, Pal?&quot;,
                &quot;You Showed Me Yours, Now I&#39;ll Show You Mine&quot;, &quot;Salt In Your Vaseline&quot;, &quot;Cracking My Knuckles&quot;,
                &quot;Break Glass In Case Of War&quot;, &quot;My Turn&quot;, &quot;No Pun Intended&quot;, &quot;Look No Hands&quot;, &quot;Very Sharp Stick&quot;,
                &quot;Weapons Of Mass Deception&quot;, &quot;...And Another Thing&quot;, &quot;Clerical Error&quot;, &quot;Silly Mid On&quot;,
                &quot;You And Whose Army?&quot;, &quot;This Sector Ain&#39;t Big Enough For The Both Of Us&quot;,
                &quot;Diplomacy Was Never My Strong Suite&quot;, &quot;Such A Pretty Big Red Button&quot;,
                &quot;Synthetic Paragon Rubber Company&quot;, &quot;Forget And Fire&quot;, &quot;I Was Just Following Orders&quot;,
                &quot;Weapon of Mass Distraction&quot;, &quot;Forgive and Forget&quot;, &quot;Innocence Is No Excuse&quot;,
                &quot;Psychosis Is Only One State Of Mind&quot;, &quot;Lets Dance&quot;, &quot;AI Avenger&quot;, &quot;Dead Man Walking&quot;,
                &quot;A Little Less Conversation&quot;, &quot;Here One Minute, Gone The Next&quot;, &quot;Here, Let Me Escort You&quot;,
                &quot;Killed With Superior Skill&quot;, &quot;External Agitation&quot;, &quot;Catch Me If You Can&quot;,
                &quot;But What About The Children?&quot;, &quot;Single Fingered Hand Gestures&quot;, &quot;A World Of Hurt&quot;,
                &quot;Looking Down The Gun Barrel&quot;, &quot;Terminal Atomic Headache&quot;, &quot;Know Thy Enemy&quot;,
                &quot;Cold Steel For An Iron Age&quot;, &quot;The Malevolent Creation&quot;, &quot;Gamma Ray Goggles&quot;, &quot;End Of Green&quot;,
                &quot;Terrorwheel&quot;, &quot;Sickening Sense Of Humour&quot;, &quot;Mines Bigger&quot;, &quot;Friendly Fire Isn&#39;t&quot;,
                &quot;No Need For Stealth&quot;, &quot;All Guns Blazin!&quot;, &quot;Harmony Dies&quot;, &quot;The Controlled Psychopath&quot;, &quot;It Ends Now&quot;,
                &quot;Forced To Be Nice&quot;, &quot;Axis of Advance&quot;, &quot;Acts of God&quot;, &quot;The Feeling&#39;s Mutual&quot;,
                &quot;The Beautiful Nightmare&quot;, &quot;If You Can Read This...&quot;, &quot;Are You Saved?&quot;, &quot;Cunning Linguist&quot;,
                &quot;Gay Abandon&quot;, &quot;My Finger&quot;, &quot;Got Legs&quot;, &quot;Hose Job&quot;, &quot;Protect And Sever&quot;, &quot;Rebuttal&quot;, &quot;Not In The Face&quot;,
                &quot;I Have Right Of Way&quot;, &quot;It Ran Into My Missile&quot;, &quot;Have A Nice Rest Of Your Life&quot;, &quot;Nose Job&quot;,
                &quot;Get My Point?&quot;, &quot;Grid Worker&quot;, &quot;Eraserhead&quot;, &quot;What Star?&quot;, &quot;All This (And Brains)&quot;,
                &quot;Random Acts Of Senseless Violence&quot;, &quot;God Will Recognize His Own&quot;,
                &quot;Would You Like A Quick Suppository With That?&quot;,
                &quot;Pop Me A Couple More Of Those Happy Pills (Eccentric)&quot;, &quot;Trouble Maker?&quot;, &quot;Talk Is Cheap&quot;,
                &quot;Tightly Strung&quot;, &quot;Have You Kept The Receipt?&quot;, &quot;It Was Broke When I Got Here&quot;,
                &quot;Insanity Plea Rejected&quot;, &quot;Thora Hird&quot;, &quot;Barbara Cartland&quot;, &quot;Freddy Starr Ate My Hamster&quot;,
                &quot;And You Thought You Knew What Terror Means&quot;, &quot;I&#39;m A &#39;Shoot First, Ask Questions Later&#39; Kinda Guy&quot;,
                &quot;Duck You Suckers&quot;, &quot;Trumpton Riots&quot;, &quot;Dodgy Transformer&quot;
            ],
            writable : false,
            configurable : true,
            enumerable : true
        },
        &quot;snoopersErrorCodes&quot; : {
            value : [
                /* Warnings. */
                &quot;Snoopers buffer is full (max 10 news).&quot;,
                &quot;No free storing slot available.&quot;,
                &quot;CRC buffer is full.&quot;,
                &quot;CRC is still active.&quot;,
                &quot;Caller already sent a message (1 news per worldScript).&quot;,
                /* News inserted successfully. */
                &quot;Success.&quot;,
                /* Error messages. */
                &quot;Required properties not found (ID and Message).&quot;,
                &quot;Unknown properties passed.&quot;,
                &quot;To few or too much passed properties (at least 2).&quot;,
                &quot;Request from invalid caller (no worldScript).&quot;,
                &quot;Property &#39;Message&#39; not a string (wrong type).&quot;,
                &quot;Property &#39;Message&#39; too short or too long (expected &gt;10 and &lt;700 chars).&quot;,
                &quot;Property &#39;Message&#39; starts with whitespace (\\f \\t \\r \\n or space).&quot;,
                &quot;Property &#39;Message&#39; - Sent message not expandable.&quot;,
                &quot;Property &#39;Message&#39; - Number of opening brackets doesn&#39;t match number of closing brackets.&quot;,
                &quot;Property &#39;Message&#39; - Expanded key (descriptions.plist) too long (limit 700 chars).&quot;,
                &quot;Property &#39;Message&#39; - Expanded key (missiontext.plist) too long (limit 700 chars).&quot;,
                &quot;Property &#39;Message&#39; - Expanded Message too long.&quot;,
                &quot;Property &#39;Message&#39; - Word with overlength detected (limit 79 chars).&quot;,
                &quot;Property &#39;Message&#39; - To many linebreaks (limit 10).&quot;,
                &quot;Property &#39;Agency&#39; - not valid (expected number in range 1 - 3).&quot;,
                &quot;Property &#39;Priority&#39; - not valid (expected number in range 1 - 3).&quot;,
                &quot;Property &#39;Pic&#39; - wrong type (expected string).&quot;,
                &quot;Property &#39;Pic&#39; - not a valid fileextension.&quot;,
                &quot;Property &#39;Music&#39; - wrong type (expected string).&quot;,
                &quot;Property &#39;Music&#39; not a valid fileextension.&quot;,
                &quot;Property &#39;Model&#39; - wrong type (expected string).&quot;,
                &quot;Property &#39;Pos&#39; - wrong type (expected array).&quot;,
                &quot;Property &#39;Pos&#39; - wrong number of arguments (expected 3 numbers).&quot;,
                &quot;Property &#39;Pos&#39; - contains NaN.&quot;,
                &quot;Property &#39;Ori&#39; - wrong type (expected number or array).&quot;,
                &quot;Property &#39;Ori&#39; - not valid (expected 1, 2, 4 or 8).&quot;,
                &quot;Snoopers was shutdown. Requirements not fullfilled.&quot;,
                &quot;Player not valid anymore.&quot;,
                &quot;Player not docked while trying to display a direct mission screen.&quot;,
                &quot;Attempt to override a missionscreen blocked.&quot;
            ],
            writable : false,
            configurable : true,
            enumerable : true
        },
        &quot;defaultPlayerVar&quot; : {
            /* Default player variables. */
            value : {
                attacker : false,
                delayedAward : null,
                locationsActivated : [false, false, false, false, false, false, false, false],
                newsForSnoopers : [],
                reputation : [0, 0, 0, 0, 0, 0, 0, 0],
                visitedBase : false
            },
            writable : false,
            configurable : true,
            enumerable : true
        }
    });

    /* Public constants. */
    Object.defineProperties(this, {
        /* value will be &#39;true&#39; if using Oolite v1.77 and newer, false if older. */
        &quot;$gte_v1_77&quot; : {
            value : (0 &gt;= oolite.compareVersion(&quot;1.77&quot;)),
            writable : false,
            configurable : true,
            enumerable : true
        },
        /* Maximum number of Jaguar Company patrol ships allowed. */
        &quot;$maxPatrolShips&quot; : {
            value : 4,
            writable : false,
            configurable : true,
            enumerable : true
        },
        /* Seed for the pseudo random number generator.
         * Affects generation of Jaguar Company and placement of the base.
         */
        &quot;$salt&quot; : {
            value : 19720231,
            writable : false,
            configurable : true,
            enumerable : true
        },
        /* Minimum reputation to be considered a helper. Equivalent to 5 observed hits. */
        &quot;$reputationHelper&quot; : {
            value : 5,
            writable : false,
            configurable : true,
            enumerable : true
        },
        /* Minimum reputation to use the black box. Equivalent to 3 kills. */
        &quot;$reputationBlackbox&quot; : {
            value : 30,
            writable : false,
            configurable : true,
            enumerable : true
        },
        /* Minimum reputation to see the locations for Jaguar Company. Equivalent to 5 kills. */
        &quot;$reputationLocations&quot; : {
            value : 50,
            writable : false,
            configurable : true,
            enumerable : true
        },
        /* Set value to &#39;true&#39; to use visual effects. Ignored if using Oolite v1.76.1 and older. */
        &quot;$visualEffects&quot; : {
            value : true,
            writable : false,
            configurable : true,
            enumerable : true
        }
    });

    /* Public variables used by OXP Config. */
    /* Turn logging on or off */
    this.$logging = false;
    /* Report AI messages for Jaguar Company if true */
    this.$logAIMessages = false;
    /* Log extra debug info. Only useful during testing. */
    this.$logExtra = false;
    /* Spawn Jaguar Company always if true */
    this.$alwaysSpawn = false;

    /* OXPConfig settings. */
    this.oxpcSettings = {
        Info : {
            Name : this.name,
            Display : &quot;Jaguar Company&quot;,
            Notify : true,
            InfoB : &quot;Development frontend for the Jaguar Company OXP.&quot;
        },
        Bool0 : {
            Name : &quot;$logging&quot;,
            Def : false,
            Desc : &quot;Turn logging on or off.&quot;
        },
        Bool1 : {
            Name : &quot;$logAIMessages&quot;,
            Def : false,
            Desc : &quot;Log AI messages if true.&quot;
        },
        Bool2 : {
            Name : &quot;$logExtra&quot;,
            Def : false,
            Desc : &quot;Log extra debug info if true.&quot;
        },
        Bool3 : {
            Name : &quot;$alwaysSpawn&quot;,
            Def : false,
            Desc : &quot;Always spawn Jaguar Company if true.&quot;
        }
    };

    /* Other public variables. */

    /* Setup player variables. */
    this.$playerVar = p_const.defaultPlayerVar;

    /* World script event handlers. */

    /* NAME
     *   startUp
     *
     * FUNCTION
     *   We only need to do this once.
     *   This will get redefined after a new game or loading of a new Commander.
     */
    this.startUp = function () {
        var cabalScript = worldScripts.Cabal_Common_Functions,
        cclVersion,
        attacker,
        delayedAward,
        locationsActivated,
        reputation,
        visitedBase,
        name,
        counter,
        length;

        if (!cabalScript || cabalScript.Cabal_Common === &#39;undefined&#39;) {
            this.$killSelf(&quot; -&gt; Cabal Common Library is missing.&quot;);

            return;
        }

        this.$ccl = new cabalScript.Cabal_Common();
        cclVersion = this.$ccl.internalVersion;

        if (cclVersion &lt; 14) {
            this.$killSelf(&quot; -&gt; Cabal Common Library is too old for any Oolite version.&quot;);

            return;
        }

        if (cclVersion === 14 &amp;&amp; this.$gte_v1_77) {
            /* Oolite v1.77 and newer. */
            this.$killSelf(&quot; -&gt; Cabal Common Library is too old for Oolite v1.77 (and newer Oolite versions).&quot;);

            return;
        }

        if (cclVersion &gt; 14 &amp;&amp; !this.$gte_v1_77) {
            /* Oolite v1.76.1 and older. */
            this.$killSelf(&quot; -&gt; Cabal Common Library is too new for Oolite v1.76.1 (and older Oolite versions).&quot;);

            return;
        }

        /* Find the shortest name length. */
        this.$shortestNameLength = -1;
        length = p_const.shipNames.length;

        for (counter = 0; counter &lt; length; counter += 1) {
            name = p_const.shipNames[counter];

            if (this.$shortestNameLength === -1 || name.length &lt; this.$shortestNameLength) {
                this.$shortestNameLength = name.length;
            }
        }

        if (missionVariables.jaguar_company) {
            /* Retrieve the player variable and parse it. */
            this.$playerVar = JSON.parse(missionVariables.jaguar_company);
            /* Clean the player variable. */
            this.$cleanPlayerVariable();
        } else {
            /* Convert old mission variables. */
            attacker = missionVariables.jaguar_company_attacker;
            delayedAward = missionVariables.jaguar_company_reputation_post_launch;
            locationsActivated = missionVariables.jaguar_company_locations_activated;
            reputation = missionVariables.jaguar_company_reputation;
            visitedBase = missionVariables.jaguar_company_visited_base;

            if (attacker !== null) {
                this.$playerVar.attacker = attacker;

                delete missionVariables.jaguar_company_attacker;
            }

            if (delayedAward !== null) {
                if (delayedAward) {
                    this.$playerVar.delayedAward = delayedAward;
                }

                delete missionVariables.jaguar_company_reputation_post_launch;
            }

            if (locationsActivated !== null) {
                for (counter = galaxyNumber; counter &gt;= 0; counter -= 1) {
                    this.$playerVar.locationsActivated[counter] = locationsActivated;
                }

                delete missionVariables.jaguar_company_locations_activated;
            }

            if (reputation !== null) {
                for (counter = galaxyNumber; counter &gt;= 0; counter -= 1) {
                    this.$playerVar.reputation[counter] = reputation;
                }

                delete missionVariables.jaguar_company_reputation;
            }

            if (visitedBase !== null) {
                this.$playerVar.visitedBase = visitedBase;

                delete missionVariables.jaguar_company_visited_base;
            }

            /* Stringify the player variable and store it. */
            missionVariables.jaguar_company = JSON.stringify(this.$playerVar);
        }

        /* Setup the private main variable + some public variables. */
        this.$setUp();
        /* Remove join navy variable. */
        p_main.joinNavy = null;
        /* Remove the closest naval ship variable. */
        p_main.closestNavyShip = null;
        /* Check if we need to create Jaguar Company in this system. Delay it. */
        this.$setUpCompanyTimerReference = new Timer(this, this.$setUpCompany, 2);
        /* Add the interface system if Oolite v1.77 and newer is used. */
        this.$addInterface();

        log(this.name + &quot; &quot; + this.version + &quot; loaded.&quot;);

        /* No longer needed after setting up. */
        delete this.startUp;
    };

    /* NAME
     *   playerWillSaveGame
     *
     * FUNCTION
     *   Player is about to save the game.
     */
    this.playerWillSaveGame = function () {
        /* Clean the player variable. */
        this.$cleanPlayerVariable();
        /* Stringify the player variable and store it. */
        missionVariables.jaguar_company = JSON.stringify(this.$playerVar);
    };

    /* NAME
     *   shipWillLaunchFromStation
     *
     * FUNCTION
     *   Player is about to launch from a station.
     */
    this.shipWillLaunchFromStation = function () {
        /* Remove the interface system if Oolite v1.77 and newer is used. */
        this.$removeInterface();
    };

    /* NAME
     *   shipLaunchedFromStation
     *
     * FUNCTION
     *   Player launched from a station.
     *
     * INPUT
     *   station - entity of the station
     */
    this.shipLaunchedFromStation = function (station) {
        var delayedAward;

        if (station.hasRole(&quot;jaguar_company_base&quot;)) {
            /* Reset welcomed flag on launch from base. */
            p_main.playerWelcomed = false;

            delayedAward = this.$playerVar.delayedAward;

            if (typeof delayedAward === &quot;number&quot;) {
                /* Add on any reputation awarded on docking with an escape pod. */
                this.$playerVar.reputation[galaxyNumber] += delayedAward;
                this.$playerVar.delayedAward = null;
            }
        }
    };

    /* NAME
     *   shipDockedWithStation
     *
     * FUNCTION
     *   Player docked with a station.
     */
    this.shipDockedWithStation = function () {
        var rescuedNames,
        lastName;

        if (this.$snoopersRescued.length) {
            if (this.$snoopersRescued.length === 1) {
                /* Send rescued news for the pilot the player brought in to Snoopers. */
                this.$sendNewsToSnoopers(expandDescription(&quot;[jaguar_company_rescue_news]&quot;, {
                        jaguar_company_pilot_name : this.$snoopersRescued.shift()
                    }));
            } else {
                /* Send rescued news for the multiple pilots the player brought in to Snoopers. */
                lastName = this.$snoopersRescued.pop();
                rescuedNames = this.$snoopersRescued.join(&quot;, &quot;) + &quot; and &quot; + lastName;
                this.$snoopersRescued = [];
                this.$sendNewsToSnoopers(expandDescription(&quot;[jaguar_company_rescue_multiple_news]&quot;, {
                        jaguar_company_pilot_names : rescuedNames
                    }));
            }
        }

        /* Add the interface system if Oolite v1.77 and newer is used. */
        this.$addInterface();
    };

    /* NAME
     *   shipWillExitWitchspace
     *
     * FUNCTION
     *   Player is about to exit from Witchspace.
     *   Reset everything just before exiting Witchspace.
     */
    this.shipWillExitWitchspace = function () {
        /* Stop and remove the timers. */
        this.$removeTimers();

        if (!system.shipsWithRole(&quot;jaguar_company_patrol&quot;).length) {
            /* Setup the private main variable + some public variables. */
            this.$setUp();
        } else {
            /* Followed Jaguar Company from interstellar space. */

            /* Remove the hyperspace follow co-ordinates. */
            this.$hyperspaceFollow = null;
        }

        /* Remove join navy variable. */
        p_main.joinNavy = null;
        /* Remove the closest naval ship variable. */
        p_main.closestNavyShip = null;
        /* Not visited the base. */
        this.$playerVar.visitedBase = false;
    };

    /* NAME
     *   shipExitedWitchspace
     *
     * FUNCTION
     *   Player exited Witchspace.
     */
    this.shipExitedWitchspace = function () {
        /* Check if we need to create Jaguar Company in this system. */
        this.$setUpCompany();
    };

    /* NAME
     *   playerEnteredNewGalaxy
     *
     * FUNCTION
     *   Remove some player variables if the player jumps galaxies.
     */
    this.playerEnteredNewGalaxy = function () {
        this.$playerVar.attacker = false;
    };

    /* NAME
     *   shipSpawned
     *
     * FUNCTION
     *   A ship has been born.
     *
     * INPUT
     *   whom - entity that was created
     */
    this.shipSpawned = function (whom) {
        var shipsScript = worldScripts[&quot;Jaguar Company Ships&quot;],
        friendList;

        if (!shipsScript) {
            /* Ships world script not setup yet. */
            return;
        }

        /* Get friend roles from the ships world script. */
        friendList = shipsScript.$friendList;

        if (!friendList || friendList.indexOf(whom.entityPersonality) === -1) {
            /* Ignore non-Jaguar Company ships. */
            return;
        }

        if (this.$logAIMessages) {
            /* Turn AI reporting on for the ship. */
            whom.reportAIMessages = true;
        }
    };

    /* NAME
     *   shipDied
     *
     * FUNCTION
     *   Stop and remove the timers if the player dies.
     */
    this.shipDied = function () {
        /* Stop and remove the timers. */
        this.$removeTimers();
    };

    /* NAME
     *   missionScreenOpportunity
     *
     * FUNCTION
     *   Show a welcome message on docking as a mission screen.
     */
    this.missionScreenOpportunity = function () {
        var base = this.$jaguarCompanyBase;

        if (!base || !base.isValid) {
            /* Base not setup. */
            return;
        }

        if (player.ship.dockedStation.entityPersonality === base.entityPersonality &amp;&amp; !p_main.playerWelcomed) {
            /* Player docked with Jaguar Company Base. */
            this.$welcomeMessage();
        }
    };

   /* NAME
     *   shipScoopedOther
     *
     * FUNCTION
     *   Player has scooped something.
     *
     * INPUT
     *   whom - entity of the scooped object
     */
    this.shipScoopedOther = function (whom) {
        if (!whom.$jaguarCompany) {
            /* Does not contain a member of Jaguar Company. */
            return;
        }

        if (this.$logging &amp;&amp; this.$logExtra) {
            log(this.name, &quot;shipScoopedOther::Scooped Jaguar Company member: &quot; + whom.$pilotName);
        }

        /* Save the pilot&#39;s name that was rescued. */
        this.$pilotsRescued.push(whom.$pilotName);
        this.$snoopersRescued.push(whom.$pilotName);
    };

    /* NAME
     *   guiScreenChanged
     *
     * FUNCTION
     *   Show Jaguar Company Base locations on certain GUI screens.
     *
     * INPUTS
     *   to - GUI screen the player has gone to
     *   from - GUI screen the player has come from
     */
    this.guiScreenChanged = function (to, from) {
        var counter,
        length;

        if (player.ship.equipmentStatus(&quot;EQ_JAGUAR_COMPANY_BLACK_BOX&quot;) !== &quot;EQUIPMENT_OK&quot; ||
            !this.$playerVar.locationsActivated[galaxyNumber]) {
            /* No software patch uploaded to the black box. */
            return;
        }

        if (this.$gte_v1_77) {
            /* Oolite v1.77 and newer. */
            if (to === &quot;GUI_SCREEN_LONG_RANGE_CHART&quot;) {
                /* Add the marked systems to the long range chart. */
                length = this.$jaguarCompanySystemIDs.length;

                for (counter = 0; counter &lt; length; counter += 1) {
                    mission.markSystem({
                        system : this.$jaguarCompanySystemIDs[counter],
                        name : this.name,
                        markerColor : &quot;orangeColor&quot;,
                        markerScale : 1.5,
                        markerShape : &quot;MARKER_SQUARE&quot;
                    });
                }

                player.consoleMessage(&quot;Orange coloured squares show Jaguar Company Base locations.&quot;, 5);

                if (player.ship.docked) {
                    player.consoleMessage(&quot;Press F4 for a list of Jaguar Company Base locations.&quot;, 5);
                } else {
                    player.consoleMessage(&quot;Press F7 then F5 for a list of Jaguar Company Base locations.&quot;, 5);
                }
            }

            if (from === &quot;GUI_SCREEN_LONG_RANGE_CHART&quot;) {
                /* Remove the marked systems from the long range chart. */
                length = this.$jaguarCompanySystemIDs.length;

                for (counter = 0; counter &lt; length; counter += 1) {
                    mission.unmarkSystem({
                        system : this.$jaguarCompanySystemIDs[counter],
                        name : this.name
                    });
                }
            }
        } else {
            /* Oolite v1.76.1 and older. */
            if (to === &quot;GUI_SCREEN_LONG_RANGE_CHART&quot;) {
                player.consoleMessage(&quot;Press F7 then F5 for a list of Jaguar Company Base locations.&quot;, 5);
            }
        }

        if (from === &quot;GUI_SCREEN_SYSTEM_DATA&quot; &amp;&amp; to === &quot;GUI_SCREEN_STATUS&quot;) {
            if (this.$gte_v1_77 &amp;&amp; player.ship.docked) {
                /* Oolite v1.77 and newer use the interface screen when docked. */
                return;
            }

            this.$showBaseLocations();
        }
    };

    /* NAME
     *   viewDirectionChanged
     *
     * FUNCTION
     *   Reset page count when the player view changes.
     */
    this.viewDirectionChanged = function () {
        this.$printIndex = 0;
    };

    /* Other global functions. */

    /* NAME
     *   oxpcNotifyOnChange
     *
     * FUNCTION
     *   This function is called by OXPConfig when settings are changed.
     *
     * INPUT
     *   n - number
     *     1 - boolean settings changed
     *     2 - short unsigned integers changed
     *     4 - unsigned 24Bit integer changed
     */
    this.oxpcNotifyOnChange = function (n) {
        if (n &amp; 1 &amp;&amp; this.$alwaysSpawn &amp;&amp; !this.$jaguarCompanyBase) {
            /* $alwaysSpawn has been set in OXPConfig and the base doesn&#39;t exist.
             * Check if we need to create Jaguar Company in this system. Delay it.
             */
            this.$setUpCompanyTimerReference = new Timer(this, this.$setUpCompany, 2);
        }
    };

    /* NAME
     *   $setUp
     *
     * FUNCTION
     *   Setup the private main variable + some public variables.
     */
    this.$setUp = function () {
        var saveGalaxyNumber = null;

        if (typeof p_main.galaxyNumber === &quot;number&quot;) {
            /* Save the internal galaxy number used by $cacheJaguarCompanySystems() */
            saveGalaxyNumber = p_main.galaxyNumber;
        }

        /* Initialise the p_main variable object.
         * Encapsulates all private global data.
         */
        p_main = {
            /* Initialise the available ship names. */
            availableShipNames : p_const.shipNames,
            /* Initial state of the black box ASC tracker. */
            blackboxASCActivated : false,
            /* Initial state of the black box holo-tracker. */
            blackboxHoloActivated : false,
            /* Internal galaxy number used by $cacheJaguarCompanySystems() */
            galaxyNumber : saveGalaxyNumber,
            /* Player welcomed. Used to control the mission screen display. */
            playerWelcomed : false,
            /* Current route index. */
            routeIndex : 0,
            /* Routes are initialised when Jaguar Company is spawned. */
            routes : [],
            /* Initialise main seed for galaxy 1. */
            seed : {
                w0 : 0x5a4a,
                w1 : 0x0248,
                w2 : 0xb753
            }
        };

        if (!this.$pilotsRescued || !this.$snoopersRescued) {
            /* Array of Jaguar Company pilot names that have been rescued.
             *
             *   $pilotsRescued - used when unloading pilots from their escape pods at a station
             *   $snoopersRescued - used when docked to send a report to Snoopers news services (if installed)
             */
            if (!this.$pilotsRescued) {
                this.$pilotsRescued = [];
            }

            if (!this.$snoopersRescued) {
                this.$snoopersRescued = [];
            }
        }

        /* Tracker object. */
        this.$tracker = null;
        /* Visual tracker object. */
        this.$visualTracker = null;
        /* Base has not been setup yet. */
        this.$jaguarCompanyBase = false;
        /* New base so clear this variable. */
        this.$swapBase = false;
        /* Remove the hyperspace follow co-ordinates. */
        this.$hyperspaceFollow = null;
        /* Create an array of Jaguar Company Base locations. */
        this.$cacheJaguarCompanySystems();
    };

    /* NAME
     *   $killSelf
     *
     * FUNCTION
     *   Removes all functions and variables.
     *
     * INPUT
     *   desc - description for the removal (optional)
     */
    this.$killSelf = function (desc) {
        var prop;

        if (desc &amp;&amp; typeof desc === &quot;string&quot;) {
            player.consoleMessage(this.name + &quot; - Check your Latest.log&quot;, 10);
            log(this.name, this.name + &quot; - Shutting down&quot; + desc);
        }

        /* Delete public functions and variables. */
        for (prop in this) {
            if (this.hasOwnProperty(prop)) {
                if (prop !== &#39;name&#39; &amp;&amp; prop !== &#39;version&#39;) {
                    delete this[prop];
                }
            }
        }

        /* Set the deactivated flag for Cabal Common Library. */
        this.deactivated = true;

        return;
    };

    /* NAME
     *   $showProps
     *
     * FUNCTION
     *   For debugging only.
     */
    this.$showProps = function () {
        var result = &quot;&quot;,
        prop,
        subProp,
        route,
        routeCounter,
        routeLength,
        news,
        counter,
        length;

        for (prop in this) {
            if (this.hasOwnProperty(prop)) {
                if (typeof this[prop] !== &quot;function&quot;) {
                    if (prop !== &quot;$playerVar&quot;) {
                        result += &quot;this.&quot; + prop + &quot;: &quot; + this[prop] + &quot;\n&quot;;
                    } else {
                        for (subProp in this.$playerVar) {
                            if (this.$playerVar.hasOwnProperty(subProp)) {
                                result += &quot;this.$playerVar.&quot; + subProp + &quot;: &quot; + this.$playerVar[subProp] + &quot;\n&quot;;
                            }
                        }
                    }
                } else {
                    result += &quot;this.&quot; + prop + &quot; = function ()\n&quot;;
                }
            }
        }

        for (prop in p_main) {
            if (p_main.hasOwnProperty(prop)) {
                result += &quot;p_main.&quot; + prop + &quot;: &quot; + p_main[prop] + &quot;\n&quot;;
            }
        }

        length = p_main.routes.length;

        if (length) {
            result += &quot;Routes (&quot; + length + &quot;)\n&quot;;

            for (counter = 0; counter &lt; length; counter += 1) {
                result += &quot;#&quot; + (counter + 1) + &quot;) &quot;;
                route = p_main.routes[counter];
                routeCounter = 1;
                routeLength = Object.keys(route).length;

                for (prop in route) {
                    if (route.hasOwnProperty(prop)) {
                        result += prop + &quot;: &quot; + route[prop] + (routeCounter === routeLength ? &quot;\n&quot; : &quot;, &quot;);
                        routeCounter += 1;
                    }
                }
            }
        }

        length = this.$playerVar.newsForSnoopers.length;

        if (length) {
            result += &quot;News for Snoopers (&quot; + length + &quot;)\n&quot;;

            for (counter = 0; counter &lt; length; counter += 1) {
                news = this.$playerVar.newsForSnoopers[counter];
                result += &quot;#&quot; + (counter + 1) + &quot;) &quot; +
                &quot;ID: &quot; + news.ID + &quot;, &quot; +
                &quot;Message: &quot; + news.Message + &quot;, &quot; +
                &quot;Agency: &quot; + news.Agency + &quot;\n&quot;;
            }
        }

        log(this.name, &quot;$showProps::\n&quot; + result);
    };

    /* NAME
     *   $cleanPlayerVariable
     *
     * FUNCTION
     *   Clean up the player variable for loading or saving.
     */
    this.$cleanPlayerVariable = function () {
        var playerVarsProps,
        defaultPlayerVarProps,
        prop,
        counter,
        length;

        /* Get the properties of the player variables. */
        playerVarsProps = Object.keys(this.$playerVar);
        /* Get the properties of the default player variables. */
        defaultPlayerVarProps = Object.keys(p_const.defaultPlayerVar);

        /* Remove old properties. */
        for (prop in this.$playerVar) {
            if (this.$playerVar.hasOwnProperty(prop)) {
                if (defaultPlayerVarProps.indexOf(prop) === -1) {
                    /* Not a default property. */
                    delete this.$playerVar[prop];
                }
            }
        }

        /* Cache the length. */
        length = defaultPlayerVarProps.length;

        /* Add new properties. */
        for (counter = 0; counter &lt; length; counter += 1) {
            prop = defaultPlayerVarProps[counter];

            if (playerVarsProps.indexOf(prop) === -1) {
                /* Missing a default property. */
                this.$playerVar[prop] = p_const.defaultPlayerVar[prop];
            }
        }
    };

    /* NAME
     *   $removeTimers
     *
     * FUNCTION
     *   Stop and remove the timers.
     */
    this.$removeTimers = function () {
        /* Stop and remove the script sanity timer. */
        if (this.$scriptSanityTimerReference) {
            if (this.$scriptSanityTimerReference.isRunning) {
                this.$scriptSanityTimerReference.stop();
            }

            this.$scriptSanityTimerReference = null;
        }

        /* Stop and remove the Black Box timer. */
        if (this.$blackBoxTimerReference) {
            if (this.$blackBoxTimerReference.isRunning) {
                this.$blackBoxTimerReference.stop();
            }

            this.$blackBoxTimerReference = null;
        }

        /* Stop and remove the base swap timer. */
        if (this.$baseSwapTimerReference) {
            if (this.$baseSwapTimerReference.isRunning) {
                this.$baseSwapTimerReference.stop();
            }

            this.$baseSwapTimerReference = null;
        }
    };

    /* NAME
     *   $addInterface
     *
     * FUNCTION
     *   Add the interface system if Oolite v1.77 and newer is used and
     *   docked and the software patch is uploaded to the black box (which has to be present).
     */
    this.$addInterface = function () {
        if (this.$gte_v1_77 &amp;&amp; player.ship.docked &amp;&amp;
            player.ship.equipmentStatus(&quot;EQ_JAGUAR_COMPANY_BLACK_BOX&quot;) === &quot;EQUIPMENT_OK&quot; &amp;&amp;
            this.$playerVar.locationsActivated[galaxyNumber]) {
            player.ship.dockedStation.setInterface(&quot;jaguar_company_base_list&quot;, {
                title : &quot;Jaguar Company Base locations&quot;,
                summary : &quot;Displays a list of Jaguar Company Base locations within the current galaxy.&quot;,
                category : expandDescription(&quot;[interfaces-category-organisations]&quot;),
                callback : this.$showBaseLocations.bind(this)
            });
        }
    };

    /* NAME
     *   $removeInterface
     *
     * FUNCTION
     *   Remove the interface system if Oolite v1.77 and newer is used.
     */
    this.$removeInterface = function () {
        if (this.$gte_v1_77 &amp;&amp; player.ship.docked) {
            /* Oolite v1.77 and newer and docked. */
            player.ship.dockedStation.setInterface(&quot;jaguar_company_base_list&quot;, null);
        }
    };

    /* NAME
     *   $showBaseLocations
     *
     * FUNCTION
     *   Show the base locations as a 2 column list.
     */
    this.$showBaseLocations = function () {
        var choicesKey,
        locations;

        /* Initial index. */
        this.$printIndex = 0;
        /* Need to work out the first choices key before we create the list. 2 column layout. */
        choicesKey = this.$firstChoicesKey(this.$jaguarCompanySystemNames, 2);
        /* Create the list. */
        locations = this.$listNames(this.$jaguarCompanySystemNames);
        /* Display it as a mission screen. */
        mission.runScreen({
            title : &quot;Jaguar Company Base locations&quot;,
            message : locations + &quot;\n&quot;,
            choicesKey : choicesKey,
            /* exitScreen is ignored by Oolite v1.76.1 and older. */
            exitScreen : &quot;GUI_SCREEN_INTERFACES&quot;
        }, this.$locationChoices, this);
    };

    /* NAME
     *   $firstChoicesKey
     *
     * FUNCTION
     *   Figure out the first choices key for the pager.
     *   Modifies the maximum amount of lines that can be used for displaying the list.
     *
     * INPUTS
     *   list - array of strings to be displayed
     *   columns - number of columns displayed
     *
     * RESULT
     *   result - choices key
     */
    this.$firstChoicesKey = function (list, columns) {
        var choicesKey;

        if (list.length &lt;= columns * 19) {
            /* Maximum lines available for the list on the mission screen with 1 choice and a blank line. */
            this.$lines = 19;
            /* Initial choices key. */
            choicesKey = &quot;jaguar_company_choices_1_page&quot;;
        } else if (list.length &lt;= 2 * columns * 18) {
            /* Maximum lines available for the list on the mission screen with 2 choices and a blank line. */
            this.$lines = 18;
            /* Initial choices key. */
            choicesKey = &quot;jaguar_company_choices_1_of_2&quot;;
        } else {
            /* Maximum lines available for the list on the mission screen with 3 choices and a blank line. */
            this.$lines = 17;
            /* Initial choices key. */
            choicesKey = &quot;jaguar_company_choices_start_of_many&quot;;
        }

        return choicesKey;
    };

    /* NAME
     *   $nextChoicesKey
     *
     * FUNCTION
     *   Figure out the next choices key for the pager.
     *
     * INPUTS
     *   choice - choice selected
     *   list - array of strings to be displayed
     *   columns - number of columns displayed
     *
     * RESULT
     *   result - choices key
     */
    this.$nextChoicesKey = function (choice, list, columns) {
        var choicesKey;

        if (choice === &quot;M_1_FIRST_PAGE&quot;) {
            this.$printIndex = 0;
            choicesKey = &quot;jaguar_company_choices_start_of_many&quot;;
        } else if (choice === &quot;2_1_NEXT_PAGE&quot;) {
            this.$printIndex = columns * this.$lines;
            choicesKey = &quot;jaguar_company_choices_2_of_2&quot;;
        } else if (choice === &quot;M_1_NEXT_PAGE&quot;) {
            this.$printIndex = this.$printIndex + (columns * this.$lines);

            if (this.$printIndex + (columns * this.$lines) &lt; list.length - 1) {
                choicesKey = &quot;jaguar_company_choices_middle_of_many&quot;;
            } else {
                choicesKey = &quot;jaguar_company_choices_end_of_many&quot;;
            }
        } else if (choice === &quot;2_1_PREV_PAGE&quot;) {
            this.$printIndex = 0;
            choicesKey = &quot;jaguar_company_choices_1_of_2&quot;;
        } else if (choice === &quot;M_2_PREV_PAGE&quot;) {
            this.$printIndex = this.$printIndex - (columns * this.$lines);

            if (this.$printIndex) {
                choicesKey = &quot;jaguar_company_choices_middle_of_many&quot;;
            } else {
                choicesKey = &quot;jaguar_company_choices_start_of_many&quot;;
            }
        } else if (choice === &quot;M_2_LAST_PAGE&quot;) {
            this.$printIndex = Math.floor(list.length / (columns * this.$lines)) * (columns * this.$lines);
            choicesKey = &quot;jaguar_company_choices_end_of_many&quot;;
        } else if (choice === &quot;1_1_EXIT&quot; || choice === &quot;2_2_EXIT&quot; || choice === &quot;M_3_EXIT&quot;) {
            choicesKey = &quot;EXIT&quot;;
        } else {
            player.consoleMessage(&quot;Error logged. Inform the author of Jaguar Company OXP.&quot;);
            log(this.name, &quot;$nextChoicesKey::choice: &quot; + choice + &quot;\n&quot; +
                &quot;* list: &quot; + list.join(&quot;, &quot;) + &quot; (&quot; + list.length + &quot;)\n&quot; +
                &quot;* columns: &quot; + columns + &quot;\n&quot; +
                &quot;* $printIndex: &quot; + this.$printIndex + &quot;\n&quot; +
                &quot;* $lines: &quot; + this.$lines + &quot;\n&quot;);
            choicesKey = &quot;ERROR&quot;;
        }

        return choicesKey;
    };

    /* NAME
     *   $locationChoices
     *
     * FUNCTION
     *   Callback for base location lister.
     *
     * INPUT
     *   choice - key of the choice selected
     */
    this.$locationChoices = function (choice) {
        var choicesKey = this.$nextChoicesKey(choice, this.$jaguarCompanySystemNames, 2),
        locations;

        if (choicesKey === &quot;EXIT&quot; || choicesKey === &quot;ERROR&quot;) {
            /* Exit selected or there was an error. */
            return;
        }

        locations = this.$listNames(this.$jaguarCompanySystemNames);
        mission.runScreen({
            title : &quot;Jaguar Company Base locations&quot;,
            message : locations + &quot;\n&quot;,
            choicesKey : choicesKey,
            /* exitScreen is ignored by Oolite v1.76.1 and older. */
            exitScreen : &quot;GUI_SCREEN_INTERFACES&quot;
        }, this.$locationChoices, this);
    };

    /* NAME
     *   $listNames
     *
     * FUNCTION
     *   Build a 2 column list of Jaguar Company Base locations.
     *   Original idea from Spara&#39;s Trophy Collector OXP.
     *   Highly modified and simplified.
     *   Modified using Cabal Common Library for Oolite v1.77 and newer.
     *
     * INPUT
     *   list - array of strings to be displayed
     *
     * RESULT
     *   result - columnized list of names as a string
     */
    this.$listNames = function (list) {
        var columnized = &quot;&quot;,
        row,
        start = this.$printIndex,
        /* Maximum number of rows. */
        lines = this.$lines,
        lname,
        rname,
        i;

        /* No Bases? */
        if (!list.length) {
            return &quot;No bases in this sector.\n&quot;;
        }

        /* Less entries than rows? */
        if (list.length - start &lt; lines) {
            lines = list.length - start;
        }

        for (i = 0; i &lt; lines; i += 1) {
            if (start + i + lines &lt; list.length) {
                /* Two column layout. */
                /* Left column. Truncated or padded with spaces. */
                lname = this.$ccl.strToWidth(list[start + i], 15, &quot; &quot;);
                /* Right column. Truncated. */
                rname = this.$ccl.strToWidth(list[start + i + lines], 15);

                /* Create the row. */
                if (this.$gte_v1_77) {
                    /* Oolite v1.77 and newer. */
                    row = this.$ccl.strAdd2Columns(lname, 1, rname, 17);
                } else {
                    /* Oolite v1.76.1 and older. */
                    row = &quot; &quot; + lname + &quot; &quot; + rname;
                }
            } else {
                /* One column layout. */
                /* Left column. Truncated. */
                lname = this.$ccl.strToWidth(list[start + i], 31);

                /* Create the row. */
                if (this.$gte_v1_77) {
                    /* Oolite v1.77 and newer. */
                    row = this.$ccl.strAddIndentedText(lname, 1);
                } else {
                    /* Oolite v1.76.1 and older. */
                    row = &quot; &quot; + lname;
                }
            }

            columnized += row + &quot;\n&quot;;
        }

        return columnized;
    };

    /* NAME
     *   $cacheJaguarCompanySystems
     *
     * FUNCTION
     *   Keep a record of system IDs and names for the current galaxy.
     */
    this.$cacheJaguarCompanySystems = function () {
        var a,
        b,
        c,
        government,
        governmentNames = [
            &quot;Anarchy&quot;,
            &quot;Feudal&quot;,
            &quot;Multi-Government&quot;
        ],
        scrambledPRN,
        systemProbability,
        counter,
        logMsg = &quot;$cacheJaguarCompanySystems::\n&quot;;

        /* Have the base locations for this galaxy been setup? */
        if (typeof p_main.galaxyNumber === &quot;number&quot; &amp;&amp; p_main.galaxyNumber === galaxyNumber) {
            /* Already setup. */
            return;
        }

        /* Save the galaxy number. */
        p_main.galaxyNumber = galaxyNumber;
        /* Clear the base location arrays. */
        this.$jaguarCompanySystemIDs = [];
        this.$jaguarCompanySystemNames = [];
        this.$jaguarCompanyInterstellar = [];

        /* Alter the seed for the current galaxy. */
        for (counter = 0; counter &lt; galaxyNumber; counter += 1) {
            this.$rng_nextgalaxy();
        }

        /* Reset the random seed. */
        p_main.rnd_seed = {};

        /* Check systems for Jaguar Company Base. */
        for (counter = 0; counter &lt; 256; counter += 1) {
            /* Figure out pseudoRandomNumber, as a 24-bit integer, for the system being checked. */
            p_main.rnd_seed.a = p_main.seed.w1 &amp; 0xff;
            p_main.rnd_seed.b = (p_main.seed.w1 &gt;&gt; 8) &amp; 0xff;
            p_main.rnd_seed.c = p_main.seed.w2 &amp; 0xff;
            p_main.rnd_seed.d = (p_main.seed.w2 &gt;&gt; 8) &amp; 0xff;
            a = this.$gen_rnd_number();
            b = this.$gen_rnd_number();
            c = this.$gen_rnd_number();
            a = (a &lt;&lt; 16) | (b &lt;&lt; 8) | c;

            /* Re-implementation of system.scrambledPseudoRandomNumber
             * Add the salt to the pseudoRandomNumber to enable generation of different sequences.
             */
            a += this.$salt;
            /* Scramble with basic LCG psuedo-random number generator. */
            a = (214013 * a + 2531011) &amp; 0xFFFFFFFF;
            a = (214013 * a + 2531011) &amp; 0xFFFFFFFF;
            a = (214013 * a + 2531011) &amp; 0xFFFFFFFF;
            /* Convert from (effectively) 32-bit signed integer to float in [0..1]. */
            scrambledPRN = a / 4294967296.0 + 0.5;

            /* Calculate the system government from the current seed. */
            government = (p_main.seed.w1 &gt;&gt; 3) &amp; 7;

            /* Now we do the actual system check for Jaguar Company. */
            if (government &lt;= 2) {
                /* We only use the first 3 government types.
                 * Therefore probabilities will be:
                 *   Anarchy:          37.5%
                 *   Feudal:           25.0%
                 *   Multi-Government: 12.5%
                 *
                 * Intestellar space will halve these probabilites.
                 */
                systemProbability = 0.125 * (3 - government);

                if (scrambledPRN &lt;= systemProbability) {
                    if (this.$logging &amp;&amp; this.$logExtra) {
                        logMsg += &quot;* Name: &quot; + System.systemNameForID(counter) +
                        &quot;, Government type: &quot; + governmentNames[government] + &quot;\n&quot;;
                    }

                    /* Insert the ID into an array. */
                    this.$jaguarCompanySystemIDs.push(counter);
                    /* Insert the name with government type into an array. */
                    this.$jaguarCompanySystemNames.push(System.systemNameForID(counter) + &quot; &quot; +
                        &quot;(&quot; + governmentNames[government] + &quot;)&quot;);
                }

                if (scrambledPRN &lt;= systemProbability / 2) {
                    if (this.$logging &amp;&amp; this.$logExtra) {
                        logMsg += &quot;** Interstellar.\n&quot;;
                    }

                    this.$jaguarCompanyInterstellar.push(counter);
                }
            }

            /* Tweak the main seed for the next system. */
            this.$rng_tweakseed();
            this.$rng_tweakseed();
            this.$rng_tweakseed();
            this.$rng_tweakseed();
        }

        /* Sort the names. */
        this.$jaguarCompanySystemNames.sort();

        if (this.$logging &amp;&amp; this.$logExtra) {
            log(this.name, logMsg);
        }
    };

    /* NAME
     *   $rng_rotatel
     *
     * FUNCTION
     *   Rotate 8-bit number leftwards.
     *
     * INPUT
     *   x - 8-bit number to rotate leftwards
     *
     * RESULT
     *   result - rotated 8-bit number
     */
    this.$rng_rotatel = function (x) {
        x = (x &amp; 0xff) * 2;

        return (x &amp; 0xff) | (x &gt; 0xff);
    };

    /* NAME
     *   $rng_twist
     *
     * FUNCTION
     *   Twist 16-bit number.
     *
     * INPUT
     *   x - 16-bit number to twist
     *
     * RESULT
     *   result - twisted 16-bit number
     */
    this.$rng_twist = function (x) {
        return (this.$rng_rotatel(x &gt;&gt; 8) &lt;&lt; 8) + this.$rng_rotatel(x &amp; 0xff);
    };

    /* NAME
     *   $rng_nextgalaxy
     *
     * FUNCTION
     *   Next galaxy.
     *
     *   Apply to main seed; once for galaxy 2
     *   twice for galaxy 3, etc.
     *   Eighth application gives galaxy 1 again.
     */
    this.$rng_nextgalaxy = function () {
        p_main.seed.w0 = this.$rng_twist(p_main.seed.w0);
        p_main.seed.w1 = this.$rng_twist(p_main.seed.w1);
        p_main.seed.w2 = this.$rng_twist(p_main.seed.w2);
    };

    /* NAME
     *   $rng_tweakseed
     *
     * FUNCTION
     *   Main seed tweaker.
     */
    this.$rng_tweakseed = function () {
        var tmp;

        tmp = p_main.seed.w0 + p_main.seed.w1 + p_main.seed.w2;
        tmp &amp;= 0xffff;

        p_main.seed.w0 = p_main.seed.w1;
        p_main.seed.w1 = p_main.seed.w2;
        p_main.seed.w2 = tmp;
    };

    /* NAME
     *   $gen_rnd_number
     *
     * FUNCTION
     *   Random number generator.
     *
     * RESULT
     *   result - random number
     */
    this.$gen_rnd_number = function () {
        var x = (p_main.rnd_seed.a * 2) &amp; 0xFF,
        a = x + p_main.rnd_seed.c;

        if (p_main.rnd_seed.a &gt; 127) {
            a += 1;
        }

        p_main.rnd_seed.a = a &amp; 0xFF;
        p_main.rnd_seed.c = x;

        /* a = any carry left from above */
        a = a / 256;
        x = p_main.rnd_seed.b;
        a = (a + x + p_main.rnd_seed.d) &amp; 0xFF;
        p_main.rnd_seed.b = a;
        p_main.rnd_seed.d = x;

        return a;
    };

    /* NAME
     *   $scriptSanityTimer
     *
     * FUNCTION
     *   Periodic function to check if Jaguar Company has spawned correctly.
     *
     *   Checks the base, asteroids, black box and tracker.
     *   Patrol ships, tug, buoy and miner are checked within the base ship script.
     *
     *   The order that this is done in is important.
     */
    this.$scriptSanityTimer = function () {
        var base = this.$jaguarCompanyBase,
        asteroids,
        asteroid,
        equipment,
        blackbox,
        counter,
        length;

        if (!base || !base.isValid) {
            /* Not setup yet. */
            return;
        }

        /* Check the base. */
        if (!this.$baseOK) {
            if (base.script.name !== &quot;jaguar_company_base.js&quot;) {
                /* Reload the ship script. */
                base.setScript(&quot;jaguar_company_base.js&quot;);
                base.script.shipSpawned();

                if (this.$logging &amp;&amp; this.$logExtra) {
                    log(this.name, &quot;Script sanity check - fixed the base.&quot;);
                }
            } else {
                /* Don&#39;t re-check. */
                this.$baseOK = true;
            }
        }

        /* Check the asteroids. */
        if (!this.$asteroidsOK) {
            /* Search for asteroids around the base. */
            asteroids = system.shipsWithPrimaryRole(&quot;jaguar_company_asteroid&quot;);

            if (asteroids.length &gt; 0) {
                /* Set the counter to all entities found. */
                p_main.asteroidsToCheck = asteroids.length;
                /* Cache the length. */
                length = asteroids.length;

                /* Iterate through each of the asteroids. */
                for (counter = 0; counter &lt; length; counter += 1) {
                    asteroid = asteroids[counter];

                    if (asteroid.script.name !== &quot;jaguar_company_asteroid.js&quot;) {
                        /* Reload the ship script. */
                        asteroid.setScript(&quot;jaguar_company_asteroid.js&quot;);
                        asteroid.script.shipSpawned();

                        if (this.$logging &amp;&amp; this.$logExtra) {
                            log(this.name, &quot;Script sanity check - fixed an asteroid.&quot;);
                        }
                    } else {
                        p_main.asteroidsToCheck -= 1;
                    }
                }

                if (!p_main.asteroidsToCheck) {
                    /* Don&#39;t re-check. */
                    this.$asteroidsOK = true;
                    p_main.asteroidsToCheck = null;
                }
            }
        }

        if (player.ship.equipmentStatus(&quot;EQ_JAGUAR_COMPANY_BLACK_BOX&quot;) !== &quot;EQUIPMENT_OK&quot;) {
            /* Doesn&#39;t have the black box locator or is damaged. */
            return;
        }

        /* Check the black box. */
        if (!this.$blackboxOK) {
            equipment = player.ship.equipment;
            length = equipment.length;

            /* Find the black box in the player&#39;s equipment list. */
            for (counter = 0; counter &lt; length; counter += 1) {
                if (equipment[counter].equipmentKey === &quot;EQ_JAGUAR_COMPANY_BLACK_BOX&quot;) {
                    blackbox = equipment[counter];

                    break;
                }
            }

            if (blackbox.scriptName !== &quot;jaguar_company_blackbox.js&quot;) {
                /* Reload the ship script. */
                blackbox.setScript(&quot;jaguar_company_blackbox.js&quot;);

                if (this.$logging &amp;&amp; this.$logExtra) {
                    log(this.name, &quot;Script sanity check - fixed the black box.&quot;);
                }
            } else {
                /* Don&#39;t re-check. */
                this.$blackboxOK = true;
            }
        }

        if (this.$blackboxOK &amp;&amp; (!this.$trackerOK || !this.$visualTrackerOK)) {
            /* Black box script has been fixed. Check the trackers. */

            /* Check the ASC tracker. */
            if (!this.$trackerOK &amp;&amp; this.$tracker &amp;&amp; this.$tracker.isValid) {
                if (this.$tracker.script.name !== &quot;jaguar_company_tracker.js&quot;) {
                    /* Reload the ship script. */
                    this.$tracker.setScript(&quot;jaguar_company_tracker.js&quot;);
                    this.$tracker.script.shipSpawned();

                    if (this.$logging &amp;&amp; this.$logExtra) {
                        log(this.name, &quot;Script sanity check - fixed the tracker.&quot;);
                    }
                } else {
                    /* Don&#39;t re-check. */
                    this.$trackerOK = true;
                }
            }

            /* Check the holo-tracker. */
            if (!this.$visualTrackerOK &amp;&amp; this.$visualTracker &amp;&amp; this.$visualTracker.isValid) {
                if (this.$visualTracker.script.name !== &quot;jaguar_company_tracker.js&quot;) {
                    /* Reload the ship script. */
                    this.$visualTracker.setScript(&quot;jaguar_company_tracker.js&quot;);
                    this.$visualTracker.script.effectSpawned();

                    if (this.$logging &amp;&amp; this.$logExtra) {
                        log(this.name, &quot;Script sanity check - fixed the visual tracker.&quot;);
                    }
                } else {
                    /* Don&#39;t re-check. */
                    this.$visualTrackerOK = true;
                }
            }
        }
    };

    /* NAME
     *   $blackBoxTimer
     *
     * FUNCTION
     *   If the player has received the black box and then attacks Jaguar Company,
     *   this will remove it and the tracker and this timer.
     *
     *   Also checks if we are within 5km of the patrol ships, if so we remove the tracker.
     *
     *   Called every 5 seconds.
     */
    this.$blackBoxTimer = function () {
        var blackBoxStatus,
        patrolShips;

        if (this.$playerVar.attacker) {
            /* The player is an attacker of Jaguar Company. */
            blackBoxStatus = player.ship.equipmentStatus(&quot;EQ_JAGUAR_COMPANY_BLACK_BOX&quot;);

            if (blackBoxStatus === &quot;EQUIPMENT_OK&quot; || blackBoxStatus === &quot;EQUIPMENT_DAMAGED&quot;) {
                /* Remove the software patch from the black box. */
                this.$playerVar.locationsActivated[galaxyNumber] = false;
                /* Remove the black box. */
                player.ship.removeEquipment(&quot;EQ_JAGUAR_COMPANY_BLACK_BOX&quot;);
                player.commsMessage(&quot;Black Box self-destructed!&quot;);
                /* Reset the black box. */
                this.$blackboxASCReset(false);
                this.$blackboxHoloReset(false);

                /* Stop and remove the Black Box timer. */
                if (this.$blackBoxTimerReference) {
                    if (this.$blackBoxTimerReference.isRunning) {
                        this.$blackBoxTimerReference.stop();
                    }

                    this.$blackBoxTimerReference = null;
                }
            }
        } else if ((this.$tracker &amp;&amp; this.$tracker.isValid) || (this.$visualTracker &amp;&amp; this.$visualTracker.isValid)) {
            if (player.ship.equipmentStatus(&quot;EQ_ADVANCED_COMPASS&quot;) !== &quot;EQUIPMENT_OK&quot;) {
                player.consoleMessage(&quot;Tracker deactivating.&quot;);
                player.consoleMessage(&quot;Advanced Space Compass damaged.&quot;);
                /* Reset the black box. */
                this.$blackboxASCReset(false);
                this.$blackboxHoloReset(false);
            } else {
                patrolShips = system.shipsWithPrimaryRole(&quot;jaguar_company_patrol&quot;, player.ship);

                if (patrolShips.length &gt; 0 &amp;&amp; player.ship.position.distanceTo(patrolShips[0].position) &lt; 5000) {
                    player.consoleMessage(&quot;Tracker deactivating.&quot;);
                    player.consoleMessage(&quot;Patrol ships close by.&quot;);
                    /* Reset the black box. */
                    this.$blackboxASCReset(false);
                    this.$blackboxHoloReset(false);
                }
            }
        }
    };

    /* NAME
     *   $baseSwapTimer
     *
     * FUNCTION
     *   Swap the base role dependent on the reputation mission variable.
     *
     *   Called every 5 seconds.
     */
    this.$baseSwapTimer = function () {
        var base = this.$jaguarCompanyBase,
        position,
        orientation,
        reputation,
        displayName,
        newBase,
        newBaseRole,
        entities,
        entity,
        distance,
        direction,
        entityCounter,
        entityLength;

        if (!base || !base.isValid) {
            /* Stop and remove the base swap timer. */
            this.$baseSwapTimerReference.stop();
            this.$baseSwapTimerReference = null;

            return;
        }

        reputation = this.$playerVar.reputation[galaxyNumber];

        /* Set up the role that the base should have. */
        if (reputation &lt; this.$reputationHelper) {
            newBaseRole = &quot;jaguar_company_base_no_discount&quot;;
        } else if (reputation &lt; this.$reputationBlackbox) {
            newBaseRole = &quot;jaguar_company_base_discount&quot;;
        } else {
            newBaseRole = &quot;jaguar_company_base_discount_and_docking&quot;;
        }

        if (base.hasRole(newBaseRole)) {
            /* The base already has this new role. No need to swap. */
            return;
        }

        /* Shift any entities that are launching. Hopefully there should only be 1 ship in the launch tube (if any).
         * There really shouldn&#39;t be anything close by to the new position as we are only placing the
         * entity a small distance outside the docking port.
         */
        entities = system.filteredEntities(this, function (entity) {
                return (entity &amp;&amp; entity.isValid);
            }, base, base.collisionRadius);

        if (entities.length) {
            /* Cache the length. */
            entityLength = entities.length;

            for (entityCounter = 0; entityCounter &lt; entityLength; entityCounter += 1) {
                entity = entities[entityCounter];
                /* Current distance of the entity from the base. */
                distance = entity.position.distanceTo(base.position);
                /* New distance to move the entity by. */
                distance = (base.collisionRadius - distance) + entity.collisionRadius + 10;
                /* Update position along the original direction vector. */
                direction = entity.position.subtract(base.position).direction();
                entity.position = entity.position.add(direction.multiply(distance));
            }
        }

        /* Copy some properties. */
        position = base.position;
        orientation = base.orientation;
        displayName = base.displayName;
        /* This is checked in the base ship script. If set, it will not set up various properties in
         * the &#39;shipSpawned&#39; base ship script event as we will be copying over the originals here.
         * $swapBase will be reset in the &#39;shipSpawned&#39; base ship script once the base has fully spawned.
         */
        this.$swapBase = true;
        /* Create a new base. */
        //        newBase = base.spawnOne(newBaseRole);
        /* Remove the original base quietly: don&#39;t trigger &#39;shipDied&#39; in the ship script. */
        base.remove(true);
        /* Setup the new base with the original properties. */
        newBase = system.addShips(newBaseRole, 1, position, 0)[0];
        newBase.position = position;
        newBase.orientation = orientation;
        newBase.displayName = displayName;
        /* Stop any kick in velocity we may get from any nearby entity.
         * Imagine a station that you need injectors to out run.
         */
        newBase.velocity = new Vector3D(0, 0, 0);
        /* Update the base reference. */
        this.$jaguarCompanyBase = newBase;
    };

    /* NAME
     *   $blackboxToggle
     *
     * FUNCTION
     *   Toggle the activation of the black box ASC equipment.
     */
    this.$blackboxToggle = function () {
        var playerShip = player.ship,
        patrolShips = system.shipsWithPrimaryRole(&quot;jaguar_company_patrol&quot;, playerShip),
        ascStatus = playerShip.equipmentStatus(&quot;EQ_ADVANCED_COMPASS&quot;),
        blackboxStatus = playerShip.equipmentStatus(&quot;EQ_JAGUAR_COMPANY_BLACK_BOX&quot;);

        if (ascStatus !== &quot;EQUIPMENT_OK&quot;) {
            player.consoleMessage(&quot;You need a working Advanced Space Compass for this equipment.&quot;);
        } else if (blackboxStatus === &quot;EQUIPMENT_OK&quot;) {
            if (!patrolShips.length) {
                player.consoleMessage(&quot;Can not show tracker. No patrol ships found.&quot;);
            } else if (playerShip.position.distanceTo(patrolShips[0].position) &lt; 5000) {
                player.consoleMessage(&quot;Tracker not activated. Patrol ships close by.&quot;);
            } else {
                if (p_main.blackboxASCActivated) {
                    this.$blackboxASCReset(true);
                } else {
                    this.$blackboxASCSet(true);
                }
            }

            p_main.blackboxASCActivated = !p_main.blackboxASCActivated;
        } else if (blackboxStatus === &quot;EQUIPMENT_DAMAGED&quot;) {
            player.commsMessage(&quot;Black Box Damaged!&quot;);
            player.commsMessage(&quot;Return to the nearest Jaguar Company Base for repairs.&quot;);
        }
    };

    /* NAME
     *   $blackboxMode
     *
     * FUNCTION
     *   Toggle the activation of the black box holo equipment.
     */
    this.$blackboxMode = function () {
        var playerShip = player.ship,
        patrolShips = system.shipsWithPrimaryRole(&quot;jaguar_company_patrol&quot;, playerShip),
        ascStatus = playerShip.equipmentStatus(&quot;EQ_ADVANCED_COMPASS&quot;),
        blackboxStatus = playerShip.equipmentStatus(&quot;EQ_JAGUAR_COMPANY_BLACK_BOX&quot;);

        if (ascStatus !== &quot;EQUIPMENT_OK&quot;) {
            player.consoleMessage(&quot;You need a working Advanced Space Compass for this equipment.&quot;);
        } else if (blackboxStatus === &quot;EQUIPMENT_OK&quot;) {
            if (!patrolShips.length) {
                player.consoleMessage(&quot;Can not show holo-tracker. No patrol ships found.&quot;);
            } else if (playerShip.position.distanceTo(patrolShips[0].position) &lt; 5000) {
                player.consoleMessage(&quot;Holo-tracker not activated. Patrol ships close by.&quot;);
            } else {
                if (p_main.blackboxHoloActivated) {
                    this.$blackboxHoloReset(true);
                } else {
                    this.$blackboxHoloSet(true);
                }
            }

            p_main.blackboxHoloActivated = !p_main.blackboxHoloActivated;
        } else if (blackboxStatus === &quot;EQUIPMENT_DAMAGED&quot;) {
            player.commsMessage(&quot;Black Box Damaged!&quot;);
            player.commsMessage(&quot;Return to the nearest Jaguar Company Base for repairs.&quot;);
        }
    };

    /* NAME
     *   $blackboxASCSet
     *
     * FUNCTION
     *   Setup the black box ASC equipment.
     *
     * INPUT
     *   showMsg - boolean
     *     true - show console message
     *     false - do not show console message
     */
    this.$blackboxASCSet = function (showMsg) {
        var patrolShips = system.shipsWithPrimaryRole(&quot;jaguar_company_patrol&quot;, player.ship);

        if (patrolShips.length &amp;&amp; (!this.$tracker || !this.$tracker.isValid)) {
            /* Invisible object. */
            this.$tracker = system.addShips(&quot;jaguar_company_tracker&quot;, 1, patrolShips[0].position, 10000)[0];

            if (showMsg &amp;&amp; this.$tracker &amp;&amp; this.$tracker.isValid) {
                player.consoleMessage(&quot;Black Box ASC tracker activated.&quot;);
                player.consoleMessage(&quot;Follow beacon code &#39;T&#39; on your ASC.&quot;);
            }
        }
    };

    /* NAME
     *   $blackboxHoloSet
     *
     * FUNCTION
     *   Setup the black box holo-tracker equipment.
     *
     * INPUT
     *   showMsg - boolean
     *     true - show console message
     *     false - do not show console message
     */
    this.$blackboxHoloSet = function (showMsg) {
        var patrolShips = system.shipsWithPrimaryRole(&quot;jaguar_company_patrol&quot;, player.ship);

        if (this.$visualEffects &amp;&amp; this.$gte_v1_77 &amp;&amp;
            patrolShips.length &amp;&amp; (!this.$visualTracker || !this.$visualTracker.isValid)) {
            /* Visual effect for Oolite v1.77 and newer. */
            this.$visualTracker = system.addVisualEffect(&quot;jaguar_company_tracker&quot;, player.ship.position);

            if (showMsg &amp;&amp; this.$visualTracker &amp;&amp; this.$visualTracker.isValid) {
                player.consoleMessage(&quot;Black Box holo-tracker activated.&quot;);
                player.consoleMessage(&quot;Green is fore, red is aft.&quot;);
            }
        }
    };

    /* NAME
     *   $blackboxASCReset
     *
     * FUNCTION
     *   Reset the black box ASC equipment.
     *
     * INPUT
     *   showMsg - boolean
     *     true - show console message
     *     false - do not show console message
     */
    this.$blackboxASCReset = function (showMsg) {
        if (this.$tracker &amp;&amp; this.$tracker.isValid) {
            /* Remove the tracker quietly: don&#39;t trigger &#39;shipDied&#39; in the ship script. */
            this.$tracker.remove(true);
            this.$trackerOK = false;

            if (showMsg) {
                player.consoleMessage(&quot;Black Box ASC tracker deactivated.&quot;);
            }
        }
    };

    /* NAME
     *   $blackboxHoloReset
     *
     * FUNCTION
     *   Reset the black box holo-tracker equipment.
     *
     * INPUT
     *   showMsg - boolean
     *     true - show console message
     *     false - do not show console message
     */
    this.$blackboxHoloReset = function (showMsg) {
        if (this.$visualEffects &amp;&amp; this.$gte_v1_77 &amp;&amp; this.$visualTracker &amp;&amp; this.$visualTracker.isValid) {
            /* Remove the visual tracker. */
            this.$visualTracker.remove();
            this.$visualTrackerOK = false;

            if (showMsg) {
                player.consoleMessage(&quot;Black Box holo-tracker deactivated.&quot;);
            }
        }
    };

    /* NAME
     *   $welcomeMessage
     *
     * FUNCTION
     *   Show a welcome message.
     */
    this.$welcomeMessage = function () {
        var reputation = this.$playerVar.reputation[galaxyNumber],
        helperLevel = this.$reputationHelper,
        blackboxLevel = this.$reputationBlackbox,
        locationsLevel = this.$reputationLocations,
        welcome,
        logMsg;

        if (typeof this.$playerVar.delayedAward === &quot;number&quot;) {
            /* Add on the delayed award to the reputation. */
            reputation += this.$playerVar.delayedAward;
        }

        if (this.$logging &amp;&amp; this.$logExtra) {
            logMsg = &quot;$welcomeMessage::reputation: &quot; + reputation + &quot;\n&quot; +
                &quot;$welcomeMessage::visitedBase: &quot; + this.$playerVar.visitedBase + &quot;\n&quot;;
        }

        p_main.playerWelcomed = true;

        welcome = expandDescription(&quot;[jaguar_company_base_greeting] &quot;);

        if (!this.$playerVar.visitedBase) {
            welcome += expandDescription(&quot;[jaguar_company_base_docked]&quot;);
        } else {
            welcome += expandDescription(&quot;[jaguar_company_base_visited]&quot;);
        }

        if (reputation &gt;= helperLevel) {
            welcome += &quot; &quot; + expandMissionText(&quot;jaguar_company_base_thankyou&quot;);
        }

        if (reputation &gt;= blackboxLevel) {
            if (player.ship.equipmentStatus(&quot;EQ_JAGUAR_COMPANY_BLACK_BOX&quot;) !== &quot;EQUIPMENT_OK&quot;) {
                /* Doesn&#39;t have the black box locator or is damaged. */
                if (player.ship.equipmentStatus(&quot;EQ_JAGUAR_COMPANY_BLACK_BOX&quot;) === &quot;EQUIPMENT_DAMAGED&quot;) {
                    /* Black box damaged. */
                    welcome += expandMissionText(&quot;jaguar_company_base_fix_black_box&quot;);
                    player.ship.setEquipmentStatus(&quot;EQ_JAGUAR_COMPANY_BLACK_BOX&quot;, &quot;EQUIPMENT_OK&quot;);
                } else {
                    /* No black box locator. */
                    if (this.$visualEffects &amp;&amp; this.$gte_v1_77) {
                        /* Oolite v1.77 and newer. */
                        welcome += expandMissionText(&quot;jaguar_company_base_no_black_box2&quot;);
                    } else {
                        /* Visual effects off or Oolite v1.76.1 and older. */
                        welcome += expandMissionText(&quot;jaguar_company_base_no_black_box1&quot;);
                    }

                    player.ship.awardEquipment(&quot;EQ_JAGUAR_COMPANY_BLACK_BOX&quot;);

                    if (!this.$blackBoxTimerReference || !this.$blackBoxTimerReference.isRunning) {
                        if (!this.$blackBoxTimerReference) {
                            /* Create a new timer. Checks every 5 seconds. */
                            this.$blackBoxTimerReference = new Timer(this, this.$blackBoxTimer, 5, 5);
                        } else {
                            /* Start the timer if it exists and has stopped. */
                            this.$blackBoxTimerReference.start();
                        }
                    }

                    /* Reset the check flag. */
                    this.$blackboxOK = false;
                }
            }
        }

        if (reputation &gt;= locationsLevel &amp;&amp; !this.$playerVar.locationsActivated[galaxyNumber]) {
            /* Upload the software patch to the black box. */
            this.$playerVar.locationsActivated[galaxyNumber] = true;
            /* Add the interface system if Oolite v1.77 and newer is used. */
            this.$addInterface();

            if (this.$gte_v1_77) {
                /* Oolite v1.77 and newer. */
                welcome += expandMissionText(&quot;jaguar_company_base_no_locator2&quot;);
            } else {
                /* Oolite v1.76.1 and older. */
                welcome += expandMissionText(&quot;jaguar_company_base_no_locator1&quot;);
            }
        }

        if (reputation &gt;= helperLevel &amp;&amp; !system.isInterstellarSpace) {
            /* Add on a market message if reputation is high enough and not in interstellar space. */
            welcome += expandMissionText(&quot;jaguar_company_base_market&quot;);

            if (player.ship.manifest.food ||
                player.ship.manifest.textiles ||
                player.ship.manifest.liquorWines ||
                player.ship.manifest.luxuries ||
                player.ship.manifest.furs ||
                player.ship.manifest.alienItems) {
                /* Add a message for some wanted items in the player&#39;s hold. */
                welcome += expandMissionText(&quot;jaguar_company_base_market_want&quot;);

                if (player.ship.manifest.food) {
                    welcome += expandMissionText(&quot;jaguar_company_base_market_want_a&quot;, {
                        jaguar_company_commodity : &quot;food&quot;
                    });
                }

                if (player.ship.manifest.textiles || player.ship.manifest.furs) {
                    welcome += expandMissionText(&quot;jaguar_company_base_market_want_a&quot;, {
                        jaguar_company_commodity : &quot;clothing&quot;
                    });
                }

                if (player.ship.manifest.liquorWines) {
                    welcome += expandMissionText(&quot;jaguar_company_base_market_want_a&quot;, {
                        jaguar_company_commodity : &quot;alcohol&quot;
                    });
                }

                if (player.ship.manifest.luxuries) {
                    welcome += expandMissionText(&quot;jaguar_company_base_market_want_a&quot;, {
                        jaguar_company_commodity : &quot;luxuries&quot;
                    });
                }

                if (player.ship.manifest.alienItems) {
                    welcome += expandMissionText(&quot;jaguar_company_base_market_want_a&quot;, {
                        jaguar_company_commodity : &quot;alien technology&quot;
                    });
                }
            }
        }

        if (this.$logging &amp;&amp; this.$logExtra) {
            logMsg += &quot;$welcomeMessage::welcome: &quot; + welcome;
            log(this.name, &quot;\n&quot; + logMsg);
        }

        this.$playerVar.visitedBase = true;
        mission.runScreen({
            title : this.$jaguarCompanyBase.displayName,
            message : welcome
        });
    };

    /* NAME
     *   $scanForWitchpointBuoy
     *
     * FUNCTION
     *   Scan for a witchpoint buoy.
     *
     * RESULT
     *   result - witchpoint buoy entity or a fake entity if it can&#39;t be found
     */
    this.$scanForWitchpointBuoy = function () {
        var buoys,
        buoy;

        /* Fake witchpoint buoy entity. Updated if one is found. */
        buoy = {
            isValid : true,
            position : new Vector3D(0, 0, 0),
            collisionRadius : 100
        };

        if (!system.isInterstellarSpace) {
            /* Find the witchpoint buoy. */
            buoys = system.filteredEntities(this, function (entity) {
                    if (!entity.isValid || entity.scanClass !== &quot;CLASS_BUOY&quot;) {
                        /* Ignore all entities that have one of these conditions:
                         * 1) not valid
                         * 2) not CLASS_BUOY
                         */
                        return false;
                    }

                    return entity.hasRole(&quot;buoy-witchpoint&quot;);
                });

            if (buoys.length) {
                /* Closest one to the origin. */
                buoy = buoys[0];
            }
        }

        return buoy;
    };

    /* NAME
     *   $isNavyShip
     *
     * FUNCTION
     *   Checks for various Galactic Navy ships.
     *
     *   This only checks for medical ships, frigates and carriers.
     *
     * INPUT
     *   entity - entity of the ship to check
     *
     * RESULT
     *   result - true if entity is a Galactic Navy ship, false if not
     */
    this.$isNavyShip = function (entity) {
        if (!entity.isValid ||
            !entity.isShip ||
            !entity.isPiloted ||
            !entity.isPolice) {
            /* Ignore all entities that have one of these conditions:
             * 1) not valid
             * 2) not a ship
             * 3) not piloted
             * 4) not police (navy should be)
             */
            return false;
        }

        return (entity.hasRole(&quot;navy-medship&quot;) ||
            entity.hasRole(&quot;navy-frigate&quot;) ||
            entity.hasRole(&quot;patrol-frigate&quot;) ||
            entity.hasRole(&quot;picket-frigate&quot;) ||
            entity.hasRole(&quot;picket-behemoth&quot;) ||
            entity.hasRole(&quot;navy-behemoth&quot;) ||
            entity.hasRole(&quot;navy-behemoth-battlegroup&quot;) ||
            entity.hasRole(&quot;behemoth&quot;));
    };

    /* NAME
     *   $scanForNavyShips
     *
     * FUNCTION
     *   Find any major Galactic Navy ships.
     *
     * INPUT
     *   near - entity of the search origin, will use the witchpoint if not specified
     *
     * RESULT
     *   result - array of ship entities
     */
    this.$scanForNavyShips = function (near) {
        var ships;

        if (!near || !near.isValid) {
            /* Defaults to the witchpoint as the origin. */
            ships = system.filteredEntities(this, this.$isNavyShip);
        } else {
            ships = system.filteredEntities(this, this.$isNavyShip, near);
        }

        return ships;
    };

    /* NAME
     *   $spawnJaguarCompany
     *
     * FUNCTION
     *   Spawn Jaguar Company
     *
     * INPUT
     *   state - number
     *     1 - general add
     *     2 - add because of Galactic Navy presence
     *     4 - add always
     */
    this.$spawnJaguarCompany = function (state) {
        var sysname,
        logMsg = &quot;$spawnJaguarCompany::&quot;;

        if (!state || state &lt;= 0 || state &gt; 7) {
            log(this.name, logMsg + &quot;This should NOT happen! Unknown state: &quot; + state);

            return;
        }

        /* Reset the check flags. */
        this.$baseOK = false;
        this.$asteroidsOK = false;

        if (!this.$scriptSanityTimerReference || !this.$scriptSanityTimerReference.isRunning) {
            /* This timer will check all Jaguar Company entities for script sanity. */
            if (!this.$scriptSanityTimerReference) {
                /* Create a new timer. Checked every 5 seconds. */
                this.$scriptSanityTimerReference = new Timer(this, this.$scriptSanityTimer, 5, 5);
            } else {
                /* Start the timer if it exists and has stopped. */
                this.$scriptSanityTimerReference.start();
            }
        }

        if (player.ship.equipmentStatus(&quot;EQ_JAGUAR_COMPANY_BLACK_BOX&quot;) === &quot;EQUIPMENT_OK&quot; ||
            player.ship.equipmentStatus(&quot;EQ_JAGUAR_COMPANY_BLACK_BOX&quot;) === &quot;EQUIPMENT_DAMAGED&quot;) {
            /* The player has a black box.
             * This timer will de-activate the tracker if too close to the patrol ships
             * or it will self-destruct the black box if the player is not allowed it.
             */
            if (!this.$blackBoxTimerReference || !this.$blackBoxTimerReference.isRunning) {
                if (!this.$blackBoxTimerReference) {
                    /* Create a new timer. Checked every 5 seconds. */
                    this.$blackBoxTimerReference = new Timer(this, this.$blackBoxTimer, 5, 5);
                } else {
                    /* Start the timer if it exists and has stopped. */
                    this.$blackBoxTimerReference.start();
                }
            }
        }

        /* Scan for the witchpoint buoy entity. */
        this.$witchpointBuoy = this.$scanForWitchpointBuoy();

        if (this.$logging) {
            sysname = system.name;

            if (system.isInterstellarSpace) {
                sysname = &quot;Interstellar&quot;;
            }

            if (state &amp; 1) {
                logMsg += &quot;\n* Adding Jaguar Company to patrol in the &quot; + sysname + &quot; space lane.&quot;;
            }

            if (state &amp; 2) {
                logMsg +=
                &quot;\n* Adding Jaguar Company to patrol with the Galactic Navy in the &quot; + sysname + &quot; space lane.&quot;;
            }

            if (state &amp; 4) {
                logMsg += &quot;\n* Always spawn set - Adding Jaguar Company to the &quot; + sysname + &quot; space lane.&quot;;
            }

            log(this.name, logMsg);
        }

        if (state &amp; 2) {
            /* Create the patrol for navy work. */
            this.$spawnJaguarCompanyNavyPatrol();
        }

        if (state &amp; 5) {
            /* Create the base. */
            this.$spawnJaguarCompanyBase();
        }
    };

    /* NAME
     *   $spawnJaguarCompanyNavyPatrol
     *
     * FUNCTION
     *   Create the patrol for navy work.
     */
    this.$spawnJaguarCompanyNavyPatrol = function () {
        var navyShips = this.$scanForNavyShips();

        if (navyShips.length) {
            p_main.joinNavy = true;
            p_main.closestNavyShip = navyShips[0];
            /* Initialise the route list with the Navy route. */
            this.$initRoute(&quot;NAVY&quot;);

            if (!system.countShipsWithRole(&quot;jaguar_company_patrol&quot;) &amp;&amp;
                !system.countShipsWithRole(&quot;jaguar_company_base&quot;)) {
                /* Add the patrol ships. */
                system.addShips(&quot;jaguar_company_patrol&quot;, this.$maxPatrolShips, navyShips[0].position, 7500);
            }
        }
    };

    /* NAME
     *   $spawnJaguarCompanyBase
     *
     * FUNCTION
     *   Create the base.
     */
    this.$spawnJaguarCompanyBase = function () {
        var ratio,
        basePosition,
        baseRole,
        dot,
        mainPlanet,
        mPovUp,
        wpPosition,
        wpsunDirection,
        wpmpDirection;

        if (this.$jaguarCompanyBase &amp;&amp; this.$jaguarCompanyBase.isValid) {
            /* Already setup. */
            return;
        }

        if (system.isInterstellarSpace) {
            /* If we are in interstellar space then the base is somewhere within
             * 7 times standard scanner range of the centre point.
             */
            basePosition = Vector3D.randomDirectionAndLength(7 * 25600);
            /* Move the base in a random direction a distance of 3 times standard scanner range. */
            basePosition = basePosition.add(Vector3D.randomDirection(3 * 25600));
        } else {
            /* Shorten some of the property names and calculations. */
            mainPlanet = system.mainPlanet;
            wpPosition = this.$witchpointBuoy.position;
            wpsunDirection = wpPosition.subtract(system.sun.position).direction();
            wpmpDirection = wpPosition.subtract(mainPlanet.position).direction();
            dot = wpsunDirection.dot(wpmpDirection);

            /* Some systems have the witchpoint, main planet and sun all in opposition/conjunction. */
            if (dot &gt; -0.5 &amp;&amp; dot &lt; 0.5) {
                /* The sun is somewhere out to the right or left.
                 *  - or up or down or any variety of directions that isn&#39;t infront or behind.
                 */
                /* Pick a ratio between 0.3 and 0.5 */
                ratio = 0.3 + (system.scrambledPseudoRandomNumber(this.$salt) * 0.2);
                /* Place the base on the witchpoint -&gt; sun route. */
                basePosition = Vector3D.interpolate(wpPosition, system.sun.position, ratio);
                /* Move it 4 to 6 times scanning range towards the main planet. */
                ratio = (4 + (system.scrambledPseudoRandomNumber(this.$salt) * 2)) * 25600;
                ratio /= basePosition.distanceTo(mainPlanet.position);
                basePosition = Vector3D.interpolate(basePosition, mainPlanet.position, ratio);
            } else {
                if (this.$logging &amp;&amp; this.$logExtra) {
                    if (dot &gt;= 0.5) {
                        /* Witchpoint is on the opposite side of the planet to the sun. */
                        log(this.name, &quot;$spawnJaguarCompanyBase::Conjunction! Choosing alternate base position.&quot;);
                    } else {
                        /* Witchpoint in between the planet and the sun. */
                        log(this.name, &quot;$spawnJaguarCompanyBase::Opposition! Choosing alternate base position.&quot;);
                    }
                }

                /* The witchpoint, main planet and sun are getting close to being in opposition/conjunction. */
                /* Pick a ratio between 0.1 and 0.3 */
                ratio = 0.1 + (system.scrambledPseudoRandomNumber(this.$salt) * 0.2);
                /* Place the base on the witchpoint -&gt; main planet route. */
                basePosition = Vector3D.interpolate(wpPosition, mainPlanet.position, ratio);
                /* Move it 6 to 8 times scanning range upwards with respect to the main planet&#39;s surface. */
                ratio = (6 + (system.scrambledPseudoRandomNumber(this.$salt + 1) * 2)) * 25600;
                mPovUp = mainPlanet.orientation.vectorUp();
                basePosition = basePosition.add(mPovUp.multiply(mainPlanet.radius + ratio));
            }
        }

        /* Set the base role dependent on the reputation mission variable. */
        if (this.$playerVar.reputation[galaxyNumber] &lt; this.$reputationHelper) {
            baseRole = &quot;jaguar_company_base_no_discount&quot;;
        } else if (this.$playerVar.reputation[galaxyNumber] &lt; this.$reputationBlackbox) {
            baseRole = &quot;jaguar_company_base_discount&quot;;
        } else {
            baseRole = &quot;jaguar_company_base_discount_and_docking&quot;;
        }

        /* Add the base. */
        this.$jaguarCompanyBase = system.addShips(baseRole, 1, basePosition, 0)[0];

        if (!this.$baseSwapTimerReference || !this.$baseSwapTimerReference.isRunning) {
            /* This timer will swap the base role if needed. */
            if (!this.$baseSwapTimerReference) {
                /* Create a new timer. Checked every 5 seconds. */
                this.$baseSwapTimerReference = new Timer(this, this.$baseSwapTimer, 5, 5);
            } else {
                /* Start the timer if it exists and has stopped. */
                this.$baseSwapTimerReference.start();
            }
        }

        if (!p_main.joinNavy) {
            /* Initialise the route list with the default route. */
            this.$initRoute();
        }
    };

    /* NAME
     *   $setUpCompany
     *
     * FUNCTION
     *   Check to see if we need to spawn Jaguar Company.
     *
     * RESULT
     *   result - true if Jaguar Company will be spawned, false if not
     */
    this.$setUpCompany = function () {
        var scrambledPRN,
        systemID,
        navyPresent = false,
        /* 50:50 chance of joining the Galactic Navy. */
        joinNavyProbability = 0.5,
        spawnInSystem = false,
        spawnCompany = 0;

        /* Stop and remove the timer. */
        if (this.$setUpCompanyTimerReference) {
            if (this.$setUpCompanyTimerReference.isRunning) {
                this.$setUpCompanyTimerReference.stop();
            }

            this.$setUpCompanyTimerReference = null;
        }

        if (!this.$alwaysSpawn) {
            if (system.sun &amp;&amp; (system.sun.isGoingNova || system.sun.hasGoneNova)) {
                /* Don&#39;t setup if the system sun is going nova or has already gone nova. */
                if (this.$logging &amp;&amp; this.$logExtra) {
                    log(this.name, &quot;$setUpCompany::\n&quot; +
                        &quot;system.sun.isGoingNova: &quot; + system.sun.isGoingNova +
                        &quot;, system.sun.hasGoneNova: &quot; + system.sun.hasGoneNova);
                }

                return false;
            }
        }

        if (this.$jaguarCompanyBase &amp;&amp; this.$jaguarCompanyBase.isValid) {
            /* Already setup. */
            return true;
        }

        /* Bit pattern for spawning...
         *
         * spawnInSystem    - 001
         * joinNavy         - 010
         * alwaysSpawn      - 100
         */

        /* In interstellar space, the scrambledPRN will be for the last system you were in. */
        scrambledPRN = system.scrambledPseudoRandomNumber(this.$salt);

        if (!p_main.joinNavy) {
            navyPresent = this.$scanForNavyShips().length &gt; 0;
        } else {
            navyPresent = true;
        }

        /* Jaguar Company are part-time reservists. */
        p_main.joinNavy = (navyPresent &amp;&amp; scrambledPRN &lt;= joinNavyProbability);

        if (system.isInterstellarSpace) {
            /* Use the last system ID. */
            systemID = this.$lastSystemID;
        } else {
            /* Save the current system ID. */
            systemID = system.ID;
            this.$lastSystemID = systemID;
        }

        if ((system.isInterstellarSpace &amp;&amp; this.$jaguarCompanyInterstellar.indexOf(systemID) !== -1) ||
            (!system.isInterstellarSpace &amp;&amp; this.$jaguarCompanySystemIDs.indexOf(systemID) !== -1)) {
            spawnInSystem = true;
        }

        /* Anarchies, Feudals and Multi-Governments or systems with Galactic Naval presence */
        spawnCompany |= (spawnInSystem ? 1 : 0);
        /* Always join the navy if we would have been created in this system. */
        spawnCompany |= ((navyPresent &amp;&amp; spawnInSystem) || p_main.joinNavy ? 2 : 0);
        /* Always spawn no matter what. */
        spawnCompany |= (this.$alwaysSpawn ? 4 : 0);

        if (this.$logging &amp;&amp; this.$logExtra) {
            log(this.name, &quot;$setUpCompany::\n&quot; +
                &quot;* navyPresent: &quot; + navyPresent + &quot;, joinNavy: &quot; + p_main.joinNavy + &quot;\n&quot; +
                &quot;* spawnInSystem: &quot; + spawnInSystem + &quot;\n&quot; +
                &quot;* spawnCompany (normally): &quot; + (spawnCompany &amp; 3 ? &quot;Yes&quot; : &quot;No&quot;));
        }

        if (spawnCompany) {
            this.$spawnJaguarCompany(spawnCompany);

            return true;
        }

        return false;
    };

    /* NAME
     *   $uniqueShipName
     *
     * FUNCTION
     *   Create a unique ship name.
     *
     * INPUTS
     *   isBase - boolean (optional)
     *     true - is a base, will generate the same name for a system
     *     false/undefined - not a base
     *   maxNameLength - maximum length of the name (optional)
     *
     * RESULT
     *   result - unique name
     */
    this.$uniqueShipName = function (isBase, maxNameLength) {
        var index,
        salt = this.$salt,
        randf,
        prefix,
        name;

        if (typeof maxNameLength !== &quot;number&quot;) {
            /* Empty maxNameLength. */
            maxNameLength = 0;
        }

        if (!p_main.availableShipNames || !p_main.availableShipNames.length) {
            /* Initialise the available ship names with a copy of the master list. */
            p_main.availableShipNames = p_const.shipNames.concat([]);
        } else if (p_main.availableShipNames &amp;&amp; p_main.availableShipNames.length &lt;= 8) {
            /* Add on a copy of the master list if the available pot gets low. */
            p_main.availableShipNames = p_main.availableShipNames.concat(p_const.shipNames);
        }

        /* Random number for the index. */
        if (isBase) {
            /* Same random number for each system. */
            randf = system.scrambledPseudoRandomNumber(salt);
        } else {
            randf = Math.random();
        }

        /* Index for the name. */
        index = Math.floor(randf * p_main.availableShipNames.length);
        /* Get a name from the available list and remove it. */
        name = p_main.availableShipNames.splice(index, 1)[0];

        /* Make sure we don&#39;t try to search for a name that is shorter than what is available. */
        if (maxNameLength) {
            /* Reset the max name length if it is shorter than what is available. */
            if (maxNameLength &lt; this.$shortestNameLength) {
                maxNameLength = this.$shortestNameLength;
            }

            /* Keep looping until we find a name short enough. */
            while (name.length &gt; maxNameLength) {
                /* Too long. Put the name back into the available list. */
                p_main.availableShipNames.splice(index, 0, name);

                /* Pick a new random number. */
                if (isBase) {
                    salt += 1;
                    randf = system.scrambledPseudoRandomNumber(salt);
                } else {
                    randf = Math.random();
                }

                /* Index for the new name. */
                index = Math.floor(randf * p_main.availableShipNames.length);
                /* Get a new name from the available list and remove it. */
                name = p_main.availableShipNames.splice(index, 1)[0];
            }
        }

        if (isBase) {
            prefix = &quot;JC Base#&quot; ;
        } else {
            prefix = &quot;JC#&quot;;
        }

        /* Return the new name. */
        return prefix + Math.floor(randf * 10000).toString() + &quot;-&quot; + system.name.substring(0, 2) + &quot;: &quot; + name;
    };

    /* NAME
     *   $initRoute
     *
     * FUNCTION
     *   Alters the route list.
     *
     * INPUT
     *   route - route code (optional)
     *     WPWB - full route (base -&gt; witchpoint -&gt; planet -&gt; witchpoint -&gt; base (dock)) (default)
     *     I - interstellar space (base -&gt; (fake) witchpoint -&gt; base (dock))
     *     NAVY - patrol with the Galactic Navy
     *     WP - witchpoint &lt;-&gt; planet
     *     BP - base -&gt; planet -&gt; base (dock)
     */
    this.$initRoute = function (route) {
        if (system.isInterstellarSpace) {
            route = &quot;I&quot;;
        } else if (typeof route !== &quot;string&quot; || route === &quot;&quot;) {
            route = &quot;WPWB&quot;;
        }

        /* Update the witchpoint buoy reference. */
        this.$witchpointBuoy = this.$scanForWitchpointBuoy();

        switch (route) {
        case &quot;I&quot;:
            /* Alters the route list for Interstellar space. */
            p_main.routes = [{
                    /* Witchpoint. Will be a fake witchpoint. */
                    entity : this.$witchpointBuoy,
                    /* Range used in AI. */
                    range : 5000,
                    /* Message to be sent to the AI. */
                    aiMessage : &quot;JAGUAR_COMPANY_INTERSTELLAR&quot;
                }, {
                    /* Jaguar Company Base. */
                    entity : this.$jaguarCompanyBase,
                    /* Range used in AI. */
                    range : 8000,
                    /* Message to be sent to the AI. */
                    aiMessage : &quot;JAGUAR_COMPANY_BASE&quot;
                }
            ];

            break;
        case &quot;NAVY&quot;:
            /* Alters the route list for navy patrol. */
            p_main.routes = [{
                    /* Navy ship to shadow. */
                    entity : p_main.closestNavyShip,
                    /* Range used in AI. */
                    range : 7500,
                    /* Message to be sent to the AI. */
                    aiMessage : &quot;JAGUAR_COMPANY_NAVY_PATROL&quot;
                }
            ];

            break;
        case &quot;WP&quot;:
            /* Alters the route list for WP-&gt;Planet and Planet-&gt;WP. */
            p_main.routes = [{
                    /* Main planet. */
                    entity : system.mainPlanet,
                    /* Range used in AI. */
                    range : 50000,
                    /* Message to be sent to the AI. */
                    aiMessage : &quot;JAGUAR_COMPANY_PLANET&quot;
                }, {
                    /* Witchpoint. */
                    entity : this.$witchpointBuoy,
                    /* Range used in AI. */
                    range : 10000,
                    /* Message to be sent to the AI. */
                    aiMessage : &quot;JAGUAR_COMPANY_WITCHPOINT&quot;
                }
            ];

            break;
        case &quot;BP&quot;:
            /* Alters the route list for Base-&gt;Planet and Planet-&gt;Base. */
            p_main.routes = [{
                    /* Jaguar Company Base. */
                    entity : this.$jaguarCompanyBase,
                    /* Range used in AI. */
                    range : 8000,
                    /* Message to be sent to the AI. */
                    aiMessage : &quot;JAGUAR_COMPANY_BASE&quot;
                }, {
                    /* Main planet. */
                    entity : system.mainPlanet,
                    /* Range used in AI. */
                    range : 50000,
                    /* Message to be sent to the AI. */
                    aiMessage : &quot;JAGUAR_COMPANY_PLANET&quot;
                }
            ];

            break;
        default:
            /* Full route list. */
            p_main.routes = [{
                    /* Witchpoint. */
                    entity : this.$witchpointBuoy,
                    /* Range used in AI. */
                    range : 10000,
                    /* Message to be sent to the AI. */
                    aiMessage : &quot;JAGUAR_COMPANY_WITCHPOINT_FROM_BASE&quot;
                }, {
                    /* Main planet. */
                    entity : system.mainPlanet,
                    /* Range used in AI. */
                    range : 50000,
                    /* Message to be sent to the AI. */
                    aiMessage : &quot;JAGUAR_COMPANY_PLANET&quot;
                }, {
                    /* Witchpoint. */
                    entity : this.$witchpointBuoy,
                    /* Range used in AI. */
                    range : 10000,
                    /* Message to be sent to the AI. */
                    aiMessage : &quot;JAGUAR_COMPANY_WITCHPOINT&quot;
                }, {
                    /* Jaguar Company Base. */
                    entity : this.$jaguarCompanyBase,
                    /* Range used in AI. */
                    range : 8000,
                    /* Message to be sent to the AI. */
                    aiMessage : &quot;JAGUAR_COMPANY_BASE&quot;
                }
            ];

            break;
        }

        /* Reset the current route index. */
        p_main.routeIndex = 0;
    };

    /* NAME
     *   $changeRoute
     *
     * FUNCTION
     *   Change the current route or set it to the routeNum index of the routes array.
     *
     * INPUT
     *   routeNum - index of the routes array (optional)
     *     &lt; 0 - pick last index
     *     num - use index &#39;num&#39;
     */
    this.$changeRoute = function (routeNum) {
        if (typeof routeNum !== &quot;number&quot;) {
            p_main.routeIndex += 1;

            /* Out-of-bounds checking. */
            if (p_main.routeIndex &gt;= p_main.routes.length) {
                p_main.routeIndex = 0;
            }
        } else {
            if (routeNum &gt;= 0) {
                /* Out-of-bounds checking. */
                if (routeNum &gt;= p_main.routes.length) {
                    routeNum = p_main.routes.length - 1;
                }

                p_main.routeIndex = routeNum;
            } else {
                p_main.routeIndex = p_main.routes.length - 1;
            }
        }
    };

    /* NAME
     *   $checkRoute
     *
     * FUNCTION
     *   Check the current route and send a message to the caller ship&#39;s AI.
     *
     * INPUT
     *   callerShip - caller ship
     */
    this.$checkRoute = function (callerShip) {
        var entity,
        distance;

        /* Out-of-bounds checking. */
        if (p_main.routeIndex &lt; 0) {
            p_main.routeIndex = p_main.routes.length - 1;
        } else if (p_main.routeIndex &gt;= p_main.routes.length) {
            p_main.routeIndex = 0;
        }

        if (this.$logging &amp;&amp; this.$logExtra) {
            entity = p_main.routes[p_main.routeIndex].entity;

            /* Check for entities becoming invalid. */
            if (!entity || !entity.isValid) {
                /* Fake entity a distance of 10 x the required range in a random direction. */
                p_main.routes[p_main.routeIndex].entity = {
                    isValid : true,
                    position : Vector3D.randomDirection(p_main.routes[p_main.routeIndex].range * 10),
                    collisionRadius : 100
                };
                entity = p_main.routes[p_main.routeIndex].entity;
            }

            /* Calculate the surface to surface distance, not centre to centre. */
            distance = callerShip.position.distanceTo(entity.position);
            distance -= callerShip.collisionRadius;
            distance -= entity.collisionRadius;

            log(this.name, &quot;$checkRoute::\n&quot; +
                &quot;* ship#&quot; + callerShip.entityPersonality +
                &quot; (&quot; + callerShip.name + &quot;: &quot; + callerShip.displayName + &quot;)\n&quot; +
                &quot;* Entity position: &quot; + entity.position + &quot;\n&quot; +
                &quot;* Distance: &quot; + distance + &quot;\n&quot; +
                &quot;* Desired range: &quot; + p_main.routes[p_main.routeIndex].range + &quot;\n&quot; +
                &quot;* Current route: &quot; + p_main.routeIndex + &quot; (&quot; + p_main.routes[p_main.routeIndex].aiMessage + &quot;)&quot;);
        }

        callerShip.reactToAIMessage(p_main.routes[p_main.routeIndex].aiMessage);
    };

    /* NAME
     *   $finishedRoute
     *
     * FUNCTION
     *   Finished the current route, change to the next one.
     *
     * INPUT
     *   callerShip - caller ship
     *   groupRole - role of our group
     *   aiResponse - AI response to send to all ships in groupRole
     */
    this.$finishedRoute = function (callerShip, groupRole, aiResponse) {
        var entity,
        distance,
        otherShips,
        otherShipsLength,
        otherShipsCounter;

        /* Calculate the surface to saved co-ordinates distance, not centre to centre. */
        distance = callerShip.position.distanceTo(callerShip.savedCoordinates);
        distance -= callerShip.collisionRadius;
        /* Take off a small fudge factor. */
        distance -= 100;

        if (distance &gt; p_main.routes[p_main.routeIndex].range) {
            /* Don&#39;t change route if we are no where near our target. */
            return;
        }

        if (this.$logging &amp;&amp; this.$logExtra) {
            entity = p_main.routes[p_main.routeIndex].entity;
            log(this.name, &quot;$finishedRoute::Checking...\n&quot; +
                &quot;* ship#&quot; + callerShip.entityPersonality +
                &quot; (&quot; + callerShip.name + &quot;: &quot; + callerShip.displayName + &quot;)\n&quot; +
                &quot;* Entity position: &quot; + entity.position + &quot;\n&quot; +
                &quot;* Saved co-ordinates: &quot; + callerShip.savedCoordinates + &quot;\n&quot; +
                &quot;* Distance: &quot; + distance + &quot;\n&quot; +
                &quot;* Desired range: &quot; + p_main.routes[p_main.routeIndex].range + &quot;\n&quot; +
                &quot;* Current route: &quot; + p_main.routeIndex + &quot; (&quot; + p_main.routes[p_main.routeIndex].aiMessage + &quot;)&quot;);
        }

        /* Change to the next route. */
        this.$changeRoute();
        /* Find other ships in &#39;groupRole&#39;. Sort by distance from the caller ship. */
        otherShips = system.shipsWithRole(groupRole, callerShip);

        if (!otherShips.length) {
            /* Return immediately if we are on our own. */
            return;
        }

        /* Cache the length. */
        otherShipsLength = otherShips.length;

        for (otherShipsCounter = 0; otherShipsCounter &lt; otherShipsLength; otherShipsCounter += 1) {
            /* Force all other ships to regroup. The ship that called this is already regrouping. */
            otherShips[otherShipsCounter].reactToAIMessage(aiResponse);
        }
    };

    /* NAME
     *   $sendNewsToSnoopers
     *
     * FUNCTION
     *   Send news to Snoopers (if available).
     *
     * INPUTS
     *   message - news to show
     *   agency - agency to use (optional)
     */
    this.$sendNewsToSnoopers = function (message, agency) {
        var news = {},
        result,
        index;

        if (!worldScripts.snoopers) {
            /* Snoopers not installed. */
            return;
        }

        if (!agency || typeof agency !== &quot;number&quot;) {
            /* Random agency. [1, 2 or 3] */
            agency = Math.floor(Math.random() * 3.0) + 1;
        }

        news.ID = this.name;
        news.Message = message;
        news.Agency = agency;
        result = worldScripts.snoopers.insertNews(news);
        index = result + 5;

        if (result &lt; 0) {
            /* Save for later. Snoopers only allows one news item at a time. */
            this.$playerVar.newsForSnoopers.push(news);

            if (this.$logging &amp;&amp; this.$logExtra) {
                log(this.name, &quot;$sendNewsToSnoopers::Saving news for later.\n&quot; +
                    &quot;* ID: &#39;&quot; + this.name + &quot;&#39;\n&quot; +
                    &quot;* Message: &#39;&quot; + message + &quot;&#39;\n&quot; +
                    &quot;* Agency: &quot; + agency + &quot;\n&quot; +
                    &quot;* result: &quot; + result + (result &gt;= -5 ? &quot;) &quot; + p_const.snoopersErrorCodes[index] : &quot;&quot;));
            }
        } else if (result &gt; 0) {
            /* Problem. */
            log(this.name, &quot;$sendNewsToSnoopers::Problem with news.\n&quot; +
                &quot;* ID: &#39;&quot; + this.name + &quot;&#39;\n&quot; +
                &quot;* Message: &#39;&quot; + message + &quot;&#39;\n&quot; +
                &quot;* Agency: &quot; + agency + &quot;\n&quot; +
                &quot;* result: &quot; + result + (result &lt;= 30 ? &quot;) &quot; + p_const.snoopersErrorCodes[index] : &quot;&quot;));
        } else {
            /* News inserted. */
            if (this.$logging &amp;&amp; this.$logExtra) {
                log(this.name, &quot;$sendNewsToSnoopers::News inserted.\n&quot; +
                    &quot;* ID: &#39;&quot; + this.name + &quot;&#39;\n&quot; +
                    &quot;* Message: &#39;&quot; + message + &quot;&#39;\n&quot; +
                    &quot;* Agency: &quot; + agency + &quot;\n&quot; +
                    &quot;* result: &quot; + result + &quot;) &quot; + p_const.snoopersErrorCodes[index]);
            }
        }
    };

    /* NAME
     *   newsDisplayed
     *
     * FUNCTION
     *   Called by Snoopers when the news item has been displayed.
     *   Check for any more news available and send it.
     */
    this.newsDisplayed = function () {
        var news = this.$playerVar.newsForSnoopers.shift();

        if (news) {
            /* More news available. Send it to Snoopers. */
            this.$sendNewsToSnoopers(news.Message, news.Agency);
        }
    };
}.bind(this)());
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/jaguar_company_asteroid.js</td>
                    <td><pre>/*jslint bitwise: true, es5: true, newcap: true, nomen: true, regexp: true, unparam: true, todo: true, white: true,
indent: 4, maxerr: 50, maxlen: 120 */
/*jshint boss: true, curly: true, eqeqeq: true, eqnull: true, es5: true, evil: true, forin: true, laxbreak: true,
loopfunc: true, noarg: true, noempty: true, strict: true, nonew: true, undef: true */
/*global Math, Vector3D, log, system, worldScripts */

/* Jaguar Company Asteroid
 *
 * Copyright © 2012-2013 Richard Thomas Harrison (Tricky)
 *
 * This work is licensed under the Creative Commons
 * Attribution-Noncommercial-Share Alike 3.0 Unported License.
 *
 * To view a copy of this license, visit
 * http://creativecommons.org/licenses/by-nc-sa/3.0/ or send a letter
 * to Creative Commons, 171 Second Street, Suite 300, San Francisco,
 * California, 94105, USA.
 *
 * Ship related functions for the asteroids cluttering the space around the base.
 */

(function () {
    &quot;use strict&quot;;

    /* Standard public variables for OXP scripts. */
    this.name = &quot;jaguar_company_asteroid.js&quot;;
    this.author = &quot;Tricky&quot;;
    this.copyright = &quot;© 2012-2013 Richard Thomas Harrison (Tricky)&quot;;
    this.license = &quot;CC BY-NC-SA 3.0&quot;;
    this.description = &quot;Ship script for the asteroids cluttering the space around the base.&quot;;
    this.version = &quot;1.2&quot;;

    /* Ship script event handlers. */

    /* NAME
     *   shipSpawned
     *
     * FUNCTION
     *   Move the asteroid to a safe distance from the base launch corridor on birth.
     */
    this.shipSpawned = function () {
        var mainScript = worldScripts[&quot;Jaguar Company&quot;],
        asteroid = this.ship,
        base = mainScript.$jaguarCompanyBase,
        /* Increased to 12km for the first try. */
        safeDistance = 11000,
        asteroidMoved = 0,
        distance,
        totalDistanceMoved = 0,
        oldDistance,
        newDistance,
        direction,
        entities,
        ok = false;

        if (!base || !base.isValid ||
            (!asteroid.hasRole(&quot;jaguar_company_asteroid&quot;) &amp;&amp; !asteroid.hasRole(&quot;jaguar_company_boulder&quot;))) {
            /* Not an asteroid spawned by the base. */
            return;
        }

        /* NAME
         *   $validEntity
         *
         * FUNCTION
         *   Stop warnings about anonymous local functions within loops.
         *   Used by &#39;system.filteredEntities&#39;. Returns true for any valid entity.
         *
         * INPUT
         *   entity - entity to check
         */
        function $validEntity(entity) {
            return (entity.isValid);
        }

        /* Don&#39;t drift. Just leave it rotating. */
        asteroid.velocity = new Vector3D(0, 0, 0);
        /* Work out if it is near to the base during spawning. */
        distance = asteroid.position.distanceTo(base.position);

        if (distance &lt; safeDistance) {
            direction = asteroid.position.subtract(base.position).direction();

            /* Check the launch corridor. (0.86 from src/Core/Entities/DockEntity.m) */
            if (direction.dot(base.heading) &gt; 0.86) {
                /* Asteroids added too close to the base can block launches.
                 * Move them to a safe distance (+/- 500m) from the base.
                 * Safe distance is altered if there is another entity nearby.
                 */
                newDistance = oldDistance = distance;

                while (!ok) {
                    asteroidMoved += 1;
                    /* Increase the safe distance by 1km. */
                    safeDistance += 1000;
                    /* Work out a new distance (varied by +/- 500m). */
                    totalDistanceMoved += distance = (safeDistance - newDistance) + (500 - (Math.random() * 1000));
                    /* Move the asteroid. */
                    asteroid.position = asteroid.position.add(direction.multiply(distance));
                    /* New distance from the base launch corridor. */
                    newDistance = oldDistance + totalDistanceMoved;
                    /* Search for any entity intersecting this asteroid (plus 500m) at the new distance. */
                    entities = system.filteredEntities(this, $validEntity, asteroid, asteroid.collisionRadius + 500);
                    /* An empty array is what we are looking for. */
                    ok = !entities.length;
                }

                if (mainScript.$logging &amp;&amp; mainScript.$logExtra) {
                    log(this.name, &quot;shipSpawned::Moving &quot; + asteroid.displayName + &quot; to &quot; + asteroid.position + &quot;\n&quot; +
                        &quot;* Moved: &quot; + asteroidMoved + &quot; times\n&quot; +
                        &quot;* Safe distance: &quot; + safeDistance + &quot;\n&quot; +
                        &quot;* Old distance: &quot; + oldDistance + &quot;\n&quot; +
                        &quot;* Total distance moved: &quot; + totalDistanceMoved + &quot;\n&quot; +
                        &quot;* New distance: &quot; + newDistance);
                }
            }
        }

        /* No longer needed after setting up. */
        delete this.shipSpawned;
    };
}.bind(this)());
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/jaguar_company_base.js</td>
                    <td><pre>/*jslint bitwise: true, es5: true, newcap: true, nomen: true, regexp: true, unparam: true, todo: true, white: true,
indent: 4, maxerr: 50, maxlen: 120 */
/*jshint boss: true, curly: true, eqeqeq: true, eqnull: true, es5: true, evil: true, forin: true, laxbreak: true,
loopfunc: true, noarg: true, noempty: true, strict: true, nonew: true, undef: true */
/*global Array, Math, Timer, Vector3D, galaxyNumber, log, system, worldScripts */

/* Jaguar Company Base
 *
 * Copyright © 2012-2013 Richard Thomas Harrison (Tricky)
 *
 * This work is licensed under the Creative Commons
 * Attribution-Noncommercial-Share Alike 3.0 Unported License.
 *
 * To view a copy of this license, visit
 * http://creativecommons.org/licenses/by-nc-sa/3.0/ or send a letter
 * to Creative Commons, 171 Second Street, Suite 300, San Francisco,
 * California, 94105, USA.
 *
 * Ship related functions for the base AI.
 */

(function () {
    &quot;use strict&quot;;

    /* Standard public variables for OXP scripts. */
    this.name = &quot;jaguar_company_base.js&quot;;
    this.author = &quot;Tricky&quot;;
    this.copyright = &quot;© 2012-2013 Richard Thomas Harrison (Tricky)&quot;;
    this.license = &quot;CC BY-NC-SA 3.0&quot;;
    this.description = &quot;Ship script for the Jaguar Company Base.&quot;;
    this.version = &quot;1.5&quot;;

    /* Private variable. */
    var p_base = {};

    /* Ship script event handlers. */

    /* NAME
     *   shipSpawned
     *
     * FUNCTION
     *   Initialise various variables on ship birth.
     */
    this.shipSpawned = function () {
        var num,
        vector,
        cross,
        angle,
        loop;

        /* Initialise the p_base variable object.
         * Encapsulates all private global data.
         */
        p_base = {
            /* Cache the world scripts. */
            mainScript : worldScripts[&quot;Jaguar Company&quot;],
            shipsScript : worldScripts[&quot;Jaguar Company Ships&quot;],
            /* Local copies of the logging variables. */
            logging : worldScripts[&quot;Jaguar Company&quot;].$logging,
            logExtra : worldScripts[&quot;Jaguar Company&quot;].$logExtra,
            /* Maximum number of splinter ships around the base. */
            maxSplinterShips : 6
        };

        /* Tug object. */
        this.$tug = system.shipsWithPrimaryRole(&quot;jaguar_company_tug&quot;)[0];
        /* Buoy object. */
        this.$buoy = system.shipsWithRole(&quot;jaguar_company_base_buoy&quot;)[0];
        /* Miner object. */
        this.$miner = system.shipsWithPrimaryRole(&quot;jaguar_company_miner&quot;)[0];
        /* Reset the check flags. */
        this.$patrolShipsOK = false;
        this.$splinterShipsOK = false;
        this.$tugOK = false;
        this.$buoyOK = false;
        this.$minerOK = false;

        if (p_base.mainScript.$swapBase) {
            /* Swapping base roles. */

            /* Register this base as a friendly. */
            p_base.shipsScript.$addFriendly({
                ship : this.ship
            });
            /* How many splinter ships have launched. */
            p_base.numSplinterShips = system.shipsWithPrimaryRole(&quot;jaguar_company_ship_splinter&quot;).length;
            /* Have all splinter ships launched. */
            p_base.splinterShipsFullyLaunched = (p_base.numSplinterShips === p_base.maxSplinterShips);
            /* Has the miner launched. */
            p_base.minerLaunched = (this.$miner &amp;&amp; this.$miner.isValid);
            /* Base fully spawned and set-up so we can reset this. */
            p_base.mainScript.$swapBase = false;
        } else {
            /* Register this base as a friendly. */
            p_base.shipsScript.$addFriendly({
                ship : this.ship,
                /* Get a unique name for the base.
                 * Maximum length for the base&#39;s name is 17 characters.
                 * Fits into the mission screen and commodities title header.
                 */
                shipName : p_base.mainScript.$uniqueShipName(true, 17)
            });

            if (!system.isInterstellarSpace) {
                /* Point the docking bay in the general direction of the sun. */
                vector = system.sun.position.subtract(this.ship.position).direction();
            } else {
                /* Point the docking bay in the general direction of the fake witchpoint. */
                vector = p_base.mainScript.$witchpointBuoy.position.subtract(this.ship.position).direction();
            }

            /* Angle to the vector from current heading + about 1/8th turn. */
            angle = this.ship.heading.angleTo(vector) + 0.707;
            /* Cross vector for rotate. */
            cross = this.ship.heading.cross(vector).direction();
            /* Rotate the base by angle. */
            this.ship.orientation = this.ship.orientation.rotate(cross, -angle);

            /* Add some clutter within 20km around the base.
             * 20 to 27 asteroids and 10 to 17 boulders
             * - gives the miners something to do. (Also apparently any Thargoids!)
             */
            num = Math.floor(system.scrambledPseudoRandomNumber(p_base.mainScript.$salt) * 8) + 20;

            for (loop = 0; loop &lt; num; loop += 1) {
                switch (Math.floor(Math.random() * 8)) {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    system.addShips(&quot;glowasteroid&quot;, 1, this.ship.position, 20000);
                    break;
                case 5:
                case 6:
                    system.addShips(&quot;glowmossasteroid&quot;, 1, this.ship.position, 20000);
                    break;
                case 7:
                    system.addShips(&quot;jaguar_company_asteroid&quot;, 1, this.ship.position, 20000);
                    break;
                default:
                    system.addShips(&quot;jaguar_company_asteroid&quot;, 1, this.ship.position, 20000);
                    break;
                }
            }

//            system.addShips(&quot;jaguar_company_asteroid&quot;, num, this.ship.position, 20000);
            num = Math.floor(system.scrambledPseudoRandomNumber(p_base.mainScript.$salt / 2) * 8) + 10;
            system.addShips(&quot;jaguar_company_boulder&quot;, num, this.ship.position, 20000);

            /* Reset the launch status of the buoy. */
            this.$buoyLaunched = false;
            /* Miner has not launched. */
            p_base.minerLaunched = false;
            /* No splinter ships have launched. */
            p_base.numSplinterShips = 0;

            if (!system.shipsWithPrimaryRole(&quot;jaguar_company_patrol&quot;).length) {
                /* No patrol ships have launched. */
                p_base.mainScript.$numPatrolShips = 0;
                /* Reset the fully launched status of the patrol ships. */
                p_base.mainScript.$patrolShipsFullyLaunched = false;
            }
        }

        /* Start up a timer to check ship script sanity. */
        this.$scriptSanityTimerReference = new Timer(this, this.$scriptSanityTimer, 5, 5);
        /* Start up a timer to do some house keeping. */
        this.$baseTimerReference = new Timer(this, this.$baseTimer, 5, 5);

        /* No longer needed after setting up. */
        delete this.shipSpawned;
    };

    /* NAME
     *   shipDied
     *
     * FUNCTION
     *   Base was destroyed.
     *   Called after the script installed by $addFriendly in jaguar_company_ships.js
     *
     * INPUTS
     *   attacker - entity that caused the death (not used)
     *   why - cause as a string
     */
    this.shipDied = function (attacker, why) {
        var mainScript,
        base = this.ship,
        basePosition,
        witchpointBuoy,
        mainPlanet,
        mPovUp,
        ratio,
        entities,
        salt,
        ok;

        /* NAME
         *   $validEntity
         *
         * FUNCTION
         *   Stop warnings about anonymous local functions within loops.
         *   Used by &#39;system.filteredEntities&#39;. Returns true for any valid entity.
         *
         * INPUT
         *   entity - entity to check
         */
        function $validEntity(entity) {
            return (entity.isValid);
        }

        if (base.name === base.displayName) {
            /* Died whilst being created. The base will not have had it&#39;s display name set up. */
            mainScript = worldScripts[&quot;Jaguar Company&quot;];
            witchpointBuoy = mainScript.$witchpointBuoy;
            mainPlanet = system.mainPlanet;
            salt = mainScript.$salt;
            ok = false;

            /* Shift the base position if it is too close to any entity.
             * If we happen to pick a new position that would collide with something already in the system
             * then the loop will pick another position and so on.
             * In practice the loop will only happen once as space is BIG.
             */
            while (!ok) {
                /* Increase the salt. */
                salt += 1;
                /* Place the base 0.1 to 0.3 units along the witchpoint -&gt; main planet route. */
                ratio = 0.1 + (system.scrambledPseudoRandomNumber(salt) * 0.2);
                basePosition = Vector3D.interpolate(witchpointBuoy.position, mainPlanet.position, ratio);
                /* Increase the salt. */
                salt += 1;
                /* Move it 6 to 8 times scanning range upwards with respect to the main planet&#39;s surface. */
                ratio = (6 + (system.scrambledPseudoRandomNumber(salt) * 2)) * 25600;
                mPovUp = mainPlanet.orientation.vectorUp();
                base.position = basePosition.add(mPovUp.multiply(mainPlanet.radius + ratio));
                /* Search for any entity intersecting this base within scanner range. */
                entities = system.filteredEntities(this, $validEntity, base, 25600);
                /* An empty array is what we are looking for. */
                ok = !entities.length;
            }

            if (mainScript.$logging &amp;&amp; mainScript.$logExtra) {
                log(this.name, &quot;shipDied::\n&quot; +
                    &quot;Base respawning: &quot; + why + &quot; whilst being created.\n&quot; +
                    &quot;* WP-Sun dot WP-MP: &quot; +
                    (witchpointBuoy.position.subtract(system.sun.position).direction()
                        .dot(witchpointBuoy.position.subtract(mainPlanet.position).direction())) + &quot;\n&quot; +
                    &quot;* Moved: &quot; + (salt - mainScript.$salt) + &quot; times.&quot;);
            }

            /* Spawn a new base. Update the public variable in the main script. */
            mainScript.$jaguarCompanyBase = base.spawnOne(&quot;jaguar_company_base&quot;);

            return;
        }
    };

    /* NAME
     *   shipRemoved
     *
     * FUNCTION
     *   Base was removed by script.
     *
     * INPUT
     *   suppressDeathEvent - boolean
     *     true - shipDied() will not be called
     *     false - shipDied() will be called
     */
    this.shipRemoved = function (suppressDeathEvent) {
        if (suppressDeathEvent) {
            return;
        }

        /* Set this as no more ships will be launched. &quot;Obvious cat is obvious!&quot; */
        worldScripts[&quot;Jaguar Company&quot;].$patrolShipsFullyLaunched = true;
    };

    /* NAME
     *   entityDestroyed
     *
     * FUNCTION
     *   The base has just become invalid.
     */
    this.entityDestroyed = function () {
        /* Set this as no more ships will be launched. &quot;Obvious cat is obvious!&quot; */
        worldScripts[&quot;Jaguar Company&quot;].$patrolShipsFullyLaunched = true;

        /* Stop and remove the timers. */
        if (this.$baseTimerReference) {
            if (this.$baseTimerReference.isRunning) {
                this.$baseTimerReference.stop();
            }

            this.$baseTimerReference = null;
        }

        if (this.$scriptSanityTimerReference) {
            if (this.$scriptSanityTimerReference.isRunning) {
                this.$scriptSanityTimerReference.stop();
            }

            this.$scriptSanityTimerReference = null;
        }
    };

    /* NAME
     *   otherShipDocked
     *
     * FUNCTION
     *   A ship has docked.
     *
     * INPUT
     *   whom - entity of the docked ship
     */
    this.otherShipDocked = function (whom) {
        if (whom.hasRole(&quot;jaguar_company_patrol&quot;)) {
            /* Reset the script check. */
            this.$patrolShipsOK = false;
        } else if (whom.hasRole(&quot;jaguar_company_ship_splinter&quot;)) {
            /* Decrease the number of splinter ships that are launched. */
            p_base.numSplinterShips -= 1;
            /* Reset the fully launched status of the splinter ships. */
            p_base.splinterShipsFullyLaunched = false;
            /* Reset the script check. */
            this.$splinterShipsOK = false;
            /* Launch another splinter ship. */
            this.$launchJaguarCompanySplinterShip();
        } else if (whom.hasRole(&quot;jaguar_company_tug&quot;)) {
            /* Reset the script check. */
            this.$tugOK = false;
        } else if (whom.hasRole(&quot;jaguar_company_miner&quot;)) {
            /* Reset the launch status of the miner. */
            p_base.minerLaunched = false;
            /* Reset the script check. */
            this.$minerOK = false;
        }
    };

    /* NAME
     *   stationLaunchedShip
     *
     * FUNCTION
     *   A ship has launched.
     *
     * INPUT
     *   whom - entity of the launched ship
     */
    this.stationLaunchedShip = function (whom) {
        if (whom.hasRole(&quot;jaguar_company_patrol&quot;)) {
            if (p_base.mainScript.$numPatrolShips === 1) {
                /* Initialise the route list with the default route. */
                p_base.mainScript.$initRoute();
            }

            if (p_base.mainScript.$numPatrolShips !== p_base.mainScript.$maxPatrolShips) {
                /* Launch another patrol ship. */
                this.$launchJaguarCompanyPatrol();
            } else {
                /* All patrol ships are now fully launched. */
                p_base.mainScript.$patrolShipsFullyLaunched = true;

                if (!p_base.splinterShipsFullyLaunched) {
                    /* Start launching splinter ships. */
                    this.$launchJaguarCompanySplinterShip();
                }
            }
        } else if (whom.hasRole(&quot;jaguar_company_ship_splinter&quot;)) {
            if (p_base.numSplinterShips !== p_base.maxSplinterShips) {
                /* Launch another splinter ship. */
                this.$launchJaguarCompanySplinterShip();
            } else {
                /* All splinter ships are now fully launched. */
                p_base.splinterShipsFullyLaunched = true;
            }
        }
    };

    /* Other global public functions. */

    /* NAME
     *   $showProps
     *
     * FUNCTION
     *   For debugging only.
     */
    this.$showProps = function () {
        var result = &quot;&quot;,
        prop;

        for (prop in this) {
            if (this.hasOwnProperty(prop)) {
                if (typeof this[prop] !== &quot;function&quot;) {
                    result += &quot;this.&quot; + prop + &quot;: &quot; + this[prop] + &quot;\n&quot;;
                } else {
                    result += &quot;this.&quot; + prop + &quot; = function ()\n&quot;;
                }
            }
        }

        for (prop in p_base) {
            if (p_base.hasOwnProperty(prop)) {
                result += &quot;p_base.&quot; + prop + &quot;: &quot; + p_base[prop] + &quot;\n&quot;;
            }
        }

        log(this.name, &quot;$showProps::\n&quot; + result);
    };

    /* NAME
     *   $scriptSanityTimer
     *
     * FUNCTION
     *   Periodic function to check if Jaguar Company ships have spawned correctly on launch.
     *
     *   Checks the Patrol ships, tug, buoy and miner.
     *
     *   Called every 5 seconds.
     */
    this.$scriptSanityTimer = function () {
        var patrolShips,
        patrolShip,
        patrolShipsToCheck,
        splinterShips,
        splinterShip,
        splinterShipsToCheck,
        tug,
        buoy,
        miner,
        counter,
        length;

        /* Check the patrol ships. */
        if (!this.$patrolShipsOK) {
            /* Search for the patrol ships. */
            patrolShips = system.shipsWithPrimaryRole(&quot;jaguar_company_patrol&quot;);

            if (patrolShips.length &gt; 0) {
                /* Set the counter to all entities found. */
                patrolShipsToCheck = patrolShips.length;
                /* Cache the length. */
                length = patrolShips.length;

                /* Iterate through each of the patrol ships. */
                for (counter = 0; counter &lt; length; counter += 1) {
                    patrolShip = patrolShips[counter];

                    if (patrolShip.script.name !== &quot;jaguar_company_patrol.js&quot;) {
                        /* Reload the ship script. */
                        patrolShip.setScript(&quot;jaguar_company_patrol.js&quot;);
                        patrolShip.script.shipSpawned();

                        if (p_base.logging &amp;&amp; p_base.logExtra) {
                            log(this.name, &quot;Script sanity check - fixed a patrol ship.&quot;);
                        }
                    } else {
                        patrolShipsToCheck -= 1;
                    }
                }

                if (!patrolShipsToCheck &amp;&amp;
                    p_base.mainScript.$numPatrolShips === p_base.mainScript.$maxPatrolShips) {
                    /* Don&#39;t re-check. */
                    this.$patrolShipsOK = true;
                }
            }
        }

        /* Check the splinter ships. */
        if (!this.$splinterShipsOK) {
            /* Search for the splinter ships. */
            splinterShips = system.shipsWithPrimaryRole(&quot;jaguar_company_ship_splinter&quot;);

            if (splinterShips.length &gt; 0) {
                /* Set the counter to all entities found. */
                splinterShipsToCheck = splinterShips.length;
                /* Cache the length. */
                length = splinterShips.length;

                /* Iterate through each of the splinter ships. */
                for (counter = 0; counter &lt; length; counter += 1) {
                    splinterShip = splinterShips[counter];

                    if (splinterShip.script.name !== &quot;jaguar_company_ship_splinter.js&quot;) {
                        /* Reload the ship script. */
                        splinterShip.setScript(&quot;jaguar_company_ship_splinter.js&quot;);
                        splinterShip.script.shipSpawned();

                        if (p_base.logging &amp;&amp; p_base.logExtra) {
                            log(this.name, &quot;Script sanity check - fixed a splinter ship.&quot;);
                        }
                    } else {
                        splinterShipsToCheck -= 1;
                    }
                }

                if (!splinterShipsToCheck &amp;&amp; p_base.numSplinterShips === p_base.maxSplinterShips) {
                    /* Don&#39;t re-check. */
                    this.$splinterShipsOK = true;
                }
            }
        }

        tug = this.$tug;

        /* Check the tug. */
        if (!this.$tugOK &amp;&amp; tug &amp;&amp; tug.isValid) {
            if (tug.script.name !== &quot;jaguar_company_tug.js&quot;) {
                /* Reload the ship script. */
                tug.setScript(&quot;jaguar_company_tug.js&quot;);
                tug.script.shipSpawned();

                if (p_base.logging &amp;&amp; p_base.logExtra) {
                    log(this.name, &quot;Script sanity check - fixed the tug.&quot;);
                }
            } else {
                /* Don&#39;t re-check. */
                this.$tugOK = true;
            }
        }

        buoy = this.$buoy;

        /* Check the buoy. */
        if (buoy &amp;&amp; buoy.isValid &amp;&amp; !this.$buoyOK) {
            if (buoy.script.name !== &quot;jaguar_company_base_buoy.js&quot;) {
                /* Reload the ship script. */
                buoy.setScript(&quot;jaguar_company_base_buoy.js&quot;);
                buoy.script.shipSpawned();

                if (p_base.logging &amp;&amp; p_base.logExtra) {
                    log(this.name, &quot;Script sanity check - fixed the buoy.&quot;);
                }
            } else {
                /* Don&#39;t re-check. */
                this.$buoyOK = true;
            }
        }

        /* Check the miner. Only check the miner ship script if not in interstellar space. */
        if (!system.isInterstellarSpace) {
            miner = this.$miner;

            if (miner &amp;&amp; miner.isValid &amp;&amp; !this.$minerOK) {
                if (miner.script.name !== &quot;jaguar_company_miner.js&quot;) {
                    /* Reload the ship script. */
                    miner.setScript(&quot;jaguar_company_miner.js&quot;);
                    miner.script.shipSpawned();

                    if (p_base.logging &amp;&amp; p_base.logExtra) {
                        log(this.name, &quot;Script sanity check - fixed the miner.&quot;);
                    }
                } else {
                    /* Don&#39;t re-check. */
                    this.$minerOK = true;
                }
            }
        }
    };

    /* NAME
     *   $baseTimer
     *
     * FUNCTION
     *   Some OXP&#39;s dick around with the scanner colours. This will reset the base&#39;s scanner colour
     *   back to the station default of solid green if the player has helped out in combat with Jaguar Company.
     *
     *   Starts the launch sequence for the patrol ships if needed.
     *
     *   Checks the buoy and launches a tug if there isn&#39;t one. Resets the scanner colour as per the base.
     *   Swaps the buoy to &#39;no beacon&#39; or &#39;beacon&#39; dependent on the reputation mission variable.
     *
     *   Called every 5 seconds.
     */
    this.$baseTimer = function () {
        var base = this.ship,
        position,
        orientation,
        newBuoy,
        newBuoyRole;

        /* Reset the base scanner colour. */
        base.scannerDisplayColor1 = null;
        base.scannerDisplayColor2 = null;

        if (!p_base.mainScript.$numPatrolShips) {
            /* Reset the fully launched status of the patrol ships. */
            p_base.mainScript.$patrolShipsFullyLaunched = false;
            /* Start launching patrol ships. */
            this.$launchJaguarCompanyPatrol();
        }

        if ((!this.$buoy || !this.$buoy.isValid) &amp;&amp; !this.$buoyLaunched &amp;&amp;
            p_base.mainScript.$patrolShipsFullyLaunched &amp;&amp;
            p_base.splinterShipsFullyLaunched) {
            /* No buoys. Launch the tug to drop a buoy off. */
            this.$launchJaguarCompanyTug();

            return;
        }

        if (this.$buoy &amp;&amp; this.$buoy.isValid) {
            /* Reset the buoy scanner colour. */
            this.$buoy.scannerDisplayColor1 = null;
            this.$buoy.scannerDisplayColor2 = null;

            if (p_base.mainScript.$playerVar.reputation[galaxyNumber] &lt; p_base.mainScript.$reputationHelper) {
                newBuoyRole = &quot;jaguar_company_base_buoy_no_beacon&quot;;
            } else {
                newBuoyRole = &quot;jaguar_company_base_buoy_beacon&quot;;
            }

            /* Check if the buoy already has the new role. */
            if (!this.$buoy.hasRole(newBuoyRole)) {
                /* Copy some properties. */
                position = this.$buoy.position;
                orientation = this.$buoy.orientation;
                /* Create a new buoy. */
                newBuoy = this.$buoy.spawnOne(newBuoyRole);
                /* Remove the origial buoy quietly: don&#39;t trigger &#39;shipDied&#39; in the ship script. */
                this.$buoy.remove(true);
                /* Setup the new buoy with the original properties. */
                newBuoy.position = position;
                newBuoy.orientation = orientation;
                /* Update the buoy reference. */
                this.$buoy = newBuoy;
            }
        }
    };

    /* NAME
     *   $launchJaguarCompanyPatrol
     *
     * FUNCTION
     *   Launch a patrol ship.
     */
    this.$launchJaguarCompanyPatrol = function () {
        if (p_base.logging &amp;&amp; p_base.logExtra) {
            log(this.name, &quot;$launchJaguarCompanyPatrol::Launching patrol ship...&quot;);
        }

        p_base.mainScript.$numPatrolShips += 1;
        this.ship.launchShipWithRole(&quot;jaguar_company_patrol&quot;);
    };

    /* NAME
     *   $launchJaguarCompanySplinterShip
     *
     * FUNCTION
     *   Launch a splinter ship.
     */
    this.$launchJaguarCompanySplinterShip = function () {
        if (p_base.logging &amp;&amp; p_base.logExtra) {
            log(this.name, &quot;$launchJaguarCompanySplinterShip::Launching splinter ship...&quot;);
        }

        p_base.numSplinterShips += 1;
        this.ship.launchShipWithRole(&quot;jaguar_company_ship_splinter&quot;);
    };

    /* NAME
     *   $launchJaguarCompanyTug
     *
     * FUNCTION
     *   Launch the tug to push the buoy into position.
     */
    this.$launchJaguarCompanyTug = function () {
        if (!this.$buoyLaunched &amp;&amp; (!this.$buoy || !this.$buoy.isValid) &amp;&amp;
            p_base.mainScript.$patrolShipsFullyLaunched &amp;&amp;
            p_base.splinterShipsFullyLaunched) {
            /* Only one tug dragging a buoy at a time. Also no more than 1 buoy in system at a time.
             * Also don&#39;t launch until all patrol ships and splinter ships have launched.
             */
            this.$buoyLaunched = true;
            this.ship.launchShipWithRole(&quot;jaguar_company_tug&quot;);

            if (p_base.logging &amp;&amp; p_base.logExtra) {
                log(this.name, &quot;$launchJaguarCompanyTug::Launching tug...&quot;);
            }
        }
    };

    /* AI functions. */

    /* NAME
     *   $launchShip
     *
     * FUNCTION
     *   Launch other ships from the base.
     *
     * INPUT
     *   arr - array of ship types to launch
     */
    this.$launchShip = function (arr) {
        var shipType,
        counter,
        length;

        if (!Array.isArray(arr)) {
            /* Default array of ship types. */
            arr = [&quot;miner&quot;];
        }

        /* Cache the length. */
        length = arr.length;

        for (counter = 0; counter &lt; length; counter += 1) {
            shipType = arr[counter];

            if (p_base.mainScript.$patrolShipsFullyLaunched) {
                if (p_base.splinterShipsFullyLaunched) {
                    if (shipType === &quot;miner&quot;) {
                        if (!system.isInterstellarSpace &amp;&amp;
                            Math.random() &lt; 0.05 &amp;&amp;
                            !p_base.minerLaunched) {
                            /* Only 1 miner at a time. */
                            p_base.minerLaunched = true;
                            this.ship.launchShipWithRole(&quot;jaguar_company_miner&quot;);

                            if (p_base.logging &amp;&amp; p_base.logExtra) {
                                log(this.name, &quot;$launchShip::Launching miner...&quot;);
                            }
                        }
                    }
                }
            }
        }
    };
}.bind(this)());
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/jaguar_company_base_buoy.js</td>
                    <td><pre>/*jslint bitwise: true, es5: true, newcap: true, nomen: true, regexp: true, unparam: true, todo: true, white: true,
indent: 4, maxerr: 50, maxlen: 120 */
/*jshint boss: true, curly: true, eqeqeq: true, eqnull: true, es5: true, evil: true, forin: true, laxbreak: true,
loopfunc: true, noarg: true, noempty: true, strict: true, nonew: true, undef: true */
/*global Timer, Vector3D, addFrameCallback, isValidFrameCallback, log, removeFrameCallback, system, worldScripts */

/* Jaguar Company Base Buoy
 *
 * Copyright © 2012-2013 Richard Thomas Harrison (Tricky)
 *
 * This work is licensed under the Creative Commons
 * Attribution-Noncommercial-Share Alike 3.0 Unported License.
 *
 * To view a copy of this license, visit
 * http://creativecommons.org/licenses/by-nc-sa/3.0/ or send a letter
 * to Creative Commons, 171 Second Street, Suite 300, San Francisco,
 * California, 94105, USA.
 *
 * Ship related functions for the base buoy.
 */

(function () {
    &quot;use strict&quot;;

    /* Standard public variables for OXP scripts. */
    this.name = &quot;jaguar_company_base_buoy.js&quot;;
    this.author = &quot;Tricky&quot;;
    this.copyright = &quot;© 2012-2013 Richard Thomas Harrison (Tricky)&quot;;
    this.license = &quot;CC BY-NC-SA 3.0&quot;;
    this.description = &quot;Ship script for the Jaguar Company Base Buoy.&quot;;
    this.version = &quot;1.3&quot;;

    /* Private variable. */
    var p_buoy = {};

    /* Ship script event handlers. */

    /* NAME
     *   shipSpawned
     *
     * FUNCTION
     *   Initialise various variables on ship birth.
     */
    this.shipSpawned = function () {
        /* Initialise the p_buoy variable object.
         * Encapsulates all private global data.
         */
        p_buoy = {
            /* Cache the world scripts. */
            mainScript : worldScripts[&quot;Jaguar Company&quot;],
            shipsScript : worldScripts[&quot;Jaguar Company Ships&quot;],
            /* Local copies of the logging variables. */
            logging : worldScripts[&quot;Jaguar Company&quot;].$logging,
            logExtra : worldScripts[&quot;Jaguar Company&quot;].$logExtra
        };

        /* Register this buoy as a friendly. */
        p_buoy.shipsScript.$addFriendly({
            ship : this.ship
        });
        /* Wait 5 seconds then find the witchpoint. */
        p_buoy.nextTarget = &quot;WITCHPOINT&quot;;
        this.$buoyTimerReference = new Timer(this, this.$buoyTimer, 5);

        /* No longer needed after setting up. */
        delete this.shipSpawned;
    };

    /* NAME
     *   shipRemoved
     *
     * FUNCTION
     *   Base buoy was removed by script.
     *
     * INPUT
     *   suppressDeathEvent - boolean
     *     true - shipDied() will not be called
     *     false - shipDied() will be called
     */
    this.shipRemoved = function (suppressDeathEvent) {
        var base;

        if (suppressDeathEvent) {
            return;
        }

        base = worldScripts[&quot;Jaguar Company&quot;].$jaguarCompanyBase;

        if (base &amp;&amp; base.isValid) {
            /* Reset the script check. */
            base.script.$buoyOK = false;
            /* Force a launch of a new buoy. */
            base.script.$buoyLaunched = false;
        }
    };

    /* NAME
     *   entityDestroyed
     *
     * FUNCTION
     *   The base buoy has just become invalid.
     */
    this.entityDestroyed = function () {
        var base = worldScripts[&quot;Jaguar Company&quot;].$jaguarCompanyBase;

        if (base &amp;&amp; base.isValid) {
            /* Reset the script check. */
            base.script.$buoyOK = false;
            /* Force a launch of a new buoy. */
            base.script.$buoyLaunched = false;
        }

        /* Stop and remove the frame callback and timer. */
        this.$removeBuoyTimer();
        this.$removeBuoyFCB();
    };

    /* Other global public functions. */

    /* NAME
     *   $removeBuoyTimer
     *
     * FUNCTION
     *   Stop and remove the timer.
     */
    this.$removeBuoyTimer = function () {
        if (this.$buoyTimerReference) {
            if (this.$buoyTimerReference.isRunning) {
                this.$buoyTimerReference.stop();
            }

            this.$buoyTimerReference = null;
        }
    };

    /* NAME
     *   $removeBuoyFCB
     *
     * FUNCTION
     *   Stop and remove the frame callback.
     */
    this.$removeBuoyFCB = function () {
        /* Turn the flashers on. */
        this.ship.lightsActive = true;

        if (this.$buoyFCBReference) {
            if (isValidFrameCallback(this.$buoyFCBReference)) {
                removeFrameCallback(this.$buoyFCBReference);
            }

            this.$buoyFCBReference = null;
        }
    };

    /* NAME
     *   $findJaguarCompanyPatrol
     *
     * FUNCTION
     *   Point the dish at Jaguar Company Patrol.
     */
    this.$findJaguarCompanyPatrol = function () {
        var patrolShips,
        patrolShipsLength,
        patrolShipsCounter,
        midpointPosition;

        /* Search for the patrol ships. */
        patrolShips = system.shipsWithPrimaryRole(&quot;jaguar_company_patrol&quot;);

        if (!patrolShips.length) {
            /* We are on our own. Point the dish at the witchpoint. */
            return p_buoy.mainScript.$witchpointBuoy.position;
        }

        /* Cache the length. */
        patrolShipsLength = patrolShips.length;

        /* Work out the midpoint position of all the patrol ships. */
        midpointPosition = new Vector3D(0, 0, 0);

        for (patrolShipsCounter = 0; patrolShipsCounter &lt; patrolShipsLength; patrolShipsCounter += 1) {
            midpointPosition = midpointPosition.add(patrolShips[patrolShipsCounter].position);
        }

        midpointPosition.x /= patrolShipsLength;
        midpointPosition.y /= patrolShipsLength;
        midpointPosition.z /= patrolShipsLength;

        return midpointPosition;
    };

    /* NAME
     *   $buoyTimer
     *
     * FUNCTION
     *   Start off with a &#39;calibration routine&#39; by finding the witchpoint then the planet.
     *   Once &#39;calibrated&#39;, track Jaguar Company patrol ships every 2 minutes.
     */
    this.$buoyTimer = function () {
        var buoy = this.ship,
        position,
        vector;

        if (p_buoy.nextTarget === &quot;JAGUAR_COMPANY_PATROL&quot;) {
            /* Find the position of then patrol ships. */
            position = this.$findJaguarCompanyPatrol();

            if (p_buoy.logging &amp;&amp; p_buoy.logExtra) {
                log(this.name, &quot;$buoyTimer::Buoy tracking Jaguar Company Patrol ships...&quot;);
            }
        } else if (p_buoy.nextTarget === &quot;PLANET&quot;) {
            this.$removeBuoyTimer();
            /* Wait 30 seconds then track Jaguar Company Patrol every 2 minutes. */
            p_buoy.nextTarget = &quot;JAGUAR_COMPANY_PATROL&quot;;
            this.$buoyTimerReference = new Timer(this, this.$buoyTimer, 30, 120);
            /* Find the position of the main planet. */
            position = system.mainPlanet.position;

            if (p_buoy.logging &amp;&amp; p_buoy.logExtra) {
                log(this.name, &quot;$buoyTimer::Buoy tracking the main planet...&quot;);
            }
        } else {
            this.$removeBuoyTimer();

            if (system.isInterstellarSpace) {
                /* Wait 30 seconds then track Jaguar Company Patrol every 2 minutes. */
                p_buoy.nextTarget = &quot;JAGUAR_COMPANY_PATROL&quot;;
                this.$buoyTimerReference = new Timer(this, this.$buoyTimer, 30, 120);
            } else {
                /* Wait 30 seconds then find the planet. */
                p_buoy.nextTarget = &quot;PLANET&quot;;
                this.$buoyTimerReference = new Timer(this, this.$buoyTimer, 30);
            }

            /* Find the position of the witchpoint. */
            position = p_buoy.mainScript.$witchpointBuoy.position;

            if (p_buoy.logging &amp;&amp; p_buoy.logExtra) {
                log(this.name, &quot;$buoyTimer::Buoy tracking the witchpoint...&quot;);
            }
        }

        /* Vector pointing towards the target. */
        vector = position.subtract(buoy.position).direction();
        /* Angle to the target from current heading. */
        p_buoy.finalAngle = buoy.heading.angleTo(vector);

        if (p_buoy.finalAngle &lt; 0.087266462599716478846184538424431) {
            /* Already pointing in the rough direction of the target.
             * Looking for a difference of greater than 5 degrees.
             */
            return;
        }

        /* Cross vector for rotate. */
        p_buoy.cross = buoy.heading.cross(vector).direction();
        /* Starting angle. */
        p_buoy.angle = 0;
        /* Should take about 5 seconds (at 60 FPS). */
        p_buoy.deltaAngle = p_buoy.finalAngle / 300;
        /* Use a frame callback to do this smoothly. */
        this.$buoyFCBReference = addFrameCallback(this.$buoyFCB.bind(this));
    };

    /* NAME
     *   $buoyFCB
     *
     * FUNCTION
     *   Frame callback to slowly rotate the buoy towards Jaguar Company Patrol.
     *
     * INPUT
     *   delta - amount of game clock time past since the last frame
     */
    this.$buoyFCB = function (delta) {
        var buoy = this.ship;

        if (!buoy || !buoy.isValid) {
            /* Buoy can be invalid for 1 frame. */
            this.$removeBuoyTimer();
            this.$removeBuoyFCB();

            return;
        }

        if (delta === 0.0) {
            /* Do nothing if paused. */
            return;
        }

        if (p_buoy.angle &gt;= p_buoy.finalAngle) {
            /* Reached the desired orientation. */
            this.$removeBuoyFCB();

            return;
        }

        /* Rotate by delta angle. */
        buoy.orientation = buoy.orientation.rotate(p_buoy.cross, -p_buoy.deltaAngle);
        /* Update the current angle. */
        p_buoy.angle += p_buoy.deltaAngle;
    };
}.bind(this)());
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/jaguar_company_blackbox.js</td>
                    <td><pre>/*jslint bitwise: true, es5: true, newcap: true, nomen: true, regexp: true, unparam: true, todo: true, white: true,
indent: 4, maxerr: 50, maxlen: 120 */
/*jshint boss: true, curly: true, eqeqeq: true, eqnull: true, es5: true, evil: true, forin: true, laxbreak: true,
loopfunc: true, noarg: true, noempty: true, strict: true, nonew: true, undef: true */
/*global worldScripts */

/* jaguar_company_blackbox.js
 *
 * Copyright © 2012-2013 Richard Thomas Harrison (Tricky)
 *
 * This work is licensed under the Creative Commons
 * Attribution-Noncommercial-Share Alike 3.0 Unported License.
 *
 * To view a copy of this license, visit
 * http://creativecommons.org/licenses/by-nc-sa/3.0/ or send a letter
 * to Creative Commons, 171 Second Street, Suite 300, San Francisco,
 * California, 94105, USA.
 *
 * Jaguar Company Black Box equipment activation script.
 */

(function () {
    &quot;use strict&quot;;

    /* Standard public variables for OXP scripts. */
    this.name = &quot;jaguar_company_blackbox.js&quot;;
    this.author = &quot;Tricky&quot;;
    this.copyright = &quot;© 2012-2013 Richard Thomas Harrison (Tricky)&quot;;
    this.license = &quot;CC BY-NC-SA 3.0&quot;;
    this.description = &quot;Jaguar Company Black Box equipment activation script.&quot;;
    this.version = &quot;1.1&quot;;

    /* NAME
     *   activated
     *
     * FUNCTION
     *   Equipment activated with the &#39;n&#39; key.
     */
    this.activated = function () {
        worldScripts[&quot;Jaguar Company&quot;].$blackboxToggle();
    };

    /* NAME
     *   mode
     *
     * FUNCTION
     *   Equipment activated with the &#39;b&#39; key.
     */
    this.mode = function () {
        worldScripts[&quot;Jaguar Company&quot;].$blackboxMode();
    };

    /* NAME
     *   equipmentDamaged
     *
     * FUNCTION
     *   Equipment has become damaged.
     *
     * INPUT
     *   equipment - entity of the equipment
     */
    this.equipmentDamaged = function (equipment) {
        if (equipment === &quot;EQ_JAGUAR_COMPANY_BLACK_BOX&quot;) {
            worldScripts[&quot;Jaguar Company&quot;].$blackboxASCReset(true);
            worldScripts[&quot;Jaguar Company&quot;].$blackboxHoloReset(true);
            player.commsMessage(&quot;Black Box Damaged!&quot;);
            player.commsMessage(&quot;Return to the nearest Jaguar Company Base for repairs.&quot;);
        }
    };
}.bind(this)());
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/jaguar_company_eq_conditions.js</td>
                    <td><pre>/*jslint bitwise: true, es5: true, newcap: true, nomen: true, regexp: true, unparam: true, todo: true, white: true,
indent: 4, maxerr: 50, maxlen: 120 */
/*jshint boss: true, curly: true, eqeqeq: true, eqnull: true, es5: true, evil: true, forin: true, laxbreak: true,
loopfunc: true, noarg: true, noempty: true, strict: true, nonew: true, undef: true */
/*global galaxyNumber, worldScripts */

/* Jaguar Company Equipment Conditions
 *
 * Copyright © 2013 Richard Thomas Harrison (Tricky)
 *
 * This work is licensed under the Creative Commons
 * Attribution-Noncommercial-Share Alike 3.0 Unported License.
 *
 * To view a copy of this license, visit
 * http://creativecommons.org/licenses/by-nc-sa/3.0/ or send a letter
 * to Creative Commons, 171 Second Street, Suite 300, San Francisco,
 * California, 94105, USA.
 *
 * Condition script for Jaguar Company equipment.
 */

(function () {
    &quot;use strict&quot;;

    /* Standard public variables for OXP scripts. */
    this.name = &quot;jaguar_company_eq_conditions.js&quot;;
    this.author = &quot;Tricky&quot;;
    this.copyright = &quot;© 2013 Richard Thomas Harrison (Tricky)&quot;;
    this.license = &quot;CC BY-NC-SA 3.0&quot;;
    this.description = &quot;Condition script for Jaguar Company equipment.&quot;;
    this.version = &quot;1.0&quot;;

    /* Equipment Condition script event handlers. */

    /* NAME
     *   allowAwardEquipment
     *
     * FUNCTION
     *   This method is called when the game engine needs to know whether a particular ship can have equipment fitted.
     *   This may be because the player is looking at possible upgrades at a station, or from a call to
     *   ship.canAwardEquipment or ship.awardEquipment, or for other similar reasons. The equipment key and a reference
     *   to the ship entity are passed as parameters. If the method does not exist, or returns a value other than false,
     *   then the equipment may be added or offered for sale (subject to other conditions, of course).
     *
     * INPUTS
     *   eqKey - equipment key
     *   ship - ship entity
     *   context - string
     *     &quot;newShip&quot; - equipment for a ship in a station shipyard (F3 F3)
     *     &quot;npc&quot; - awarding equipment to NPC on ship setup
     *     &quot;purchase&quot; - equipment for purchase on the F3 screen
     *     &quot;scripted&quot; - equipment added by JS or legacy scripts
     *
     * RESULT
     *   result - true if equipment is allowed, false if not
     */
    this.allowAwardEquipment = function (eqKey, ship, context) {
        var mainScript = worldScripts[&quot;Jaguar Company&quot;];

        if (eqKey === &quot;EQ_JAGUAR_COMPANY_BLACK_BOX&quot; &amp;&amp; ship.isPlayer) {
            if (mainScript.$playerVar.reputation[galaxyNumber] &gt;= mainScript.$reputationBlackbox) {
                /* Only allow for players with the correct reputation level. */
                return true;
            }
        }

        if (eqKey === &quot;EQ_JAGUAR_COMPANY_HARDENED_MISSILE_SMALL&quot; &amp;&amp; ship.hasRole(&quot;jaguar_company&quot;)) {
            /* Only allow Jaguar Company ships to carry this. */
            return true;
        }

        return false;
    };
}.bind(this)());
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/jaguar_company_miner.js</td>
                    <td><pre>/*jslint bitwise: true, es5: true, newcap: true, nomen: true, regexp: true, unparam: true, todo: true, white: true,
indent: 4, maxerr: 50, maxlen: 120 */
/*jshint boss: true, curly: true, eqeqeq: true, eqnull: true, es5: true, evil: true, forin: true, laxbreak: true,
loopfunc: true, noarg: true, noempty: true, strict: true, nonew: true, undef: true */
/*global expandDescription, worldScripts */

/* Jaguar Company Miner
 *
 * Copyright © 2012-2013 Richard Thomas Harrison (Tricky)
 *
 * This work is licensed under the Creative Commons
 * Attribution-Noncommercial-Share Alike 3.0 Unported License.
 *
 * To view a copy of this license, visit
 * http://creativecommons.org/licenses/by-nc-sa/3.0/ or send a letter
 * to Creative Commons, 171 Second Street, Suite 300, San Francisco,
 * California, 94105, USA.
 *
 * Ship related functions for the miner.
 */

(function () {
    &quot;use strict&quot;;

    /* Standard public variables for OXP scripts. */
    this.name = &quot;jaguar_company_miner.js&quot;;
    this.author = &quot;Tricky&quot;;
    this.copyright = &quot;© 2012-2013 Richard Thomas Harrison (Tricky)&quot;;
    this.license = &quot;CC BY-NC-SA 3.0&quot;;
    this.description = &quot;Ship script for the Jaguar Company Miner.&quot;;
    this.version = &quot;1.2&quot;;

    /* Private variable. */
    var p_miner = {};

    /* Ship script event handlers. */

    /* NAME
     *   shipSpawned
     *
     * FUNCTION
     *   Initialise various variables on ship birth.
     */
    this.shipSpawned = function () {
        var base;

        /* Initialise the p_miner variable object.
         * Encapsulates all private global data.
         */
        p_miner = {
            /* Cache the world scripts. */
            mainScript : worldScripts[&quot;Jaguar Company&quot;],
            shipsScript : worldScripts[&quot;Jaguar Company Ships&quot;],
            /* Local copies of the logging variables. */
            logging : worldScripts[&quot;Jaguar Company&quot;].$logging,
            logExtra : worldScripts[&quot;Jaguar Company&quot;].$logExtra,
            /* Local copy of the friendList array. */
            friendList : worldScripts[&quot;Jaguar Company Ships&quot;].$friendList
        };

        /* Register this ship as a friendly. */
        p_miner.shipsScript.$addFriendly({
            ship : this.ship,
            /* Random name for the pilot. Used when talking about attacks and sending a report to Snoopers. */
            pilotName : expandDescription(&quot;%N [nom1]&quot;),
            /* Get a unique name for the patrol ship. */
            shipName : p_miner.mainScript.$uniqueShipName()
        });

        base = p_miner.mainScript.$jaguarCompanyBase;

        if (base &amp;&amp; base.isValid) {
            /* Update the base script miner references. */
            base.script.$minerOK = false;
            base.script.$miner = this.ship;
        }

        /* No longer needed after setting up. */
        delete this.shipSpawned;
    };

    /* Other global public functions. */

    /* AI functions. */

    /* NAME
     *   $setCoordsToJaguarCompanyBuoy
     *
     * FUNCTION
     *   Set the co-ordinates to the surface of the buoy or the base.
     */
    this.$setCoordsToJaguarCompanyBuoy = function () {
        var base = p_miner.mainScript.$jaguarCompanyBase;

        if (!base || !base.isValid) {
            /* If the base has gone, just go to the nearest station. */
            this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_BASE_NOT_FOUND&quot;);
        } else {
            if (base.script.$buoy &amp;&amp; base.script.$buoy.isValid) {
                /* Set the coords to the buoy. */
                this.$setCoordsToEntity(base.script.$buoy);
                this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_BUOY_FOUND&quot;);
            } else {
                /* Set the coords to the base. */
                this.$setCoordsToEntity(base);
                this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_BASE_FOUND&quot;);
            }
        }
    };
}.bind(this)());
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/jaguar_company_patrol.js</td>
                    <td><pre>/*jslint bitwise: true, es5: true, newcap: true, nomen: true, regexp: true, unparam: true, todo: true, white: true,
indent: 4, maxerr: 50, maxlen: 120 */
/*jshint boss: true, curly: true, eqeqeq: true, eqnull: true, es5: true, evil: true, forin: true, laxbreak: true,
loopfunc: true, noarg: true, noempty: true, strict: true, nonew: true, undef: true */
/*global Array, Math, Timer, Vector3D, expandDescription, parseInt, system, worldScripts */

/* Jaguar Company Patrol
 *
 * Copyright © 2012-2013 Richard Thomas Harrison (Tricky)
 *
 * This work is licensed under the Creative Commons
 * Attribution-Noncommercial-Share Alike 3.0 Unported License.
 *
 * To view a copy of this license, visit
 * http://creativecommons.org/licenses/by-nc-sa/3.0/ or send a letter
 * to Creative Commons, 171 Second Street, Suite 300, San Francisco,
 * California, 94105, USA.
 *
 * Ship related functions for the patrol and intercept AIs.
 * Missile subentity code based on tgGeneric_externalMissiles.js by Thargoid (modified)
 */

(function () {
    &quot;use strict&quot;;

    /* Standard public variables for OXP scripts. */
    this.name = &quot;jaguar_company_patrol.js&quot;;
    this.author = &quot;Tricky&quot;;
    this.copyright = &quot;© 2012-2013 Richard Thomas Harrison (Tricky)&quot;;
    this.license = &quot;CC BY-NC-SA 3.0&quot;;
    this.description = &quot;Ship script for the Jaguar Company Patrol ships.&quot;;
    this.version = &quot;1.10&quot;;

    /* Private variable. */
    var p_patrol = {};

    /* Ship script event handlers. */

    /* NAME
     *   shipSpawned
     *
     * FUNCTION
     *   Initialise various variables on ship birth.
     */
    this.shipSpawned = function () {
        var counter;

        /* Initialise the p_patrol variable object.
         * Encapsulates all private global data.
         */
        p_patrol = {
            /* Cache the world scripts. */
            mainScript : worldScripts[&quot;Jaguar Company&quot;],
            shipsScript : worldScripts[&quot;Jaguar Company Ships&quot;],
            /* Local copies of the logging variables. */
            logging : worldScripts[&quot;Jaguar Company&quot;].$logging,
            logExtra : worldScripts[&quot;Jaguar Company&quot;].$logExtra,
            /* Local copy of the friendList array. */
            friendList : worldScripts[&quot;Jaguar Company Ships&quot;].$friendList,
            /* Standard distances. */
            distance : {
                close : 10000,
                nearby : 20000,
                farAway : 40000
            },
            /* Default missile. */
            missileRole : &quot;EQ_HARDENED_MISSILE&quot;,
            /* Default number of missiles. */
            initialMissiles : this.ship.missileCapacity,
            /* Starting amount of fuel. */
            fuel : this.ship.fuel
        };

        /* Register this ship as a friendly. */
        p_patrol.shipsScript.$addFriendly({
            ship : this.ship,
            /* Random name for the pilot. Used when talking about attacks and sending a report to Snoopers. */
            pilotName : expandDescription(&quot;%N [nom1]&quot;),
            /* Get a unique name for the patrol ship. */
            shipName : p_patrol.mainScript.$uniqueShipName()
        });
        /* Timer reference. */
        this.$addFuelTimerReference = new Timer(this, this.$addFuelTimer, 1, 1);

        /* Thargoid&#39;s missile code.
         *
         * Just to ensure ship is fully loaded with selected missile type and nothing else.
         */
        if (this.ship.scriptInfo.missileRole) {
            /* missileRole should be defined in shipdata.plist */
            p_patrol.missileRole = this.ship.scriptInfo.missileRole;
        }

        if (this.ship.scriptInfo.initialMissiles) {
            p_patrol.initialMissiles = parseInt(this.ship.scriptInfo.initialMissiles, 10);
        }

        if (this.ship.missiles.length &gt; 0) {
            /* Remove all spawning missiles. */
            this.ship.awardEquipment(&quot;EQ_MISSILE_REMOVAL&quot;);
        }

        /* Restock with selected ones. */
        for (counter = 0; counter &lt; p_patrol.initialMissiles; counter += 1) {
            this.ship.awardEquipment(p_patrol.missileRole);
        }

        /* No longer needed after setting up. */
        delete this.shipSpawned;
    };

    /* NAME
     *   shipFiredMissile
     *
     * FUNCTION
     *   Thargoid&#39;s missile code. (Simplified - taken out the local function.)
     *
     * INPUT
     *   missile - missile entity
     */
    this.shipFiredMissile = function (missile) {
        var counter,
        subEntities,
        subEntity;

        subEntities = this.ship.subEntities;

        if (!subEntities || !subEntities.length) {
            /* If we&#39;ve run out of sub-ents before we run out of missiles. */
            return;
        }

        /* Set counter to number of sub-ents minus 1 (as entity array goes up from zero). */
        for (counter = subEntities.length - 1; counter &gt;= 0; counter -= 1) {
            subEntity = subEntities[counter];

            if (subEntity.hasRole(missile.primaryRole)) {
                /* If the sub-ent is the same as the missile being fired. */
                /* Move the fired missile to the sub-ent position and convert to real-world co-ordinates. */
                missile.position = this.ship.position.add(subEntity.position.rotateBy(this.ship.orientation));
                /* Point the missile in the right direction. */
                missile.orientation = subEntity.orientation.multiply(this.ship.orientation);
                /* Desired speed of missile is it&#39;s maximum speed. */
                missile.desiredSpeed = missile.maxSpeed;
                /* Remove the sub-ent version of the missile. */
                subEntity.remove();

                /* Come out of the loop, as we&#39;ve done our swap. */
                break;
            }
        }
    };

    /* NAME
     *   shipRemoved
     *
     * FUNCTION
     *   Patrol ship was removed by script.
     *
     * INPUT
     *   suppressDeathEvent - boolean
     *     true - shipDied() will not be called
     *     false - shipDied() will be called
     */
    this.shipRemoved = function (suppressDeathEvent) {
        if (suppressDeathEvent) {
            return;
        }

        /* Decrease the number of patrol ships in the system. */
        worldScripts[&quot;Jaguar Company&quot;].$numPatrolShips -= 1;
    };

    /* NAME
     *   entityDestroyed
     *
     * FUNCTION
     *   The patrol ship has just become invalid.
     */
    this.entityDestroyed = function () {
        /* Decrease the number of patrol ships in the system. */
        worldScripts[&quot;Jaguar Company&quot;].$numPatrolShips -= 1;
        /* Stop and remove the timer. */
        this.$removeAddFuelTimer();
    };

    /* Other global public functions. */

    /* NAME
     *   $removeAddFuelTimer
     *
     * FUNCTION
     *   Stop and remove the timer.
     */
    this.$removeAddFuelTimer = function () {
        if (this.$addFuelTimerReference) {
            if (this.$addFuelTimerReference.isRunning) {
                this.$addFuelTimerReference.stop();
            }

            this.$addFuelTimerReference = null;
        }
    };

    /* NAME
     *   $addFuelTimer
     *
     * FUNCTION
     *   addFuel in the AI doesn&#39;t allow small increases.
     *
     *   This function allow us to increment the amount of fuel in tinier amounts.
     *   Called every second.
     */
    this.$addFuelTimer = function () {
        var actualFuel,
        internalFuel;

        if (this.ship.speed &gt; this.ship.maxSpeed) {
            /* No fuel collection during Injection or Torus drive. */
            return;
        }

        /* Round off the actual fuel amount to the nearest lowest tenth.
         * The actual fuel amount can be something like 6.6000000000000005 even though
         * the system just uses the 1st decimal place.
         */
        actualFuel = Math.floor(this.ship.fuel * 10) / 10;
        /* The internal fuel amount is also rounded off in a similar manner for the following adjustment. */
        internalFuel = Math.floor(p_patrol.fuel * 10) / 10;

        /* Adjust the internal fuel amount if the actual fuel amount has changed.
         * Needed if the actual fuel amount has been reduced by Injection or Torus drive.
         */
        if (actualFuel !== internalFuel) {
            p_patrol.fuel = actualFuel;
        }

        if (p_patrol.fuel &lt; 7) {
            /* 0.1 LY of fuel every 100 seconds. */
            p_patrol.fuel += 0.001;

            /* Cap the fuel level. */
            if (p_patrol.fuel &gt; 7) {
                p_patrol.fuel = 7;
            }

            /* Set the actual fuel amount to the new fuel amount.
             * Adjust to the nearest lowest tenth.
             */
            this.ship.fuel = Math.floor(p_patrol.fuel * 10) / 10;
        } else {
            /* Make sure that the fuel tanks aren&#39;t over filled. */
            p_patrol.fuel = 7;
            this.ship.fuel = 7;
        }
    };

    /* NAME
     *   $queryAverageDistance
     *
     * FUNCTION
     *   Find the average distance to a set of ships from the patrol ship.
     *
     * INPUT
     *   ships - array of ships
     *
     * RESULT
     *   result - average distance to the set of ships
     */
    this.$queryAverageDistance = function (ships) {
        var averageDistance = 0,
        shipsLength,
        shipsCounter,
        ship,
        distance;

        if (!ships || !ships.length) {
            /* The array is empty. */
            return 0;
        }

        /* Cache the length. */
        shipsLength = ships.length;

        for (shipsCounter = 0; shipsCounter &lt; shipsLength; shipsCounter += 1) {
            ship = ships[shipsCounter];
            /* Centre to centre distance. */
            distance = this.ship.position.distanceTo(ship.position);
            /* Take off the collision radius of this ship. */
            distance -= this.ship.collisionRadius;
            /* Take off the collision radius of the other ship. */
            distance -= ship.collisionRadius;
            /* Add this distance to all the other distances. */
            averageDistance += distance;
        }

        /* Average all the distances and return it. */
        return (averageDistance / shipsLength);
    };

    /* AI functions. */

    /* NAME
     *   $setCoordsToMainPlanet
     *
     * FUNCTION
     *   Set the co-ordinates to the surface of the main planet.
     */
    this.$setCoordsToMainPlanet = function () {
        this.$setCoordsToEntity(system.mainPlanet);
        this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_MAINPLANET_SET&quot;);
    };

    /* NAME
     *   $setCoordsToNavyShips
     *
     * FUNCTION
     *   Set the co-ordinates to the nearest navy ship.
     */
    this.$setCoordsToNavyShips = function () {
        var navyShips = p_patrol.mainScript.$scanForNavyShips(this.ship);

        if (navyShips.length) {
            /* Update the main script closest navy ship reference. */
            p_patrol.mainScript.$closestNavyShip = navyShips[0];
            p_patrol.mainScript.$initRoute(&quot;NAVY&quot;);
            /* Set the coords to the nearest navy ship. */
            this.$setCoordsToEntity(navyShips[0]);
            this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_NAVY_FOUND&quot;);
        } else {
            /* Navy has gone. Go back to base if possible. */
            p_patrol.mainScript.$initRoute();
            p_patrol.mainScript.$changeRoute(-1);
            this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_NAVY_NOT_FOUND&quot;);
        }
    };

    /* NAME
     *   $setCoordsToWitchpoint
     *
     * FUNCTION
     *   Set the co-ordinates to the surface of the witchpoint buoy.
     */
    this.$setCoordsToWitchpoint = function () {
        this.$setCoordsToEntity(p_patrol.mainScript.$witchpointBuoy);
        this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_WITCHPOINT_SET&quot;);
    };

    /* NAME
     *   $setCoordsToJaguarCompanyBuoy
     *
     * FUNCTION
     *   Set the co-ordinates to the surface of the buoy.
     */
    this.$setCoordsToJaguarCompanyBuoy = function () {
        var base = p_patrol.mainScript.$jaguarCompanyBase;

        if (!base || !base.isValid) {
            if (system.isInterstellarSpace) {
                this.ship.fuel = 7;
                this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_EXIT_INTERSTELLAR&quot;);
            } else {
                /* If it has gone, just patrol the witchpoint to the planet lane. */
                p_patrol.mainScript.$initRoute(&quot;WP&quot;);
                this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_BASE_NOT_FOUND&quot;);
            }
        } else {
            if (base.script.$buoy &amp;&amp; base.script.$buoy.isValid) {
                /* Set the coords to the buoy. */
                this.$setCoordsToEntity(base.script.$buoy);
                this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_BUOY_FOUND&quot;);
            } else {
                /* Set the coords to the base. */
                this.$setCoordsToEntity(base);
                this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_BASE_FOUND&quot;);
            }
        }
    };

    /* NAME
     *   $addPatrolToNewSystem
     *
     * FUNCTION
     *   Jaguar Company were forced out of interstellar space as there was no base.
     *   Create a new base in the new system.
     */
    this.$addPatrolToNewSystem = function () {
        if (system.shipsWithPrimaryRole(&quot;jaguar_company_patrol&quot;).length === p_patrol.mainScript.$numPatrolShips) {
            /* Last ship out will create the base. */
            if (!p_patrol.mainScript.$setUpCompany()) {
                /* Base would not be created, just patrol the witchpoint to the planet lane. */
                p_patrol.mainScript.$initRoute(&quot;WP&quot;);
            } else {
                /* Base was created. Set the route. Should be a route to the base. */
                p_patrol.mainScript.$changeRoute(-1);
            }
        }
    };

    /* NAME
     *   $checkHyperspaceFollow
     *
     * FUNCTION
     *   Check to see if the patrol ship is the initiator of the wormhole or is following.
     */
    this.$checkHyperspaceFollow = function () {
        if (p_patrol.mainScript.$hyperspaceFollow) {
            /* This ship is following. */
            this.ship.savedCoordinates = p_patrol.mainScript.$hyperspaceFollow;
            this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_HYPERSPACE_FOLLOW&quot;);

            return;
        }

        /* This ship is opening the initial wormhole. */
        p_patrol.mainScript.$hyperspaceFollow = this.ship.position;
        this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_HYPERSPACE&quot;);
    };

    /* NAME
     *   $checkRoute
     *
     * FUNCTION
     *   Check current patrol route.
     */
    this.$checkRoute = function () {
        /* Call common code used by all of Jaguar Company. */
        p_patrol.mainScript.$checkRoute(this.ship);
    };

    /* NAME
     *   $finishedRoute
     *
     * FUNCTION
     *   Finished the current patrol route, change to the next one.
     */
    this.$finishedRoute = function () {
        /* Call common code used by all of Jaguar Company. */
        p_patrol.mainScript.$finishedRoute(this.ship, &quot;jaguar_company_patrol&quot;, &quot;JAGUAR_COMPANY_REGROUP&quot;);
    };

    /* NAME
     *   $scanForAllJaguarCompany
     *
     * FUNCTION
     *   Scan for the other ships to see if the full group is present.
     */
    this.$scanForAllJaguarCompany = function () {
        var base,
        patrolShips,
        counter,
        length,
        lurkPosition,
        variation;

        if (p_patrol.mainScript.$maxPatrolShips === 1) {
            /* We are on our own. */
            this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_NOT_FOUND&quot;);

            return;
        }

        patrolShips = system.shipsWithPrimaryRole(&quot;jaguar_company_patrol&quot;);

        if (patrolShips.length === p_patrol.mainScript.$numPatrolShips ||
            p_patrol.mainScript.$patrolShipsFullyLaunched) {
            /* Announce that we have found all of Jaguar Company to the AI. */
            this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_ALL_PRESENT&quot;);
        } else {
            base = p_patrol.mainScript.$jaguarCompanyBase;

            if (base &amp;&amp; base.isValid) {
                /* Set the starting lurk position to the base position. */
                lurkPosition = base.position;
            } else {
                /* START OF CODE THAT SHOULD NEVER BE REACHED.
                 * This is here purely for error checking sake.
                 * If the base is destroyed it will set the patrol ships fully launched variable,
                 * therefore this code block shouldn&#39;t be reached.
                 */
                if (patrolShips.length === 1) {
                    /* We are on our own. */
                    lurkPosition = patrolShips[0].position;
                } else {
                    /* Cache the length. */
                    length = patrolShips.length;

                    /* Work out the midpoint position of all ships. */
                    lurkPosition = new Vector3D(0, 0, 0);

                    for (counter = 0; counter &lt; length; counter += 1) {
                        lurkPosition = lurkPosition.add(patrolShips[counter].position);
                    }

                    lurkPosition.x /= length;
                    lurkPosition.y /= length;
                    lurkPosition.z /= length;

                    /* Higher variation if further away. */
                    variation = (this.ship.position.distanceTo(lurkPosition) &gt; 51200 ? 0.5 : 0.2);

                    /* Move the vector a random amount. */
                    lurkPosition.x += variation * (Math.random() - variation);
                    lurkPosition.y += variation * (Math.random() - variation);
                    lurkPosition.z += variation * (Math.random() - variation);
                }
                /* END OF CODE THAT SHOULD NEVER BE REACHED. */
            }

            /* Move the lurk position 20km out in a random direction and save the co-ordinates for the AI. */
            this.ship.savedCoordinates = lurkPosition.add(Vector3D.randomDirection(20000));
            this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_NOT_PRESENT&quot;);
        }
    };

    /* NAME
     *   $scanForJaguarCompany
     *
     * FUNCTION
     *   Scan for the other ships and find the midpoint position of the group.
     */
    this.$scanForJaguarCompany = function () {
        var otherShips,
        otherShipsLength,
        otherShipsCounter,
        midpointPosition,
        variation;

        otherShips = system.shipsWithPrimaryRole(&quot;jaguar_company_patrol&quot;, this.ship);

        if (!otherShips.length) {
            /* We are on our own. */
            this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_NOT_FOUND&quot;);

            return;
        }

        /* Cache the length. */
        otherShipsLength = otherShips.length;

        /* Work out the midpoint position of all ships. */
        midpointPosition = this.ship.position;

        for (otherShipsCounter = 0; otherShipsCounter &lt; otherShipsLength; otherShipsCounter += 1) {
            midpointPosition = midpointPosition.add(otherShips[otherShipsCounter].position);
        }

        midpointPosition.x /= (otherShipsLength + 1);
        midpointPosition.y /= (otherShipsLength + 1);
        midpointPosition.z /= (otherShipsLength + 1);

        /* Higher variation if further away. */
        variation = (this.ship.position.distanceTo(midpointPosition) &gt; 51200 ? 0.5 : 0.2);

        /* Move the vector a random amount. */
        midpointPosition.x += variation * (Math.random() - variation);
        midpointPosition.y += variation * (Math.random() - variation);
        midpointPosition.z += variation * (Math.random() - variation);

        /* Save the co-ordinates for the AI. */
        this.ship.savedCoordinates = midpointPosition;
        /* Announce that we have found Jaguar Company to the AI. */
        this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_FOUND&quot;);
    };

    /* NAME
     *   $checkJaguarCompanyClosestDistance
     *
     * FUNCTION
     *   Check how close we are to other ships.
     *
     * INPUT
     *   arr - closest distance allowed (as an array) (just uses the first element in the array)
     */
    this.$checkJaguarCompanyClosestDistance = function (arr) {
        var minimumDistance,
        actualDistance,
        otherShips;

        if (!Array.isArray(arr)) {
            /* Default. */
            minimumDistance = 250.0;
        } else {
            minimumDistance = arr[0];
        }

        /* More ships will increase the minimum distance. */
        actualDistance = minimumDistance * Math.ceil(p_patrol.mainScript.$numPatrolShips / 8);
        /* Modify for surface to surface. */
        actualDistance += this.ship.collisionRadius;
        /* Check for any patrol ships within the calculated sphere. */
        otherShips = system.shipsWithPrimaryRole(&quot;jaguar_company_patrol&quot;, this.ship, actualDistance);

        if (!otherShips.length) {
            this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_DISTANCE_OK&quot;);
        } else {
            /* If we are less than the minimum distance from the closest ship then we need to move away. */
            this.ship.target = otherShips[0];
            this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_TOO_CLOSE&quot;);
        }

        return;
    };

    /* NAME
     *   $checkJaguarCompanyAverageDistance
     *
     * FUNCTION
     *   Check our average distance to all other ships.
     */
    this.$checkJaguarCompanyAverageDistance = function () {
        var otherShips,
        averageDistance,
        close,
        nearby,
        farAway;

        otherShips = system.shipsWithPrimaryRole(&quot;jaguar_company_patrol&quot;, this.ship);

        if (!otherShips.length) {
            /* Return immediately if we are on our own. */
            return;
        }

        /* Find the average distance to all the other ships. */
        averageDistance = this.$queryAverageDistance(otherShips);

        close = (p_patrol.distance.close) + ((Math.random() * 2000.0) - 1000.0);
        nearby = (p_patrol.distance.nearby) + ((Math.random() * 2000.0) - 1000.0);
        farAway = (p_patrol.distance.farAway) + ((Math.random() * 2000.0) - 1000.0);

        /* I would love to create a fuzzy logic controller for this. */
        if (averageDistance &lt; close) {
            /* We have regrouped. */
            this.ship.sendAIMessage(&quot;JAGUAR_COMPANY_REGROUPED&quot;);
        } else if (averageDistance &gt;= close &amp;&amp; averageDistance &lt; nearby) {
            /* We are close. */
            this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_CLOSE&quot;);
        } else if (averageDistance &gt;= nearby &amp;&amp; averageDistance &lt; farAway) {
            /* We are nearby. */
            this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_NEARBY&quot;);
        } else {
            /* We are far away. */
            this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_FAR_AWAY&quot;);
        }
    };

    /* NAME
     *   $checkJaguarCompanyRegroup
     *
     * FUNCTION
     *   Tell everyone to regroup if the average distance to all the other ships is too great.
     *
     * INPUT
     *   arr - furthest distance allowed before a regroup message is sent out (as an array)
     *         (just uses the first element in the array)
     */
    this.$checkJaguarCompanyRegroup = function (arr) {
        var maxDistance,
        otherShips,
        otherShipsLength,
        otherShipsCounter;

        otherShips = system.shipsWithPrimaryRole(&quot;jaguar_company_patrol&quot;, this.ship);

        if (!otherShips.length) {
            /* Return immediately if we are on our own. */
            return;
        }

        if (!Array.isArray(arr)) {
            /* Default. */
            maxDistance = 15000.0;
        } else {
            maxDistance = arr[0];
        }

        /* Find the average distance to all the other ships
         * and check if this is more than the furthest distance allowed (+/- 1km).
         */
        if (this.$queryAverageDistance(otherShips) &gt;= maxDistance + ((Math.random() * 2000.0) - 1000.0)) {
            /* Tell all ships, including ourself, to regroup. */
            this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_REGROUP&quot;);

            /* Cache the length. */
            otherShipsLength = otherShips.length;

            for (otherShipsCounter = 0; otherShipsCounter &lt; otherShipsLength; otherShipsCounter += 1) {
                otherShips[otherShipsCounter].reactToAIMessage(&quot;JAGUAR_COMPANY_REGROUP&quot;);
            }
        }
    };
}.bind(this)());
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/jaguar_company_pilot.js</td>
                    <td><pre>/*jslint bitwise: true, es5: true, newcap: true, nomen: true, regexp: true, unparam: true, todo: true, white: true,
indent: 4, maxerr: 50, maxlen: 120 */
/*jshint boss: true, curly: true, eqeqeq: true, eqnull: true, es5: true, evil: true, forin: true, laxbreak: true,
loopfunc: true, noarg: true, noempty: true, strict: true, nonew: true, undef: true */
/*global Math, expandDescription, galaxyNumber, player, randomInhabitantsDescription, worldScripts */

/* jaguar_company_pilot.js
 *
 * Copyright © 2012-2013 Richard Thomas Harrison (Tricky)
 *
 * This work is licensed under the Creative Commons
 * Attribution-Noncommercial-Share Alike 3.0 Unported License.
 *
 * To view a copy of this license, visit
 * http://creativecommons.org/licenses/by-nc-sa/3.0/ or send a letter
 * to Creative Commons, 171 Second Street, Suite 300, San Francisco,
 * California, 94105, USA.
 *
 * Jaguar Company Pilot script for delivering escape-pods to a station.
 */

(function () {
    &quot;use strict&quot;;

    /* Standard public variables for OXP scripts. */
    this.name = &quot;jaguar_company_pilot.js&quot;;
    this.author = &quot;Tricky&quot;;
    this.copyright = &quot;© 2012-2013 Richard Thomas Harrison (Tricky)&quot;;
    this.license = &quot;CC BY-NC-SA 3.0&quot;;
    this.description = &quot;Jaguar Company Pilot script for delivering escape-pods to a station.&quot;;
    this.version = &quot;1.2&quot;;

    /* NAME
     *   unloadCharacter
     *
     * FUNCTION
     *   Shows a rescue message for Jaguar Company pilots you deliver back to a station.
     *   Also increases reputation.
     */
    this.unloadCharacter = function () {
        var mainScript = worldScripts[&quot;Jaguar Company&quot;],
        insurance,
        bonus = 0,
        message,
        pilotName;

        if (mainScript.$pilotsRescued.length) {
            /* Get the name of one of the rescued pilots. */
            pilotName = mainScript.$pilotsRescued.shift();
        } else {
            /* Random name. Shouldn&#39;t be executed. */
            pilotName = expandDescription(&quot;%N [nom1]&quot;);
        }

        /* Multiple of 5 Cr for insurance. */
        insurance = 500 + (Math.floor(Math.random() * 40) * 5);
        /* Create the message for the arrival report. */
        message = &quot;For rescuing &quot; + pilotName + &quot;, a &quot; + randomInhabitantsDescription(false) +
            &quot; and member of Jaguar Company, their insurance pays &quot; + insurance + &quot; ₢.&quot;;

        if (player.ship.dockedStation.hasRole(&quot;jaguar_company_base&quot;)) {
            /* Give a bonus for bringing the pilot back to one of their base&#39;s. Multiple of 5 Cr. */
            bonus = 100 + (Math.floor(Math.random() * 20) * 5);
            message += &quot; Jaguar Company has also added a bonus of &quot; + bonus +
            &quot; ₢ for bringing the pilot back to their base.&quot;;
            /* Increase the reputation of the player with Jaguar Company *after* launching.
             * You don&#39;t want to be in the base when it swaps roles.
             */
            if (mainScript.$playerVar.delayedAward !== &quot;number&quot;) {
                mainScript.$playerVar.delayedAward = 0;
            }

            mainScript.$playerVar.delayedAward += 6;
        } else {
            /* Increase the reputation of the player with Jaguar Company. */
            mainScript.$playerVar.reputation[galaxyNumber] += 4;
        }

        /* Add on the insurance and bonus to the player&#39;s credits. */
        player.credits += (insurance + bonus);
        /* Show message on arrival. */
        player.addMessageToArrivalReport(expandDescription(message));
    };
}.bind(this)());
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/jaguar_company_ship_splinter.js</td>
                    <td><pre>/*jslint bitwise: true, es5: true, newcap: true, nomen: true, regexp: true, unparam: true, todo: true, white: true,
indent: 4, maxerr: 50, maxlen: 120 */
/*jshint boss: true, curly: true, eqeqeq: true, eqnull: true, es5: true, evil: true, forin: true, laxbreak: true,
loopfunc: true, noarg: true, noempty: true, strict: true, nonew: true, undef: true */
/*global Math, Timer, Vector3D, expandDescription, galaxyNumber, log, parseInt, worldScripts */

/* Jaguar Company Splinter Ship
 *
 * Copyright © 2012-2013 Richard Thomas Harrison (Tricky)
 *
 * This work is licensed under the Creative Commons
 * Attribution-Noncommercial-Share Alike 3.0 Unported License.
 *
 * To view a copy of this license, visit
 * http://creativecommons.org/licenses/by-nc-sa/3.0/ or send a letter
 * to Creative Commons, 171 Second Street, Suite 300, San Francisco,
 * California, 94105, USA.
 *
 * Ship related functions for the splinter ship AI.
 * Missile subentity code based on tgGeneric_externalMissiles.js by Thargoid (modified)
 */

(function () {
    &quot;use strict&quot;;

    /* Standard public variables for OXP scripts. */
    this.name = &quot;jaguar_company_ship_splinter.js&quot;;
    this.author = &quot;Tricky&quot;;
    this.copyright = &quot;© 2013 Richard Thomas Harrison (Tricky)&quot;;
    this.license = &quot;CC BY-NC-SA 3.0&quot;;
    this.description = &quot;Ship script for the Jaguar Company Splinter ships.&quot;;
    this.version = &quot;1.0&quot;;

    /* Private variable. */
    var p_splinter = {};

    /* Ship script event handlers. */

    /* NAME
     *   shipSpawned
     *
     * FUNCTION
     *   Initialise various variables on ship birth.
     */
    this.shipSpawned = function () {
        var counter;

        /* Initialise the p_splinter variable object.
         * Encapsulates all private global data.
         */
        p_splinter = {
            /* Cache the world scripts. */
            mainScript : worldScripts[&quot;Jaguar Company&quot;],
            shipsScript : worldScripts[&quot;Jaguar Company Ships&quot;],
            /* Local copies of the logging variables. */
            logging : worldScripts[&quot;Jaguar Company&quot;].$logging,
            logExtra : worldScripts[&quot;Jaguar Company&quot;].$logExtra,
            /* Local copy of the friendList array. */
            friendList : worldScripts[&quot;Jaguar Company Ships&quot;].$friendList,
            /* Default missile. */
            missileRole : &quot;EQ_HARDENED_MISSILE&quot;,
            /* Default number of missiles. */
            initialMissiles : this.ship.missileCapacity,
        };

        /* Register this ship as a friendly. */
        p_splinter.shipsScript.$addFriendly({
            ship : this.ship,
            /* Random name for the pilot. Used when talking about attacks and sending a report to Snoopers. */
            pilotName : expandDescription(&quot;%N [nom1]&quot;),
            /* Get a unique name for the patrol ship. */
            shipName : p_splinter.mainScript.$uniqueShipName()
        });
        /* Move the lurk position 15km out in a random direction from the base. */
        this.$lurkPosition = p_splinter.mainScript.$jaguarCompanyBase.position.add(Vector3D.randomDirection(15000));
        /* Reset the lurk timer. */
        this.$lurkTimerReference = null;
        /* Set the just launched flag. */
        this.$justLaunched = true;
        /* Set the timer to fire every 5 seconds. */
        this.$splinterShipTimerReference = new Timer(this, this.$splinterShipTimer, 5, 5);

        /* Thargoid&#39;s missile code.
         *
         * Just to ensure ship is fully loaded with selected missile type and nothing else.
         */
        if (this.ship.scriptInfo.missileRole) {
            /* missileRole should be defined in shipdata.plist */
            p_splinter.missileRole = this.ship.scriptInfo.missileRole;
        }

        if (this.ship.scriptInfo.initialMissiles) {
            p_splinter.initialMissiles = parseInt(this.ship.scriptInfo.initialMissiles, 10);
        }

        if (this.ship.missiles.length &gt; 0) {
            /* Remove all spawning missiles. */
            this.ship.awardEquipment(&quot;EQ_MISSILE_REMOVAL&quot;);
        }

        /* Restock with selected ones. */
        for (counter = 0; counter &lt; p_splinter.initialMissiles; counter += 1) {
            this.ship.awardEquipment(p_splinter.missileRole);
        }

        /* No longer needed after setting up. */
        delete this.shipSpawned;
    };

    /* NAME
     *   shipFiredMissile
     *
     * FUNCTION
     *   Thargoid&#39;s missile code. (Simplified - taken out the local function.)
     *
     * INPUT
     *   missile - missile entity
     */
    this.shipFiredMissile = function (missile) {
        var counter,
        subEntities,
        subEntity;

        subEntities = this.ship.subEntities;

        if (!subEntities || !subEntities.length) {
            /* If we&#39;ve run out of sub-ents before we run out of missiles. */
            return;
        }

        /* Set counter to number of sub-ents minus 1 (as entity array goes up from zero). */
        for (counter = subEntities.length - 1; counter &gt;= 0; counter -= 1) {
            subEntity = subEntities[counter];

            if (subEntity.hasRole(missile.primaryRole)) {
                /* If the sub-ent is the same as the missile being fired. */
                /* Move the fired missile to the sub-ent position and convert to real-world co-ordinates. */
                missile.position = this.ship.position.add(subEntity.position.rotateBy(this.ship.orientation));
                /* Point the missile in the right direction. */
                missile.orientation = subEntity.orientation.multiply(this.ship.orientation);
                /* Desired speed of missile is it&#39;s maximum speed. */
                missile.desiredSpeed = missile.maxSpeed;
                /* Remove the sub-ent version of the missile. */
                subEntity.remove();

                /* Come out of the loop, as we&#39;ve done our swap. */
                break;
            }
        }
    };

    /* NAME
     *   entityDestroyed
     *
     * FUNCTION
     *   The splinter ship has just become invalid.
     */
    this.entityDestroyed = function () {
        /* Stop and remove the timers. */
        this.$removeLurkTimer();
        this.$removeSplinterShipTimer();
    };

    /* Other global public functions. */

    /* NAME
     *   $removeLurkTimer
     *
     * FUNCTION
     *   Stop and remove the timer.
     */
    this.$removeLurkTimer = function () {
        if (this.$lurkTimerReference) {
            if (this.$lurkTimerReference.isRunning) {
                this.$lurkTimerReference.stop();
            }

            this.$lurkTimerReference = null;
        }
    };

    /* NAME
     *   $removeSplinterShipTimer
     *
     * FUNCTION
     *   Stop and remove the timer.
     */
    this.$removeSplinterShipTimer = function () {
        if (this.$splinterShipTimerReference) {
            if (this.$splinterShipTimerReference.isRunning) {
                this.$splinterShipTimerReference.stop();
            }

            this.$splinterShipTimerReference = null;
        }
    };

    /* NAME
     *   $splinterShipTimer
     *
     * FUNCTION
     *   Hide the splinter ships on the scanner as rocks.
     */
    this.$splinterShipTimer = function () {
        if (p_splinter.mainScript.$playerVar.reputation[galaxyNumber] &lt; p_splinter.mainScript.$reputationHelper) {
            /* This will set the splinter ship&#39;s scanner colour to white if the player
             * has not helped out in combat with Jaguar Company.
             */
            this.ship.scannerDisplayColor1 = &quot;whiteColor&quot;;
            this.ship.scannerDisplayColor2 = &quot;whiteColor&quot;;
        } else {
            /* Reset the splinter ship scanner colour. */
            this.ship.scannerDisplayColor1 = null;
            this.ship.scannerDisplayColor2 = null;
        }
    };

    /* AI functions. */

    /* NAME
     *   $setCoordsToWitchpoint
     *
     * FUNCTION
     *   Set the co-ordinates to the surface of the witchpoint buoy.
     */
    this.$setCoordsToWitchpoint = function () {
        this.$setCoordsToEntity(p_splinter.mainScript.$witchpointBuoy);
        this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_WITCHPOINT_SET&quot;);
    };

    /* NAME
     *   $setCoordsToJaguarCompanyBuoy
     *
     * FUNCTION
     *   Set the co-ordinates to the surface of the buoy.
     */
    this.$setCoordsToJaguarCompanyBuoy = function () {
        var base = p_splinter.mainScript.$jaguarCompanyBase;

        if (!base || !base.isValid) {
            /* If the base has gone, EXPLODE!. */
            this.ship.switchAI(&quot;timebombAI.plist&quot;);

            if (p_splinter.logging &amp;&amp; p_splinter.logExtra) {
                log(this.name, &quot;$setCoordsToJaguarCompanyBuoy::BANG!!!&quot;);
            }
        } else {
            if (base.script.$buoy &amp;&amp; base.script.$buoy.isValid) {
                /* Set the coords to the buoy. */
                this.$setCoordsToEntity(base.script.$buoy);
                this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_BUOY_FOUND&quot;);
            } else {
                /* Set the coords to the base. */
                this.$setCoordsToEntity(base);
                this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_BASE_FOUND&quot;);
            }
        }
    };

    /* NAME
     *   $findLurkCoordinates
     *
     * FUNCTION
     *   Returns co-ordinates to lurk about.
     */
    this.$findLurkCoordinates = function () {
        var base = p_splinter.mainScript.$jaguarCompanyBase;

        if (!base || !base.isValid) {
            /* If the base has gone, EXPLODE!. */
            this.ship.switchAI(&quot;timebombAI.plist&quot;);

            if (p_splinter.logging &amp;&amp; p_splinter.logExtra) {
                log(this.name, &quot;$findLurkCoordinates::BANG!!!&quot;);
            }
        } else {
            /* Save the co-ordinates for the AI. */
            this.ship.savedCoordinates = this.$lurkPosition;
            this.ship.reactToAIMessage(&quot;LURK&quot;);
        }
    };

    /* NAME
     *   $addLurkTimer
     *
     * FUNCTION
     *   Restarts the lurk timer and returns co-ordinates to lurk about.
     */
    this.$addLurkTimer = function () {
        var base = p_splinter.mainScript.$jaguarCompanyBase;

        if (!base || !base.isValid) {
            /* If the base has gone, EXPLODE!. */
            this.ship.switchAI(&quot;timebombAI.plist&quot;);

            if (p_splinter.logging &amp;&amp; p_splinter.logExtra) {
                log(this.name, &quot;$addLurkTimer::BANG!!!&quot;);
            }
        } else {
            /* Set the timer to fire in 5-10 minutes. */
            this.$lurkTimerReference = new Timer(this, this.$addLurkTimer, ((Math.random() * 5) + 5) * 60);

            if (!this.$justLaunched &amp;&amp; Math.random() &lt;= 0.05) {
                /* 1 in 20 chance of docking. */
                this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_DOCK&quot;);
                this.$removeLurkTimer();
            } else {
                /* Reset the just launched flag. */
                this.$justLaunched = false;
                /* Move the lurk position 15km out in a random direction from the base. */
                this.$lurkPosition = base.position.add(Vector3D.randomDirection(15000));
            }
        }
    };
}.bind(this)());
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/jaguar_company_ships.js</td>
                    <td><pre>/*jslint bitwise: true, es5: true, newcap: true, nomen: true, regexp: true, unparam: true, todo: true, white: true,
indent: 4, maxerr: 50, maxlen: 120 */
/*jshint boss: true, curly: true, eqeqeq: true, eqnull: true, es5: true, evil: true, forin: true, laxbreak: true,
loopfunc: true, noarg: true, noempty: true, strict: true, nonew: true, undef: true */
/*global Array, Math, Timer, Vector3D, clock, expandDescription, galaxyNumber, log, missionVariables, player, system,
worldScripts */

/* Jaguar Company Ships
 *
 * Copyright © 2012-2013 Richard Thomas Harrison (Tricky)
 *
 * This work is licensed under the Creative Commons
 * Attribution-Noncommercial-Share Alike 3.0 Unported License.
 *
 * To view a copy of this license, visit
 * http://creativecommons.org/licenses/by-nc-sa/3.0/ or send a letter
 * to Creative Commons, 171 Second Street, Suite 300, San Francisco,
 * California, 94105, USA.
 *
 * World script to setup Jaguar Company ships.
 */

(function () {
    &quot;use strict&quot;;

    /* Standard public variables for OXP scripts. */
    this.name = &quot;Jaguar Company Ships&quot;;
    this.author = &quot;Tricky&quot;;
    this.copyright = &quot;© 2012-2013 Richard Thomas Harrison (Tricky)&quot;;
    this.license = &quot;CC BY-NC-SA 3.0&quot;;
    this.description = &quot;Script to initialise the Jaguar Company ships.&quot;;
    this.version = &quot;1.4&quot;;

    /* Private variable. */
    var p_ships = {};

    /* World script event handlers. */

    /* NAME
     *   startUp
     *
     * FUNCTION
     *   We only need to do this once.
     *   This will get redefined after a new game or loading of a new Commander.
     */
    this.startUp = function () {
        var mainScript = worldScripts[&quot;Jaguar Company&quot;],
        cabalScript = worldScripts.Cabal_Common_Functions,
        ccl,
        cclVersion;

        if (!cabalScript || cabalScript.Cabal_Common === &#39;undefined&#39;) {
            this.$killSelf(&quot; -&gt; Cabal Common Library is missing.&quot;);

            return;
        }

        ccl = new cabalScript.Cabal_Common();
        cclVersion = ccl.internalVersion;

        if (cclVersion &lt; 14) {
            this.$killSelf(&quot; -&gt; Cabal Common Library is too old for any Oolite version.&quot;);

            return;
        }

        if (cclVersion === 14 &amp;&amp; mainScript.$gte_v1_77) {
            /* Oolite v1.77 and newer. */
            this.$killSelf(&quot; -&gt; Cabal Common Library is too old for Oolite v1.77 (and newer Oolite versions).&quot;);

            return;
        }

        if (cclVersion &gt; 14 &amp;&amp; !mainScript.$gte_v1_77) {
            /* Oolite v1.76.1 and older. */
            this.$killSelf(&quot; -&gt; Cabal Common Library is too new for Oolite v1.76.1 (and older Oolite versions).&quot;);

            return;
        }

        /* Setup the private ships variable + some public variables. Delay it. */
        this.$setUpTimerReference = new Timer(this, this.$setUp, 0.5, 0.5);

        log(this.name + &quot; &quot; + this.version + &quot; loaded.&quot;);

        /* No longer needed after setting up. */
        delete this.startUp;
    };

    /* NAME
     *   shipWillExitWitchspace
     *
     * FUNCTION
     *   Reset everything just before exiting Witchspace.
     */
    this.shipWillExitWitchspace = function () {
        /* Setup the private ships variable + some public variables. */
        this.$setUp();
    };

    /* NAME
     *   shipAttackedOther
     *
     * FUNCTION
     *   Player fired a laser at someone and hit.
     *
     * INPUT
     *   victim - entity of the ship the player is attacking.
     */
    this.shipAttackedOther = function (victim) {
        var victimKey,
        victimsIndex,
        jaguarCompany,
        attackerIndex,
        observer,
        pilotName,
        reputation,
        helperLevel,
        blackboxLevel,
        locationsLevel,
        blackboxStatus;

        if (!this.$isHostile(victim)) {
            /* Ignore victims that are not hostile to Jaguar Company. */
            return;
        }

        if (Math.random() &lt; 0.9) {
            /* Jaguar Company is too busy to see you helping. */
            return;
        }

        /* Unique key (entityPersonality) for the victim. */
        victimKey = victim.entityPersonality;

        /* Search for any members of Jaguar Company within maximum scanner range of the player ship. */
        jaguarCompany = system.filteredEntities(this, function (entity) {
                /* Unique key (entityPersonality) for the entity. */
                var entityKey = entity.entityPersonality;

                /* Only interested in entities that aren&#39;t the victim. */
                return (victimKey !== entityKey &amp;&amp; this.$friendList.indexOf(entityKey) !== -1);
            }, player.ship, player.ship.scannerRange);

        if (!jaguarCompany.length) {
            /* Nobody around. */
            return;
        }

        /* Skip the next bit if the victim is a thargoid/tharglet. */
        if (!victim.isThargoid) {
            /* Find the index of the victim in the attackers index array. */
            attackerIndex = p_ships.attackersIndex.indexOf(victimKey);
            /* Get the victims index array. */
            victimsIndex = p_ships.attackers[attackerIndex].victimsIndex;
            /* Re-filter to find out if any of Jaguar Company found so far
             * are victims of the ship the player is attacking.
             */
            jaguarCompany = jaguarCompany.filter(function (entity) {
                    return (victimsIndex.indexOf(entity.entityPersonality) !== -1);
                });

            if (!jaguarCompany.length) {
                /* Nobody around. */
                return;
            }
        }

        /* Increase the reputation of the player with Jaguar Company. */
        reputation = p_ships.mainScript.$playerVar.reputation[galaxyNumber] + 1;
        p_ships.mainScript.$playerVar.reputation[galaxyNumber] = reputation;
        /* Pick a random member of Jaguar Company as the observer. */
        observer = jaguarCompany[Math.floor(Math.random() * jaguarCompany.length)];

        if (observer.isPiloted || observer.isStation) {
            if (observer.$pilotName) {
                /* Get the observer&#39;s name. */
                pilotName = observer.$pilotName;
            } else {
                /* Use displayName as the name of the observer. */
                pilotName = observer.name + &quot;: &quot; + observer.displayName;
            }

            /* Send a thank you message to the player. */
            player.commsMessage(pilotName + &quot;: &quot; + expandDescription(&quot;[jaguar_company_player_help]&quot;));
            /* Equipment status of the black box. */
            blackboxStatus = player.ship.equipmentStatus(&quot;EQ_JAGUAR_COMPANY_BLACK_BOX&quot;);

            helperLevel = p_ships.mainScript.$reputationHelper;
            blackboxLevel = p_ships.mainScript.$reputationBlackbox;
            locationsLevel = p_ships.mainScript.$reputationLocations;

            if (reputation === helperLevel) {
                player.commsMessage(pilotName + &quot;: &quot; + expandDescription(&quot;[jaguar_company_player_help_buoy]&quot;));
            } else if (reputation === blackboxLevel &amp;&amp; blackboxStatus !== &quot;EQUIPMENT_OK&quot;) {
                player.commsMessage(pilotName + &quot;: &quot; + expandDescription(&quot;[jaguar_company_player_help_blackbox]&quot;));
            } else if (reputation === locationsLevel &amp;&amp; blackboxStatus === &quot;EQUIPMENT_OK&quot;) {
                player.commsMessage(pilotName + &quot;: &quot; + expandDescription(&quot;[jaguar_company_player_help_locations]&quot;));
            }
        }
    };

    /* NAME
     *   shipKilledOther
     *
     * FUNCTION
     *   Player killed something.
     *
     * INPUT
     *   victim - entity of the ship the player killed
     */
    this.shipKilledOther = function (victim) {
        var victimsIndex,
        victimKey,
        jaguarCompany,
        attackerIndex,
        observer,
        pilotName,
        newsSource,
        reputation,
        helperLevel,
        blackboxLevel,
        locationsLevel,
        blackboxStatus;

        if (!this.$isHostile(victim)) {
            /* Ignore victims that are not hostile to Jaguar Company. */
            return;
        }

        /* Unique key (entityPersonality) for the victim. */
        victimKey = victim.entityPersonality;

        /* Search for any members of Jaguar Company within maximum scanner range of the player ship. */
        jaguarCompany = system.filteredEntities(this, function (entity) {
                /* Unique key (entityPersonality) for the entity. */
                var entityKey = entity.entityPersonality;

                /* Only interested in entities that aren&#39;t the victim. */
                return (victimKey !== entityKey &amp;&amp; this.$friendList.indexOf(entityKey) !== -1);
            }, player.ship, player.ship.scannerRange);

        if (!jaguarCompany.length) {
            /* Nobody around. */
            return;
        }

        /* Skip the next bit if the victim is a thargoid/tharglet. */
        if (!victim.isThargoid) {
            /* Find the index of the victim in the attackers index array. */
            attackerIndex = p_ships.attackersIndex.indexOf(victimKey);
            /* Get the victims index array. */
            victimsIndex = p_ships.attackers[attackerIndex].victimsIndex;
            /* Re-filter to find out if any of Jaguar Company found so far
             * are victims of the ship the player has killed.
             */
            jaguarCompany = jaguarCompany.filter(function (entity) {
                    return (victimsIndex.indexOf(entity.entityPersonality) !== -1);
                });

            if (!jaguarCompany.length) {
                /* Nobody around. */
                return;
            }
        }

        /* Increase the reputation of the player with Jaguar Company. */
        reputation = p_ships.mainScript.$playerVar.reputation[galaxyNumber] + 10;
        p_ships.mainScript.$playerVar.reputation[galaxyNumber] = reputation;
        /* Pick a random member of Jaguar Company as the observer. */
        observer = jaguarCompany[Math.floor(Math.random() * jaguarCompany.length)];

        if (observer.isPiloted || observer.isStation) {
            if (observer.$pilotName) {
                /* News source is the observer. */
                newsSource = observer.$pilotName;
                pilotName = observer.$pilotName;
            } else {
                /* Random name for the news source. */
                newsSource = expandDescription(&quot;%N [nom1]&quot;);
                /* Use displayName as the name of the observer. */
                pilotName = observer.name + &quot;: &quot; + observer.displayName;
            }

            /* Send a thank you message to the player. */
            player.commsMessage(pilotName + &quot;: &quot; + expandDescription(&quot;[jaguar_company_player_help]&quot;));
            /* Equipment status of the black box. */
            blackboxStatus = player.ship.equipmentStatus(&quot;EQ_JAGUAR_COMPANY_BLACK_BOX&quot;);

            helperLevel = p_ships.mainScript.$reputationHelper;
            blackboxLevel = p_ships.mainScript.$reputationBlackbox;
            locationsLevel = p_ships.mainScript.$reputationLocations;

            if (reputation &gt;= helperLevel &amp;&amp; reputation &lt; helperLevel + 10) {
                player.commsMessage(pilotName + &quot;: &quot; + expandDescription(&quot;[jaguar_company_player_help_buoy]&quot;));
            } else if (reputation &gt;= blackboxLevel &amp;&amp; reputation &lt; blackboxLevel + 10 &amp;&amp;
                blackboxStatus !== &quot;EQUIPMENT_OK&quot;) {
                player.commsMessage(pilotName + &quot;: &quot; + expandDescription(&quot;[jaguar_company_player_help_blackbox]&quot;));
            } else if (reputation &gt;= locationsLevel &amp;&amp; reputation &lt; locationsLevel + 10 &amp;&amp;
                blackboxStatus === &quot;EQUIPMENT_OK&quot;) {
                player.commsMessage(pilotName + &quot;: &quot; + expandDescription(&quot;[jaguar_company_player_help_locations]&quot;));
            }

            if (!p_ships.newsSent || clock.seconds - p_ships.newsSent &gt; 30 * 60) {
                /* First kill in the current system or more than 30 minutes since the last kill. */
                p_ships.newsSent = clock.seconds;
                /* Send news to Snoopers. */
                p_ships.mainScript.$sendNewsToSnoopers(expandDescription(&quot;[jaguar_company_help_news]&quot;, {
                        jaguar_company_pilot_name : newsSource
                    }));
            }
        }
    };

    /* Other global public functions. */

    /* NAME
     *   $setUp
     *
     * FUNCTION
     *   Setup the private ships variable and clear the public friend list array.
     */
    this.$setUp = function () {
        if (!worldScripts[&quot;Jaguar Company&quot;]) {
            /* Main script not loaded yet. */
            return;
        }

        /* Stop and remove the timer. */
        if (this.$setUpTimerReference) {
            if (this.$setUpTimerReference.isRunning) {
                this.$setUpTimerReference.stop();
            }

            this.$setUpTimerReference = null;
        }

        /* Initialise the p_ships variable object.
         * Encapsulates all private global data.
         */
        p_ships = {
            /* Cache the main world script. */
            mainScript : worldScripts[&quot;Jaguar Company&quot;],
            /* Local copies of the logging variables. */
            logging : worldScripts[&quot;Jaguar Company&quot;].$logging,
            logExtra : worldScripts[&quot;Jaguar Company&quot;].$logExtra,
            /* Initialise the attackers and attackers index array. */
            attackers : [],
            attackersIndex : [],
            /* 5% probability of a message being transmitted. */
            messageProbability : 0.95
        };
        /* A list of all ship entities that are considered friendly to each other. */
        this.$friendList = [];
    };

    /* NAME
     *   $killSelf
     *
     * FUNCTION
     *   Removes all functions and variables.
     *
     * INPUT
     *   desc - description for the removal (optional)
     */
    this.$killSelf = function (desc) {
        var prop;

        if (desc &amp;&amp; typeof desc === &quot;string&quot;) {
            player.consoleMessage(this.name + &quot; - Check your Latest.log&quot;, 10);
            log(this.name, this.name + &quot; - Shutting down&quot; + desc);
        }

        /* Delete public functions and variables. */
        for (prop in this) {
            if (this.hasOwnProperty(prop)) {
                if (prop !== &#39;name&#39; &amp;&amp; prop !== &#39;version&#39;) {
                    delete this[prop];
                }
            }
        }

        /* Set the deactivated flag for Cabal Common Library. */
        this.deactivated = true;

        return;
    };

    /* NAME
     *   $showProps
     *
     * FUNCTION
     *   For debugging only.
     */
    this.$showProps = function () {
        var result = &quot;&quot;,
        prop,
        attacker,
        attackerCounter,
        attackerLength,
        victim,
        victimCounter,
        victimLength,
        counter,
        length;

        for (prop in this) {
            if (this.hasOwnProperty(prop)) {
                if (typeof this[prop] !== &quot;function&quot;) {
                    result += &quot;this.&quot; + prop + &quot;: &quot; + this[prop] + &quot;\n&quot;;
                } else {
                    result += &quot;this.&quot; + prop + &quot; = function ()\n&quot;;
                }
            }
        }

        for (prop in p_ships) {
            if (p_ships.hasOwnProperty(prop)) {
                result += &quot;p_ships.&quot; + prop + &quot;: &quot; + p_ships[prop] + &quot;\n&quot;;
            }
        }

        attackerLength = p_ships.attackers.length;

        if (attackerLength) {
            result += &quot;Attackers (&quot; + attackerLength + &quot;)\n&quot;;

            for (attackerCounter = 0; attackerCounter &lt; attackerLength; attackerCounter += 1) {
                result += &quot;#&quot; + (attackerCounter + 1) + &quot;) &quot;;
                attacker = p_ships.attackers[attackerCounter];
                counter = 1;
                length = Object.keys(attacker).length;

                for (prop in attacker) {
                    if (attacker.hasOwnProperty(prop)) {
                        result += prop + &quot;: &quot; + attacker[prop] + (counter === length ? &quot;\n&quot; : &quot;, &quot;);
                        counter += 1;
                    }
                }

                victimLength = attacker.victims.length;

                if (victimLength) {
                    result += &quot;* Victims (&quot; + victimLength + &quot;)\n&quot;;

                    for (victimCounter = 0; victimCounter &lt; victimLength; victimCounter += 1) {
                        result += &quot;* #&quot; + (victimCounter + 1) + &quot;) &quot;;
                        victim = attacker.victims[victimCounter];
                        counter = 1;
                        length = Object.keys(victim).length;

                        for (prop in victim) {
                            if (victim.hasOwnProperty(prop)) {
                                result += prop + &quot;: &quot; + victim[prop] + (counter === length ? &quot;\n&quot; : &quot;, &quot;);
                                counter += 1;
                            }
                        }
                    }
                }
            }
        }

        log(this.name, &quot;$showProps::\n&quot; + result);
    };

    /* NAME
     *   $startAttackersTimer
     *
     * FUNCTION
     *   Start the attackers timer.
     */
    this.$startAttackersTimer = function () {
        if (!this.$attackersCleanupTimerReference || !this.$attackersCleanupTimerReference.isRunning) {
            /* Start the attack cleanup timer. */
            if (!this.$attackersCleanupTimerReference) {
                /* New timer. */
                this.$attackersCleanupTimerReference = new Timer(this, this.$attackersCleanupTimer, 60, 60);
            } else {
                /* Restart current timer. */
                this.$attackersCleanupTimerReference.start();
            }

            if (p_ships.logging &amp;&amp; p_ships.logExtra) {
                log(this.name, &quot;$startAttackersTimer::Started the attack cleanup timer.&quot;);
            }
        }
    };

    /* NAME
     *   $stopAttackersTimer
     *
     * FUNCTION
     *   Stop and remove the attackers timer.
     */
    this.$stopAttackersTimer = function () {
        if (this.$attackersCleanupTimerReference) {
            if (this.$attackersCleanupTimerReference.isRunning) {
                this.$attackersCleanupTimerReference.stop();
            }

            this.$attackersCleanupTimerReference = null;

            if (p_ships.logging &amp;&amp; p_ships.logExtra) {
                log(this.name, &quot;$stopAttackersTimer::Removed the attack cleanup timer.&quot;);
            }
        }
    };

    /* NAME
     *   $removeFriendly
     *
     * FUNCTION
     *   Remove the unique key (entityPersonality) of a ship from the friend list array.
     *
     * INPUT
     *   key - unique key (entityPersonality) of the ship
     */
    this.$removeFriendly = function (key) {
        var index = this.$friendList.indexOf(key);

        if (index !== -1) {
            /* Remove the ship from the friend list. */
            this.$friendList.splice(index, 1);
        }
    };

    /* NAME
     *   $addFriendly
     *
     * FUNCTION
     *   Add the unique key (entityPersonality) of a ship to the friend list array.
     *   Chains some new ship script event handler hooks to the originals.
     *
     * INPUT
     *   args - object
     *     .ship - entity of the ship
     *     .pilotName - name of the pilot (optional)
     *     .shipName - display name of the ship (optional)
     */
    this.$addFriendly = function (args) {
        var ship,
        shipKey;

        if (!args || !args.ship || !args.ship.isValid) {
            /* Need a valid ship as a property of args. */
            return;
        }

        ship = args.ship;
        /* Unique key (entityPersonality) for the ship. */
        shipKey = ship.entityPersonality;

        if (this.$friendList.indexOf(shipKey) !== -1) {
            /* Already setup. */
            return;
        }

        /* Save the ship key. */
        ship.script.$shipKey = shipKey;

        if (typeof args.pilotName === &quot;string&quot;) {
            ship.$pilotName = args.pilotName;

            /* Save the original ship script event handler hook. */
            ship.script.$ships_shipLaunchedEscapePod = ship.script.shipLaunchedEscapePod;

            /* NAME
             *   shipLaunchedEscapePod
             *
             * FUNCTION
             *   The shipLaunchedEscapePod handler is called when the pilot bails out.
             *
             *   Inlined this function because it is small.
             *
             * INPUT
             *   escapepod - contains the main pod with the pilot
             */
            ship.script.shipLaunchedEscapePod = function (escapepod) {
                /* Identify this pod as containing a member of Jaguar Company. */
                escapepod.$jaguarCompany = true;
                /* Transfer pilot name to the escape pod. */
                escapepod.$pilotName = this.ship.$pilotName;

                if (this.$ships_shipLaunchedEscapePod) {
                    /* Call the original. */
                    this.$ships_shipLaunchedEscapePod.apply(this, arguments);
                }
            };
        }

        if (typeof args.shipName === &quot;string&quot;) {
            ship.displayName = args.shipName;
        }

        /* Add the ship key to the friend list. */
        this.$friendList.push(shipKey);

        /* Save the original ship script event handler hooks. */
        ship.script.$ships_entityDestroyed = ship.script.entityDestroyed;
        ship.script.$ships_shipAttackedWithMissile = ship.script.shipAttackedWithMissile;
        ship.script.$ships_shipBeingAttacked = ship.script.shipBeingAttacked;
        ship.script.$ships_shipDied = ship.script.shipDied;
        ship.script.$ships_shipTakingDamage = ship.script.shipTakingDamage;
        ship.script.$ships_shipTargetDestroyed = ship.script.shipTargetDestroyed;

        /* New ship script event handler hooks. */

        /* NAME
         *   entityDestroyed
         *
         * FUNCTION
         *   Friendly ship has just become invalid.
         */
        ship.script.entityDestroyed = function () {
            worldScripts[&quot;Jaguar Company Ships&quot;].$removeFriendly(this.$shipKey);

            if (this.$ships_entityDestroyed) {
                /* Call the original. */
                this.$ships_entityDestroyed.apply(this, arguments);
            }
        };

        /* NAME
         *   shipAttackedWithMissile
         *
         * FUNCTION
         *   Friendly ship is being attacked with a missile.
         *
         * INPUTS
         *   missile - entity of the missile (not used)
         *   attacker - entity of the attacker
         */
        ship.script.shipAttackedWithMissile = function (missile, attacker) {
            worldScripts[&quot;Jaguar Company Ships&quot;].$shipIsBeingAttackedWithMissile(this.ship, attacker);

            if (this.$ships_shipAttackedWithMissile) {
                /* Call the original. */
                this.$ships_shipAttackedWithMissile.apply(this, arguments);
            }
        };

        /* NAME
         *   shipBeingAttacked
         *
         * FUNCTION
         *   Friendly ship is being attacked.
         *
         * INPUT
         *   attacker - entity of the attacker
         */
        ship.script.shipBeingAttacked = function (attacker) {
            worldScripts[&quot;Jaguar Company Ships&quot;].$shipIsBeingAttacked(this.ship, attacker);

            if (this.$ships_shipBeingAttacked) {
                /* Call the original. */
                this.$ships_shipBeingAttacked.apply(this, arguments);
            }
        };

        /* NAME
         *   shipDied
         *
         * FUNCTION
         *   Friendly ship has died.
         *
         * INPUTS
         *   attacker - entity of the attacker
         *   why - cause as a string
         */
        ship.script.shipDied = function (attacker, why) {
            worldScripts[&quot;Jaguar Company Ships&quot;].$shipDied(this.ship, attacker, why);

            if (this.$ships_shipDied) {
                /* Call the original. */
                this.$ships_shipDied.apply(this, arguments);
            }
        };

        /* NAME
         *   shipTakingDamage
         *
         * FUNCTION
         *   Friendly ship is taking damage.
         *
         * INPUTS
         *   amount - amount of damage
         *   attacker - entity that caused the damage
         *   type - type of damage as a string
         */
        ship.script.shipTakingDamage = function (amount, attacker, type) {
            worldScripts[&quot;Jaguar Company Ships&quot;].$shipTakingDamage(this.ship, amount, attacker, type);

            if (this.$ships_shipTakingDamage) {
                /* Call the original. */
                this.$ships_shipTakingDamage.apply(this, arguments);
            }
        };

        /* NAME
         *   shipTargetDestroyed
         *
         * FUNCTION
         *   Friendly ship killed someone.
         *
         *   Inlined this function because it doesn&#39;t call functions within the OXP.
         *
         * INPUT
         *   target - entity of the target
         */
        ship.script.shipTargetDestroyed = function (target) {
            var conhunt = missionVariables.conhunt,
            pilotName;

            if (target.primaryRole === &quot;constrictor&quot; &amp;&amp; conhunt &amp;&amp; conhunt === &quot;STAGE_1&quot;) {
                if (this.ship.$pilotName) {
                    /* Get the pilot&#39;s name. */
                    pilotName = this.ship.$pilotName;
                } else {
                    /* Use displayName as the name of the pilot. */
                    pilotName = this.ship.displayName;
                }

                /* Just in case the ship kills the constrictor, let&#39;s not break the mission for the player... */
                missionVariables.conhunt = &quot;CONSTRICTOR_DESTROYED&quot;;
                player.score += 1;
                player.credits += target.bounty;
                player.consoleMessage(pilotName + &quot; assisted in the death of &quot; + target.name);
                player.consoleMessage(
                    pilotName + &quot;: Commander &quot; + player.name +
                    &quot;, you have the kill and bounty of &quot; + target.bounty + &quot;₢.&quot;);

                if (p_ships.logging &amp;&amp; p_ships.logExtra) {
                    log(this.name, &quot;shipTargetDestroyed::&quot; +
                        pilotName + &quot; flying &#39;&quot; + this.ship.name + &quot;: &quot; + this.ship.displayName + &quot;&#39;&quot; +
                        &quot; killed - &quot; + target.name + &quot; : &quot; + target.bounty);
                }
            }

            if (this.$ships_shipTargetDestroyed) {
                /* Call the original. */
                this.$ships_shipTargetDestroyed.apply(this, arguments);
            }
        };

        /* Common ship script functions. */

        /* NAME
         *   $setCoordsToEntity
         *
         * FUNCTION
         *   Set the co-ordinates to the surface of the entity.
         *   This borrows some code from &#39;src/Core/Entities/ShipEntityAI.m - setCourseToPlanet&#39;
         *
         * INPUT
         *   entity - entity to set co-ordinates to
         */
        ship.script.$setCoordsToEntity = function (entity) {
            var position = entity.position,
            distance,
            ratio,
            variation;

            /* Calculate a vector position between the entity&#39;s surface and the ship. */
            distance = this.ship.position.distanceTo(position);
            ratio = (entity.collisionRadius + this.ship.collisionRadius + 100) / distance;
            position = Vector3D.interpolate(position, this.ship.position, ratio);

            /* Higher variation if further away. */
            variation = (distance &gt; 51200 ? 0.5 : 0.2);

            /* Move the vector a random amount. */
            position.x += variation * (Math.random() - variation);
            position.y += variation * (Math.random() - variation);
            position.z += variation * (Math.random() - variation);

            /* Save this position for &#39;setDestinationFromCoordinates&#39; in the AI. */
            this.ship.savedCoordinates = position;
        };

        /* Common AI sendScriptMessage functions. */

        /* NAME
         *   $checkTargetIsValid
         *
         * FUNCTION
         *   Checks the current target to make sure it is still valid.
         *
         *   Responds to the caller ship with a &#39;TARGET_LOST&#39; AI message.
         *
         *   Inlined this function because it is small.
         */
        ship.script.$checkTargetIsValid = function () {
            if (!this.ship.target || !this.ship.target.isValid) {
                /* Target was lost or became invalid. */
                this.ship.reactToAIMessage(&quot;TARGET_LOST&quot;);
            }
        };

        /* NAME
         *   $performJaguarCompanyAttackTarget
         *
         * FUNCTION
         *   This does something similar to a mix between the deployEscorts and groupAttackTarget AI commands.
         */
        ship.script.$performJaguarCompanyAttackTarget = function () {
            worldScripts[&quot;Jaguar Company Ships&quot;].$performAttackTarget(this.ship);
        };

        /* NAME
         *   $recallAIState
         *
         * FUNCTION
         *   Recall the saved AI state.
         *
         *   Inlined this function because it is small.
         */
        ship.script.$recallAIState = function () {
            var mainScript = worldScripts[&quot;Jaguar Company&quot;];

            if (mainScript.$logging &amp;&amp; mainScript.$logExtra) {
                log(this.name,
                    &quot;[&quot; + this.ship.AI + &quot;::&quot; + this.ship.AIState + &quot;] $recallAIState::&quot; +
                    this.ship.name + &quot;: &quot; + this.ship.displayName + &quot; - state: &quot; + this.$savedAIState);
            }

            this.ship.AIState = this.$savedAIState;
        };

        /* NAME
         *   $saveAIState
         *
         * FUNCTION
         *   Save the current AI state.
         *
         * INPUT
         *   arr - alternative AI state (as an array) (optional) (just uses the first element in the array)
         *
         *   Inlined this function because it is small.
         */
        ship.script.$saveAIState = function (arr) {
            var mainScript = worldScripts[&quot;Jaguar Company&quot;],
            state;

            if (!Array.isArray(arr)) {
                /* Default. */
                state = this.ship.AIState;
            } else {
                state = arr[0];
            }

            this.$savedAIState = state;

            if (mainScript.$logging &amp;&amp; mainScript.$logExtra) {
                log(this.name,
                    &quot;[&quot; + this.ship.AI + &quot;::&quot; + this.ship.AIState + &quot;] $saveAIState::&quot; +
                    this.ship.name + &quot;: &quot; + this.ship.displayName + &quot; - state: &quot; + this.$savedAIState);
            }
        };

        /* NAME
         *   $scanForAttackers
         *
         * FUNCTION
         *   Scan for current ships or players from the past that have attacked us.
         *   Also scan for potential attackers.
         */
        ship.script.$scanForAttackers = function () {
            worldScripts[&quot;Jaguar Company Ships&quot;].$scanForAttackers(this.ship);
        };

        if (p_ships.mainScript.$gte_v1_77) {
            /* Oolite v1.77 and newer. */

            /* NAME
             *   $scanForCascadeWeapon
             *
             * FUNCTION
             *   Do nothing. The real magic is done in the &#39;cascadeWeaponDetected&#39; ship event function.
             */
            ship.script.$scanForCascadeWeapon = function () {
                return;
            };

            /* Save the original ship event hooks. */
            ship.script.$ships_cascadeWeaponDetected = ship.script.cascadeWeaponDetected;
            ship.script.$ships_shipBeingAttackedUnsuccessfully = ship.script.shipBeingAttackedUnsuccessfully;

            /* NAME
             *   cascadeWeaponDetected
             *
             * FUNCTION
             *   The cascadeWeaponDetected handler fires when a Q-bomb (or equivalent device) detonates within
             *   scanner range of the player. The stock Q-mine (and potentially OXP equivalents) will also send
             *   this handler at the start of the countdown, giving ships more time to react.
             *
             *   Reacts with a &#39;CASCADE_WEAPON_FOUND&#39; AI message rather than &#39;CASCADE_WEAPON_DETECTED&#39;
             *   used by Oolite v1.77 and newer.
             *
             *   Inlined this function because it doesn&#39;t call functions within the OXP.
             *
             * INPUT
             *   weapon - entity of the cascade weapon
             */
            ship.script.cascadeWeaponDetected = function (weapon) {
                /* Set the target and send a CASCADE_WEAPON_FOUND message to the AI. */
                this.ship.target = weapon;
                this.ship.reactToAIMessage(&quot;CASCADE_WEAPON_FOUND&quot;);

                if (this.$ships_cascadeWeaponDetected) {
                    /* Call the original. */
                    this.$ships_cascadeWeaponDetected.apply(this, arguments);
                }
            };

            /* NAME
             *   shipBeingAttackedUnsuccessfully
             *
             * FUNCTION
             *   A ship is being unsuccessfully attacked.
             *
             * INPUT
             *   attacker - entity of the attacker
             */
            ship.script.shipBeingAttackedUnsuccessfully = function (attacker) {
                worldScripts[&quot;Jaguar Company Ships&quot;].$shipIsBeingAttackedUnsuccessfully(this.ship, attacker);

                if (this.$ships_shipBeingAttackedUnsuccessfully) {
                    /* Call the original. */
                    this.$ships_shipBeingAttackedUnsuccessfully.apply(this, arguments);
                }
            };
        } else {
            /* Oolite v1.76.1 and older. */

            /* NAME
             *   $scanForCascadeWeapon
             *
             * FUNCTION
             *   Scan for cascade weapons. Won&#39;t be needed when v1.78 comes out.
             *   Reacts with a &#39;CASCADE_WEAPON_FOUND&#39; AI message rather than &#39;CASCADE_WEAPON_DETECTED&#39;
             *   used by Oolite v1.77 and newer.
             *
             *   Inlined this function because it doesn&#39;t call functions within the OXP.
             */
            ship.script.$scanForCascadeWeapon = function () {
                /* This is modified from some code in Random Hits spacebar ship script. */
                var cascadeWeaponRoles = [
                    &quot;EQ_QC_MINE&quot;,
                    &quot;EQ_CASCADE_MISSILE&quot;,
                    &quot;EQ_LAW_MISSILE&quot;,
                    &quot;EQ_OVERRIDE_MISSILE&quot;,
                    &quot;energy-bomb&quot;,
                    &quot;RANDOM_HITS_MINE&quot;
                ],
                cascadeWeapons;

                /* Search for any cascade weapons within maximum scanner range of the caller ship. */
                cascadeWeapons = system.filteredEntities(this, function (entity) {
                        return (cascadeWeaponRoles.indexOf(entity.primaryRole) !== -1);
                    }, this.ship, this.ship.scannerRange);

                if (cascadeWeapons.length) {
                    /* Found at least one. First one in the cascadeWeapons array is the closest.
                     * Set the target and send a CASCADE_WEAPON_FOUND message to the AI.
                     */
                    this.ship.target = cascadeWeapons[0];
                    this.ship.reactToAIMessage(&quot;CASCADE_WEAPON_FOUND&quot;);
                }
            };
        }
    };

    /* NAME
     *   $addAttacker
     *
     * FUNCTION
     *   Add an attacker and victim to the attackers array.
     *
     * INPUTS
     *   attacker - entity of the attacker
     *   victim - entity of the victim (optional)
     *
     * RESULT
     *   result - object containing attacker and victim indexes, -1 if not added.
     */
    this.$addAttacker = function (attacker, victim) {
        var attackerKey,
        attackerIndex,
        victimKey,
        victimIndex,
        logMsg = &quot;&quot;;

        if (!attacker || !attacker.isValid) {
            /* The attacker is no longer valid. */
            return -1;
        }

        if (this.$friendList.indexOf(attacker.entityPersonality) !== -1) {
            /* Don&#39;t add members of Jaguar Company. */
            return -1;
        }

        if (attacker.isPolice) {
            /* Don&#39;t add police ships. */
            return -1;
        }

        /* Start the attackers timer if not started already. */
        this.$startAttackersTimer();
        /* Get the attacker&#39;s key. */
        attackerKey = attacker.entityPersonality;
        /* Get the attacker&#39;s index. */
        attackerIndex = p_ships.attackersIndex.indexOf(attackerKey);

        if (attackerIndex === -1) {
            if (p_ships.logging &amp;&amp; p_ships.logExtra) {
                logMsg += &quot;\nAdding attacker#&quot; + attackerKey + &quot; (&quot; + attacker.displayName + &quot;)&quot;;
            }

            /* Create an entry for the attacker if it doesn&#39;t exist.
             * push() returns the new length. The attacker index will be 1 less than this.
             */
            attackerIndex = p_ships.attackers.push({
                    hostile : false,
                    ship : attacker,
                    shipKey : attackerKey,
                    victims : [],
                    victimsIndex : []
                }) - 1;
            /* Create the index entry for the attacker. */
            p_ships.attackersIndex[attackerIndex] = attackerKey;
        }

        if (!victim || !victim.isValid) {
            victimIndex = -1;
        } else {
            /* Get the victim&#39;s key. */
            victimKey = victim.entityPersonality;
            /* Get the victim&#39;s index. */
            victimIndex = p_ships.attackers[attackerIndex].victimsIndex.indexOf(victimKey);

            if (victimIndex === -1) {
                if (p_ships.logging &amp;&amp; p_ships.logExtra) {
                    logMsg += &quot;\nAdding victim#&quot; + victimKey + &quot; (&quot; + victim.name + &quot;: &quot; + victim.displayName + &quot;)&quot; +
                    &quot; attacked by attacker#&quot; + attackerKey + &quot; (&quot; + attacker.displayName + &quot;)&quot;;
                }

                /* Create an entry for the victim if it doesn&#39;t exist.
                 * push() returns the new length. The victim index will be 1 less than this.
                 */
                victimIndex = p_ships.attackers[attackerIndex].victims.push({
                        attackCounter : 0,
                        attackTime : clock.seconds,
                        missCounter : 0,
                        missTime : clock.seconds,
                        ship : victim,
                        shipKey : victimKey
                    }) - 1;
                /* Create the index entry for the victim. */
                p_ships.attackers[attackerIndex].victimsIndex[victimIndex] = victimKey;
            }
        }

        if (p_ships.logging &amp;&amp; p_ships.logExtra &amp;&amp; logMsg.length) {
            log(this.name, &quot;$addAttacker::&quot; + logMsg);
        }

        return {
            attackerIndex : attackerIndex,
            victimIndex : victimIndex
        };
    };

    /* NAME
     *   $removeAttacker
     *
     * FUNCTION
     *   Remove an attacker from the attackers array.
     *
     * INPUT
     *   attackerKey - unique key (entityPersonality) of the attacker
     */
    this.$removeAttacker = function (attackerKey) {
        var attackersIndex,
        attackerIndex;

        attackersIndex = p_ships.attackersIndex;
        /* Get the attacker&#39;s index. */
        attackerIndex = attackersIndex.indexOf(attackerKey);

        if (!attackersIndex.length || attackerIndex === -1) {
            /* No such attacker. */
            return;
        }

        /* Remove the attacker from the attackers array. */
        p_ships.attackers.splice(attackerIndex, 1);
        /* Remove the attacker from the attackers index array. */
        p_ships.attackersIndex.splice(attackerIndex, 1);
    };

    /* NAME
     *   $removeVictimFromAttacker
     *
     * FUNCTION
     *   Remove a victim from the victims array of the attacker.
     *
     * INPUTS
     *   victimKey - unique key (entityPersonality) of the victim
     *   attackerKey - unique key (entityPersonality) of the attacker
     */
    this.$removeVictimFromAttacker = function (victimKey, attackerKey) {
        var attackersIndex,
        attackerIndex,
        victimsIndex,
        victimIndex;

        attackersIndex = p_ships.attackersIndex;
        /* Get the attacker&#39;s index. */
        attackerIndex = attackersIndex.indexOf(attackerKey);

        if (!attackersIndex.length || attackerIndex === -1) {
            /* No such attacker. */
            return;
        }

        victimsIndex = p_ships.attackers[attackerIndex].victimsIndex;
        /* Get the victim&#39;s index. */
        victimIndex = victimsIndex.indexOf(victimKey);

        if (!victimsIndex.length || victimIndex === -1) {
            /* No such victim. */
            return;
        }

        /* Remove the victim from the victims array. */
        p_ships.attackers[attackerIndex].victims.splice(victimIndex, 1);
        /* Remove the victim from the victims index array. */
        p_ships.attackers[attackerIndex].victimsIndex.splice(victimIndex, 1);
    };

    /* NAME
     *   $attackersCleanupTimer
     *
     * FUNCTION
     *   Periodic timer to clean up the attackers array.
     *
     *   Called every 1 minute.
     */
    this.$attackersCleanupTimer = function () {
        var attackers,
        attackerIndex,
        attackerKey,
        attackersCounter,
        attackersLength,
        attacker,
        victimKey,
        victimsCounter,
        victimsLength,
        victim,
        mainScript,
        logMsg;

        if (!p_ships.attackers.length) {
            /* No attackers, stop and remove this timer. */
            this.$stopAttackersTimer();

            /* Reset the attackers and index array. Pointless, but done for potential error avoidance. */
            p_ships.attackersIndex = [];
            p_ships.attackers = [];

            return;
        }

        if (p_ships.logging &amp;&amp; p_ships.logExtra) {
            logMsg = &quot;$attackersCleanupTimer::Checking attackers...&quot;;
        }

        /* Cache the length. */
        attackersLength = p_ships.attackers.length;
        /* Empty array to copy the attackers into. */
        attackers = [];

        /* Create a copy of the attackers array. The index should follow the original */
        for (attackersCounter = 0; attackersCounter &lt; attackersLength; attackersCounter += 1) {
            /* Iterate over each attacker. */
            attacker = p_ships.attackers[attackersCounter];
            /* No need to copy the victimsIndex property as we don&#39;t use it in the cleanup. */
            attackers.push({
                hostile : attacker.hostile,
                ship : attacker.ship,
                shipKey : attacker.shipKey,
                /* Empty array to copy the victims into. */
                victims : []
            });

            /* Cache the length. */
            victimsLength = attacker.victims.length;

            /* Create a copy of the victims array for the attacker. The index should follow the original. */
            for (victimsCounter = 0; victimsCounter &lt; victimsLength; victimsCounter += 1) {
                /* Iterate over each victim. */
                victim = attacker.victims[victimsCounter];
                /* No need to copy the attackCounter and missCounter properties as we don&#39;t use them in the cleanup. */
                attackers[attackersCounter].victims.push({
                    attackTime : victim.attackTime,
                    missTime : victim.missTime,
                    ship : victim.ship,
                    shipKey : victim.shipKey
                });
            }
        }

        mainScript = p_ships.mainScript;

        /* attackersLength already set-up. */
        for (attackersCounter = 0; attackersCounter &lt; attackersLength; attackersCounter += 1) {
            /* Iterate over each attacker. */
            attacker = attackers[attackersCounter];
            attackerKey = attacker.shipKey;

            if (p_ships.logging &amp;&amp; p_ships.logExtra) {
                logMsg += &quot;\n* attacker#&quot; + attackerKey;

                if (attacker.ship.displayName !== undefined) {
                    logMsg += &quot; (&quot; + attacker.ship.displayName + &quot;)&quot;;
                }

                logMsg += &quot;, &quot; + attacker.victims.length + &quot; victims&quot;;
            }

            if (!attacker.ship.isValid) {
                if (p_ships.logging &amp;&amp; p_ships.logExtra) {
                    logMsg += &quot;, removing (dead/not valid)&quot;;
                }

                /* Remove the invalid attacker from the real attackers array. */
                this.$removeAttacker(attackerKey);
            } else if (attacker.ship.hasRole(&quot;tharglet&quot;) &amp;&amp; attacker.ship.isCargo) {
                if (p_ships.logging &amp;&amp; p_ships.logExtra) {
                    logMsg += &quot;, removing (inactive tharglet)&quot;;
                }

                /* Remove the inactive tharglet from the real attackers array. */
                this.$removeAttacker(attackerKey);
            } else if (attacker.ship.isDerelict) {
                if (p_ships.logging &amp;&amp; p_ships.logExtra) {
                    logMsg += &quot;, removing (derelict)&quot;;
                }

                /* Remove the derelict attacker from the real attackers array. */
                this.$removeAttacker(attackerKey);
            } else if (attacker.ship.isPlayer &amp;&amp;
                mainScript.$playerVar.reputation[galaxyNumber] &gt;= mainScript.$reputationHelper) {
                if (p_ships.logging &amp;&amp; p_ships.logExtra) {
                    logMsg += &quot;, removing (player turned from the dark side)&quot;;
                }

                /* Remove the player from the real attackers array. */
                this.$removeAttacker(attackerKey);
            } else if (attacker.victims.length) {
                if (p_ships.logging &amp;&amp; p_ships.logExtra) {
                    logMsg += &quot;, checking victims...&quot;;
                }

                /* Cache the length. */
                victimsLength = attacker.victims.length;

                for (victimsCounter = 0; victimsCounter &lt; victimsLength; victimsCounter += 1) {
                    /* Iterate over each victim. */
                    victim = attacker.victims[victimsCounter];
                    victimKey = victim.shipKey;

                    if (p_ships.logging &amp;&amp; p_ships.logExtra) {
                        logMsg += &quot;\n** victim#&quot; + victimKey;

                        if (victim.ship.displayName !== undefined) {
                            logMsg += &quot; (&quot; + victim.ship.name + &quot;: &quot; + victim.ship.displayName + &quot;)&quot;;
                        }
                    }

                    if (!victim.ship.isValid) {
                        if (p_ships.logging &amp;&amp; p_ships.logExtra) {
                            logMsg += &quot;, removing (dead/not valid)&quot;;
                        }

                        /* Remove the invalid victim from the real victims array. */
                        this.$removeVictimFromAttacker(victimKey, attackerKey);
                    } else if (victim.ship.isDerelict) {
                        if (p_ships.logging &amp;&amp; p_ships.logExtra) {
                            logMsg += &quot;, removing (derelict)&quot;;
                        }

                        /* Remove the derelict victim from the real victims array. */
                        this.$removeVictimFromAttacker(victimKey, attackerKey);
                    } else if (!attacker.hostile &amp;&amp;
                        (clock.seconds - victim.attackTime &gt; 5 || clock.seconds - victim.missTime &gt; 5)) {
                        if (p_ships.logging &amp;&amp; p_ships.logExtra) {
                            logMsg += &quot;, removing (no longer attacked)&quot;;
                        }

                        /* More than 5 seconds have passed since the first attack.
                         * Remove the old victim from the real victims array.
                         */
                        this.$removeVictimFromAttacker(victimKey, attackerKey);
                    }
                }

                if (p_ships.logging &amp;&amp; p_ships.logExtra) {
                    logMsg += &quot;\n&quot; + &quot;$attackersCleanupTimer::Finished checking victims.&quot;;
                }
            }

            if (!attacker.hostile) {
                /* Find the real index of the attacker. May have changed. */
                attackerIndex = p_ships.attackersIndex.indexOf(attackerKey);

                if (attackerIndex !== -1 &amp;&amp; !p_ships.attackers[attackerIndex].victims.length) {
                    if (p_ships.logging &amp;&amp; p_ships.logExtra) {
                        logMsg += &quot;\n** attacker#&quot; + attackerKey + &quot; (&quot; + attacker.ship.displayName + &quot;)&quot; +
                        &quot;, removing (no victims)&quot;;
                    }

                    /* Has no victims so no longer an attacker.
                     * Remove the attacker from the real attackers array.
                     */
                    this.$removeAttacker(attackerKey);
                }
            }
        }

        if (p_ships.logging &amp;&amp; p_ships.logExtra) {
            logMsg += &quot;\n&quot; + &quot;$attackersCleanupTimer::Finished checking attackers.&quot;;
            log(this.name, logMsg);
        }

        if (!p_ships.attackers.length) {
            /* No attackers, stop and remove this timer. */
            this.$stopAttackersTimer();

            /* Reset the attackers and index array. Pointless, but done for potential error avoidance. */
            p_ships.attackersIndex = [];
            p_ships.attackers = [];
        }
    };

    /* NAME
     *   $makeHostile
     *
     * FUNCTION
     *   Makes the attacking ship hostile to the victim&#39;s group.
     *
     * INPUTS
     *   attacker - entity of the attacker
     *   victim - entity of the victim
     */
    this.$makeHostile = function (attacker, victim) {
        var index;

        if (!attacker || !attacker.isValid || !victim || !victim.isValid) {
            /* The attacker and/or victim is no longer valid. */
            return;
        }

        if (this.$friendList.indexOf(attacker.entityPersonality) !== -1) {
            /* The attacker is a member of Jaguar Company. */
            return;
        }

        if (this.$isHostile(attacker)) {
            /* Already hostile. */
            return;
        }

        if (p_ships.logging &amp;&amp; p_ships.logExtra) {
            log(this.name, &quot;$makeHostile::Make hostile:&quot; +
                &quot; attacker#&quot; + attacker.entityPersonality + &quot; (&quot; + attacker.displayName + &quot;)&quot; +
                &quot;, bounty: &quot; + attacker.bounty +
                &quot;, victim#&quot; + victim.entityPersonality + &quot; (&quot; + victim.name + &quot;: &quot; + victim.displayName + &quot;)&quot;);
        }

        /* Add the attacker (if needed) and get the attacker and victim index. */
        index = this.$addAttacker(attacker, victim);

        if (index !== -1) {
            /* Set the hostile property. */
            p_ships.attackers[index.attackerIndex].hostile = true;
        }
    };

    /* NAME
     *   $isHostile
     *
     * FUNCTION
     *   Check if the ship is hostile.
     *
     * INPUT
     *   ship - entity of the ship to check
     *
     * RESULT
     *   result - return true if ship is hostile, otherwise return false
     */
    this.$isHostile = function (ship) {
        var index,
        attackerIndex,
        counter,
        length;

        if (!ship || !ship.isValid || this.$friendList.indexOf(ship.entityPersonality) !== -1) {
            /* The ship is no longer valid or is a member of Jaguar Company. */
            return false;
        }

        if (ship.isThargoid) {
            /* Cache the length. */
            length = ship.escortGroup.length;

            for (counter = 0; counter &lt; length; counter += 1) {
                /* Add the thargoid and tharglets (if needed) and get the attacker index. */
                index = this.$addAttacker(ship.escortGroup[counter]);

                if (index !== -1) {
                    /* Set the hostile property. */
                    p_ships.attackers[index.attackerIndex].hostile = true;
                }
            }

            /* Always true for Thargoids/tharglets. */
            return true;
        }

        if (!p_ships.attackers.length) {
            /* No attackers. */
            return false;
        }

        /* Find the index of the ship in the attackers index. */
        attackerIndex = p_ships.attackersIndex.indexOf(ship.entityPersonality);

        if (attackerIndex === -1) {
            /* No such attacker. */
            return false;
        }

        /* Return hostile status. */
        return p_ships.attackers[attackerIndex].hostile;
    };

    /* NAME
     *   $increaseAttackCounter
     *
     * FUNCTION
     *   Increase the ship&#39;s attack counter for the victim.
     *
     * INPUTS
     *   attacker - entity of the attacker
     *   victim - entity of the attacked ship
     */
    this.$increaseAttackCounter = function (attacker, victim) {
        var index;

        if (!attacker || !attacker.isValid || !victim || !victim.isValid) {
            /* The attacker and/or victim is no longer valid. */
            return;
        }

        /* Setup the attacker and victim. */
        index = this.$addAttacker(attacker, victim);

        if (index !== -1) {
            /* Increase the attack counter for the victim. */
            p_ships.attackers[index.attackerIndex].victims[index.victimIndex].attackCounter += 1;
        }
    };

    /* NAME
     *   $attackCounter
     *
     * FUNCTION
     *   Return the attack counter for the victim.
     *
     * INPUTS
     *   attacker - entity of the attacker
     *   victim - entity of the attacked ship
     *
     * RESULT
     *   result - return attackCounter if available, otherwise return -1
     */
    this.$attackCounter = function (attacker, victim) {
        var attackerIndex,
        victimIndex;

        if (!attacker || !attacker.isValid || !victim || !victim.isValid) {
            /* The attacker and/or victim is no longer valid. */
            return -1;
        }

        if (!p_ships.attackers.length) {
            /* No attackers. */
            return -1;
        }

        /* Find the index of the attacker. */
        attackerIndex = p_ships.attackersIndex.indexOf(attacker.entityPersonality);

        if (attackerIndex === -1 || !p_ships.attackers[attackerIndex].victims.length) {
            /* No such attacker or victims. */
            return -1;
        }

        /* Find the index of the victim. */
        victimIndex = p_ships.attackers[attackerIndex].victimsIndex.indexOf(victim.entityPersonality);

        if (victimIndex === -1) {
            /* No such victim. */
            return -1;
        }

        /* Return attack counter. */
        return p_ships.attackers[attackerIndex].victims[victimIndex].attackCounter;
    };

    /* NAME
     *   $resetAttackCounter
     *
     * FUNCTION
     *   Reset the attack counter to 1.
     *
     * INPUTS
     *   attacker - entity of the attacker
     *   victim - entity of the attacked ship
     */
    this.$resetAttackCounter = function (attacker, victim) {
        var attackerIndex,
        victimIndex;

        if (!attacker || !attacker.isValid || !victim || !victim.isValid) {
            /* The attacker and/or victim is no longer valid. */
            return;
        }

        if (!p_ships.attackers.length) {
            /* No attackers. */
            return;
        }

        /* Find the index of the attacker. */
        attackerIndex = p_ships.attackersIndex.indexOf(attacker.entityPersonality);

        if (attackerIndex === -1 || !p_ships.attackers[attackerIndex].victims.length) {
            /* No such attacker or victims. */
            return;
        }

        /* Find the index of the victim. */
        victimIndex = p_ships.attackers[attackerIndex].victimsIndex.indexOf(victim.entityPersonality);

        if (victimIndex === -1) {
            /* No such victim. */
            return;
        }

        /* Reset the attack counter to 1. */
        p_ships.attackers[attackerIndex].victims[victimIndex].attackCounter = 1;
    };

    /* NAME
     *   $attackTime
     *
     * FUNCTION
     *   Return the attack time for the victim or &#39;clock.seconds&#39; if not available.
     *
     * INPUTS
     *   attacker - entity of the attacker
     *   victim - entity of the attacked ship
     *
     * RESULT
     *   result - return attackTime if available, otherwise return &#39;clock.seconds&#39;
     */
    this.$attackTime = function (attacker, victim) {
        var attackerIndex,
        victimIndex;

        if (!attacker || !attacker.isValid || !victim || !victim.isValid) {
            /* The attacker and/or victim is no longer valid. */
            return clock.seconds;
        }

        if (!p_ships.attackers.length) {
            /* No attackers. */
            return clock.seconds;
        }

        /* Find the index of the attacker. */
        attackerIndex = p_ships.attackersIndex.indexOf(attacker.entityPersonality);

        if (attackerIndex === -1 || !p_ships.attackers[attackerIndex].victims.length) {
            /* No such attacker or victims. */
            return clock.seconds;
        }

        /* Find the index of the victim. */
        victimIndex = p_ships.attackers[attackerIndex].victimsIndex.indexOf(victim.entityPersonality);

        if (victimIndex === -1) {
            /* No such victim. */
            return clock.seconds;
        }

        /* Return attack time. */
        return p_ships.attackers[attackerIndex].victims[victimIndex].attackTime;
    };

    /* NAME
     *   $increaseMissCounter
     *
     * FUNCTION
     *   Increase the ship&#39;s miss counter for the victim.
     *
     * INPUTS
     *   attacker - entity of the attacker
     *   victim - entity of the attacked ship
     */
    this.$increaseMissCounter = function (attacker, victim) {
        var index;

        if (!attacker || !attacker.isValid || !victim || !victim.isValid) {
            /* The attacker and/or victim is no longer valid. */
            return;
        }

        /* Setup the attacker and victim. */
        index = this.$addAttacker(attacker, victim);

        if (index !== -1) {
            /* Increase the miss counter for the victim. */
            p_ships.attackers[index.attackerIndex].victims[index.victimIndex].missCounter += 1;
        }
    };

    /* NAME
     *   $missCounter
     *
     * FUNCTION
     *   Return the miss counter for the victim.
     *
     * INPUTS
     *   attacker - entity of the attacker
     *   victim - entity of the attacked ship
     *
     * RESULT
     *   result - return missCounter if available, otherwise return -1
     */
    this.$missCounter = function (attacker, victim) {
        var attackerIndex,
        victimIndex;

        if (!attacker || !attacker.isValid || !victim || !victim.isValid) {
            /* The attacker and/or victim is no longer valid. */
            return -1;
        }

        if (!p_ships.attackers.length) {
            /* No attackers. */
            return -1;
        }

        /* Find the index of the attacker. */
        attackerIndex = p_ships.attackersIndex.indexOf(attacker.entityPersonality);

        if (attackerIndex === -1 || !p_ships.attackers[attackerIndex].victims.length) {
            /* No such attacker or victims. */
            return -1;
        }

        /* Find the index of the victim. */
        victimIndex = p_ships.attackers[attackerIndex].victimsIndex.indexOf(victim.entityPersonality);

        if (victimIndex === -1) {
            /* No such victim. */
            return -1;
        }

        /* Return miss counter. */
        return p_ships.attackers[attackerIndex].victims[victimIndex].missCounter;
    };

    /* NAME
     *   $resetMissCounter
     *
     * FUNCTION
     *   Reset the miss counter to 1.
     *
     * INPUTS
     *   attacker - entity of the attacker
     *   victim - entity of the attacked ship
     */
    this.$resetMissCounter = function (attacker, victim) {
        var attackerIndex,
        victimIndex;

        if (!attacker || !attacker.isValid || !victim || !victim.isValid) {
            /* The attacker and/or victim is no longer valid. */
            return;
        }

        if (!p_ships.attackers.length) {
            /* No attackers. */
            return;
        }

        /* Find the index of the attacker. */
        attackerIndex = p_ships.attackersIndex.indexOf(attacker.entityPersonality);

        if (attackerIndex === -1 || !p_ships.attackers[attackerIndex].victims.length) {
            /* No such attacker or victims. */
            return;
        }

        /* Find the index of the victim. */
        victimIndex = p_ships.attackers[attackerIndex].victimsIndex.indexOf(victim.entityPersonality);

        if (victimIndex === -1) {
            /* No such victim. */
            return;
        }

        /* Reset the miss counter to 1. */
        p_ships.attackers[attackerIndex].victims[victimIndex].missCounter = 1;
    };

    /* NAME
     *   $missTime
     *
     * FUNCTION
     *   Return the miss time for the victim or &#39;clock.seconds&#39; if not available.
     *
     * INPUTS
     *   attacker - entity of the attacker
     *   victim - entity of the attacked ship
     *
     * RESULT
     *   result - return missTime if available, otherwise return &#39;clock.seconds&#39;
     */
    this.$missTime = function (attacker, victim) {
        var attackerIndex,
        victimIndex;

        if (!attacker || !attacker.isValid || !victim || !victim.isValid) {
            /* The attacker and/or victim is no longer valid. */
            return clock.seconds;
        }

        if (!p_ships.attackers.length) {
            /* No attackers. */
            return clock.seconds;
        }

        /* Find the index of the attacker. */
        attackerIndex = p_ships.attackersIndex.indexOf(attacker.entityPersonality);

        if (attackerIndex === -1 || !p_ships.attackers[attackerIndex].victims.length) {
            /* No such attacker or victims. */
            return clock.seconds;
        }

        /* Find the index of the victim. */
        victimIndex = p_ships.attackers[attackerIndex].victimsIndex.indexOf(victim.entityPersonality);

        if (victimIndex === -1) {
            /* No such victim. */
            return clock.seconds;
        }

        /* Return miss time. */
        return p_ships.attackers[attackerIndex].victims[victimIndex].missTime;
    };

    /* New ship script event handler hooks. */

    /* NAME
     *   $shipDied
     *
     * FUNCTION
     *   A ship has died.
     *
     *   Not to be confused with the world script event function &#39;shipDied&#39;,
     *   although it should be called from the ship script event function &#39;shipDied&#39;.
     *
     * INPUTS
     *   victim - entity that died
     *   attacker - entity that caused the death
     *   why - cause as a string
     */
    this.$shipDied = function (victim, attacker, why) {
        var destroyedBy = attacker,
        pilotName;

        if (attacker &amp;&amp; attacker.isValid &amp;&amp; !victim.isDerelict) {
            destroyedBy = &quot;ship#&quot; + attacker.entityPersonality + &quot; (&quot; + attacker.displayName + &quot;)&quot;;

            if (why === &quot;energy damage&quot; || why === &quot;cascade weapon&quot;) {
                /* Check for piloted ships that aren&#39;t hostile.
                 * Generally this will pick up death by a surprise/instant kill, i.e. cascade weapon.
                 */
                if (attacker.isPiloted &amp;&amp; !this.$isHostile(attacker)) {
                    /* Make the attacker a hostile for future checking. */
                    this.$makeHostile(attacker, victim);

                    if (attacker.isPlayer) {
                        /* Remember the player, even if they jump system. */
                        p_ships.mainScript.$playerVar.attacker = true;
                        /* Clear the reputation of the player. */
                        p_ships.mainScript.$playerVar.reputation[galaxyNumber] = 0;
                    }
                }
            }

            if ((victim.isPiloted || victim.isStation) &amp;&amp; Math.random() &gt; p_ships.messageProbability) {
                if (victim.$pilotName) {
                    /* Get the victims&#39;s name. */
                    pilotName = victim.$pilotName;
                } else {
                    /* Use displayName as the name of the victim. */
                    pilotName = victim.name + &quot;: &quot; + victim.displayName;
                }

                if (player.ship &amp;&amp; player.ship.isValid &amp;&amp;
                    victim.position.distanceTo(player.ship.position) &lt; victim.scannerRange) {
                    /* Death message. */
                    player.consoleMessage(pilotName + &quot;: &quot; + expandDescription(&quot;[jaguar_company_death]&quot;));
                }
            }
        }

        if (p_ships.logging &amp;&amp; p_ships.logExtra) {
            log(this.name,
                &quot;$shipDied::&quot; +
                &quot;ship#&quot; + victim.entityPersonality + &quot; (&quot; + victim.name + &quot;: &quot; + victim.displayName + &quot;)&quot; +
                &quot; was destroyed by &quot; + destroyedBy +
                &quot;, reason: &quot; + why);
        }
    };

    /* NAME
     *   $shipIsBeingAttacked
     *
     * FUNCTION
     *   Remember who is attacking us. Pay particular attention to players.
     *
     *   The AI will send an ATTACKED message to this ship.
     *   Since we check for occurences of &quot;friendly fire&quot; we can not use or respond to that message,
     *   so we send out a new message of HOSTILE_FIRE if it really is an attack.
     *
     *   Not to be confused with the world script event function &#39;shipBeingAttacked&#39;,
     *   although it should be called from the ship script event function &#39;shipBeingAttacked&#39;.
     *
     * INPUTS
     *   victim - caller ship
     *   attacker - entity of the attacker
     */
    this.$shipIsBeingAttacked = function (victim, attacker) {
        var attackCounter,
        piloted,
        pilotName,
        psInRange;

        if (!attacker || !attacker.isValid ||
            !victim || !victim.isValid ||
            victim.isDerelict) {
            /* The attacker is no longer valid
             * or the victim is no longer valid
             * or the victim is a derelict
             */
            return;
        }

        piloted = (victim.isPiloted || victim.isStation);
        psInRange = (player.ship &amp;&amp; player.ship.isValid &amp;&amp;
            victim.position.distanceTo(player.ship.position) &lt; victim.scannerRange);

        if (victim.$pilotName) {
            /* Get the victims&#39;s name. */
            pilotName = victim.$pilotName;
        } else {
            /* Use displayName as the name of the victim. */
            pilotName = victim.name + &quot;: &quot; + victim.displayName;
        }

        /* Check if the attacker is a friend of the victim. */
        if (this.$friendList.indexOf(attacker.entityPersonality) !== -1) {
            if (piloted &amp;&amp; Math.random() &gt; p_ships.messageProbability &amp;&amp; psInRange) {
                /* Broadcast a &quot;friendly fire&quot; message. */
                player.consoleMessage(pilotName + &quot;: &quot; + expandDescription(&quot;[jaguar_company_friendly_fire]&quot;));
            }

            /* Tell the attacker that we are a friend. */
            attacker.reactToAIMessage(&quot;FRIENDLY_FIRE&quot;);

            return;
        }

        /* Setup the attacker and victim if needed and increase the attack counter. */
        this.$increaseAttackCounter(attacker, victim);

        if (this.$isHostile(attacker)) {
            /* Already been marked as hostile. */
            if (piloted &amp;&amp; Math.random() &gt; p_ships.messageProbability) {
                /* Show hostile message. */
                if (attacker.isPlayer) {
                    /* Player hostile message. */
                    player.consoleMessage(pilotName + &quot;: &quot; + expandDescription(&quot;[jaguar_company_player_hostile_fire]&quot;));
                } else if (psInRange) {
                    /* Other ship hostile message. */
                    player.consoleMessage(pilotName + &quot;: &quot; + expandDescription(&quot;[jaguar_company_hostile_fire]&quot;));
                }
            }

            /* Send back a custom AI message. */
            victim.reactToAIMessage(&quot;HOSTILE_FIRE&quot;);

            return;
        }

        /* Thargoids/tharglets and pirates don&#39;t get warnings. */
        if (!attacker.isThargoid &amp;&amp; !attacker.isPirate) {
            if (clock.seconds - this.$attackTime(attacker, victim) &gt; 5) {
                /* More than 5 seconds since the last &quot;friendly fire&quot; hit. */
                this.$resetAttackCounter(attacker, victim);
            }

            attackCounter = this.$attackCounter(attacker, victim);

            if (attackCounter === -1) {
                /* Not an attacker or there are no victims. */
                return;
            }

            if (attackCounter &lt; 5) {
                /* We&#39;ve only hit this ship less than 5 times. Assume &quot;friendly fire&quot;. */
                if (attackCounter === 1) {
                    /* Only show &quot;friendly fire&quot; message on the first hit. */
                    if (attacker.isPlayer) {
                        /* Decrease reputation. */
                        p_ships.mainScript.$playerVar.reputation[galaxyNumber] -= 1;

                        if (piloted) {
                            /* Player warning. */
                            player.consoleMessage(pilotName + &quot;: &quot; +
                                expandDescription(&quot;[jaguar_company_player_friendly_fire]&quot;));
                        }
                    } else if (piloted &amp;&amp; psInRange) {
                        /* Other ship warning. */
                        player.consoleMessage(pilotName + &quot;: &quot; + expandDescription(&quot;[jaguar_company_friendly_fire]&quot;));
                    }
                }

                return;
            }
        }

        /* Everybody has had all the warnings they are going to get once we have reached this point.
         * This section is only executed once. Hostiles are caught above after this.
         */

        /* Make the attacker a hostile for future checking. */
        this.$makeHostile(attacker, victim);

        if (attacker.isPlayer) {
            /* Remember the player, even if they jump system. */
            p_ships.mainScript.$playerVar.attacker = true;
            /* Clear the reputation of the player. */
            p_ships.mainScript.$playerVar.reputation[galaxyNumber] = 0;

            if (piloted) {
                /* Player hostile message. */
                player.consoleMessage(pilotName + &quot;: &quot; + expandDescription(&quot;[jaguar_company_player_hostile_fire]&quot;));
            }
        } else if (piloted &amp;&amp; psInRange) {
            /* Other ship hostile message. */
            player.consoleMessage(pilotName + &quot;: &quot; + expandDescription(&quot;[jaguar_company_hostile_fire]&quot;));
        }

        /* Send back a custom AI message. */
        victim.reactToAIMessage(&quot;HOSTILE_FIRE&quot;);
    };

    /* NAME
     *   $shipIsBeingAttackedUnsuccessfully
     *
     * FUNCTION
     *   Oolite v1.77 and newer.
     *
     *   A ship is being unsuccessfully attacked.
     *
     *   The AI will send an ATTACKER_MISSED message to this ship.
     *   Since we check for occurences of &quot;friendly fire&quot; we can not use or respond to that message,
     *   so we send out a new message of HOSTILE_FIRE if it really is an attack.
     *
     *   Not to be confused with the world script event function &#39;shipBeingAttackedUnsuccessfully&#39;,
     *   although it should be called from the ship script event function &#39;shipBeingAttackedUnsuccessfully&#39;.
     *
     * INPUTS
     *   victim - caller ship
     *   attacker - entity of the unsuccessful attacker
     */
    this.$shipIsBeingAttackedUnsuccessfully = function (victim, attacker) {
        var missCounter,
        piloted,
        pilotName,
        psInRange;

        if (!attacker || !attacker.isValid ||
            !victim || !victim.isValid ||
            victim.isDerelict) {
            /* The attacker is no longer valid
             * or the victim is no longer valid
             * or the victim is a derelict
             */
            return;
        }

        /* Check if the attacker is a friend of the victim. */
        if (this.$friendList.indexOf(attacker.entityPersonality) !== -1) {
            /* Tell the attacker that we are a friend. */
            attacker.reactToAIMessage(&quot;FRIENDLY_FIRE&quot;);

            return;
        }

        /* Setup the attacker and victim if needed and increase the miss counter. */
        this.$increaseMissCounter(attacker, victim);

        if (this.$isHostile(attacker)) {
            /* Already been marked as hostile. Treat it as though the attacker hit. */
            victim.reactToAIMessage(&quot;HOSTILE_FIRE&quot;);

            return;
        }

        /* Thargoids/tharglets and pirates don&#39;t get warnings. */
        if (!attacker.isThargoid &amp;&amp; !attacker.isPirate) {
            if (clock.seconds - this.$missTime(attacker, victim) &gt; 5) {
                /* More than 5 seconds since the last &quot;friendly fire&quot; miss. */
                this.$resetMissCounter(attacker, victim);
            }

            missCounter = this.$missCounter(attacker, victim);

            if (missCounter === -1) {
                /* Not an attacker or there are no victims. */
                return;
            }

            if (missCounter &lt; 5) {
                /* We&#39;ve only missed this ship less than 5 times. Assume ineptitude. */
                return;
            }
        }

        /* Everybody has had all the chances they are going to get once we have reached this point.
         * This section is only executed once. Hostiles are caught above after this.
         */

        /* Make the attacker a hostile for future checking. */
        this.$makeHostile(attacker, victim);

        piloted = (victim.isPiloted || victim.isStation);
        psInRange = (player.ship &amp;&amp; player.ship.isValid &amp;&amp;
            victim.position.distanceTo(player.ship.position) &lt; victim.scannerRange);

        if (victim.$pilotName) {
            /* Get the victims&#39;s name. */
            pilotName = victim.$pilotName;
        } else {
            /* Use displayName as the name of the victim. */
            pilotName = victim.name + &quot;: &quot; + victim.displayName;
        }

        if (attacker.isPlayer) {
            /* Remember the player, even if they jump system. */
            p_ships.mainScript.$playerVar.attacker = true;
            /* Clear the reputation of the player. */
            p_ships.mainScript.$playerVar.reputation[galaxyNumber] = 0;

            if (piloted) {
                /* Player hostile message. */
                player.consoleMessage(pilotName + &quot;: &quot; + expandDescription(&quot;[jaguar_company_player_hostile_fire]&quot;));
            }
        } else if (piloted &amp;&amp; psInRange) {
            /* Other ship hostile message. */
            player.consoleMessage(pilotName + &quot;: &quot; + expandDescription(&quot;[jaguar_company_hostile_fire]&quot;));
        }

        /* Send back a custom AI message. */
        victim.reactToAIMessage(&quot;HOSTILE_FIRE&quot;);
    };

    /* NAME
     *   $shipIsBeingAttackedWithMissile
     *
     * FUNCTION
     *   The AI will automatically send an INCOMING_MISSILE message to this ship.
     *   Since we don&#39;t have to do anything fancy that would confuse the AI state system
     *   we don&#39;t have to send a special message like the general attack system below.
     *
     *   No such thing as &quot;friendly fire&quot; with a missile.
     *
     *   Not to be confused with the world script event function &#39;shipAttackedWithMissile&#39;,
     *   although it should be called from the ship script event function &#39;shipAttackedWithMissile&#39;.
     *
     * INPUTS
     *   victim - caller ship
     *   attacker - entity of the attacker
     */
    this.$shipIsBeingAttackedWithMissile = function (victim, attacker) {
        var piloted,
        pilotName;

        if (!attacker || !attacker.isValid ||
            !victim || !victim.isValid ||
            victim.isDerelict) {
            /* The attacker is no longer valid
             * or the victim is no longer valid
             * or the victim is a derelict
             */
            return;
        }

        /* Setup the attacker and victim if needed and increase the attack counter. */
        this.$increaseAttackCounter(attacker, victim);
        /* Make the attacker a hostile for future checking. */
        this.$makeHostile(attacker, victim);

        piloted = (victim.isPiloted || victim.isStation);

        if (victim.$pilotName) {
            /* Get the victims&#39;s name. */
            pilotName = victim.$pilotName;
        } else {
            /* Use displayName as the name of the victim. */
            pilotName = victim.name + &quot;: &quot; + victim.displayName;
        }

        if (attacker.isPlayer) {
            /* Remember the player, even if they jump system. */
            p_ships.mainScript.$playerVar.attacker = true;
            /* Clear the reputation of the player. */
            p_ships.mainScript.$playerVar.reputation[galaxyNumber] = 0;

            if (piloted) {
                /* Player hostile message. */
                player.consoleMessage(pilotName + &quot;: &quot; + expandDescription(&quot;[jaguar_company_player_hostile_fire]&quot;));
            }
        } else if (piloted &amp;&amp; player.ship &amp;&amp; player.ship.isValid &amp;&amp;
            victim.position.distanceTo(player.ship.position) &lt; victim.scannerRange) {
            /* Other ship hostile message. */
            player.consoleMessage(pilotName + &quot;: &quot; + expandDescription(&quot;[jaguar_company_hostile_fire]&quot;));
        }
    };

    /* NAME
     *   $shipTakingDamage
     *
     * FUNCTION
     *   Taking damage. Check attacker and what type.
     *
     *   Not to be confused with the world script event function &#39;shipTakingDamage&#39;,
     *   although it should be called from the ship script event function &#39;shipTakingDamage&#39;.
     *
     * INPUTS
     *   victim - entity that is being damaged
     *   amount - amount of damage
     *   attacker - entity that caused the damage
     *   type - type of damage as a string
     */
    this.$shipTakingDamage = function (victim, amount, attacker, type) {
        if (attacker &amp;&amp; attacker.isValid &amp;&amp; attacker.isShip &amp;&amp; type === &quot;scrape damage&quot;) {
            /* Make sure it is a ship dealing scrape damage. */
            if (this.$friendList.indexOf(attacker.entityPersonality) !== -1) {
                /* Cancel damage from collision with Jaguar Company ships. */
                victim.energy += amount;
                /* Target the ship we are colliding with. */
                victim.target = attacker;

                if (victim.AI === &quot;jaguar_company_interceptAI.plist&quot;) {
                    /* Force an exit of the intercept AI. */
                    victim.lightsActive = false;
                    victim.exitAI();
                }

                /* Move away from the ship we are colliding with. */
                victim.reactToAIMessage(&quot;JAGUAR_COMPANY_TAKING_DAMAGE&quot;);
            }
        }
    };

    /* Internal AI functions. Called by ship script. */

    /* NAME
     *   $performAttackTarget
     *
     * FUNCTION
     *   This does something similar to a mix between the deployEscorts and groupAttackTarget AI commands.
     *
     * INPUT
     *   callerShip - entity of the caller ship
     */
    this.$performAttackTarget = function (callerShip) {
        var target = callerShip.target,
        otherShips,
        idleShips = [],
        idleShip,
        counter,
        length;

        if (this.$friendList.indexOf(callerShip.entityPersonality) === -1) {
            /* Caller ship is not a friend of Jaguar Company. */
            return;
        }

        if (target === null) {
            /* Return immediately if we have no target. */
            return;
        }

        if (this.$friendList.indexOf(target.entityPersonality) !== -1 || !this.$isHostile(target)) {
            /* Clear the target and return for one of the following 2 states...
             * 1. Target is a friend.
             * 2. Target is not a hostile.
             */
            callerShip.target = null;

            return;
        }

        /* Force attacker to hostile status. */
        this.$makeHostile(target, callerShip);
        /* React to our own attack call. */
        callerShip.reactToAIMessage(&quot;JAGUAR_COMPANY_ATTACK_TARGET&quot;);

        /* NAME
         *   $identifyFriends
         *
         * FUNCTION
         *   Stop warnings about anonymous local functions within loops.
         *   Used by &#39;system.filteredEntities&#39;. Returns true for any friend of the caller ship.
         *
         * INPUT
         *   entity - entity to check
         */
        function $identifyFriends(entity) {
            if (!entity.isValid || entity.isCloaked || entity.isDerelict) {
                /* Ignore all entities that have one of these conditions:
                 * 1) not valid
                 * 2) cloaked
                 * 3) is a derelict
                 */
                return false;
            }

            /* Is a friend of the caller ship. */
            return (this.$friendList.indexOf(entity.entityPersonality) !== -1);
        }

        /* Limit range of check to scanner range of caller ship. */
        otherShips = system.filteredEntities(this, $identifyFriends, callerShip, callerShip.scannerRange);

        if (!otherShips.length) {
            /* Return immediately if we are on our own. */
            return;
        }

        /* Cache the length. */
        length = otherShips.length;

        for (counter = 0; counter &lt; length; counter += 1) {
            if (!otherShips[counter].hasHostileTarget) {
                /* Other ship not in attack mode. Put it on the idle list. */
                idleShips.push(otherShips[counter]);
            }
        }

        if (!idleShips.length) {
            /* Return immediately if there are no idle ships. */
            return;
        }

        /* Get a random number of idle ships to deploy. */
        length = Math.ceil(Math.random() * idleShips.length);

        for (counter = 0; counter &lt; length; counter += 1) {
            idleShip = idleShips[counter];

            /* The idle ship is not currently in attack mode. Give it a target. */
            idleShip.target = target;
            idleShip.reactToAIMessage(&quot;JAGUAR_COMPANY_ATTACK_TARGET&quot;);
        }
    };

    /* NAME
     *   $scanForAttackers
     *
     * FUNCTION
     *   Scan for ships from the past that have attacked the caller ship.
     *   Also scan for potential attackers.
     *
     * INPUT
     *   callerShip - entity of the caller ship
     */
    this.$scanForAttackers = function (callerShip) {
        var target = null,
        attackersWithinRange,
        pilotName,
        counter,
        length;

        if (this.$friendList.indexOf(callerShip.entityPersonality) === -1) {
            /* Caller ship is not a friend of Jaguar Company. */
            return;
        }

        /* NAME
         *   $identifyAttacker
         *
         * FUNCTION
         *   Stop warnings about anonymous local functions within loops.
         *   Used by &#39;system.filteredEntities&#39;. Returns true for attackers or potential attackers.
         *
         * INPUT
         *   entity - entity to check
         */
        function $identifyAttacker(entity) {
            if (!entity.isValid || entity.isCloaked || entity.isDerelict) {
                /* Ignore all entities that have one of these conditions:
                 * 1) not valid
                 * 2) cloaked
                 * 3) is a derelict
                 */
                return false;
            }

            if (this.$isHostile(entity)) {
                /* The entity is a previous hostile for the caller ship. */
                return true;
            }

            if (entity.isPlayer &amp;&amp; p_ships.mainScript.$playerVar.attacker) {
                /* Player has attacked us in the past. */
                return true;
            }

            if (p_ships.mainScript.$jaguarCompanyBase &amp;&amp; p_ships.mainScript.$jaguarCompanyBase.isValid &amp;&amp;
                entity.position.distanceTo(p_ships.mainScript.$jaguarCompanyBase.position) &lt; 30000) {
                /* All ships not identified as hostile so far are safe within 30km of the base. */
                return false;
            }

            if (entity.isPirate) {
                /* The entity is a pirate. */
                return true;
            }

            if (entity.bounty &gt; 20 || Math.random() &lt; ((entity.bounty - 10) / 40)) {
                /* Entity has a bounty greater than 20Cr.
                 * o Entities with a low bounty (minimum 11Cr) have a very small chance of being picked on.
                 *   o Bounty of 11Cr: 1 in 40 chance.
                 *   o Bounty of 20Cr: 1 in 4 chance.
                 */
                return true;
            }

            /* Everything else is ignored. */
            return false;
        }

        /* Find past attackers and potential attackers within range of the caller ship. */
        attackersWithinRange = system.filteredEntities(this, $identifyAttacker, callerShip, callerShip.scannerRange);

        if (!attackersWithinRange.length) {
            /* No attackers. */
            callerShip.reactToAIMessage(&quot;ATTACKERS_NOT_FOUND&quot;);
        } else {
            /* Cache the length. */
            length = attackersWithinRange.length;

            for (counter = 0; counter &lt; length; counter += 1) {
                /* Force all attackers within range to hostile status. */
                this.$makeHostile(attackersWithinRange[counter], callerShip);
            }

            /* Set target to the closest attacker. */
            target = attackersWithinRange[0];

            if ((callerShip.isPiloted || callerShip.isStation) &amp;&amp; Math.random() &gt; p_ships.messageProbability) {
                if (callerShip.$pilotName) {
                    /* Get the callerShip&#39;s name. */
                    pilotName = callerShip.$pilotName;
                } else {
                    /* Use displayName as the name of the callerShip. */
                    pilotName = callerShip.name + &quot;: &quot; + callerShip.displayName;
                }

                /* Show hostile message. */
                if (target.isPlayer) {
                    /* Player hostile message. */
                    player.consoleMessage(pilotName + &quot;: &quot; + expandDescription(&quot;[jaguar_company_player_hostile_fire]&quot;));
                } else {
                    if (player.ship &amp;&amp; player.ship.isValid &amp;&amp;
                        callerShip.position.distanceTo(player.ship.position) &lt; callerShip.scannerRange) {
                        /* Other ship hostile message. */
                        player.consoleMessage(pilotName + &quot;: &quot; + expandDescription(&quot;[jaguar_company_hostile_fire]&quot;));
                    }
                }
            }

            /* Set the target. */
            callerShip.target = target;
            callerShip.reactToAIMessage(&quot;ATTACKERS_FOUND&quot;);
        }
    };
}.bind(this)());
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/jaguar_company_tracker.js</td>
                    <td><pre>/*jslint bitwise: true, es5: true, newcap: true, nomen: true, regexp: true, unparam: true, todo: true, white: true,
indent: 4, maxerr: 50, maxlen: 120 */
/*jshint boss: true, curly: true, eqeqeq: true, eqnull: true, es5: true, evil: true, forin: true, laxbreak: true,
loopfunc: true, noarg: true, noempty: true, strict: true, nonew: true, undef: true */
/*global Timer, addFrameCallback, isValidFrameCallback, log, player, removeFrameCallback, system, worldScripts */

/* Jaguar Company Tracker
 *
 * Copyright © 2012-2013 Richard Thomas Harrison (Tricky)
 *
 * This work is licensed under the Creative Commons
 * Attribution-Noncommercial-Share Alike 3.0 Unported License.
 *
 * To view a copy of this license, visit
 * http://creativecommons.org/licenses/by-nc-sa/3.0/ or send a letter
 * to Creative Commons, 171 Second Street, Suite 300, San Francisco,
 * California, 94105, USA.
 *
 * Ship/Effect related functions for the patrol tracker.
 */

(function () {
    &quot;use strict&quot;;

    /* Standard public variables for OXP scripts. */
    this.name = &quot;jaguar_company_tracker.js&quot;;
    this.author = &quot;Tricky&quot;;
    this.copyright = &quot;© 2012-2013 Richard Thomas Harrison (Tricky)&quot;;
    this.license = &quot;CC BY-NC-SA 3.0&quot;;
    this.description = &quot;Ship script for the Jaguar Company Tracker.&quot;;
    this.version = &quot;1.2&quot;;

    /* Private variable. */
    var p_tracker = {};

    /* Ship script event handlers. */

    /* NAME
     *   shipSpawned
     *
     * FUNCTION
     *   Initialise various variables on ship birth. Oolite v1.76.1 and older.
     */
    this.shipSpawned = function () {
        /* Common setup. */
        this.$setUp();
        /* Use a frame callback to keep the position constant. */
        this.$trackerFCBReference = addFrameCallback(this.$invisibleTrackerFCB.bind(this));

        /* No longer needed after setting up. */
        delete this.shipSpawned;
        delete this.effectSpawned;
        delete this.$visualTrackerFCB;
    };

    /* NAME
     *   effectSpawned
     *
     * FUNCTION
     *   Initialise various variables on effect birth. Oolite v1.77 and newer.
     */
    this.effectSpawned = function () {
        /* Common setup. */
        this.$setUp();
        /* Use a frame callback to keep the position constant. */
        this.$trackerFCBReference = addFrameCallback(this.$visualTrackerFCB.bind(this));

        /* No longer needed after setting up. */
        delete this.shipSpawned;
        delete this.effectSpawned;
        delete this.$invisibleTrackerFCB;
    };

    /* NAME
     *   shipDied
     *
     * FUNCTION
     *   Patrol tracker was destroyed.
     *
     *   Not triggered for Oolite v1.77 and newer visual effects.
     *
     * INPUTS
     *   whom - entity that caused the death
     *   why - cause as a string
     */
    this.shipDied = function (whom, why) {
        var destroyedBy = whom,
        tracker = this.ship,
        patrolShips;

        if (whom &amp;&amp; whom.isValid) {
            destroyedBy = &quot;ship#&quot; + whom.entityPersonality + &quot; (&quot; + whom.displayName + &quot;)&quot;;
            patrolShips = system.shipsWithPrimaryRole(&quot;jaguar_company_patrol&quot;);

            if (patrolShips.length &gt; 0) {
                /* Patrol still around. Re-spawn. */
                worldScripts[&quot;Jaguar Company&quot;].$tracker = patrolShips[0].spawnOne(&quot;jaguar_company_tracker&quot;);
            }
        }

        if (p_tracker.logging &amp;&amp; p_tracker.logExtra) {
            log(this.name, &quot;shipDied::&quot; +
                &quot;ship#&quot; + tracker.entityPersonality + &quot; (&quot; + tracker.displayName + &quot;)&quot; +
                &quot; was destroyed by &quot; + destroyedBy +
                &quot;, reason: &quot; + why);
        }
    };

    /* NAME
     *   shipRemoved, effectRemoved, entityDestroyed and $removeTrackerRefs
     *
     * FUNCTION
     *   The patrol tracker has just become invalid or was removed.
     */
    this.shipRemoved = this.effectRemoved = this.entityDestroyed = this.$removeTrackerRefs = function () {
        /* Stop and remove the timer. */
        if (this.$trackerTimerReference) {
            if (this.$trackerTimerReference.isRunning) {
                this.$trackerTimerReference.stop();
            }

            this.$trackerTimerReference = null;
        }

        /* Stop and remove the frame callback. */
        if (this.$trackerFCBReference) {
            if (isValidFrameCallback(this.$trackerFCBReference)) {
                removeFrameCallback(this.$trackerFCBReference);
            }

            this.$trackerFCBReference = null;
        }
    };

    /* Other global functions. */

    /* NAME
     *   $setUp
     *
     * FUNCTION
     *   Setup the private main variable + some public variables.
     */
    this.$setUp = function () {
        /* Initialise the p_tracker variable object.
         * Encapsulates all private global data.
         */
        p_tracker = {
            /* Cache the main world script. */
            mainScript : worldScripts[&quot;Jaguar Company&quot;],
            /* Local copies of the logging variables. */
            logging : worldScripts[&quot;Jaguar Company&quot;].$logging,
            logExtra : worldScripts[&quot;Jaguar Company&quot;].$logExtra,
            /* Updated by the timer. */
            closestPatrolShip : null,
            /* Material used by the visual effect. */
            material : &quot;none&quot;
        };

        /* Track the patrol ships every 0.25 seconds. */
        this.$trackerTimerReference = new Timer(this, this.$trackerTimer, 0.25, 0.25);
    };

    /* NAME
     *   $trackerTimer
     *
     * FUNCTION
     *   Tracker timer. Updates the closest patrol ship position.
     *
     *   Called every 0.25 seconds.
     */
    this.$trackerTimer = function () {
        var tracker = this.ship || this.visualEffect,
        playerShip,
        patrolShips;

        if (!tracker || !tracker.isValid) {
            /* Tracker no longer valid. */
            this.$removeTrackerRefs();

            if (p_tracker.logging &amp;&amp; p_tracker.logExtra) {
                log(this.name, &quot;$trackerTimer::Tracker not valid&quot;);
            }

            return;
        }

        /* Player ship object. */
        playerShip = player.ship;

        if (!playerShip || !playerShip.isValid) {
            /* If the player has died, reset the tracker. */
            p_tracker.mainScript.$blackboxASCReset(false);
            p_tracker.mainScript.$blackboxHoloReset(false);

            return;
        }

        /* Search for the patrol ships. Sort by distance from the player. */
        patrolShips = system.shipsWithPrimaryRole(&quot;jaguar_company_patrol&quot;, playerShip);

        if (!patrolShips.length) {
            /* We are on our own. Deactivate the black box. */
            p_tracker.mainScript.$blackboxASCReset(true);
            p_tracker.mainScript.$blackboxHoloReset(true);

            if (p_tracker.logging &amp;&amp; p_tracker.logExtra) {
                log(this.name, &quot;$trackerTimer::Tracker removed - no patrol ships&quot;);
            }

            return;
        }

        /* Update the closest patrol ship reference. */
        p_tracker.closestPatrolShip = patrolShips[0];
    };

    /* NAME
     *   $invisibleTrackerFCB
     *
     * FUNCTION
     *   Tracker frame callback.
     *
     *   Used by Oolite v1.76.1 and older.
     *
     * INPUT
     *   delta - amount of game clock time past since the last frame
     */
    this.$invisibleTrackerFCB = function (delta) {
        var tracker = this.ship,
        closestPatrolShip = p_tracker.closestPatrolShip,
        playerShip,
        distance;

        if (!tracker || !tracker.isValid) {
            /* Tracker can be invalid for 1 frame. */
            this.$removeTrackerRefs();

            return;
        }

        if (delta === 0.0 || !closestPatrolShip || !closestPatrolShip.isValid) {
            /* Do nothing if paused or the position of the closest patrol ship has not been setup. */
            return;
        }

        /* Player ship object. */
        playerShip = player.ship;

        if (!playerShip || !playerShip.isValid) {
            /* If the player has died, reset the tracker. */
            p_tracker.mainScript.$blackboxASCReset(false);

            return;
        }

        /* Distance above the closest patrol ship. */
        distance = 5 + closestPatrolShip.collisionRadius;
        /* Keep the tracker above the closest patrol ship. */
        tracker.position = closestPatrolShip.position.add(closestPatrolShip.orientation.vectorUp().multiply(distance));
    };

    /* NAME
     *   $visualTrackerFCB
     *
     * FUNCTION
     *   Tracker frame callback.
     *
     *   Used by Oolite v1.77 and newer for visual effects.
     *
     * INPUT
     *   delta - amount of game clock time past since the last frame
     */
    this.$visualTrackerFCB = function (delta) {
        var tracker = this.visualEffect,
        closestPatrolShip = p_tracker.closestPatrolShip,
        playerShip,
        distance,
        vector,
        angle,
        cross;

        if (!tracker || !tracker.isValid) {
            /* Tracker can be invalid for 1 frame. */
            this.$removeTrackerRefs();

            return;
        }

        if (delta === 0.0 || !closestPatrolShip || !closestPatrolShip.isValid) {
            /* Do nothing if paused or the closest patrol ship has not been setup. */
            return;
        }

        /* Player ship object. */
        playerShip = player.ship;

        if (!playerShip || !playerShip.isValid) {
            /* If the player has died, reset the tracker. */
            p_tracker.mainScript.$blackboxHoloReset(false);

            return;
        }

        if (playerShip.viewDirection !== &quot;VIEW_FORWARD&quot; &amp;&amp; p_tracker.material !== &quot;off&quot;) {
            p_tracker.material = &quot;off&quot;;
            /* Make the tracker small. */
            tracker.scale(0.001);
            /* Move the tracker so it can&#39;t be seen. Centre of the player ship should do it. */
            tracker.position = playerShip.position;
        } else if (playerShip.viewDirection === &quot;VIEW_FORWARD&quot;) {
            /* Scale the tracker to it&#39;s original size. */
            tracker.scale(1.0);
            /* Vector pointing towards the target. */
            vector = closestPatrolShip.position.subtract(playerShip.position).direction();

            if (vector.dot(playerShip.heading) &gt;= 0 &amp;&amp; p_tracker.material !== &quot;green&quot;) {
                p_tracker.material = &quot;green&quot;;
                /* Change the tracker colour to be green. */
                tracker.setMaterials({
                    &quot;jaguar_company_tracker&quot; : {
                        diffuse_color : [&quot;0&quot;, &quot;0.667&quot;, &quot;0&quot;, &quot;1&quot;],
                        diffuse_map : &quot;jaguar_company_tracker_diffuse.png&quot;,
                        emission_color : [&quot;0&quot;, &quot;0.05&quot;, &quot;0&quot;, &quot;1&quot;],
                        shininess : &quot;5&quot;,
                        specular_color : [&quot;0&quot;, &quot;0.2&quot;, &quot;0&quot;, &quot;1&quot;]
                    }
                });
            } else if (vector.dot(playerShip.heading) &lt; 0 &amp;&amp; p_tracker.material !== &quot;red&quot;) {
                p_tracker.material = &quot;red&quot;;
                /* Change the tracker colour to be red. */
                tracker.setMaterials({
                    &quot;jaguar_company_tracker&quot; : {
                        diffuse_color : [&quot;0.667&quot;, &quot;0&quot;, &quot;0&quot;, &quot;1&quot;],
                        diffuse_map : &quot;jaguar_company_tracker_diffuse.png&quot;,
                        emission_color : [&quot;0.05&quot;, &quot;0&quot;, &quot;0&quot;, &quot;1&quot;],
                        shininess : &quot;5&quot;,
                        specular_color : [&quot;0.2&quot;, &quot;0&quot;, &quot;0&quot;, &quot;1&quot;]
                    }
                });
            }

            /* Distance in front of the player. */
            distance = 100 + playerShip.collisionRadius;
            /* Keep the tracker in front of the player. */
            tracker.position = playerShip.position.add(playerShip.heading.multiply(distance));
            /* Angle to the target from current heading. */
            angle = playerShip.heading.angleTo(vector);
            /* Cross vector for rotate. */
            cross = playerShip.heading.cross(vector).direction();
            /* Rotate the tracker by the angle. */
            tracker.orientation = playerShip.orientation.rotate(cross, -angle);
        }
    };
}.bind(this)());
</pre></td>
                </tr>
                <tr>
                    <td valign="top">Scripts/jaguar_company_tug.js</td>
                    <td><pre>/*jslint bitwise: true, es5: true, newcap: true, nomen: true, regexp: true, unparam: true, todo: true, white: true,
indent: 4, maxerr: 50, maxlen: 120 */
/*jshint boss: true, curly: true, eqeqeq: true, eqnull: true, es5: true, evil: true, forin: true, laxbreak: true,
loopfunc: true, noarg: true, noempty: true, strict: true, nonew: true, undef: true */
/*global Vector3D, expandDescription, galaxyNumber, worldScripts */

/* Jaguar Company Tug
 *
 * Copyright © 2012-2013 Richard Thomas Harrison (Tricky)
 *
 * This work is licensed under the Creative Commons
 * Attribution-Noncommercial-Share Alike 3.0 Unported License.
 *
 * To view a copy of this license, visit
 * http://creativecommons.org/licenses/by-nc-sa/3.0/ or send a letter
 * to Creative Commons, 171 Second Street, Suite 300, San Francisco,
 * California, 94105, USA.
 *
 * Ship related functions for the tug.
 */

(function () {
    &quot;use strict&quot;;

    /* Standard public variables for OXP scripts. */
    this.name = &quot;jaguar_company_tug.js&quot;;
    this.author = &quot;Tricky&quot;;
    this.copyright = &quot;© 2012-2013 Richard Thomas Harrison (Tricky)&quot;;
    this.license = &quot;CC BY-NC-SA 3.0&quot;;
    this.description = &quot;Ship script for the Jaguar Company Tug.&quot;;
    this.version = &quot;1.2&quot;;

    /* Private variable. */
    var p_tug = {};

    /* Ship script event handlers. */

    /* NAME
     *   shipSpawned
     *
     * FUNCTION
     *   Initialise various variables on ship birth.
     */
    this.shipSpawned = function () {
        var base;

        /* Initialise the p_tug variable object.
         * Encapsulates all private global data.
         */
        p_tug = {
            /* Cache the world scripts. */
            mainScript : worldScripts[&quot;Jaguar Company&quot;],
            shipsScript : worldScripts[&quot;Jaguar Company Ships&quot;],
            /* Local copies of the logging variables. */
            logging : worldScripts[&quot;Jaguar Company&quot;].$logging,
            logExtra : worldScripts[&quot;Jaguar Company&quot;].$logExtra,
            /* Local copy of the friendList array. */
            friendList : worldScripts[&quot;Jaguar Company Ships&quot;].$friendList
        };

        /* Register this ship as a friendly. */
        p_tug.shipsScript.$addFriendly({
            ship : this.ship,
            /* Random name for the pilot. Used when talking about attacks and sending a report to Snoopers. */
            pilotName : expandDescription(&quot;%N [nom1]&quot;),
            /* Get a unique name for the patrol ship. */
            shipName : p_tug.mainScript.$uniqueShipName()
        });

        base = p_tug.mainScript.$jaguarCompanyBase;

        if (base &amp;&amp; base.isValid) {
            /* Update the base script tug references. */
            base.script.$tugOK = false;
            base.script.$tug = this.ship;
        }

        /* No longer needed after setting up. */
        delete this.shipSpawned;
    };

    /* NAME
     *   shipRemoved
     *
     * FUNCTION
     *   Tug was removed by script.
     *
     * INPUT
     *   suppressDeathEvent - boolean
     *     true - shipDied() will not be called
     *     false - shipDied() will be called
     */
    this.shipRemoved = function (suppressDeathEvent) {
        var base;

        if (suppressDeathEvent) {
            return;
        }

        base = worldScripts[&quot;Jaguar Company&quot;].$jaguarCompanyBase;

        if (base &amp;&amp; base.isValid) {
            /* Reset the script check. */
            base.script.$buoyOK = false;

            if (!base.script.$buoy || !base.script.$buoy.isValid) {
                /* Not released the buoy yet, reset the launch status of the buoy. */
                base.script.$buoyLaunched = false;
            }
        }
    };

    /* NAME
     *   entityDestroyed
     *
     * FUNCTION
     *   The tug has just become invalid.
     */
    this.entityDestroyed = function () {
        var base = worldScripts[&quot;Jaguar Company&quot;].$jaguarCompanyBase;

        if (base &amp;&amp; base.isValid) {
            /* Reset the script check. */
            base.script.$buoyOK = false;

            if (!base.script.$buoy || !base.script.$buoy.isValid) {
                /* Not released the buoy yet, reset the launch status of the buoy. */
                base.script.$buoyLaunched = false;
            }
        }
    };

    /* Other global public functions. */

    /* AI functions. */

    /* NAME
     *   $setCoordsToJaguarCompanyBuoy
     *
     * FUNCTION
     *   Set the co-ordinates to the surface of the buoy or the base.
     */
    this.$setCoordsToJaguarCompanyBuoy = function () {
        var base = p_tug.mainScript.$jaguarCompanyBase;

        if (!base || !base.isValid) {
            /* If the base has gone, just go to the nearest station. */
            this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_BASE_NOT_FOUND&quot;);
        } else {
            if (base.script.$buoy &amp;&amp; base.script.$buoy.isValid) {
                /* Set the coords to the buoy. */
                this.$setCoordsToEntity(base.script.$buoy);
                this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_BUOY_FOUND&quot;);
            } else {
                /* Set the coords to the base. */
                this.$setCoordsToEntity(base);
                this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_BASE_FOUND&quot;);
            }
        }
    };

    /* NAME
     *   $setCoordsForBuoyDropOff
     *
     * FUNCTION
     *   Set the co-ordinates for the buoy drop-off position.
     */
    this.$setCoordsForBuoyDropOff = function () {
        var base = p_tug.mainScript.$jaguarCompanyBase,
        distance = 10000;

        if (!base || !base.isValid) {
            /* If it has gone, just go to the nearest station. */
            this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_BUOY_DROP_OFF_NOT_FOUND&quot;);

            return;
        }

        /* Calculate the base surface to buoy centre distance, not centre to centre. */
        distance += base.collisionRadius;
        /* Add on desired range. */
        distance += 20;

        /* Set the ending position for the tug in front of the base. */
        this.ship.savedCoordinates = base.position.add(base.heading.multiply(distance));
        this.ship.reactToAIMessage(&quot;JAGUAR_COMPANY_BUOY_DROP_OFF_FOUND&quot;);
    };

    /* NAME
     *   $releaseBuoy
     *
     * FUNCTION
     *   Release the buoy by removing the sub-entity and replacing with a real buoy.
     */
    this.$releaseBuoy = function () {
        var tug = this.ship,
        subEntities = tug.subEntities,
        base = p_tug.mainScript.$jaguarCompanyBase,
        buoyPosition,
        buoyRole,
        buoy;

        /* We make the assumption that the buoy is the 1st sub-entity. */
        if (!subEntities.length || !subEntities[0].hasRole(&quot;jaguar_company_base_buoy_subent&quot;)) {
            /* The buoy isn&#39;t there??? */
            return;
        }

        /* Calculate the real-world position for the buoy. */
        buoyPosition = tug.position.add(subEntities[0].position.rotateBy(tug.orientation));
        /* Remove the buoy sub-entity quietly: don&#39;t trigger &#39;shipDied&#39; in the ship script. */
        subEntities[0].remove(true);

        if (p_tug.mainScript.$playerVar.reputation[galaxyNumber] &lt; p_tug.mainScript.$reputationHelper) {
            /* No beacon. Scanner colour is solid white. */
            buoyRole = &quot;jaguar_company_base_buoy_no_beacon&quot;;
        } else {
            /* Beacon. Standard scanner colour for a buoy. */
            buoyRole = &quot;jaguar_company_base_buoy_beacon&quot;;
        }

        /* Create the real buoy and add it to the system. */
        buoy = tug.spawnOne(buoyRole);
        buoy.position = buoyPosition;
        /* Keep the original orientation. */
        buoy.orientation = tug.orientation;

        if (base &amp;&amp; base.isValid) {
            /* Update the base script buoy reference. */
            base.script.$buoy = buoy;
        }

        /* Stop the kick in velocity from spawning the buoy and it colliding with the tug.
         * In effect this will put the tug into reverse.
         */
        tug.velocity = new Vector3D(0, 0, 0).subtract(tug.vectorForward.multiply(tug.maxSpeed));
    };
}.bind(this)());
</pre></td>
                </tr>
            </table>
        </a>
    </body>
</html>
